const __vite__mapDeps = (i, m = __vite__mapDeps, d = (m.f || (m.f = ["./iLYf0Sq1.js", "./yyT2kV9q.js", "./CmEnrCKT.js", "./Space.DPCVtlQR.css", "./BlN-vP97.js", "./Button.D9p-WugV.css", "./CgsQ9Uq3.js", "./KitFixedWrapper.DE7v6Nd5.css", "./daily-reward.CW9CzfBk.css", "./TmoCDlCt.js", "./BiLgCW7n.js", "./debug.DT26iZTI.css", "./DOLXq3pz.js", "./B-9jdqlw.js", "./DvbdnX0I.js", "./q5upmFvJ.js", "./BRGwvg8G.js", "./CounterLongAnimation.ouwqL6ic.css", "./DRl6sO1_.js", "./KitSpinner.DReKiGKL.css", "./DbcxBu8S.js", "./Skeleton.xVKnJk6W.css", "./BQbswO9G.js", "./CSY6eHiV.js", "./CuGh0E9g.js", "./C8EdW745.js", "./BottomSheet.C5RVGCHE.css", "./ShareLink.DPfgkXCn.css", "./InviteFrenModal.BSkLT0Pv.css", "./BAoKJSOm.js", "./KitPageSpinner.DlXPGRRG.css", "./frens.Bot7ev5e.css", "./Cer4ew5n.js", "./game.cQvDk7a9.css", "./D7SOA-Jp.js", "./Bw0EqUBt.js", "./BzfPPPwq.js", "./SkeletonImage.DICSPyi9.css", "./TribeItemAvatar.CfA3BJvS.css", "./CmRp5c7_.js", "./AvatarPlain.--zDMT8e.css", "./index.DAI0yWiO.css", "./BkffHi65.js", "./BTrPcjR2.js", "./-Is95xOq.js", "./Input.BsTu2kln.css", "./Welcome.DDdFhC5p.css", "./preview.wk4giYP7.css", "./DEH-KEtj.js", "./DsuB3pnN.js", "./KitNotificationScreen.C9W-1HbD.css", "./B7oqqIgM.js", "./tasks.BYBPHKN9.css", "./Dds7imDr.js", "./_...DVCOH5dI.css", "./Wc3ymD1D.js", "./CxBPw343.js", "./CKE2JaU9.js", "./FarmFasterSheet.BhxZNU5a.css", "./Dv98v3E4.js", "./hN2I0bM6.js", "./TribeListItemTemplate.DYU88o6X.css", "./TribeUserItem.BKp7vZWj.css", "./Baa1GDhV.js", "./TribeListSkeleton.5U-P63O9.css", "./index.BWoRjgcN.css", "./Bd4Cy6he.js", "./DEV35q5J.js", "./TopListTemplate.DifC1k7o.css", "./leaderboard.BP2Mxrx2.css", "./COaImu1A.js", "./DSLZ4F3A.js", "./C0DBYNVT.js", "./TribeBaseItem.pEoSRgh3.css", "./TribeTopItem.CYgXvEbT.css", "./U91BqYPI.js", "./TribeCreateProperty.BzchwXxC.css", "./index.BCDVmIQo.css", "./Ci9s3BIe.js", "./list.Bo4N0EuF.css", "./BpA4NLmK.js", "./new.CN746v58.css", "./BodZrVwd.js", "./top.DyD8tSe6.css", "./T8wHmvvD.js", "./DQYttrq3.js", "./transaction-default.DyqLZNwp.css", "./_id_.BXwuckCu.css", "./BRN8SaId.js", "./index.CjxcL5i6.css", "./4gvLoaua.js", "./welcome.BQPbcpT3.css"]))) => i.map(i => d[i]);
var el = Object.defineProperty;
var tl = (ue, Yi, ea) => Yi in ue ? el(ue, Yi, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: ea
}) : ue[Yi] = ea;
var Io = (ue, Yi, ea) => tl(ue, typeof Yi != "symbol" ? Yi + "" : Yi, ea);
const global$1 = globalThis || void 0 || self;
/**
 * @vue/shared v3.5.11
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
/*! #__NO_SIDE_EFFECTS__ */
function makeMap(ue) {
	const Yi = Object.create(null);
	for (const ea of ue.split(",")) Yi[ea] = 1;
	return ea => ea in Yi
}
const EMPTY_OBJ = {},
	EMPTY_ARR = [],
	NOOP = () => {},
	NO = () => !1,
	isOn = ue => ue.charCodeAt(0) === 111 && ue.charCodeAt(1) === 110 && (ue.charCodeAt(2) > 122 || ue.charCodeAt(2) < 97),
	isModelListener = ue => ue.startsWith("onUpdate:"),
	extend$1 = Object.assign,
	remove = (ue, Yi) => {
		const ea = ue.indexOf(Yi);
		ea > -1 && ue.splice(ea, 1)
	},
	hasOwnProperty$3 = Object.prototype.hasOwnProperty,
	hasOwn$1 = (ue, Yi) => hasOwnProperty$3.call(ue, Yi),
	isArray$4 = Array.isArray,
	isMap = ue => toTypeString$1(ue) === "[object Map]",
	isSet = ue => toTypeString$1(ue) === "[object Set]",
	isDate$3 = ue => toTypeString$1(ue) === "[object Date]",
	isRegExp$3 = ue => toTypeString$1(ue) === "[object RegExp]",
	isFunction$2 = ue => typeof ue == "function",
	isString$4 = ue => typeof ue == "string",
	isSymbol$1 = ue => typeof ue == "symbol",
	isObject$3 = ue => ue !== null && typeof ue == "object",
	isPromise$3 = ue => (isObject$3(ue) || isFunction$2(ue)) && isFunction$2(ue.then) && isFunction$2(ue.catch),
	objectToString$2 = Object.prototype.toString,
	toTypeString$1 = ue => objectToString$2.call(ue),
	toRawType = ue => toTypeString$1(ue).slice(8, -1),
	isPlainObject$4 = ue => toTypeString$1(ue) === "[object Object]",
	isIntegerKey = ue => isString$4(ue) && ue !== "NaN" && ue[0] !== "-" && "" + parseInt(ue, 10) === ue,
	isReservedProp = makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
	cacheStringFunction = ue => {
		const Yi = Object.create(null);
		return ea => Yi[ea] || (Yi[ea] = ue(ea))
	},
	camelizeRE = /-(\w)/g,
	camelize = cacheStringFunction(ue => ue.replace(camelizeRE, (Yi, ea) => ea ? ea.toUpperCase() : "")),
	hyphenateRE = /\B([A-Z])/g,
	hyphenate = cacheStringFunction(ue => ue.replace(hyphenateRE, "-$1").toLowerCase()),
	capitalize$2 = cacheStringFunction(ue => ue.charAt(0).toUpperCase() + ue.slice(1)),
	toHandlerKey = cacheStringFunction(ue => ue ? `on${capitalize$2(ue)}` : ""),
	hasChanged = (ue, Yi) => !Object.is(ue, Yi),
	invokeArrayFns = (ue, ...Yi) => {
		for (let ea = 0; ea < ue.length; ea++) ue[ea](...Yi)
	},
	def = (ue, Yi, ea, ta = !1) => {
		Object.defineProperty(ue, Yi, {
			configurable: !0,
			enumerable: !1,
			writable: ta,
			value: ea
		})
	},
	looseToNumber = ue => {
		const Yi = parseFloat(ue);
		return isNaN(Yi) ? ue : Yi
	},
	toNumber = ue => {
		const Yi = isString$4(ue) ? Number(ue) : NaN;
		return isNaN(Yi) ? ue : Yi
	};
let _globalThis$3;
const getGlobalThis$1 = () => _globalThis$3 || (_globalThis$3 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global$1 < "u" ? global$1 : {});

function normalizeStyle(ue) {
	if (isArray$4(ue)) {
		const Yi = {};
		for (let ea = 0; ea < ue.length; ea++) {
			const ta = ue[ea],
				na = isString$4(ta) ? parseStringStyle(ta) : normalizeStyle(ta);
			if (na)
				for (const ra in na) Yi[ra] = na[ra]
		}
		return Yi
	} else if (isString$4(ue) || isObject$3(ue)) return ue
}
const listDelimiterRE = /;(?![^(]*\))/g,
	propertyDelimiterRE = /:([^]+)/,
	styleCommentRE = /\/\*[^]*?\*\//g;

function parseStringStyle(ue) {
	const Yi = {};
	return ue.replace(styleCommentRE, "").split(listDelimiterRE).forEach(ea => {
		if (ea) {
			const ta = ea.split(propertyDelimiterRE);
			ta.length > 1 && (Yi[ta[0].trim()] = ta[1].trim())
		}
	}), Yi
}

function normalizeClass(ue) {
	let Yi = "";
	if (isString$4(ue)) Yi = ue;
	else if (isArray$4(ue))
		for (let ea = 0; ea < ue.length; ea++) {
			const ta = normalizeClass(ue[ea]);
			ta && (Yi += ta + " ")
		} else if (isObject$3(ue))
			for (const ea in ue) ue[ea] && (Yi += ea + " ");
	return Yi.trim()
}

function normalizeProps(ue) {
	if (!ue) return null;
	let {
		class: Yi,
		style: ea
	} = ue;
	return Yi && !isString$4(Yi) && (ue.class = normalizeClass(Yi)), ea && (ue.style = normalizeStyle(ea)), ue
}
const specialBooleanAttrs = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
	isSpecialBooleanAttr = makeMap(specialBooleanAttrs);

function includeBooleanAttr(ue) {
	return !!ue || ue === ""
}

function looseCompareArrays(ue, Yi) {
	if (ue.length !== Yi.length) return !1;
	let ea = !0;
	for (let ta = 0; ea && ta < ue.length; ta++) ea = looseEqual(ue[ta], Yi[ta]);
	return ea
}

function looseEqual(ue, Yi) {
	if (ue === Yi) return !0;
	let ea = isDate$3(ue),
		ta = isDate$3(Yi);
	if (ea || ta) return ea && ta ? ue.getTime() === Yi.getTime() : !1;
	if (ea = isSymbol$1(ue), ta = isSymbol$1(Yi), ea || ta) return ue === Yi;
	if (ea = isArray$4(ue), ta = isArray$4(Yi), ea || ta) return ea && ta ? looseCompareArrays(ue, Yi) : !1;
	if (ea = isObject$3(ue), ta = isObject$3(Yi), ea || ta) {
		if (!ea || !ta) return !1;
		const na = Object.keys(ue).length,
			ra = Object.keys(Yi).length;
		if (na !== ra) return !1;
		for (const ia in ue) {
			const aa = ue.hasOwnProperty(ia),
				oa = Yi.hasOwnProperty(ia);
			if (aa && !oa || !aa && oa || !looseEqual(ue[ia], Yi[ia])) return !1
		}
	}
	return String(ue) === String(Yi)
}

function looseIndexOf(ue, Yi) {
	return ue.findIndex(ea => looseEqual(ea, Yi))
}
const isRef$1 = ue => !!(ue && ue.__v_isRef === !0),
	toDisplayString$1 = ue => isString$4(ue) ? ue : ue == null ? "" : isArray$4(ue) || isObject$3(ue) && (ue.toString === objectToString$2 || !isFunction$2(ue.toString)) ? isRef$1(ue) ? toDisplayString$1(ue.value) : JSON.stringify(ue, replacer, 2) : String(ue),
	replacer = (ue, Yi) => isRef$1(Yi) ? replacer(ue, Yi.value) : isMap(Yi) ? {
		[`Map(${Yi.size})`]: [...Yi.entries()].reduce((ea, [ta, na], ra) => (ea[stringifySymbol(ta, ra) + " =>"] = na, ea), {})
	} : isSet(Yi) ? {
		[`Set(${Yi.size})`]: [...Yi.values()].map(ea => stringifySymbol(ea))
	} : isSymbol$1(Yi) ? stringifySymbol(Yi) : isObject$3(Yi) && !isArray$4(Yi) && !isPlainObject$4(Yi) ? String(Yi) : Yi,
	stringifySymbol = (ue, Yi = "") => {
		var ea;
		return isSymbol$1(ue) ? `Symbol(${(ea=ue.description)!=null?ea:Yi})` : ue
	};
/**
 * @vue/reactivity v3.5.11
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
let activeEffectScope;
class EffectScope {
	constructor(Yi = !1) {
		this.detached = Yi, this._active = !0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = activeEffectScope, !Yi && activeEffectScope && (this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1)
	}
	get active() {
		return this._active
	}
	pause() {
		if (this._active) {
			this._isPaused = !0;
			let Yi, ea;
			if (this.scopes)
				for (Yi = 0, ea = this.scopes.length; Yi < ea; Yi++) this.scopes[Yi].pause();
			for (Yi = 0, ea = this.effects.length; Yi < ea; Yi++) this.effects[Yi].pause()
		}
	}
	resume() {
		if (this._active && this._isPaused) {
			this._isPaused = !1;
			let Yi, ea;
			if (this.scopes)
				for (Yi = 0, ea = this.scopes.length; Yi < ea; Yi++) this.scopes[Yi].resume();
			for (Yi = 0, ea = this.effects.length; Yi < ea; Yi++) this.effects[Yi].resume()
		}
	}
	run(Yi) {
		if (this._active) {
			const ea = activeEffectScope;
			try {
				return activeEffectScope = this, Yi()
			} finally {
				activeEffectScope = ea
			}
		}
	}
	on() {
		activeEffectScope = this
	}
	off() {
		activeEffectScope = this.parent
	}
	stop(Yi) {
		if (this._active) {
			let ea, ta;
			for (ea = 0, ta = this.effects.length; ea < ta; ea++) this.effects[ea].stop();
			for (ea = 0, ta = this.cleanups.length; ea < ta; ea++) this.cleanups[ea]();
			if (this.scopes)
				for (ea = 0, ta = this.scopes.length; ea < ta; ea++) this.scopes[ea].stop(!0);
			if (!this.detached && this.parent && !Yi) {
				const na = this.parent.scopes.pop();
				na && na !== this && (this.parent.scopes[this.index] = na, na.index = this.index)
			}
			this.parent = void 0, this._active = !1
		}
	}
}

function effectScope(ue) {
	return new EffectScope(ue)
}

function getCurrentScope$1() {
	return activeEffectScope
}

function onScopeDispose(ue, Yi = !1) {
	activeEffectScope && activeEffectScope.cleanups.push(ue)
}
let activeSub;
const pausedQueueEffects = new WeakSet;
class ReactiveEffect {
	constructor(Yi) {
		this.fn = Yi, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, activeEffectScope && activeEffectScope.active && activeEffectScope.effects.push(this)
	}
	pause() {
		this.flags |= 64
	}
	resume() {
		this.flags & 64 && (this.flags &= -65, pausedQueueEffects.has(this) && (pausedQueueEffects.delete(this), this.trigger()))
	}
	notify() {
		this.flags & 2 && !(this.flags & 32) || this.flags & 8 || batch(this)
	}
	run() {
		if (!(this.flags & 1)) return this.fn();
		this.flags |= 2, cleanupEffect(this), prepareDeps(this);
		const Yi = activeSub,
			ea = shouldTrack;
		activeSub = this, shouldTrack = !0;
		try {
			return this.fn()
		} finally {
			cleanupDeps(this), activeSub = Yi, shouldTrack = ea, this.flags &= -3
		}
	}
	stop() {
		if (this.flags & 1) {
			for (let Yi = this.deps; Yi; Yi = Yi.nextDep) removeSub(Yi);
			this.deps = this.depsTail = void 0, cleanupEffect(this), this.onStop && this.onStop(), this.flags &= -2
		}
	}
	trigger() {
		this.flags & 64 ? pausedQueueEffects.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
	}
	runIfDirty() {
		isDirty(this) && this.run()
	}
	get dirty() {
		return isDirty(this)
	}
}
let batchDepth = 0,
	batchedSub, batchedComputed;

function batch(ue, Yi = !1) {
	if (ue.flags |= 8, Yi) {
		ue.next = batchedComputed, batchedComputed = ue;
		return
	}
	ue.next = batchedSub, batchedSub = ue
}

function startBatch() {
	batchDepth++
}

function endBatch() {
	if (--batchDepth > 0) return;
	if (batchedComputed) {
		let Yi = batchedComputed;
		for (batchedComputed = void 0; Yi;) {
			const ea = Yi.next;
			Yi.next = void 0, Yi.flags &= -9, Yi = ea
		}
	}
	let ue;
	for (; batchedSub;) {
		let Yi = batchedSub;
		for (batchedSub = void 0; Yi;) {
			const ea = Yi.next;
			if (Yi.next = void 0, Yi.flags &= -9, Yi.flags & 1) try {
				Yi.trigger()
			} catch (ta) {
				ue || (ue = ta)
			}
			Yi = ea
		}
	}
	if (ue) throw ue
}

function prepareDeps(ue) {
	for (let Yi = ue.deps; Yi; Yi = Yi.nextDep) Yi.version = -1, Yi.prevActiveLink = Yi.dep.activeLink, Yi.dep.activeLink = Yi
}

function cleanupDeps(ue) {
	let Yi, ea = ue.depsTail,
		ta = ea;
	for (; ta;) {
		const na = ta.prevDep;
		ta.version === -1 ? (ta === ea && (ea = na), removeSub(ta), removeDep(ta)) : Yi = ta, ta.dep.activeLink = ta.prevActiveLink, ta.prevActiveLink = void 0, ta = na
	}
	ue.deps = Yi, ue.depsTail = ea
}

function isDirty(ue) {
	for (let Yi = ue.deps; Yi; Yi = Yi.nextDep)
		if (Yi.dep.version !== Yi.version || Yi.dep.computed && (refreshComputed(Yi.dep.computed) || Yi.dep.version !== Yi.version)) return !0;
	return !!ue._dirty
}

function refreshComputed(ue) {
	if (ue.flags & 4 && !(ue.flags & 16) || (ue.flags &= -17, ue.globalVersion === globalVersion)) return;
	ue.globalVersion = globalVersion;
	const Yi = ue.dep;
	if (ue.flags |= 2, Yi.version > 0 && !ue.isSSR && ue.deps && !isDirty(ue)) {
		ue.flags &= -3;
		return
	}
	const ea = activeSub,
		ta = shouldTrack;
	activeSub = ue, shouldTrack = !0;
	try {
		prepareDeps(ue);
		const na = ue.fn(ue._value);
		(Yi.version === 0 || hasChanged(na, ue._value)) && (ue._value = na, Yi.version++)
	} catch (na) {
		throw Yi.version++, na
	} finally {
		activeSub = ea, shouldTrack = ta, cleanupDeps(ue), ue.flags &= -3
	}
}

function removeSub(ue, Yi = !1) {
	const {
		dep: ea,
		prevSub: ta,
		nextSub: na
	} = ue;
	if (ta && (ta.nextSub = na, ue.prevSub = void 0), na && (na.prevSub = ta, ue.nextSub = void 0), ea.subs === ue && (ea.subs = ta), !ea.subs && ea.computed) {
		ea.computed.flags &= -5;
		for (let ra = ea.computed.deps; ra; ra = ra.nextDep) removeSub(ra, !0)
	}!Yi && !--ea.sc && ea.map && ea.map.delete(ea.key)
}

function removeDep(ue) {
	const {
		prevDep: Yi,
		nextDep: ea
	} = ue;
	Yi && (Yi.nextDep = ea, ue.prevDep = void 0), ea && (ea.prevDep = Yi, ue.nextDep = void 0)
}
let shouldTrack = !0;
const trackStack = [];

function pauseTracking() {
	trackStack.push(shouldTrack), shouldTrack = !1
}

function resetTracking() {
	const ue = trackStack.pop();
	shouldTrack = ue === void 0 ? !0 : ue
}

function cleanupEffect(ue) {
	const {
		cleanup: Yi
	} = ue;
	if (ue.cleanup = void 0, Yi) {
		const ea = activeSub;
		activeSub = void 0;
		try {
			Yi()
		} finally {
			activeSub = ea
		}
	}
}
let globalVersion = 0;
class Link {
	constructor(Yi, ea) {
		this.sub = Yi, this.dep = ea, this.version = ea.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0
	}
}
class Dep {
	constructor(Yi) {
		this.computed = Yi, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0
	}
	track(Yi) {
		if (!activeSub || !shouldTrack || activeSub === this.computed) return;
		let ea = this.activeLink;
		if (ea === void 0 || ea.sub !== activeSub) ea = this.activeLink = new Link(activeSub, this), activeSub.deps ? (ea.prevDep = activeSub.depsTail, activeSub.depsTail.nextDep = ea, activeSub.depsTail = ea) : activeSub.deps = activeSub.depsTail = ea, addSub(ea);
		else if (ea.version === -1 && (ea.version = this.version, ea.nextDep)) {
			const ta = ea.nextDep;
			ta.prevDep = ea.prevDep, ea.prevDep && (ea.prevDep.nextDep = ta), ea.prevDep = activeSub.depsTail, ea.nextDep = void 0, activeSub.depsTail.nextDep = ea, activeSub.depsTail = ea, activeSub.deps === ea && (activeSub.deps = ta)
		}
		return ea
	}
	trigger(Yi) {
		this.version++, globalVersion++, this.notify(Yi)
	}
	notify(Yi) {
		startBatch();
		try {
			for (let ea = this.subs; ea; ea = ea.prevSub) ea.sub.notify() && ea.sub.dep.notify()
		} finally {
			endBatch()
		}
	}
}

function addSub(ue) {
	if (ue.dep.sc++, ue.sub.flags & 4) {
		const Yi = ue.dep.computed;
		if (Yi && !ue.dep.subs) {
			Yi.flags |= 20;
			for (let ta = Yi.deps; ta; ta = ta.nextDep) addSub(ta)
		}
		const ea = ue.dep.subs;
		ea !== ue && (ue.prevSub = ea, ea && (ea.nextSub = ue)), ue.dep.subs = ue
	}
}
const targetMap = new WeakMap,
	ITERATE_KEY = Symbol(""),
	MAP_KEY_ITERATE_KEY = Symbol(""),
	ARRAY_ITERATE_KEY = Symbol("");

function track(ue, Yi, ea) {
	if (shouldTrack && activeSub) {
		let ta = targetMap.get(ue);
		ta || targetMap.set(ue, ta = new Map);
		let na = ta.get(ea);
		na || (ta.set(ea, na = new Dep), na.map = ta, na.key = ea), na.track()
	}
}

function trigger(ue, Yi, ea, ta, na, ra) {
	const ia = targetMap.get(ue);
	if (!ia) {
		globalVersion++;
		return
	}
	const aa = oa => {
		oa && oa.trigger()
	};
	if (startBatch(), Yi === "clear") ia.forEach(aa);
	else {
		const oa = isArray$4(ue),
			la = oa && isIntegerKey(ea);
		if (oa && ea === "length") {
			const sa = Number(ta);
			ia.forEach((ca, ua) => {
				(ua === "length" || ua === ARRAY_ITERATE_KEY || !isSymbol$1(ua) && ua >= sa) && aa(ca)
			})
		} else switch (ea !== void 0 && aa(ia.get(ea)), la && aa(ia.get(ARRAY_ITERATE_KEY)), Yi) {
			case "add":
				oa ? la && aa(ia.get("length")) : (aa(ia.get(ITERATE_KEY)), isMap(ue) && aa(ia.get(MAP_KEY_ITERATE_KEY)));
				break;
			case "delete":
				oa || (aa(ia.get(ITERATE_KEY)), isMap(ue) && aa(ia.get(MAP_KEY_ITERATE_KEY)));
				break;
			case "set":
				isMap(ue) && aa(ia.get(ITERATE_KEY));
				break
		}
	}
	endBatch()
}

function getDepFromReactive(ue, Yi) {
	const ea = targetMap.get(ue);
	return ea && ea.get(Yi)
}

function reactiveReadArray(ue) {
	const Yi = toRaw(ue);
	return Yi === ue ? Yi : (track(Yi, "iterate", ARRAY_ITERATE_KEY), isShallow(ue) ? Yi : Yi.map(toReactive))
}

function shallowReadArray(ue) {
	return track(ue = toRaw(ue), "iterate", ARRAY_ITERATE_KEY), ue
}
const arrayInstrumentations = {
	__proto__: null,
	[Symbol.iterator]() {
		return iterator(this, Symbol.iterator, toReactive)
	},
	concat(...ue) {
		return reactiveReadArray(this).concat(...ue.map(Yi => isArray$4(Yi) ? reactiveReadArray(Yi) : Yi))
	},
	entries() {
		return iterator(this, "entries", ue => (ue[1] = toReactive(ue[1]), ue))
	},
	every(ue, Yi) {
		return apply$1(this, "every", ue, Yi, void 0, arguments)
	},
	filter(ue, Yi) {
		return apply$1(this, "filter", ue, Yi, ea => ea.map(toReactive), arguments)
	},
	find(ue, Yi) {
		return apply$1(this, "find", ue, Yi, toReactive, arguments)
	},
	findIndex(ue, Yi) {
		return apply$1(this, "findIndex", ue, Yi, void 0, arguments)
	},
	findLast(ue, Yi) {
		return apply$1(this, "findLast", ue, Yi, toReactive, arguments)
	},
	findLastIndex(ue, Yi) {
		return apply$1(this, "findLastIndex", ue, Yi, void 0, arguments)
	},
	forEach(ue, Yi) {
		return apply$1(this, "forEach", ue, Yi, void 0, arguments)
	},
	includes(...ue) {
		return searchProxy(this, "includes", ue)
	},
	indexOf(...ue) {
		return searchProxy(this, "indexOf", ue)
	},
	join(ue) {
		return reactiveReadArray(this).join(ue)
	},
	lastIndexOf(...ue) {
		return searchProxy(this, "lastIndexOf", ue)
	},
	map(ue, Yi) {
		return apply$1(this, "map", ue, Yi, void 0, arguments)
	},
	pop() {
		return noTracking(this, "pop")
	},
	push(...ue) {
		return noTracking(this, "push", ue)
	},
	reduce(ue, ...Yi) {
		return reduce(this, "reduce", ue, Yi)
	},
	reduceRight(ue, ...Yi) {
		return reduce(this, "reduceRight", ue, Yi)
	},
	shift() {
		return noTracking(this, "shift")
	},
	some(ue, Yi) {
		return apply$1(this, "some", ue, Yi, void 0, arguments)
	},
	splice(...ue) {
		return noTracking(this, "splice", ue)
	},
	toReversed() {
		return reactiveReadArray(this).toReversed()
	},
	toSorted(ue) {
		return reactiveReadArray(this).toSorted(ue)
	},
	toSpliced(...ue) {
		return reactiveReadArray(this).toSpliced(...ue)
	},
	unshift(...ue) {
		return noTracking(this, "unshift", ue)
	},
	values() {
		return iterator(this, "values", toReactive)
	}
};

function iterator(ue, Yi, ea) {
	const ta = shallowReadArray(ue),
		na = ta[Yi]();
	return ta !== ue && !isShallow(ue) && (na._next = na.next, na.next = () => {
		const ra = na._next();
		return ra.value && (ra.value = ea(ra.value)), ra
	}), na
}
const arrayProto = Array.prototype;

function apply$1(ue, Yi, ea, ta, na, ra) {
	const ia = shallowReadArray(ue),
		aa = ia !== ue && !isShallow(ue),
		oa = ia[Yi];
	if (oa !== arrayProto[Yi]) {
		const ca = oa.apply(ue, ra);
		return aa ? toReactive(ca) : ca
	}
	let la = ea;
	ia !== ue && (aa ? la = function(ca, ua) {
		return ea.call(this, toReactive(ca), ua, ue)
	} : ea.length > 2 && (la = function(ca, ua) {
		return ea.call(this, ca, ua, ue)
	}));
	const sa = oa.call(ia, la, ta);
	return aa && na ? na(sa) : sa
}

function reduce(ue, Yi, ea, ta) {
	const na = shallowReadArray(ue);
	let ra = ea;
	return na !== ue && (isShallow(ue) ? ea.length > 3 && (ra = function(ia, aa, oa) {
		return ea.call(this, ia, aa, oa, ue)
	}) : ra = function(ia, aa, oa) {
		return ea.call(this, ia, toReactive(aa), oa, ue)
	}), na[Yi](ra, ...ta)
}

function searchProxy(ue, Yi, ea) {
	const ta = toRaw(ue);
	track(ta, "iterate", ARRAY_ITERATE_KEY);
	const na = ta[Yi](...ea);
	return (na === -1 || na === !1) && isProxy(ea[0]) ? (ea[0] = toRaw(ea[0]), ta[Yi](...ea)) : na
}

function noTracking(ue, Yi, ea = []) {
	pauseTracking(), startBatch();
	const ta = toRaw(ue)[Yi].apply(ue, ea);
	return endBatch(), resetTracking(), ta
}
const isNonTrackableKeys = makeMap("__proto__,__v_isRef,__isVue"),
	builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).filter(ue => ue !== "arguments" && ue !== "caller").map(ue => Symbol[ue]).filter(isSymbol$1));

function hasOwnProperty$2(ue) {
	isSymbol$1(ue) || (ue = String(ue));
	const Yi = toRaw(this);
	return track(Yi, "has", ue), Yi.hasOwnProperty(ue)
}
class BaseReactiveHandler {
	constructor(Yi = !1, ea = !1) {
		this._isReadonly = Yi, this._isShallow = ea
	}
	get(Yi, ea, ta) {
		const na = this._isReadonly,
			ra = this._isShallow;
		if (ea === "__v_isReactive") return !na;
		if (ea === "__v_isReadonly") return na;
		if (ea === "__v_isShallow") return ra;
		if (ea === "__v_raw") return ta === (na ? ra ? shallowReadonlyMap : readonlyMap : ra ? shallowReactiveMap : reactiveMap).get(Yi) || Object.getPrototypeOf(Yi) === Object.getPrototypeOf(ta) ? Yi : void 0;
		const ia = isArray$4(Yi);
		if (!na) {
			let oa;
			if (ia && (oa = arrayInstrumentations[ea])) return oa;
			if (ea === "hasOwnProperty") return hasOwnProperty$2
		}
		const aa = Reflect.get(Yi, ea, isRef(Yi) ? Yi : ta);
		return (isSymbol$1(ea) ? builtInSymbols.has(ea) : isNonTrackableKeys(ea)) || (na || track(Yi, "get", ea), ra) ? aa : isRef(aa) ? ia && isIntegerKey(ea) ? aa : aa.value : isObject$3(aa) ? na ? readonly(aa) : reactive(aa) : aa
	}
}
class MutableReactiveHandler extends BaseReactiveHandler {
	constructor(Yi = !1) {
		super(!1, Yi)
	}
	set(Yi, ea, ta, na) {
		let ra = Yi[ea];
		if (!this._isShallow) {
			const oa = isReadonly(ra);
			if (!isShallow(ta) && !isReadonly(ta) && (ra = toRaw(ra), ta = toRaw(ta)), !isArray$4(Yi) && isRef(ra) && !isRef(ta)) return oa ? !1 : (ra.value = ta, !0)
		}
		const ia = isArray$4(Yi) && isIntegerKey(ea) ? Number(ea) < Yi.length : hasOwn$1(Yi, ea),
			aa = Reflect.set(Yi, ea, ta, isRef(Yi) ? Yi : na);
		return Yi === toRaw(na) && (ia ? hasChanged(ta, ra) && trigger(Yi, "set", ea, ta) : trigger(Yi, "add", ea, ta)), aa
	}
	deleteProperty(Yi, ea) {
		const ta = hasOwn$1(Yi, ea);
		Yi[ea];
		const na = Reflect.deleteProperty(Yi, ea);
		return na && ta && trigger(Yi, "delete", ea, void 0), na
	}
	has(Yi, ea) {
		const ta = Reflect.has(Yi, ea);
		return (!isSymbol$1(ea) || !builtInSymbols.has(ea)) && track(Yi, "has", ea), ta
	}
	ownKeys(Yi) {
		return track(Yi, "iterate", isArray$4(Yi) ? "length" : ITERATE_KEY), Reflect.ownKeys(Yi)
	}
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
	constructor(Yi = !1) {
		super(!0, Yi)
	}
	set(Yi, ea) {
		return !0
	}
	deleteProperty(Yi, ea) {
		return !0
	}
}
const mutableHandlers = new MutableReactiveHandler,
	readonlyHandlers = new ReadonlyReactiveHandler,
	shallowReactiveHandlers = new MutableReactiveHandler(!0),
	shallowReadonlyHandlers = new ReadonlyReactiveHandler(!0),
	toShallow = ue => ue,
	getProto = ue => Reflect.getPrototypeOf(ue);

function get(ue, Yi, ea = !1, ta = !1) {
	ue = ue.__v_raw;
	const na = toRaw(ue),
		ra = toRaw(Yi);
	ea || (hasChanged(Yi, ra) && track(na, "get", Yi), track(na, "get", ra));
	const {
		has: ia
	} = getProto(na), aa = ta ? toShallow : ea ? toReadonly : toReactive;
	if (ia.call(na, Yi)) return aa(ue.get(Yi));
	if (ia.call(na, ra)) return aa(ue.get(ra));
	ue !== na && ue.get(Yi)
}

function has(ue, Yi = !1) {
	const ea = this.__v_raw,
		ta = toRaw(ea),
		na = toRaw(ue);
	return Yi || (hasChanged(ue, na) && track(ta, "has", ue), track(ta, "has", na)), ue === na ? ea.has(ue) : ea.has(ue) || ea.has(na)
}

function size(ue, Yi = !1) {
	return ue = ue.__v_raw, !Yi && track(toRaw(ue), "iterate", ITERATE_KEY), Reflect.get(ue, "size", ue)
}

function add$1(ue, Yi = !1) {
	!Yi && !isShallow(ue) && !isReadonly(ue) && (ue = toRaw(ue));
	const ea = toRaw(this);
	return getProto(ea).has.call(ea, ue) || (ea.add(ue), trigger(ea, "add", ue, ue)), this
}

function set$1(ue, Yi, ea = !1) {
	!ea && !isShallow(Yi) && !isReadonly(Yi) && (Yi = toRaw(Yi));
	const ta = toRaw(this),
		{
			has: na,
			get: ra
		} = getProto(ta);
	let ia = na.call(ta, ue);
	ia || (ue = toRaw(ue), ia = na.call(ta, ue));
	const aa = ra.call(ta, ue);
	return ta.set(ue, Yi), ia ? hasChanged(Yi, aa) && trigger(ta, "set", ue, Yi) : trigger(ta, "add", ue, Yi), this
}

function deleteEntry(ue) {
	const Yi = toRaw(this),
		{
			has: ea,
			get: ta
		} = getProto(Yi);
	let na = ea.call(Yi, ue);
	na || (ue = toRaw(ue), na = ea.call(Yi, ue)), ta && ta.call(Yi, ue);
	const ra = Yi.delete(ue);
	return na && trigger(Yi, "delete", ue, void 0), ra
}

function clear() {
	const ue = toRaw(this),
		Yi = ue.size !== 0,
		ea = ue.clear();
	return Yi && trigger(ue, "clear", void 0, void 0), ea
}

function createForEach(ue, Yi) {
	return function(ta, na) {
		const ra = this,
			ia = ra.__v_raw,
			aa = toRaw(ia),
			oa = Yi ? toShallow : ue ? toReadonly : toReactive;
		return !ue && track(aa, "iterate", ITERATE_KEY), ia.forEach((la, sa) => ta.call(na, oa(la), oa(sa), ra))
	}
}

function createIterableMethod(ue, Yi, ea) {
	return function(...ta) {
		const na = this.__v_raw,
			ra = toRaw(na),
			ia = isMap(ra),
			aa = ue === "entries" || ue === Symbol.iterator && ia,
			oa = ue === "keys" && ia,
			la = na[ue](...ta),
			sa = ea ? toShallow : Yi ? toReadonly : toReactive;
		return !Yi && track(ra, "iterate", oa ? MAP_KEY_ITERATE_KEY : ITERATE_KEY), {
			next() {
				const {
					value: ca,
					done: ua
				} = la.next();
				return ua ? {
					value: ca,
					done: ua
				} : {
					value: aa ? [sa(ca[0]), sa(ca[1])] : sa(ca),
					done: ua
				}
			},
			[Symbol.iterator]() {
				return this
			}
		}
	}
}

function createReadonlyMethod(ue) {
	return function(...Yi) {
		return ue === "delete" ? !1 : ue === "clear" ? void 0 : this
	}
}

function createInstrumentations() {
	const ue = {
			get(ra) {
				return get(this, ra)
			},
			get size() {
				return size(this)
			},
			has,
			add: add$1,
			set: set$1,
			delete: deleteEntry,
			clear,
			forEach: createForEach(!1, !1)
		},
		Yi = {
			get(ra) {
				return get(this, ra, !1, !0)
			},
			get size() {
				return size(this)
			},
			has,
			add(ra) {
				return add$1.call(this, ra, !0)
			},
			set(ra, ia) {
				return set$1.call(this, ra, ia, !0)
			},
			delete: deleteEntry,
			clear,
			forEach: createForEach(!1, !0)
		},
		ea = {
			get(ra) {
				return get(this, ra, !0)
			},
			get size() {
				return size(this, !0)
			},
			has(ra) {
				return has.call(this, ra, !0)
			},
			add: createReadonlyMethod("add"),
			set: createReadonlyMethod("set"),
			delete: createReadonlyMethod("delete"),
			clear: createReadonlyMethod("clear"),
			forEach: createForEach(!0, !1)
		},
		ta = {
			get(ra) {
				return get(this, ra, !0, !0)
			},
			get size() {
				return size(this, !0)
			},
			has(ra) {
				return has.call(this, ra, !0)
			},
			add: createReadonlyMethod("add"),
			set: createReadonlyMethod("set"),
			delete: createReadonlyMethod("delete"),
			clear: createReadonlyMethod("clear"),
			forEach: createForEach(!0, !0)
		};
	return ["keys", "values", "entries", Symbol.iterator].forEach(ra => {
		ue[ra] = createIterableMethod(ra, !1, !1), ea[ra] = createIterableMethod(ra, !0, !1), Yi[ra] = createIterableMethod(ra, !1, !0), ta[ra] = createIterableMethod(ra, !0, !0)
	}), [ue, ea, Yi, ta]
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = createInstrumentations();

function createInstrumentationGetter(ue, Yi) {
	const ea = Yi ? ue ? shallowReadonlyInstrumentations : shallowInstrumentations : ue ? readonlyInstrumentations : mutableInstrumentations;
	return (ta, na, ra) => na === "__v_isReactive" ? !ue : na === "__v_isReadonly" ? ue : na === "__v_raw" ? ta : Reflect.get(hasOwn$1(ea, na) && na in ta ? ea : ta, na, ra)
}
const mutableCollectionHandlers = {
		get: createInstrumentationGetter(!1, !1)
	},
	shallowCollectionHandlers = {
		get: createInstrumentationGetter(!1, !0)
	},
	readonlyCollectionHandlers = {
		get: createInstrumentationGetter(!0, !1)
	},
	shallowReadonlyCollectionHandlers = {
		get: createInstrumentationGetter(!0, !0)
	},
	reactiveMap = new WeakMap,
	shallowReactiveMap = new WeakMap,
	readonlyMap = new WeakMap,
	shallowReadonlyMap = new WeakMap;

function targetTypeMap(ue) {
	switch (ue) {
		case "Object":
		case "Array":
			return 1;
		case "Map":
		case "Set":
		case "WeakMap":
		case "WeakSet":
			return 2;
		default:
			return 0
	}
}

function getTargetType(ue) {
	return ue.__v_skip || !Object.isExtensible(ue) ? 0 : targetTypeMap(toRawType(ue))
}

function reactive(ue) {
	return isReadonly(ue) ? ue : createReactiveObject(ue, !1, mutableHandlers, mutableCollectionHandlers, reactiveMap)
}

function shallowReactive(ue) {
	return createReactiveObject(ue, !1, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap)
}

function readonly(ue) {
	return createReactiveObject(ue, !0, readonlyHandlers, readonlyCollectionHandlers, readonlyMap)
}

function shallowReadonly(ue) {
	return createReactiveObject(ue, !0, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap)
}

function createReactiveObject(ue, Yi, ea, ta, na) {
	if (!isObject$3(ue) || ue.__v_raw && !(Yi && ue.__v_isReactive)) return ue;
	const ra = na.get(ue);
	if (ra) return ra;
	const ia = getTargetType(ue);
	if (ia === 0) return ue;
	const aa = new Proxy(ue, ia === 2 ? ta : ea);
	return na.set(ue, aa), aa
}

function isReactive(ue) {
	return isReadonly(ue) ? isReactive(ue.__v_raw) : !!(ue && ue.__v_isReactive)
}

function isReadonly(ue) {
	return !!(ue && ue.__v_isReadonly)
}

function isShallow(ue) {
	return !!(ue && ue.__v_isShallow)
}

function isProxy(ue) {
	return ue ? !!ue.__v_raw : !1
}

function toRaw(ue) {
	const Yi = ue && ue.__v_raw;
	return Yi ? toRaw(Yi) : ue
}

function markRaw(ue) {
	return !hasOwn$1(ue, "__v_skip") && Object.isExtensible(ue) && def(ue, "__v_skip", !0), ue
}
const toReactive = ue => isObject$3(ue) ? reactive(ue) : ue,
	toReadonly = ue => isObject$3(ue) ? readonly(ue) : ue;

function isRef(ue) {
	return ue ? ue.__v_isRef === !0 : !1
}

function ref$1(ue) {
	return createRef(ue, !1)
}

function shallowRef(ue) {
	return createRef(ue, !0)
}

function createRef(ue, Yi) {
	return isRef(ue) ? ue : new RefImpl(ue, Yi)
}
class RefImpl {
	constructor(Yi, ea) {
		this.dep = new Dep, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = ea ? Yi : toRaw(Yi), this._value = ea ? Yi : toReactive(Yi), this.__v_isShallow = ea
	}
	get value() {
		return this.dep.track(), this._value
	}
	set value(Yi) {
		const ea = this._rawValue,
			ta = this.__v_isShallow || isShallow(Yi) || isReadonly(Yi);
		Yi = ta ? Yi : toRaw(Yi), hasChanged(Yi, ea) && (this._rawValue = Yi, this._value = ta ? Yi : toReactive(Yi), this.dep.trigger())
	}
}

function unref(ue) {
	return isRef(ue) ? ue.value : ue
}
const shallowUnwrapHandlers = {
	get: (ue, Yi, ea) => Yi === "__v_raw" ? ue : unref(Reflect.get(ue, Yi, ea)),
	set: (ue, Yi, ea, ta) => {
		const na = ue[Yi];
		return isRef(na) && !isRef(ea) ? (na.value = ea, !0) : Reflect.set(ue, Yi, ea, ta)
	}
};

function proxyRefs(ue) {
	return isReactive(ue) ? ue : new Proxy(ue, shallowUnwrapHandlers)
}
class CustomRefImpl {
	constructor(Yi) {
		this.__v_isRef = !0, this._value = void 0;
		const ea = this.dep = new Dep,
			{
				get: ta,
				set: na
			} = Yi(ea.track.bind(ea), ea.trigger.bind(ea));
		this._get = ta, this._set = na
	}
	get value() {
		return this._value = this._get()
	}
	set value(Yi) {
		this._set(Yi)
	}
}

function customRef(ue) {
	return new CustomRefImpl(ue)
}
class ObjectRefImpl {
	constructor(Yi, ea, ta) {
		this._object = Yi, this._key = ea, this._defaultValue = ta, this.__v_isRef = !0, this._value = void 0
	}
	get value() {
		const Yi = this._object[this._key];
		return this._value = Yi === void 0 ? this._defaultValue : Yi
	}
	set value(Yi) {
		this._object[this._key] = Yi
	}
	get dep() {
		return getDepFromReactive(toRaw(this._object), this._key)
	}
}
class GetterRefImpl {
	constructor(Yi) {
		this._getter = Yi, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0
	}
	get value() {
		return this._value = this._getter()
	}
}

function toRef(ue, Yi, ea) {
	return isRef(ue) ? ue : isFunction$2(ue) ? new GetterRefImpl(ue) : isObject$3(ue) && arguments.length > 1 ? propertyToRef(ue, Yi, ea) : ref$1(ue)
}

function propertyToRef(ue, Yi, ea) {
	const ta = ue[Yi];
	return isRef(ta) ? ta : new ObjectRefImpl(ue, Yi, ea)
}
class ComputedRefImpl {
	constructor(Yi, ea, ta) {
		this.fn = Yi, this.setter = ea, this._value = void 0, this.dep = new Dep(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = globalVersion - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !ea, this.isSSR = ta
	}
	notify() {
		if (this.flags |= 16, !(this.flags & 8) && activeSub !== this) return batch(this, !0), !0
	}
	get value() {
		const Yi = this.dep.track();
		return refreshComputed(this), Yi && (Yi.version = this.dep.version), this._value
	}
	set value(Yi) {
		this.setter && this.setter(Yi)
	}
}

function computed$1(ue, Yi, ea = !1) {
	let ta, na;
	return isFunction$2(ue) ? ta = ue : (ta = ue.get, na = ue.set), new ComputedRefImpl(ta, na, ea)
}
const INITIAL_WATCHER_VALUE = {},
	cleanupMap = new WeakMap;
let activeWatcher;

function onWatcherCleanup(ue, Yi = !1, ea = activeWatcher) {
	if (ea) {
		let ta = cleanupMap.get(ea);
		ta || cleanupMap.set(ea, ta = []), ta.push(ue)
	}
}

function watch$1(ue, Yi, ea = EMPTY_OBJ) {
	const {
		immediate: ta,
		deep: na,
		once: ra,
		scheduler: ia,
		augmentJob: aa,
		call: oa
	} = ea, la = Ca => na ? Ca : isShallow(Ca) || na === !1 || na === 0 ? traverse(Ca, 1) : traverse(Ca);
	let sa, ca, ua, da, ha = !1,
		pa = !1;
	if (isRef(ue) ? (ca = () => ue.value, ha = isShallow(ue)) : isReactive(ue) ? (ca = () => la(ue), ha = !0) : isArray$4(ue) ? (pa = !0, ha = ue.some(Ca => isReactive(Ca) || isShallow(Ca)), ca = () => ue.map(Ca => {
			if (isRef(Ca)) return Ca.value;
			if (isReactive(Ca)) return la(Ca);
			if (isFunction$2(Ca)) return oa ? oa(Ca, 2) : Ca()
		})) : isFunction$2(ue) ? Yi ? ca = oa ? () => oa(ue, 2) : ue : ca = () => {
			if (ua) {
				pauseTracking();
				try {
					ua()
				} finally {
					resetTracking()
				}
			}
			const Ca = activeWatcher;
			activeWatcher = sa;
			try {
				return oa ? oa(ue, 3, [da]) : ue(da)
			} finally {
				activeWatcher = Ca
			}
		} : ca = NOOP, Yi && na) {
		const Ca = ca,
			ka = na === !0 ? 1 / 0 : na;
		ca = () => traverse(Ca(), ka)
	}
	const va = getCurrentScope$1(),
		ba = () => {
			sa.stop(), va && remove(va.effects, sa)
		};
	if (ra && Yi) {
		const Ca = Yi;
		Yi = (...ka) => {
			Ca(...ka), ba()
		}
	}
	let Ea = pa ? new Array(ue.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
	const Sa = Ca => {
		if (!(!(sa.flags & 1) || !sa.dirty && !Ca))
			if (Yi) {
				const ka = sa.run();
				if (na || ha || (pa ? ka.some((Pa, ja) => hasChanged(Pa, Ea[ja])) : hasChanged(ka, Ea))) {
					ua && ua();
					const Pa = activeWatcher;
					activeWatcher = sa;
					try {
						const ja = [ka, Ea === INITIAL_WATCHER_VALUE ? void 0 : pa && Ea[0] === INITIAL_WATCHER_VALUE ? [] : Ea, da];
						oa ? oa(Yi, 3, ja) : Yi(...ja), Ea = ka
					} finally {
						activeWatcher = Pa
					}
				}
			} else sa.run()
	};
	return aa && aa(Sa), sa = new ReactiveEffect(ca), sa.scheduler = ia ? () => ia(Sa, !1) : Sa, da = Ca => onWatcherCleanup(Ca, !1, sa), ua = sa.onStop = () => {
		const Ca = cleanupMap.get(sa);
		if (Ca) {
			if (oa) oa(Ca, 4);
			else
				for (const ka of Ca) ka();
			cleanupMap.delete(sa)
		}
	}, Yi ? ta ? Sa(!0) : Ea = sa.run() : ia ? ia(Sa.bind(null, !0), !0) : sa.run(), ba.pause = sa.pause.bind(sa), ba.resume = sa.resume.bind(sa), ba.stop = ba, ba
}

function traverse(ue, Yi = 1 / 0, ea) {
	if (Yi <= 0 || !isObject$3(ue) || ue.__v_skip || (ea = ea || new Set, ea.has(ue))) return ue;
	if (ea.add(ue), Yi--, isRef(ue)) traverse(ue.value, Yi, ea);
	else if (isArray$4(ue))
		for (let ta = 0; ta < ue.length; ta++) traverse(ue[ta], Yi, ea);
	else if (isSet(ue) || isMap(ue)) ue.forEach(ta => {
		traverse(ta, Yi, ea)
	});
	else if (isPlainObject$4(ue)) {
		for (const ta in ue) traverse(ue[ta], Yi, ea);
		for (const ta of Object.getOwnPropertySymbols(ue)) Object.prototype.propertyIsEnumerable.call(ue, ta) && traverse(ue[ta], Yi, ea)
	}
	return ue
}
/**
 * @vue/runtime-core v3.5.11
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
const stack = [];
let isWarning = !1;

function warn$1(ue, ...Yi) {
	if (isWarning) return;
	isWarning = !0, pauseTracking();
	const ea = stack.length ? stack[stack.length - 1].component : null,
		ta = ea && ea.appContext.config.warnHandler,
		na = getComponentTrace();
	if (ta) callWithErrorHandling(ta, ea, 11, [ue + Yi.map(ra => {
		var ia, aa;
		return (aa = (ia = ra.toString) == null ? void 0 : ia.call(ra)) != null ? aa : JSON.stringify(ra)
	}).join(""), ea && ea.proxy, na.map(({
		vnode: ra
	}) => `at <${formatComponentName$1(ea,ra.type)}>`).join(`
`), na]);
	else {
		const ra = [`[Vue warn]: ${ue}`, ...Yi];
		na.length && ra.push(`
`, ...formatTrace(na)), console.warn(...ra)
	}
	resetTracking(), isWarning = !1
}

function getComponentTrace() {
	let ue = stack[stack.length - 1];
	if (!ue) return [];
	const Yi = [];
	for (; ue;) {
		const ea = Yi[0];
		ea && ea.vnode === ue ? ea.recurseCount++ : Yi.push({
			vnode: ue,
			recurseCount: 0
		});
		const ta = ue.component && ue.component.parent;
		ue = ta && ta.vnode
	}
	return Yi
}

function formatTrace(ue) {
	const Yi = [];
	return ue.forEach((ea, ta) => {
		Yi.push(...ta === 0 ? [] : [`
`], ...formatTraceEntry(ea))
	}), Yi
}

function formatTraceEntry({
	vnode: ue,
	recurseCount: Yi
}) {
	const ea = Yi > 0 ? `... (${Yi} recursive calls)` : "",
		ta = ue.component ? ue.component.parent == null : !1,
		na = ` at <${formatComponentName$1(ue.component,ue.type,ta)}`,
		ra = ">" + ea;
	return ue.props ? [na, ...formatProps(ue.props), ra] : [na + ra]
}

function formatProps(ue) {
	const Yi = [],
		ea = Object.keys(ue);
	return ea.slice(0, 3).forEach(ta => {
		Yi.push(...formatProp(ta, ue[ta]))
	}), ea.length > 3 && Yi.push(" ..."), Yi
}

function formatProp(ue, Yi, ea) {
	return isString$4(Yi) ? (Yi = JSON.stringify(Yi), ea ? Yi : [`${ue}=${Yi}`]) : typeof Yi == "number" || typeof Yi == "boolean" || Yi == null ? ea ? Yi : [`${ue}=${Yi}`] : isRef(Yi) ? (Yi = formatProp(ue, toRaw(Yi.value), !0), ea ? Yi : [`${ue}=Ref<`, Yi, ">"]) : isFunction$2(Yi) ? [`${ue}=fn${Yi.name?`<${Yi.name}>`:""}`] : (Yi = toRaw(Yi), ea ? Yi : [`${ue}=`, Yi])
}

function callWithErrorHandling(ue, Yi, ea, ta) {
	try {
		return ta ? ue(...ta) : ue()
	} catch (na) {
		handleError(na, Yi, ea)
	}
}

function callWithAsyncErrorHandling(ue, Yi, ea, ta) {
	if (isFunction$2(ue)) {
		const na = callWithErrorHandling(ue, Yi, ea, ta);
		return na && isPromise$3(na) && na.catch(ra => {
			handleError(ra, Yi, ea)
		}), na
	}
	if (isArray$4(ue)) {
		const na = [];
		for (let ra = 0; ra < ue.length; ra++) na.push(callWithAsyncErrorHandling(ue[ra], Yi, ea, ta));
		return na
	}
}

function handleError(ue, Yi, ea, ta = !0) {
	const na = Yi ? Yi.vnode : null,
		{
			errorHandler: ra,
			throwUnhandledErrorInProduction: ia
		} = Yi && Yi.appContext.config || EMPTY_OBJ;
	if (Yi) {
		let aa = Yi.parent;
		const oa = Yi.proxy,
			la = `https://vuejs.org/error-reference/#runtime-${ea}`;
		for (; aa;) {
			const sa = aa.ec;
			if (sa) {
				for (let ca = 0; ca < sa.length; ca++)
					if (sa[ca](ue, oa, la) === !1) return
			}
			aa = aa.parent
		}
		if (ra) {
			pauseTracking(), callWithErrorHandling(ra, null, 10, [ue, oa, la]), resetTracking();
			return
		}
	}
	logError(ue, ea, na, ta, ia)
}

function logError(ue, Yi, ea, ta = !0, na = !1) {
	if (na) throw ue;
	console.error(ue)
}
const queue$1 = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null,
	postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;

function nextTick(ue) {
	const Yi = currentFlushPromise || resolvedPromise;
	return ue ? Yi.then(this ? ue.bind(this) : ue) : Yi
}

function findInsertionIndex$1(ue) {
	let Yi = flushIndex + 1,
		ea = queue$1.length;
	for (; Yi < ea;) {
		const ta = Yi + ea >>> 1,
			na = queue$1[ta],
			ra = getId(na);
		ra < ue || ra === ue && na.flags & 2 ? Yi = ta + 1 : ea = ta
	}
	return Yi
}

function queueJob(ue) {
	if (!(ue.flags & 1)) {
		const Yi = getId(ue),
			ea = queue$1[queue$1.length - 1];
		!ea || !(ue.flags & 2) && Yi >= getId(ea) ? queue$1.push(ue) : queue$1.splice(findInsertionIndex$1(Yi), 0, ue), ue.flags |= 1, queueFlush()
	}
}

function queueFlush() {
	currentFlushPromise || (currentFlushPromise = resolvedPromise.then(flushJobs))
}

function queuePostFlushCb(ue) {
	isArray$4(ue) ? pendingPostFlushCbs.push(...ue) : activePostFlushCbs && ue.id === -1 ? activePostFlushCbs.splice(postFlushIndex + 1, 0, ue) : ue.flags & 1 || (pendingPostFlushCbs.push(ue), ue.flags |= 1), queueFlush()
}

function flushPreFlushCbs(ue, Yi, ea = flushIndex + 1) {
	for (; ea < queue$1.length; ea++) {
		const ta = queue$1[ea];
		if (ta && ta.flags & 2) {
			if (ue && ta.id !== ue.uid) continue;
			queue$1.splice(ea, 1), ea--, ta.flags & 4 && (ta.flags &= -2), ta(), ta.flags & 4 || (ta.flags &= -2)
		}
	}
}

function flushPostFlushCbs(ue) {
	if (pendingPostFlushCbs.length) {
		const Yi = [...new Set(pendingPostFlushCbs)].sort((ea, ta) => getId(ea) - getId(ta));
		if (pendingPostFlushCbs.length = 0, activePostFlushCbs) {
			activePostFlushCbs.push(...Yi);
			return
		}
		for (activePostFlushCbs = Yi, postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
			const ea = activePostFlushCbs[postFlushIndex];
			ea.flags & 4 && (ea.flags &= -2), ea.flags & 8 || ea(), ea.flags &= -2
		}
		activePostFlushCbs = null, postFlushIndex = 0
	}
}
const getId = ue => ue.id == null ? ue.flags & 2 ? -1 : 1 / 0 : ue.id;

function flushJobs(ue) {
	try {
		for (flushIndex = 0; flushIndex < queue$1.length; flushIndex++) {
			const Yi = queue$1[flushIndex];
			Yi && !(Yi.flags & 8) && (Yi.flags & 4 && (Yi.flags &= -2), callWithErrorHandling(Yi, Yi.i, Yi.i ? 15 : 14), Yi.flags & 4 || (Yi.flags &= -2))
		}
	} finally {
		for (; flushIndex < queue$1.length; flushIndex++) {
			const Yi = queue$1[flushIndex];
			Yi && (Yi.flags &= -2)
		}
		flushIndex = -1, queue$1.length = 0, flushPostFlushCbs(), currentFlushPromise = null, (queue$1.length || pendingPostFlushCbs.length) && flushJobs()
	}
}
let currentRenderingInstance = null,
	currentScopeId = null;

function setCurrentRenderingInstance(ue) {
	const Yi = currentRenderingInstance;
	return currentRenderingInstance = ue, currentScopeId = ue && ue.type.__scopeId || null, Yi
}

function withCtx(ue, Yi = currentRenderingInstance, ea) {
	if (!Yi || ue._n) return ue;
	const ta = (...na) => {
		ta._d && setBlockTracking(-1);
		const ra = setCurrentRenderingInstance(Yi);
		let ia;
		try {
			ia = ue(...na)
		} finally {
			setCurrentRenderingInstance(ra), ta._d && setBlockTracking(1)
		}
		return ia
	};
	return ta._n = !0, ta._c = !0, ta._d = !0, ta
}

function withDirectives(ue, Yi) {
	if (currentRenderingInstance === null) return ue;
	const ea = getComponentPublicInstance(currentRenderingInstance),
		ta = ue.dirs || (ue.dirs = []);
	for (let na = 0; na < Yi.length; na++) {
		let [ra, ia, aa, oa = EMPTY_OBJ] = Yi[na];
		ra && (isFunction$2(ra) && (ra = {
			mounted: ra,
			updated: ra
		}), ra.deep && traverse(ia), ta.push({
			dir: ra,
			instance: ea,
			value: ia,
			oldValue: void 0,
			arg: aa,
			modifiers: oa
		}))
	}
	return ue
}

function invokeDirectiveHook(ue, Yi, ea, ta) {
	const na = ue.dirs,
		ra = Yi && Yi.dirs;
	for (let ia = 0; ia < na.length; ia++) {
		const aa = na[ia];
		ra && (aa.oldValue = ra[ia].value);
		let oa = aa.dir[ta];
		oa && (pauseTracking(), callWithAsyncErrorHandling(oa, ea, 8, [ue.el, aa, ue, Yi]), resetTracking())
	}
}
const TeleportEndKey = Symbol("_vte"),
	isTeleport = ue => ue.__isTeleport,
	leaveCbKey = Symbol("_leaveCb"),
	enterCbKey$1 = Symbol("_enterCb");

function useTransitionState() {
	const ue = {
		isMounted: !1,
		isLeaving: !1,
		isUnmounting: !1,
		leavingVNodes: new Map
	};
	return onMounted(() => {
		ue.isMounted = !0
	}), onBeforeUnmount(() => {
		ue.isUnmounting = !0
	}), ue
}
const TransitionHookValidator = [Function, Array],
	BaseTransitionPropsValidators = {
		mode: String,
		appear: Boolean,
		persisted: Boolean,
		onBeforeEnter: TransitionHookValidator,
		onEnter: TransitionHookValidator,
		onAfterEnter: TransitionHookValidator,
		onEnterCancelled: TransitionHookValidator,
		onBeforeLeave: TransitionHookValidator,
		onLeave: TransitionHookValidator,
		onAfterLeave: TransitionHookValidator,
		onLeaveCancelled: TransitionHookValidator,
		onBeforeAppear: TransitionHookValidator,
		onAppear: TransitionHookValidator,
		onAfterAppear: TransitionHookValidator,
		onAppearCancelled: TransitionHookValidator
	},
	recursiveGetSubtree = ue => {
		const Yi = ue.subTree;
		return Yi.component ? recursiveGetSubtree(Yi.component) : Yi
	},
	BaseTransitionImpl = {
		name: "BaseTransition",
		props: BaseTransitionPropsValidators,
		setup(ue, {
			slots: Yi
		}) {
			const ea = getCurrentInstance(),
				ta = useTransitionState();
			return () => {
				const na = Yi.default && getTransitionRawChildren(Yi.default(), !0);
				if (!na || !na.length) return;
				const ra = findNonCommentChild(na),
					ia = toRaw(ue),
					{
						mode: aa
					} = ia;
				if (ta.isLeaving) return emptyPlaceholder(ra);
				const oa = getInnerChild$1(ra);
				if (!oa) return emptyPlaceholder(ra);
				let la = resolveTransitionHooks(oa, ia, ta, ea, ua => la = ua);
				oa.type !== Comment && setTransitionHooks(oa, la);
				const sa = ea.subTree,
					ca = sa && getInnerChild$1(sa);
				if (ca && ca.type !== Comment && !isSameVNodeType(oa, ca) && recursiveGetSubtree(ea).type !== Comment) {
					const ua = resolveTransitionHooks(ca, ia, ta, ea);
					if (setTransitionHooks(ca, ua), aa === "out-in" && oa.type !== Comment) return ta.isLeaving = !0, ua.afterLeave = () => {
						ta.isLeaving = !1, ea.job.flags & 8 || ea.update(), delete ua.afterLeave
					}, emptyPlaceholder(ra);
					aa === "in-out" && oa.type !== Comment && (ua.delayLeave = (da, ha, pa) => {
						const va = getLeavingNodesForType(ta, ca);
						va[String(ca.key)] = ca, da[leaveCbKey] = () => {
							ha(), da[leaveCbKey] = void 0, delete la.delayedLeave
						}, la.delayedLeave = pa
					})
				}
				return ra
			}
		}
	};

function findNonCommentChild(ue) {
	let Yi = ue[0];
	if (ue.length > 1) {
		for (const ea of ue)
			if (ea.type !== Comment) {
				Yi = ea;
				break
			}
	}
	return Yi
}
const BaseTransition = BaseTransitionImpl;

function getLeavingNodesForType(ue, Yi) {
	const {
		leavingVNodes: ea
	} = ue;
	let ta = ea.get(Yi.type);
	return ta || (ta = Object.create(null), ea.set(Yi.type, ta)), ta
}

function resolveTransitionHooks(ue, Yi, ea, ta, na) {
	const {
		appear: ra,
		mode: ia,
		persisted: aa = !1,
		onBeforeEnter: oa,
		onEnter: la,
		onAfterEnter: sa,
		onEnterCancelled: ca,
		onBeforeLeave: ua,
		onLeave: da,
		onAfterLeave: ha,
		onLeaveCancelled: pa,
		onBeforeAppear: va,
		onAppear: ba,
		onAfterAppear: Ea,
		onAppearCancelled: Sa
	} = Yi, Ca = String(ue.key), ka = getLeavingNodesForType(ea, ue), Pa = (Ga, Ja) => {
		Ga && callWithAsyncErrorHandling(Ga, ta, 9, Ja)
	}, ja = (Ga, Ja) => {
		const Ua = Ja[1];
		Pa(Ga, Ja), isArray$4(Ga) ? Ga.every(xa => xa.length <= 1) && Ua() : Ga.length <= 1 && Ua()
	}, Za = {
		mode: ia,
		persisted: aa,
		beforeEnter(Ga) {
			let Ja = oa;
			if (!ea.isMounted)
				if (ra) Ja = va || oa;
				else return;
			Ga[leaveCbKey] && Ga[leaveCbKey](!0);
			const Ua = ka[Ca];
			Ua && isSameVNodeType(ue, Ua) && Ua.el[leaveCbKey] && Ua.el[leaveCbKey](), Pa(Ja, [Ga])
		},
		enter(Ga) {
			let Ja = la,
				Ua = sa,
				xa = ca;
			if (!ea.isMounted)
				if (ra) Ja = ba || la, Ua = Ea || sa, xa = Sa || ca;
				else return;
			let ma = !1;
			const fa = Ga[enterCbKey$1] = ga => {
				ma || (ma = !0, ga ? Pa(xa, [Ga]) : Pa(Ua, [Ga]), Za.delayedLeave && Za.delayedLeave(), Ga[enterCbKey$1] = void 0)
			};
			Ja ? ja(Ja, [Ga, fa]) : fa()
		},
		leave(Ga, Ja) {
			const Ua = String(ue.key);
			if (Ga[enterCbKey$1] && Ga[enterCbKey$1](!0), ea.isUnmounting) return Ja();
			Pa(ua, [Ga]);
			let xa = !1;
			const ma = Ga[leaveCbKey] = fa => {
				xa || (xa = !0, Ja(), fa ? Pa(pa, [Ga]) : Pa(ha, [Ga]), Ga[leaveCbKey] = void 0, ka[Ua] === ue && delete ka[Ua])
			};
			ka[Ua] = ue, da ? ja(da, [Ga, ma]) : ma()
		},
		clone(Ga) {
			const Ja = resolveTransitionHooks(Ga, Yi, ea, ta, na);
			return na && na(Ja), Ja
		}
	};
	return Za
}

function emptyPlaceholder(ue) {
	if (isKeepAlive(ue)) return ue = cloneVNode(ue), ue.children = null, ue
}

function getInnerChild$1(ue) {
	if (!isKeepAlive(ue)) return isTeleport(ue.type) && ue.children ? findNonCommentChild(ue.children) : ue;
	const {
		shapeFlag: Yi,
		children: ea
	} = ue;
	if (ea) {
		if (Yi & 16) return ea[0];
		if (Yi & 32 && isFunction$2(ea.default)) return ea.default()
	}
}

function setTransitionHooks(ue, Yi) {
	ue.shapeFlag & 6 && ue.component ? (ue.transition = Yi, setTransitionHooks(ue.component.subTree, Yi)) : ue.shapeFlag & 128 ? (ue.ssContent.transition = Yi.clone(ue.ssContent), ue.ssFallback.transition = Yi.clone(ue.ssFallback)) : ue.transition = Yi
}

function getTransitionRawChildren(ue, Yi = !1, ea) {
	let ta = [],
		na = 0;
	for (let ra = 0; ra < ue.length; ra++) {
		let ia = ue[ra];
		const aa = ea == null ? ia.key : String(ea) + String(ia.key != null ? ia.key : ra);
		ia.type === Fragment ? (ia.patchFlag & 128 && na++, ta = ta.concat(getTransitionRawChildren(ia.children, Yi, aa))) : (Yi || ia.type !== Comment) && ta.push(aa != null ? cloneVNode(ia, {
			key: aa
		}) : ia)
	}
	if (na > 1)
		for (let ra = 0; ra < ta.length; ra++) ta[ra].patchFlag = -2;
	return ta
} /*! #__NO_SIDE_EFFECTS__ */
function defineComponent(ue, Yi) {
	return isFunction$2(ue) ? extend$1({
		name: ue.name
	}, Yi, {
		setup: ue
	}) : ue
}

function markAsyncBoundary(ue) {
	ue.ids = [ue.ids[0] + ue.ids[2]++ + "-", 0, 0]
}

function setRef(ue, Yi, ea, ta, na = !1) {
	if (isArray$4(ue)) {
		ue.forEach((ha, pa) => setRef(ha, Yi && (isArray$4(Yi) ? Yi[pa] : Yi), ea, ta, na));
		return
	}
	if (isAsyncWrapper(ta) && !na) return;
	const ra = ta.shapeFlag & 4 ? getComponentPublicInstance(ta.component) : ta.el,
		ia = na ? null : ra,
		{
			i: aa,
			r: oa
		} = ue,
		la = Yi && Yi.r,
		sa = aa.refs === EMPTY_OBJ ? aa.refs = {} : aa.refs,
		ca = aa.setupState,
		ua = toRaw(ca),
		da = ca === EMPTY_OBJ ? () => !1 : ha => hasOwn$1(ua, ha);
	if (la != null && la !== oa && (isString$4(la) ? (sa[la] = null, da(la) && (ca[la] = null)) : isRef(la) && (la.value = null)), isFunction$2(oa)) callWithErrorHandling(oa, aa, 12, [ia, sa]);
	else {
		const ha = isString$4(oa),
			pa = isRef(oa);
		if (ha || pa) {
			const va = () => {
				if (ue.f) {
					const ba = ha ? da(oa) ? ca[oa] : sa[oa] : oa.value;
					na ? isArray$4(ba) && remove(ba, ra) : isArray$4(ba) ? ba.includes(ra) || ba.push(ra) : ha ? (sa[oa] = [ra], da(oa) && (ca[oa] = sa[oa])) : (oa.value = [ra], ue.k && (sa[ue.k] = oa.value))
				} else ha ? (sa[oa] = ia, da(oa) && (ca[oa] = ia)) : pa && (oa.value = ia, ue.k && (sa[ue.k] = ia))
			};
			ia ? (va.id = -1, queuePostRenderEffect(va, ea)) : va()
		}
	}
}
let hasLoggedMismatchError = !1;
const logMismatchError = () => {
		hasLoggedMismatchError || (console.error("Hydration completed but contains mismatches."), hasLoggedMismatchError = !0)
	},
	isSVGContainer = ue => ue.namespaceURI.includes("svg") && ue.tagName !== "foreignObject",
	isMathMLContainer = ue => ue.namespaceURI.includes("MathML"),
	getContainerType = ue => {
		if (ue.nodeType === 1) {
			if (isSVGContainer(ue)) return "svg";
			if (isMathMLContainer(ue)) return "mathml"
		}
	},
	isComment = ue => ue.nodeType === 8;

function createHydrationFunctions(ue) {
	const {
		mt: Yi,
		p: ea,
		o: {
			patchProp: ta,
			createText: na,
			nextSibling: ra,
			parentNode: ia,
			remove: aa,
			insert: oa,
			createComment: la
		}
	} = ue, sa = (Sa, Ca) => {
		if (!Ca.hasChildNodes()) {
			ea(null, Sa, Ca), flushPostFlushCbs(), Ca._vnode = Sa;
			return
		}
		ca(Ca.firstChild, Sa, null, null, null), flushPostFlushCbs(), Ca._vnode = Sa
	}, ca = (Sa, Ca, ka, Pa, ja, Za = !1) => {
		Za = Za || !!Ca.dynamicChildren;
		const Ga = isComment(Sa) && Sa.data === "[",
			Ja = () => pa(Sa, Ca, ka, Pa, ja, Ga),
			{
				type: Ua,
				ref: xa,
				shapeFlag: ma,
				patchFlag: fa
			} = Ca;
		let ga = Sa.nodeType;
		Ca.el = Sa, fa === -2 && (Za = !1, Ca.dynamicChildren = null);
		let wa = null;
		switch (Ua) {
			case Text:
				ga !== 3 ? Ca.children === "" ? (oa(Ca.el = na(""), ia(Sa), Sa), wa = Sa) : wa = Ja() : (Sa.data !== Ca.children && (logMismatchError(), Sa.data = Ca.children), wa = ra(Sa));
				break;
			case Comment:
				Ea(Sa) ? (wa = ra(Sa), ba(Ca.el = Sa.content.firstChild, Sa, ka)) : ga !== 8 || Ga ? wa = Ja() : wa = ra(Sa);
				break;
			case Static:
				if (Ga && (Sa = ra(Sa), ga = Sa.nodeType), ga === 1 || ga === 3) {
					wa = Sa;
					const Ma = !Ca.children.length;
					for (let Aa = 0; Aa < Ca.staticCount; Aa++) Ma && (Ca.children += wa.nodeType === 1 ? wa.outerHTML : wa.data), Aa === Ca.staticCount - 1 && (Ca.anchor = wa), wa = ra(wa);
					return Ga ? ra(wa) : wa
				} else Ja();
				break;
			case Fragment:
				Ga ? wa = ha(Sa, Ca, ka, Pa, ja, Za) : wa = Ja();
				break;
			default:
				if (ma & 1)(ga !== 1 || Ca.type.toLowerCase() !== Sa.tagName.toLowerCase()) && !Ea(Sa) ? wa = Ja() : wa = ua(Sa, Ca, ka, Pa, ja, Za);
				else if (ma & 6) {
					Ca.slotScopeIds = ja;
					const Ma = ia(Sa);
					if (Ga ? wa = va(Sa) : isComment(Sa) && Sa.data === "teleport start" ? wa = va(Sa, Sa.data, "teleport end") : wa = ra(Sa), Yi(Ca, Ma, null, ka, Pa, getContainerType(Ma), Za), isAsyncWrapper(Ca)) {
						let Aa;
						Ga ? (Aa = createVNode(Fragment), Aa.anchor = wa ? wa.previousSibling : Ma.lastChild) : Aa = Sa.nodeType === 3 ? createTextVNode("") : createVNode("div"), Aa.el = Sa, Ca.component.subTree = Aa
					}
				} else ma & 64 ? ga !== 8 ? wa = Ja() : wa = Ca.type.hydrate(Sa, Ca, ka, Pa, ja, Za, ue, da) : ma & 128 && (wa = Ca.type.hydrate(Sa, Ca, ka, Pa, getContainerType(ia(Sa)), ja, Za, ue, ca))
		}
		return xa != null && setRef(xa, null, Pa, Ca), wa
	}, ua = (Sa, Ca, ka, Pa, ja, Za) => {
		Za = Za || !!Ca.dynamicChildren;
		const {
			type: Ga,
			props: Ja,
			patchFlag: Ua,
			shapeFlag: xa,
			dirs: ma,
			transition: fa
		} = Ca, ga = Ga === "input" || Ga === "option";
		if (ga || Ua !== -1) {
			ma && invokeDirectiveHook(Ca, null, ka, "created");
			let wa = !1;
			if (Ea(Sa)) {
				wa = needTransition(Pa, fa) && ka && ka.vnode.props && ka.vnode.props.appear;
				const Aa = Sa.content.firstChild;
				wa && fa.beforeEnter(Aa), ba(Aa, Sa, ka), Ca.el = Sa = Aa
			}
			if (xa & 16 && !(Ja && (Ja.innerHTML || Ja.textContent))) {
				let Aa = da(Sa.firstChild, Ca, Sa, ka, Pa, ja, Za);
				for (; Aa;) {
					isMismatchAllowed(Sa, 1) || logMismatchError();
					const Ra = Aa;
					Aa = Aa.nextSibling, aa(Ra)
				}
			} else if (xa & 8) {
				let Aa = Ca.children;
				Aa[0] === `
` && (Sa.tagName === "PRE" || Sa.tagName === "TEXTAREA") && (Aa = Aa.slice(1)), Sa.textContent !== Aa && (isMismatchAllowed(Sa, 0) || logMismatchError(), Sa.textContent = Ca.children)
			}
			if (Ja) {
				if (ga || !Za || Ua & 48) {
					const Aa = Sa.tagName.includes("-");
					for (const Ra in Ja)(ga && (Ra.endsWith("value") || Ra === "indeterminate") || isOn(Ra) && !isReservedProp(Ra) || Ra[0] === "." || Aa) && ta(Sa, Ra, null, Ja[Ra], void 0, ka)
				} else if (Ja.onClick) ta(Sa, "onClick", null, Ja.onClick, void 0, ka);
				else if (Ua & 4 && isReactive(Ja.style))
					for (const Aa in Ja.style) Ja.style[Aa]
			}
			let Ma;
			(Ma = Ja && Ja.onVnodeBeforeMount) && invokeVNodeHook(Ma, ka, Ca), ma && invokeDirectiveHook(Ca, null, ka, "beforeMount"), ((Ma = Ja && Ja.onVnodeMounted) || ma || wa) && queueEffectWithSuspense(() => {
				Ma && invokeVNodeHook(Ma, ka, Ca), wa && fa.enter(Sa), ma && invokeDirectiveHook(Ca, null, ka, "mounted")
			}, Pa)
		}
		return Sa.nextSibling
	}, da = (Sa, Ca, ka, Pa, ja, Za, Ga) => {
		Ga = Ga || !!Ca.dynamicChildren;
		const Ja = Ca.children,
			Ua = Ja.length;
		for (let xa = 0; xa < Ua; xa++) {
			const ma = Ga ? Ja[xa] : Ja[xa] = normalizeVNode(Ja[xa]),
				fa = ma.type === Text;
			Sa ? (fa && !Ga && xa + 1 < Ua && normalizeVNode(Ja[xa + 1]).type === Text && (oa(na(Sa.data.slice(ma.children.length)), ka, ra(Sa)), Sa.data = ma.children), Sa = ca(Sa, ma, Pa, ja, Za, Ga)) : fa && !ma.children ? oa(ma.el = na(""), ka) : (isMismatchAllowed(ka, 1) || logMismatchError(), ea(null, ma, ka, null, Pa, ja, getContainerType(ka), Za))
		}
		return Sa
	}, ha = (Sa, Ca, ka, Pa, ja, Za) => {
		const {
			slotScopeIds: Ga
		} = Ca;
		Ga && (ja = ja ? ja.concat(Ga) : Ga);
		const Ja = ia(Sa),
			Ua = da(ra(Sa), Ca, Ja, ka, Pa, ja, Za);
		return Ua && isComment(Ua) && Ua.data === "]" ? ra(Ca.anchor = Ua) : (logMismatchError(), oa(Ca.anchor = la("]"), Ja, Ua), Ua)
	}, pa = (Sa, Ca, ka, Pa, ja, Za) => {
		if (isMismatchAllowed(Sa.parentElement, 1) || logMismatchError(), Ca.el = null, Za) {
			const Ua = va(Sa);
			for (;;) {
				const xa = ra(Sa);
				if (xa && xa !== Ua) aa(xa);
				else break
			}
		}
		const Ga = ra(Sa),
			Ja = ia(Sa);
		return aa(Sa), ea(null, Ca, Ja, Ga, ka, Pa, getContainerType(Ja), ja), Ga
	}, va = (Sa, Ca = "[", ka = "]") => {
		let Pa = 0;
		for (; Sa;)
			if (Sa = ra(Sa), Sa && isComment(Sa) && (Sa.data === Ca && Pa++, Sa.data === ka)) {
				if (Pa === 0) return ra(Sa);
				Pa--
			} return Sa
	}, ba = (Sa, Ca, ka) => {
		const Pa = Ca.parentNode;
		Pa && Pa.replaceChild(Sa, Ca);
		let ja = ka;
		for (; ja;) ja.vnode.el === Ca && (ja.vnode.el = ja.subTree.el = Sa), ja = ja.parent
	}, Ea = Sa => Sa.nodeType === 1 && Sa.tagName === "TEMPLATE";
	return [sa, ca]
}
const allowMismatchAttr = "data-allow-mismatch",
	MismatchTypeString = {
		0: "text",
		1: "children",
		2: "class",
		3: "style",
		4: "attribute"
	};

function isMismatchAllowed(ue, Yi) {
	if (Yi === 0 || Yi === 1)
		for (; ue && !ue.hasAttribute(allowMismatchAttr);) ue = ue.parentElement;
	const ea = ue && ue.getAttribute(allowMismatchAttr);
	if (ea == null) return !1;
	if (ea === "") return !0;
	{
		const ta = ea.split(",");
		return Yi === 0 && ta.includes("children") ? !0 : ea.split(",").includes(MismatchTypeString[Yi])
	}
}
const isAsyncWrapper = ue => !!ue.type.__asyncLoader,
	isKeepAlive = ue => ue.type.__isKeepAlive,
	KeepAliveImpl = {
		name: "KeepAlive",
		__isKeepAlive: !0,
		props: {
			include: [String, RegExp, Array],
			exclude: [String, RegExp, Array],
			max: [String, Number]
		},
		setup(ue, {
			slots: Yi
		}) {
			const ea = getCurrentInstance(),
				ta = ea.ctx;
			if (!ta.renderer) return () => {
				const Ea = Yi.default && Yi.default();
				return Ea && Ea.length === 1 ? Ea[0] : Ea
			};
			const na = new Map,
				ra = new Set;
			let ia = null;
			const aa = ea.suspense,
				{
					renderer: {
						p: oa,
						m: la,
						um: sa,
						o: {
							createElement: ca
						}
					}
				} = ta,
				ua = ca("div");
			ta.activate = (Ea, Sa, Ca, ka, Pa) => {
				const ja = Ea.component;
				la(Ea, Sa, Ca, 0, aa), oa(ja.vnode, Ea, Sa, Ca, ja, aa, ka, Ea.slotScopeIds, Pa), queuePostRenderEffect(() => {
					ja.isDeactivated = !1, ja.a && invokeArrayFns(ja.a);
					const Za = Ea.props && Ea.props.onVnodeMounted;
					Za && invokeVNodeHook(Za, ja.parent, Ea)
				}, aa)
			}, ta.deactivate = Ea => {
				const Sa = Ea.component;
				invalidateMount(Sa.m), invalidateMount(Sa.a), la(Ea, ua, null, 1, aa), queuePostRenderEffect(() => {
					Sa.da && invokeArrayFns(Sa.da);
					const Ca = Ea.props && Ea.props.onVnodeUnmounted;
					Ca && invokeVNodeHook(Ca, Sa.parent, Ea), Sa.isDeactivated = !0
				}, aa)
			};

			function da(Ea) {
				resetShapeFlag(Ea), sa(Ea, ea, aa, !0)
			}

			function ha(Ea) {
				na.forEach((Sa, Ca) => {
					const ka = getComponentName$1(Sa.type);
					ka && !Ea(ka) && pa(Ca)
				})
			}

			function pa(Ea) {
				const Sa = na.get(Ea);
				Sa && (!ia || !isSameVNodeType(Sa, ia)) ? da(Sa) : ia && resetShapeFlag(ia), na.delete(Ea), ra.delete(Ea)
			}
			watch(() => [ue.include, ue.exclude], ([Ea, Sa]) => {
				Ea && ha(Ca => matches(Ea, Ca)), Sa && ha(Ca => !matches(Sa, Ca))
			}, {
				flush: "post",
				deep: !0
			});
			let va = null;
			const ba = () => {
				va != null && (isSuspense(ea.subTree.type) ? queuePostRenderEffect(() => {
					na.set(va, getInnerChild(ea.subTree))
				}, ea.subTree.suspense) : na.set(va, getInnerChild(ea.subTree)))
			};
			return onMounted(ba), onUpdated(ba), onBeforeUnmount(() => {
				na.forEach(Ea => {
					const {
						subTree: Sa,
						suspense: Ca
					} = ea, ka = getInnerChild(Sa);
					if (Ea.type === ka.type && Ea.key === ka.key) {
						resetShapeFlag(ka);
						const Pa = ka.component.da;
						Pa && queuePostRenderEffect(Pa, Ca);
						return
					}
					da(Ea)
				})
			}), () => {
				if (va = null, !Yi.default) return ia = null;
				const Ea = Yi.default(),
					Sa = Ea[0];
				if (Ea.length > 1) return ia = null, Ea;
				if (!isVNode$1(Sa) || !(Sa.shapeFlag & 4) && !(Sa.shapeFlag & 128)) return ia = null, Sa;
				let Ca = getInnerChild(Sa);
				if (Ca.type === Comment) return ia = null, Ca;
				const ka = Ca.type,
					Pa = getComponentName$1(isAsyncWrapper(Ca) ? Ca.type.__asyncResolved || {} : ka),
					{
						include: ja,
						exclude: Za,
						max: Ga
					} = ue;
				if (ja && (!Pa || !matches(ja, Pa)) || Za && Pa && matches(Za, Pa)) return Ca.shapeFlag &= -257, ia = Ca, Sa;
				const Ja = Ca.key == null ? ka : Ca.key,
					Ua = na.get(Ja);
				return Ca.el && (Ca = cloneVNode(Ca), Sa.shapeFlag & 128 && (Sa.ssContent = Ca)), va = Ja, Ua ? (Ca.el = Ua.el, Ca.component = Ua.component, Ca.transition && setTransitionHooks(Ca, Ca.transition), Ca.shapeFlag |= 512, ra.delete(Ja), ra.add(Ja)) : (ra.add(Ja), Ga && ra.size > parseInt(Ga, 10) && pa(ra.values().next().value)), Ca.shapeFlag |= 256, ia = Ca, isSuspense(Sa.type) ? Sa : Ca
			}
		}
	},
	KeepAlive = KeepAliveImpl;

function matches(ue, Yi) {
	return isArray$4(ue) ? ue.some(ea => matches(ea, Yi)) : isString$4(ue) ? ue.split(",").includes(Yi) : isRegExp$3(ue) ? (ue.lastIndex = 0, ue.test(Yi)) : !1
}

function onActivated(ue, Yi) {
	registerKeepAliveHook(ue, "a", Yi)
}

function onDeactivated(ue, Yi) {
	registerKeepAliveHook(ue, "da", Yi)
}

function registerKeepAliveHook(ue, Yi, ea = currentInstance) {
	const ta = ue.__wdc || (ue.__wdc = () => {
		let na = ea;
		for (; na;) {
			if (na.isDeactivated) return;
			na = na.parent
		}
		return ue()
	});
	if (injectHook(Yi, ta, ea), ea) {
		let na = ea.parent;
		for (; na && na.parent;) isKeepAlive(na.parent.vnode) && injectToKeepAliveRoot(ta, Yi, ea, na), na = na.parent
	}
}

function injectToKeepAliveRoot(ue, Yi, ea, ta) {
	const na = injectHook(Yi, ue, ta, !0);
	onUnmounted(() => {
		remove(ta[Yi], na)
	}, ea)
}

function resetShapeFlag(ue) {
	ue.shapeFlag &= -257, ue.shapeFlag &= -513
}

function getInnerChild(ue) {
	return ue.shapeFlag & 128 ? ue.ssContent : ue
}

function injectHook(ue, Yi, ea = currentInstance, ta = !1) {
	if (ea) {
		const na = ea[ue] || (ea[ue] = []),
			ra = Yi.__weh || (Yi.__weh = (...ia) => {
				pauseTracking();
				const aa = setCurrentInstance(ea),
					oa = callWithAsyncErrorHandling(Yi, ea, ue, ia);
				return aa(), resetTracking(), oa
			});
		return ta ? na.unshift(ra) : na.push(ra), ra
	}
}
const createHook = ue => (Yi, ea = currentInstance) => {
		(!isInSSRComponentSetup || ue === "sp") && injectHook(ue, (...ta) => Yi(...ta), ea)
	},
	onBeforeMount = createHook("bm"),
	onMounted = createHook("m"),
	onBeforeUpdate = createHook("bu"),
	onUpdated = createHook("u"),
	onBeforeUnmount = createHook("bum"),
	onUnmounted = createHook("um"),
	onServerPrefetch = createHook("sp"),
	onRenderTriggered = createHook("rtg"),
	onRenderTracked = createHook("rtc");

function onErrorCaptured(ue, Yi = currentInstance) {
	injectHook("ec", ue, Yi)
}
const COMPONENTS = "components",
	DIRECTIVES = "directives";

function resolveComponent(ue, Yi) {
	return resolveAsset(COMPONENTS, ue, !0, Yi) || ue
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");

function resolveDynamicComponent(ue) {
	return isString$4(ue) ? resolveAsset(COMPONENTS, ue, !1) || ue : ue || NULL_DYNAMIC_COMPONENT
}

function resolveDirective(ue) {
	return resolveAsset(DIRECTIVES, ue)
}

function resolveAsset(ue, Yi, ea = !0, ta = !1) {
	const na = currentRenderingInstance || currentInstance;
	if (na) {
		const ra = na.type;
		if (ue === COMPONENTS) {
			const aa = getComponentName$1(ra, !1);
			if (aa && (aa === Yi || aa === camelize(Yi) || aa === capitalize$2(camelize(Yi)))) return ra
		}
		const ia = resolve$1(na[ue] || ra[ue], Yi) || resolve$1(na.appContext[ue], Yi);
		return !ia && ta ? ra : ia
	}
}

function resolve$1(ue, Yi) {
	return ue && (ue[Yi] || ue[camelize(Yi)] || ue[capitalize$2(camelize(Yi))])
}

function renderList(ue, Yi, ea, ta) {
	let na;
	const ra = ea,
		ia = isArray$4(ue);
	if (ia || isString$4(ue)) {
		const aa = ia && isReactive(ue);
		let oa = !1;
		aa && (oa = !isShallow(ue), ue = shallowReadArray(ue)), na = new Array(ue.length);
		for (let la = 0, sa = ue.length; la < sa; la++) na[la] = Yi(oa ? toReactive(ue[la]) : ue[la], la, void 0, ra)
	} else if (typeof ue == "number") {
		na = new Array(ue);
		for (let aa = 0; aa < ue; aa++) na[aa] = Yi(aa + 1, aa, void 0, ra)
	} else if (isObject$3(ue))
		if (ue[Symbol.iterator]) na = Array.from(ue, (aa, oa) => Yi(aa, oa, void 0, ra));
		else {
			const aa = Object.keys(ue);
			na = new Array(aa.length);
			for (let oa = 0, la = aa.length; oa < la; oa++) {
				const sa = aa[oa];
				na[oa] = Yi(ue[sa], sa, oa, ra)
			}
		}
	else na = [];
	return na
}

function createSlots(ue, Yi) {
	for (let ea = 0; ea < Yi.length; ea++) {
		const ta = Yi[ea];
		if (isArray$4(ta))
			for (let na = 0; na < ta.length; na++) ue[ta[na].name] = ta[na].fn;
		else ta && (ue[ta.name] = ta.key ? (...na) => {
			const ra = ta.fn(...na);
			return ra && (ra.key = ta.key), ra
		} : ta.fn)
	}
	return ue
}

function renderSlot(ue, Yi, ea = {}, ta, na) {
	if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) return Yi !== "default" && (ea.name = Yi), openBlock(), createBlock(Fragment, null, [createVNode("slot", ea, ta && ta())], 64);
	let ra = ue[Yi];
	ra && ra._c && (ra._d = !1), openBlock();
	const ia = ra && ensureValidVNode(ra(ea)),
		aa = createBlock(Fragment, {
			key: (ea.key || ia && ia.key || `_${Yi}`) + (!ia && ta ? "_fb" : "")
		}, ia || (ta ? ta() : []), ia && ue._ === 1 ? 64 : -2);
	return !na && aa.scopeId && (aa.slotScopeIds = [aa.scopeId + "-s"]), ra && ra._c && (ra._d = !0), aa
}

function ensureValidVNode(ue) {
	return ue.some(Yi => isVNode$1(Yi) ? !(Yi.type === Comment || Yi.type === Fragment && !ensureValidVNode(Yi.children)) : !0) ? ue : null
}
const getPublicInstance = ue => ue ? isStatefulComponent(ue) ? getComponentPublicInstance(ue) : getPublicInstance(ue.parent) : null,
	publicPropertiesMap = extend$1(Object.create(null), {
		$: ue => ue,
		$el: ue => ue.vnode.el,
		$data: ue => ue.data,
		$props: ue => ue.props,
		$attrs: ue => ue.attrs,
		$slots: ue => ue.slots,
		$refs: ue => ue.refs,
		$parent: ue => getPublicInstance(ue.parent),
		$root: ue => getPublicInstance(ue.root),
		$host: ue => ue.ce,
		$emit: ue => ue.emit,
		$options: ue => resolveMergedOptions(ue),
		$forceUpdate: ue => ue.f || (ue.f = () => {
			queueJob(ue.update)
		}),
		$nextTick: ue => ue.n || (ue.n = nextTick.bind(ue.proxy)),
		$watch: ue => instanceWatch.bind(ue)
	}),
	hasSetupBinding = (ue, Yi) => ue !== EMPTY_OBJ && !ue.__isScriptSetup && hasOwn$1(ue, Yi),
	PublicInstanceProxyHandlers = {
		get({
			_: ue
		}, Yi) {
			if (Yi === "__v_skip") return !0;
			const {
				ctx: ea,
				setupState: ta,
				data: na,
				props: ra,
				accessCache: ia,
				type: aa,
				appContext: oa
			} = ue;
			let la;
			if (Yi[0] !== "$") {
				const da = ia[Yi];
				if (da !== void 0) switch (da) {
					case 1:
						return ta[Yi];
					case 2:
						return na[Yi];
					case 4:
						return ea[Yi];
					case 3:
						return ra[Yi]
				} else {
					if (hasSetupBinding(ta, Yi)) return ia[Yi] = 1, ta[Yi];
					if (na !== EMPTY_OBJ && hasOwn$1(na, Yi)) return ia[Yi] = 2, na[Yi];
					if ((la = ue.propsOptions[0]) && hasOwn$1(la, Yi)) return ia[Yi] = 3, ra[Yi];
					if (ea !== EMPTY_OBJ && hasOwn$1(ea, Yi)) return ia[Yi] = 4, ea[Yi];
					shouldCacheAccess && (ia[Yi] = 0)
				}
			}
			const sa = publicPropertiesMap[Yi];
			let ca, ua;
			if (sa) return Yi === "$attrs" && track(ue.attrs, "get", ""), sa(ue);
			if ((ca = aa.__cssModules) && (ca = ca[Yi])) return ca;
			if (ea !== EMPTY_OBJ && hasOwn$1(ea, Yi)) return ia[Yi] = 4, ea[Yi];
			if (ua = oa.config.globalProperties, hasOwn$1(ua, Yi)) return ua[Yi]
		},
		set({
			_: ue
		}, Yi, ea) {
			const {
				data: ta,
				setupState: na,
				ctx: ra
			} = ue;
			return hasSetupBinding(na, Yi) ? (na[Yi] = ea, !0) : ta !== EMPTY_OBJ && hasOwn$1(ta, Yi) ? (ta[Yi] = ea, !0) : hasOwn$1(ue.props, Yi) || Yi[0] === "$" && Yi.slice(1) in ue ? !1 : (ra[Yi] = ea, !0)
		},
		has({
			_: {
				data: ue,
				setupState: Yi,
				accessCache: ea,
				ctx: ta,
				appContext: na,
				propsOptions: ra
			}
		}, ia) {
			let aa;
			return !!ea[ia] || ue !== EMPTY_OBJ && hasOwn$1(ue, ia) || hasSetupBinding(Yi, ia) || (aa = ra[0]) && hasOwn$1(aa, ia) || hasOwn$1(ta, ia) || hasOwn$1(publicPropertiesMap, ia) || hasOwn$1(na.config.globalProperties, ia)
		},
		defineProperty(ue, Yi, ea) {
			return ea.get != null ? ue._.accessCache[Yi] = 0 : hasOwn$1(ea, "value") && this.set(ue, Yi, ea.value, null), Reflect.defineProperty(ue, Yi, ea)
		}
	};

function normalizePropsOrEmits(ue) {
	return isArray$4(ue) ? ue.reduce((Yi, ea) => (Yi[ea] = null, Yi), {}) : ue
}

function mergeModels(ue, Yi) {
	return !ue || !Yi ? ue || Yi : isArray$4(ue) && isArray$4(Yi) ? ue.concat(Yi) : extend$1({}, normalizePropsOrEmits(ue), normalizePropsOrEmits(Yi))
}
let shouldCacheAccess = !0;

function applyOptions(ue) {
	const Yi = resolveMergedOptions(ue),
		ea = ue.proxy,
		ta = ue.ctx;
	shouldCacheAccess = !1, Yi.beforeCreate && callHook$1(Yi.beforeCreate, ue, "bc");
	const {
		data: na,
		computed: ra,
		methods: ia,
		watch: aa,
		provide: oa,
		inject: la,
		created: sa,
		beforeMount: ca,
		mounted: ua,
		beforeUpdate: da,
		updated: ha,
		activated: pa,
		deactivated: va,
		beforeDestroy: ba,
		beforeUnmount: Ea,
		destroyed: Sa,
		unmounted: Ca,
		render: ka,
		renderTracked: Pa,
		renderTriggered: ja,
		errorCaptured: Za,
		serverPrefetch: Ga,
		expose: Ja,
		inheritAttrs: Ua,
		components: xa,
		directives: ma,
		filters: fa
	} = Yi;
	if (la && resolveInjections(la, ta, null), ia)
		for (const Ma in ia) {
			const Aa = ia[Ma];
			isFunction$2(Aa) && (ta[Ma] = Aa.bind(ea))
		}
	if (na) {
		const Ma = na.call(ea, ea);
		isObject$3(Ma) && (ue.data = reactive(Ma))
	}
	if (shouldCacheAccess = !0, ra)
		for (const Ma in ra) {
			const Aa = ra[Ma],
				Ra = isFunction$2(Aa) ? Aa.bind(ea, ea) : isFunction$2(Aa.get) ? Aa.get.bind(ea, ea) : NOOP,
				Ta = !isFunction$2(Aa) && isFunction$2(Aa.set) ? Aa.set.bind(ea) : NOOP,
				La = computed({
					get: Ra,
					set: Ta
				});
			Object.defineProperty(ta, Ma, {
				enumerable: !0,
				configurable: !0,
				get: () => La.value,
				set: ya => La.value = ya
			})
		}
	if (aa)
		for (const Ma in aa) createWatcher(aa[Ma], ta, ea, Ma);
	if (oa) {
		const Ma = isFunction$2(oa) ? oa.call(ea) : oa;
		Reflect.ownKeys(Ma).forEach(Aa => {
			provide(Aa, Ma[Aa])
		})
	}
	sa && callHook$1(sa, ue, "c");

	function wa(Ma, Aa) {
		isArray$4(Aa) ? Aa.forEach(Ra => Ma(Ra.bind(ea))) : Aa && Ma(Aa.bind(ea))
	}
	if (wa(onBeforeMount, ca), wa(onMounted, ua), wa(onBeforeUpdate, da), wa(onUpdated, ha), wa(onActivated, pa), wa(onDeactivated, va), wa(onErrorCaptured, Za), wa(onRenderTracked, Pa), wa(onRenderTriggered, ja), wa(onBeforeUnmount, Ea), wa(onUnmounted, Ca), wa(onServerPrefetch, Ga), isArray$4(Ja))
		if (Ja.length) {
			const Ma = ue.exposed || (ue.exposed = {});
			Ja.forEach(Aa => {
				Object.defineProperty(Ma, Aa, {
					get: () => ea[Aa],
					set: Ra => ea[Aa] = Ra
				})
			})
		} else ue.exposed || (ue.exposed = {});
	ka && ue.render === NOOP && (ue.render = ka), Ua != null && (ue.inheritAttrs = Ua), xa && (ue.components = xa), ma && (ue.directives = ma), Ga && markAsyncBoundary(ue)
}

function resolveInjections(ue, Yi, ea = NOOP) {
	isArray$4(ue) && (ue = normalizeInject(ue));
	for (const ta in ue) {
		const na = ue[ta];
		let ra;
		isObject$3(na) ? "default" in na ? ra = inject(na.from || ta, na.default, !0) : ra = inject(na.from || ta) : ra = inject(na), isRef(ra) ? Object.defineProperty(Yi, ta, {
			enumerable: !0,
			configurable: !0,
			get: () => ra.value,
			set: ia => ra.value = ia
		}) : Yi[ta] = ra
	}
}

function callHook$1(ue, Yi, ea) {
	callWithAsyncErrorHandling(isArray$4(ue) ? ue.map(ta => ta.bind(Yi.proxy)) : ue.bind(Yi.proxy), Yi, ea)
}

function createWatcher(ue, Yi, ea, ta) {
	let na = ta.includes(".") ? createPathGetter(ea, ta) : () => ea[ta];
	if (isString$4(ue)) {
		const ra = Yi[ue];
		isFunction$2(ra) && watch(na, ra)
	} else if (isFunction$2(ue)) watch(na, ue.bind(ea));
	else if (isObject$3(ue))
		if (isArray$4(ue)) ue.forEach(ra => createWatcher(ra, Yi, ea, ta));
		else {
			const ra = isFunction$2(ue.handler) ? ue.handler.bind(ea) : Yi[ue.handler];
			isFunction$2(ra) && watch(na, ra, ue)
		}
}

function resolveMergedOptions(ue) {
	const Yi = ue.type,
		{
			mixins: ea,
			extends: ta
		} = Yi,
		{
			mixins: na,
			optionsCache: ra,
			config: {
				optionMergeStrategies: ia
			}
		} = ue.appContext,
		aa = ra.get(Yi);
	let oa;
	return aa ? oa = aa : !na.length && !ea && !ta ? oa = Yi : (oa = {}, na.length && na.forEach(la => mergeOptions$2(oa, la, ia, !0)), mergeOptions$2(oa, Yi, ia)), isObject$3(Yi) && ra.set(Yi, oa), oa
}

function mergeOptions$2(ue, Yi, ea, ta = !1) {
	const {
		mixins: na,
		extends: ra
	} = Yi;
	ra && mergeOptions$2(ue, ra, ea, !0), na && na.forEach(ia => mergeOptions$2(ue, ia, ea, !0));
	for (const ia in Yi)
		if (!(ta && ia === "expose")) {
			const aa = internalOptionMergeStrats[ia] || ea && ea[ia];
			ue[ia] = aa ? aa(ue[ia], Yi[ia]) : Yi[ia]
		} return ue
}
const internalOptionMergeStrats = {
	data: mergeDataFn,
	props: mergeEmitsOrPropsOptions,
	emits: mergeEmitsOrPropsOptions,
	methods: mergeObjectOptions,
	computed: mergeObjectOptions,
	beforeCreate: mergeAsArray,
	created: mergeAsArray,
	beforeMount: mergeAsArray,
	mounted: mergeAsArray,
	beforeUpdate: mergeAsArray,
	updated: mergeAsArray,
	beforeDestroy: mergeAsArray,
	beforeUnmount: mergeAsArray,
	destroyed: mergeAsArray,
	unmounted: mergeAsArray,
	activated: mergeAsArray,
	deactivated: mergeAsArray,
	errorCaptured: mergeAsArray,
	serverPrefetch: mergeAsArray,
	components: mergeObjectOptions,
	directives: mergeObjectOptions,
	watch: mergeWatchOptions,
	provide: mergeDataFn,
	inject: mergeInject
};

function mergeDataFn(ue, Yi) {
	return Yi ? ue ? function() {
		return extend$1(isFunction$2(ue) ? ue.call(this, this) : ue, isFunction$2(Yi) ? Yi.call(this, this) : Yi)
	} : Yi : ue
}

function mergeInject(ue, Yi) {
	return mergeObjectOptions(normalizeInject(ue), normalizeInject(Yi))
}

function normalizeInject(ue) {
	if (isArray$4(ue)) {
		const Yi = {};
		for (let ea = 0; ea < ue.length; ea++) Yi[ue[ea]] = ue[ea];
		return Yi
	}
	return ue
}

function mergeAsArray(ue, Yi) {
	return ue ? [...new Set([].concat(ue, Yi))] : Yi
}

function mergeObjectOptions(ue, Yi) {
	return ue ? extend$1(Object.create(null), ue, Yi) : Yi
}

function mergeEmitsOrPropsOptions(ue, Yi) {
	return ue ? isArray$4(ue) && isArray$4(Yi) ? [...new Set([...ue, ...Yi])] : extend$1(Object.create(null), normalizePropsOrEmits(ue), normalizePropsOrEmits(Yi ?? {})) : Yi
}

function mergeWatchOptions(ue, Yi) {
	if (!ue) return Yi;
	if (!Yi) return ue;
	const ea = extend$1(Object.create(null), ue);
	for (const ta in Yi) ea[ta] = mergeAsArray(ue[ta], Yi[ta]);
	return ea
}

function createAppContext() {
	return {
		app: null,
		config: {
			isNativeTag: NO,
			performance: !1,
			globalProperties: {},
			optionMergeStrategies: {},
			errorHandler: void 0,
			warnHandler: void 0,
			compilerOptions: {}
		},
		mixins: [],
		components: {},
		directives: {},
		provides: Object.create(null),
		optionsCache: new WeakMap,
		propsCache: new WeakMap,
		emitsCache: new WeakMap
	}
}
let uid$1 = 0;

function createAppAPI(ue, Yi) {
	return function(ta, na = null) {
		isFunction$2(ta) || (ta = extend$1({}, ta)), na != null && !isObject$3(na) && (na = null);
		const ra = createAppContext(),
			ia = new WeakSet,
			aa = [];
		let oa = !1;
		const la = ra.app = {
			_uid: uid$1++,
			_component: ta,
			_props: na,
			_container: null,
			_context: ra,
			_instance: null,
			version: version$1,
			get config() {
				return ra.config
			},
			set config(sa) {},
			use(sa, ...ca) {
				return ia.has(sa) || (sa && isFunction$2(sa.install) ? (ia.add(sa), sa.install(la, ...ca)) : isFunction$2(sa) && (ia.add(sa), sa(la, ...ca))), la
			},
			mixin(sa) {
				return ra.mixins.includes(sa) || ra.mixins.push(sa), la
			},
			component(sa, ca) {
				return ca ? (ra.components[sa] = ca, la) : ra.components[sa]
			},
			directive(sa, ca) {
				return ca ? (ra.directives[sa] = ca, la) : ra.directives[sa]
			},
			mount(sa, ca, ua) {
				if (!oa) {
					const da = la._ceVNode || createVNode(ta, na);
					return da.appContext = ra, ua === !0 ? ua = "svg" : ua === !1 && (ua = void 0), ca && Yi ? Yi(da, sa) : ue(da, sa, ua), oa = !0, la._container = sa, sa.__vue_app__ = la, getComponentPublicInstance(da.component)
				}
			},
			onUnmount(sa) {
				aa.push(sa)
			},
			unmount() {
				oa && (callWithAsyncErrorHandling(aa, la._instance, 16), ue(null, la._container), delete la._container.__vue_app__)
			},
			provide(sa, ca) {
				return ra.provides[sa] = ca, la
			},
			runWithContext(sa) {
				const ca = currentApp;
				currentApp = la;
				try {
					return sa()
				} finally {
					currentApp = ca
				}
			}
		};
		return la
	}
}
let currentApp = null;

function provide(ue, Yi) {
	if (currentInstance) {
		let ea = currentInstance.provides;
		const ta = currentInstance.parent && currentInstance.parent.provides;
		ta === ea && (ea = currentInstance.provides = Object.create(ta)), ea[ue] = Yi
	}
}

function inject(ue, Yi, ea = !1) {
	const ta = currentInstance || currentRenderingInstance;
	if (ta || currentApp) {
		const na = currentApp ? currentApp._context.provides : ta ? ta.parent == null ? ta.vnode.appContext && ta.vnode.appContext.provides : ta.parent.provides : void 0;
		if (na && ue in na) return na[ue];
		if (arguments.length > 1) return ea && isFunction$2(Yi) ? Yi.call(ta && ta.proxy) : Yi
	}
}

function hasInjectionContext() {
	return !!(currentInstance || currentRenderingInstance || currentApp)
}
const internalObjectProto = {},
	createInternalObject = () => Object.create(internalObjectProto),
	isInternalObject = ue => Object.getPrototypeOf(ue) === internalObjectProto;

function initProps(ue, Yi, ea, ta = !1) {
	const na = {},
		ra = createInternalObject();
	ue.propsDefaults = Object.create(null), setFullProps(ue, Yi, na, ra);
	for (const ia in ue.propsOptions[0]) ia in na || (na[ia] = void 0);
	ea ? ue.props = ta ? na : shallowReactive(na) : ue.type.props ? ue.props = na : ue.props = ra, ue.attrs = ra
}

function updateProps(ue, Yi, ea, ta) {
	const {
		props: na,
		attrs: ra,
		vnode: {
			patchFlag: ia
		}
	} = ue, aa = toRaw(na), [oa] = ue.propsOptions;
	let la = !1;
	if ((ta || ia > 0) && !(ia & 16)) {
		if (ia & 8) {
			const sa = ue.vnode.dynamicProps;
			for (let ca = 0; ca < sa.length; ca++) {
				let ua = sa[ca];
				if (isEmitListener(ue.emitsOptions, ua)) continue;
				const da = Yi[ua];
				if (oa)
					if (hasOwn$1(ra, ua)) da !== ra[ua] && (ra[ua] = da, la = !0);
					else {
						const ha = camelize(ua);
						na[ha] = resolvePropValue(oa, aa, ha, da, ue, !1)
					}
				else da !== ra[ua] && (ra[ua] = da, la = !0)
			}
		}
	} else {
		setFullProps(ue, Yi, na, ra) && (la = !0);
		let sa;
		for (const ca in aa)(!Yi || !hasOwn$1(Yi, ca) && ((sa = hyphenate(ca)) === ca || !hasOwn$1(Yi, sa))) && (oa ? ea && (ea[ca] !== void 0 || ea[sa] !== void 0) && (na[ca] = resolvePropValue(oa, aa, ca, void 0, ue, !0)) : delete na[ca]);
		if (ra !== aa)
			for (const ca in ra)(!Yi || !hasOwn$1(Yi, ca)) && (delete ra[ca], la = !0)
	}
	la && trigger(ue.attrs, "set", "")
}

function setFullProps(ue, Yi, ea, ta) {
	const [na, ra] = ue.propsOptions;
	let ia = !1,
		aa;
	if (Yi)
		for (let oa in Yi) {
			if (isReservedProp(oa)) continue;
			const la = Yi[oa];
			let sa;
			na && hasOwn$1(na, sa = camelize(oa)) ? !ra || !ra.includes(sa) ? ea[sa] = la : (aa || (aa = {}))[sa] = la : isEmitListener(ue.emitsOptions, oa) || (!(oa in ta) || la !== ta[oa]) && (ta[oa] = la, ia = !0)
		}
	if (ra) {
		const oa = toRaw(ea),
			la = aa || EMPTY_OBJ;
		for (let sa = 0; sa < ra.length; sa++) {
			const ca = ra[sa];
			ea[ca] = resolvePropValue(na, oa, ca, la[ca], ue, !hasOwn$1(la, ca))
		}
	}
	return ia
}

function resolvePropValue(ue, Yi, ea, ta, na, ra) {
	const ia = ue[ea];
	if (ia != null) {
		const aa = hasOwn$1(ia, "default");
		if (aa && ta === void 0) {
			const oa = ia.default;
			if (ia.type !== Function && !ia.skipFactory && isFunction$2(oa)) {
				const {
					propsDefaults: la
				} = na;
				if (ea in la) ta = la[ea];
				else {
					const sa = setCurrentInstance(na);
					ta = la[ea] = oa.call(null, Yi), sa()
				}
			} else ta = oa;
			na.ce && na.ce._setProp(ea, ta)
		}
		ia[0] && (ra && !aa ? ta = !1 : ia[1] && (ta === "" || ta === hyphenate(ea)) && (ta = !0))
	}
	return ta
}
const mixinPropsCache = new WeakMap;

function normalizePropsOptions(ue, Yi, ea = !1) {
	const ta = ea ? mixinPropsCache : Yi.propsCache,
		na = ta.get(ue);
	if (na) return na;
	const ra = ue.props,
		ia = {},
		aa = [];
	let oa = !1;
	if (!isFunction$2(ue)) {
		const sa = ca => {
			oa = !0;
			const [ua, da] = normalizePropsOptions(ca, Yi, !0);
			extend$1(ia, ua), da && aa.push(...da)
		};
		!ea && Yi.mixins.length && Yi.mixins.forEach(sa), ue.extends && sa(ue.extends), ue.mixins && ue.mixins.forEach(sa)
	}
	if (!ra && !oa) return isObject$3(ue) && ta.set(ue, EMPTY_ARR), EMPTY_ARR;
	if (isArray$4(ra))
		for (let sa = 0; sa < ra.length; sa++) {
			const ca = camelize(ra[sa]);
			validatePropName(ca) && (ia[ca] = EMPTY_OBJ)
		} else if (ra)
			for (const sa in ra) {
				const ca = camelize(sa);
				if (validatePropName(ca)) {
					const ua = ra[sa],
						da = ia[ca] = isArray$4(ua) || isFunction$2(ua) ? {
							type: ua
						} : extend$1({}, ua),
						ha = da.type;
					let pa = !1,
						va = !0;
					if (isArray$4(ha))
						for (let ba = 0; ba < ha.length; ++ba) {
							const Ea = ha[ba],
								Sa = isFunction$2(Ea) && Ea.name;
							if (Sa === "Boolean") {
								pa = !0;
								break
							} else Sa === "String" && (va = !1)
						} else pa = isFunction$2(ha) && ha.name === "Boolean";
					da[0] = pa, da[1] = va, (pa || hasOwn$1(da, "default")) && aa.push(ca)
				}
			}
	const la = [ia, aa];
	return isObject$3(ue) && ta.set(ue, la), la
}

function validatePropName(ue) {
	return ue[0] !== "$" && !isReservedProp(ue)
}
const isInternalKey = ue => ue[0] === "_" || ue === "$stable",
	normalizeSlotValue = ue => isArray$4(ue) ? ue.map(normalizeVNode) : [normalizeVNode(ue)],
	normalizeSlot$1 = (ue, Yi, ea) => {
		if (Yi._n) return Yi;
		const ta = withCtx((...na) => normalizeSlotValue(Yi(...na)), ea);
		return ta._c = !1, ta
	},
	normalizeObjectSlots = (ue, Yi, ea) => {
		const ta = ue._ctx;
		for (const na in ue) {
			if (isInternalKey(na)) continue;
			const ra = ue[na];
			if (isFunction$2(ra)) Yi[na] = normalizeSlot$1(na, ra, ta);
			else if (ra != null) {
				const ia = normalizeSlotValue(ra);
				Yi[na] = () => ia
			}
		}
	},
	normalizeVNodeSlots = (ue, Yi) => {
		const ea = normalizeSlotValue(Yi);
		ue.slots.default = () => ea
	},
	assignSlots = (ue, Yi, ea) => {
		for (const ta in Yi)(ea || ta !== "_") && (ue[ta] = Yi[ta])
	},
	initSlots = (ue, Yi, ea) => {
		const ta = ue.slots = createInternalObject();
		if (ue.vnode.shapeFlag & 32) {
			const na = Yi._;
			na ? (assignSlots(ta, Yi, ea), ea && def(ta, "_", na, !0)) : normalizeObjectSlots(Yi, ta)
		} else Yi && normalizeVNodeSlots(ue, Yi)
	},
	updateSlots = (ue, Yi, ea) => {
		const {
			vnode: ta,
			slots: na
		} = ue;
		let ra = !0,
			ia = EMPTY_OBJ;
		if (ta.shapeFlag & 32) {
			const aa = Yi._;
			aa ? ea && aa === 1 ? ra = !1 : assignSlots(na, Yi, ea) : (ra = !Yi.$stable, normalizeObjectSlots(Yi, na)), ia = Yi
		} else Yi && (normalizeVNodeSlots(ue, Yi), ia = {
			default: 1
		});
		if (ra)
			for (const aa in na) !isInternalKey(aa) && ia[aa] == null && delete na[aa]
	},
	queuePostRenderEffect = queueEffectWithSuspense;

function createRenderer(ue) {
	return baseCreateRenderer(ue)
}

function createHydrationRenderer(ue) {
	return baseCreateRenderer(ue, createHydrationFunctions)
}

function baseCreateRenderer(ue, Yi) {
	const ea = getGlobalThis$1();
	ea.__VUE__ = !0;
	const {
		insert: ta,
		remove: na,
		patchProp: ra,
		createElement: ia,
		createText: aa,
		createComment: oa,
		setText: la,
		setElementText: sa,
		parentNode: ca,
		nextSibling: ua,
		setScopeId: da = NOOP,
		insertStaticContent: ha
	} = ue, pa = (qa, Ka, lo, yo = null, fo = null, vo = null, so = void 0, Xa = null, to = !!Ka.dynamicChildren) => {
		if (qa === Ka) return;
		qa && !isSameVNodeType(qa, Ka) && (yo = Ia(qa), ya(qa, fo, vo, !0), qa = null), Ka.patchFlag === -2 && (to = !1, Ka.dynamicChildren = null);
		const {
			type: ho,
			ref: Eo,
			shapeFlag: wo
		} = Ka;
		switch (ho) {
			case Text:
				va(qa, Ka, lo, yo);
				break;
			case Comment:
				ba(qa, Ka, lo, yo);
				break;
			case Static:
				qa == null && Ea(Ka, lo, yo, so);
				break;
			case Fragment:
				xa(qa, Ka, lo, yo, fo, vo, so, Xa, to);
				break;
			default:
				wo & 1 ? ka(qa, Ka, lo, yo, fo, vo, so, Xa, to) : wo & 6 ? ma(qa, Ka, lo, yo, fo, vo, so, Xa, to) : (wo & 64 || wo & 128) && ho.process(qa, Ka, lo, yo, fo, vo, so, Xa, to, ro)
		}
		Eo != null && fo && setRef(Eo, qa && qa.ref, vo, Ka || qa, !Ka)
	}, va = (qa, Ka, lo, yo) => {
		if (qa == null) ta(Ka.el = aa(Ka.children), lo, yo);
		else {
			const fo = Ka.el = qa.el;
			Ka.children !== qa.children && la(fo, Ka.children)
		}
	}, ba = (qa, Ka, lo, yo) => {
		qa == null ? ta(Ka.el = oa(Ka.children || ""), lo, yo) : Ka.el = qa.el
	}, Ea = (qa, Ka, lo, yo) => {
		[qa.el, qa.anchor] = ha(qa.children, Ka, lo, yo, qa.el, qa.anchor)
	}, Sa = ({
		el: qa,
		anchor: Ka
	}, lo, yo) => {
		let fo;
		for (; qa && qa !== Ka;) fo = ua(qa), ta(qa, lo, yo), qa = fo;
		ta(Ka, lo, yo)
	}, Ca = ({
		el: qa,
		anchor: Ka
	}) => {
		let lo;
		for (; qa && qa !== Ka;) lo = ua(qa), na(qa), qa = lo;
		na(Ka)
	}, ka = (qa, Ka, lo, yo, fo, vo, so, Xa, to) => {
		Ka.type === "svg" ? so = "svg" : Ka.type === "math" && (so = "mathml"), qa == null ? Pa(Ka, lo, yo, fo, vo, so, Xa, to) : Ga(qa, Ka, fo, vo, so, Xa, to)
	}, Pa = (qa, Ka, lo, yo, fo, vo, so, Xa) => {
		let to, ho;
		const {
			props: Eo,
			shapeFlag: wo,
			transition: Ao,
			dirs: _o
		} = qa;
		if (to = qa.el = ia(qa.type, vo, Eo && Eo.is, Eo), wo & 8 ? sa(to, qa.children) : wo & 16 && Za(qa.children, to, null, yo, fo, resolveChildrenNamespace(qa, vo), so, Xa), _o && invokeDirectiveHook(qa, null, yo, "created"), ja(to, qa, qa.scopeId, so, yo), Eo) {
			for (const Fo in Eo) Fo !== "value" && !isReservedProp(Fo) && ra(to, Fo, null, Eo[Fo], vo, yo);
			"value" in Eo && ra(to, "value", null, Eo.value, vo), (ho = Eo.onVnodeBeforeMount) && invokeVNodeHook(ho, yo, qa)
		}
		_o && invokeDirectiveHook(qa, null, yo, "beforeMount");
		const Lo = needTransition(fo, Ao);
		Lo && Ao.beforeEnter(to), ta(to, Ka, lo), ((ho = Eo && Eo.onVnodeMounted) || Lo || _o) && queuePostRenderEffect(() => {
			ho && invokeVNodeHook(ho, yo, qa), Lo && Ao.enter(to), _o && invokeDirectiveHook(qa, null, yo, "mounted")
		}, fo)
	}, ja = (qa, Ka, lo, yo, fo) => {
		if (lo && da(qa, lo), yo)
			for (let vo = 0; vo < yo.length; vo++) da(qa, yo[vo]);
		if (fo) {
			let vo = fo.subTree;
			if (Ka === vo || isSuspense(vo.type) && (vo.ssContent === Ka || vo.ssFallback === Ka)) {
				const so = fo.vnode;
				ja(qa, so, so.scopeId, so.slotScopeIds, fo.parent)
			}
		}
	}, Za = (qa, Ka, lo, yo, fo, vo, so, Xa, to = 0) => {
		for (let ho = to; ho < qa.length; ho++) {
			const Eo = qa[ho] = Xa ? cloneIfMounted(qa[ho]) : normalizeVNode(qa[ho]);
			pa(null, Eo, Ka, lo, yo, fo, vo, so, Xa)
		}
	}, Ga = (qa, Ka, lo, yo, fo, vo, so) => {
		const Xa = Ka.el = qa.el;
		let {
			patchFlag: to,
			dynamicChildren: ho,
			dirs: Eo
		} = Ka;
		to |= qa.patchFlag & 16;
		const wo = qa.props || EMPTY_OBJ,
			Ao = Ka.props || EMPTY_OBJ;
		let _o;
		if (lo && toggleRecurse(lo, !1), (_o = Ao.onVnodeBeforeUpdate) && invokeVNodeHook(_o, lo, Ka, qa), Eo && invokeDirectiveHook(Ka, qa, lo, "beforeUpdate"), lo && toggleRecurse(lo, !0), (wo.innerHTML && Ao.innerHTML == null || wo.textContent && Ao.textContent == null) && sa(Xa, ""), ho ? Ja(qa.dynamicChildren, ho, Xa, lo, yo, resolveChildrenNamespace(Ka, fo), vo) : so || Aa(qa, Ka, Xa, null, lo, yo, resolveChildrenNamespace(Ka, fo), vo, !1), to > 0) {
			if (to & 16) Ua(Xa, wo, Ao, lo, fo);
			else if (to & 2 && wo.class !== Ao.class && ra(Xa, "class", null, Ao.class, fo), to & 4 && ra(Xa, "style", wo.style, Ao.style, fo), to & 8) {
				const Lo = Ka.dynamicProps;
				for (let Fo = 0; Fo < Lo.length; Fo++) {
					const jo = Lo[Fo],
						eo = wo[jo],
						Oa = Ao[jo];
					(Oa !== eo || jo === "value") && ra(Xa, jo, eo, Oa, fo, lo)
				}
			}
			to & 1 && qa.children !== Ka.children && sa(Xa, Ka.children)
		} else !so && ho == null && Ua(Xa, wo, Ao, lo, fo);
		((_o = Ao.onVnodeUpdated) || Eo) && queuePostRenderEffect(() => {
			_o && invokeVNodeHook(_o, lo, Ka, qa), Eo && invokeDirectiveHook(Ka, qa, lo, "updated")
		}, yo)
	}, Ja = (qa, Ka, lo, yo, fo, vo, so) => {
		for (let Xa = 0; Xa < Ka.length; Xa++) {
			const to = qa[Xa],
				ho = Ka[Xa],
				Eo = to.el && (to.type === Fragment || !isSameVNodeType(to, ho) || to.shapeFlag & 70) ? ca(to.el) : lo;
			pa(to, ho, Eo, null, yo, fo, vo, so, !0)
		}
	}, Ua = (qa, Ka, lo, yo, fo) => {
		if (Ka !== lo) {
			if (Ka !== EMPTY_OBJ)
				for (const vo in Ka) !isReservedProp(vo) && !(vo in lo) && ra(qa, vo, Ka[vo], null, fo, yo);
			for (const vo in lo) {
				if (isReservedProp(vo)) continue;
				const so = lo[vo],
					Xa = Ka[vo];
				so !== Xa && vo !== "value" && ra(qa, vo, Xa, so, fo, yo)
			}
			"value" in lo && ra(qa, "value", Ka.value, lo.value, fo)
		}
	}, xa = (qa, Ka, lo, yo, fo, vo, so, Xa, to) => {
		const ho = Ka.el = qa ? qa.el : aa(""),
			Eo = Ka.anchor = qa ? qa.anchor : aa("");
		let {
			patchFlag: wo,
			dynamicChildren: Ao,
			slotScopeIds: _o
		} = Ka;
		_o && (Xa = Xa ? Xa.concat(_o) : _o), qa == null ? (ta(ho, lo, yo), ta(Eo, lo, yo), Za(Ka.children || [], lo, Eo, fo, vo, so, Xa, to)) : wo > 0 && wo & 64 && Ao && qa.dynamicChildren ? (Ja(qa.dynamicChildren, Ao, lo, fo, vo, so, Xa), (Ka.key != null || fo && Ka === fo.subTree) && traverseStaticChildren(qa, Ka, !0)) : Aa(qa, Ka, lo, Eo, fo, vo, so, Xa, to)
	}, ma = (qa, Ka, lo, yo, fo, vo, so, Xa, to) => {
		Ka.slotScopeIds = Xa, qa == null ? Ka.shapeFlag & 512 ? fo.ctx.activate(Ka, lo, yo, so, to) : fa(Ka, lo, yo, fo, vo, so, to) : ga(qa, Ka, to)
	}, fa = (qa, Ka, lo, yo, fo, vo, so) => {
		const Xa = qa.component = createComponentInstance(qa, yo, fo);
		if (isKeepAlive(qa) && (Xa.ctx.renderer = ro), setupComponent(Xa, !1, so), Xa.asyncDep) {
			if (fo && fo.registerDep(Xa, wa, so), !qa.el) {
				const to = Xa.subTree = createVNode(Comment);
				ba(null, to, Ka, lo)
			}
		} else wa(Xa, qa, Ka, lo, fo, vo, so)
	}, ga = (qa, Ka, lo) => {
		const yo = Ka.component = qa.component;
		if (shouldUpdateComponent(qa, Ka, lo))
			if (yo.asyncDep && !yo.asyncResolved) {
				Ma(yo, Ka, lo);
				return
			} else yo.next = Ka, yo.update();
		else Ka.el = qa.el, yo.vnode = Ka
	}, wa = (qa, Ka, lo, yo, fo, vo, so) => {
		const Xa = () => {
			if (qa.isMounted) {
				let {
					next: wo,
					bu: Ao,
					u: _o,
					parent: Lo,
					vnode: Fo
				} = qa;
				{
					const Qa = locateNonHydratedAsyncRoot(qa);
					if (Qa) {
						wo && (wo.el = Fo.el, Ma(qa, wo, so)), Qa.asyncDep.then(() => {
							qa.isUnmounted || Xa()
						});
						return
					}
				}
				let jo = wo,
					eo;
				toggleRecurse(qa, !1), wo ? (wo.el = Fo.el, Ma(qa, wo, so)) : wo = Fo, Ao && invokeArrayFns(Ao), (eo = wo.props && wo.props.onVnodeBeforeUpdate) && invokeVNodeHook(eo, Lo, wo, Fo), toggleRecurse(qa, !0);
				const Oa = renderComponentRoot(qa),
					Da = qa.subTree;
				qa.subTree = Oa, pa(Da, Oa, ca(Da.el), Ia(Da), qa, fo, vo), wo.el = Oa.el, jo === null && updateHOCHostEl(qa, Oa.el), _o && queuePostRenderEffect(_o, fo), (eo = wo.props && wo.props.onVnodeUpdated) && queuePostRenderEffect(() => invokeVNodeHook(eo, Lo, wo, Fo), fo)
			} else {
				let wo;
				const {
					el: Ao,
					props: _o
				} = Ka, {
					bm: Lo,
					m: Fo,
					parent: jo,
					root: eo,
					type: Oa
				} = qa, Da = isAsyncWrapper(Ka);
				if (toggleRecurse(qa, !1), Lo && invokeArrayFns(Lo), !Da && (wo = _o && _o.onVnodeBeforeMount) && invokeVNodeHook(wo, jo, Ka), toggleRecurse(qa, !0), Ao && Wa) {
					const Qa = () => {
						qa.subTree = renderComponentRoot(qa), Wa(Ao, qa.subTree, qa, fo, null)
					};
					Da && Oa.__asyncHydrate ? Oa.__asyncHydrate(Ao, qa, Qa) : Qa()
				} else {
					eo.ce && eo.ce._injectChildStyle(Oa);
					const Qa = qa.subTree = renderComponentRoot(qa);
					pa(null, Qa, lo, yo, qa, fo, vo), Ka.el = Qa.el
				}
				if (Fo && queuePostRenderEffect(Fo, fo), !Da && (wo = _o && _o.onVnodeMounted)) {
					const Qa = Ka;
					queuePostRenderEffect(() => invokeVNodeHook(wo, jo, Qa), fo)
				}(Ka.shapeFlag & 256 || jo && isAsyncWrapper(jo.vnode) && jo.vnode.shapeFlag & 256) && qa.a && queuePostRenderEffect(qa.a, fo), qa.isMounted = !0, Ka = lo = yo = null
			}
		};
		qa.scope.on();
		const to = qa.effect = new ReactiveEffect(Xa);
		qa.scope.off();
		const ho = qa.update = to.run.bind(to),
			Eo = qa.job = to.runIfDirty.bind(to);
		Eo.i = qa, Eo.id = qa.uid, to.scheduler = () => queueJob(Eo), toggleRecurse(qa, !0), ho()
	}, Ma = (qa, Ka, lo) => {
		Ka.component = qa;
		const yo = qa.vnode.props;
		qa.vnode = Ka, qa.next = null, updateProps(qa, Ka.props, yo, lo), updateSlots(qa, Ka.children, lo), pauseTracking(), flushPreFlushCbs(qa), resetTracking()
	}, Aa = (qa, Ka, lo, yo, fo, vo, so, Xa, to = !1) => {
		const ho = qa && qa.children,
			Eo = qa ? qa.shapeFlag : 0,
			wo = Ka.children,
			{
				patchFlag: Ao,
				shapeFlag: _o
			} = Ka;
		if (Ao > 0) {
			if (Ao & 128) {
				Ta(ho, wo, lo, yo, fo, vo, so, Xa, to);
				return
			} else if (Ao & 256) {
				Ra(ho, wo, lo, yo, fo, vo, so, Xa, to);
				return
			}
		}
		_o & 8 ? (Eo & 16 && ao(ho, fo, vo), wo !== ho && sa(lo, wo)) : Eo & 16 ? _o & 16 ? Ta(ho, wo, lo, yo, fo, vo, so, Xa, to) : ao(ho, fo, vo, !0) : (Eo & 8 && sa(lo, ""), _o & 16 && Za(wo, lo, yo, fo, vo, so, Xa, to))
	}, Ra = (qa, Ka, lo, yo, fo, vo, so, Xa, to) => {
		qa = qa || EMPTY_ARR, Ka = Ka || EMPTY_ARR;
		const ho = qa.length,
			Eo = Ka.length,
			wo = Math.min(ho, Eo);
		let Ao;
		for (Ao = 0; Ao < wo; Ao++) {
			const _o = Ka[Ao] = to ? cloneIfMounted(Ka[Ao]) : normalizeVNode(Ka[Ao]);
			pa(qa[Ao], _o, lo, null, fo, vo, so, Xa, to)
		}
		ho > Eo ? ao(qa, fo, vo, !0, !1, wo) : Za(Ka, lo, yo, fo, vo, so, Xa, to, wo)
	}, Ta = (qa, Ka, lo, yo, fo, vo, so, Xa, to) => {
		let ho = 0;
		const Eo = Ka.length;
		let wo = qa.length - 1,
			Ao = Eo - 1;
		for (; ho <= wo && ho <= Ao;) {
			const _o = qa[ho],
				Lo = Ka[ho] = to ? cloneIfMounted(Ka[ho]) : normalizeVNode(Ka[ho]);
			if (isSameVNodeType(_o, Lo)) pa(_o, Lo, lo, null, fo, vo, so, Xa, to);
			else break;
			ho++
		}
		for (; ho <= wo && ho <= Ao;) {
			const _o = qa[wo],
				Lo = Ka[Ao] = to ? cloneIfMounted(Ka[Ao]) : normalizeVNode(Ka[Ao]);
			if (isSameVNodeType(_o, Lo)) pa(_o, Lo, lo, null, fo, vo, so, Xa, to);
			else break;
			wo--, Ao--
		}
		if (ho > wo) {
			if (ho <= Ao) {
				const _o = Ao + 1,
					Lo = _o < Eo ? Ka[_o].el : yo;
				for (; ho <= Ao;) pa(null, Ka[ho] = to ? cloneIfMounted(Ka[ho]) : normalizeVNode(Ka[ho]), lo, Lo, fo, vo, so, Xa, to), ho++
			}
		} else if (ho > Ao)
			for (; ho <= wo;) ya(qa[ho], fo, vo, !0), ho++;
		else {
			const _o = ho,
				Lo = ho,
				Fo = new Map;
			for (ho = Lo; ho <= Ao; ho++) {
				const So = Ka[ho] = to ? cloneIfMounted(Ka[ho]) : normalizeVNode(Ka[ho]);
				So.key != null && Fo.set(So.key, ho)
			}
			let jo, eo = 0;
			const Oa = Ao - Lo + 1;
			let Da = !1,
				Qa = 0;
			const uo = new Array(Oa);
			for (ho = 0; ho < Oa; ho++) uo[ho] = 0;
			for (ho = _o; ho <= wo; ho++) {
				const So = qa[ho];
				if (eo >= Oa) {
					ya(So, fo, vo, !0);
					continue
				}
				let Wo;
				if (So.key != null) Wo = Fo.get(So.key);
				else
					for (jo = Lo; jo <= Ao; jo++)
						if (uo[jo - Lo] === 0 && isSameVNodeType(So, Ka[jo])) {
							Wo = jo;
							break
						} Wo === void 0 ? ya(So, fo, vo, !0) : (uo[Wo - Lo] = ho + 1, Wo >= Qa ? Qa = Wo : Da = !0, pa(So, Ka[Wo], lo, null, fo, vo, so, Xa, to), eo++)
			}
			const bo = Da ? getSequence(uo) : EMPTY_ARR;
			for (jo = bo.length - 1, ho = Oa - 1; ho >= 0; ho--) {
				const So = Lo + ho,
					Wo = Ka[So],
					Po = So + 1 < Eo ? Ka[So + 1].el : yo;
				uo[ho] === 0 ? pa(null, Wo, lo, Po, fo, vo, so, Xa, to) : Da && (jo < 0 || ho !== bo[jo] ? La(Wo, lo, Po, 2) : jo--)
			}
		}
	}, La = (qa, Ka, lo, yo, fo = null) => {
		const {
			el: vo,
			type: so,
			transition: Xa,
			children: to,
			shapeFlag: ho
		} = qa;
		if (ho & 6) {
			La(qa.component.subTree, Ka, lo, yo);
			return
		}
		if (ho & 128) {
			qa.suspense.move(Ka, lo, yo);
			return
		}
		if (ho & 64) {
			so.move(qa, Ka, lo, ro);
			return
		}
		if (so === Fragment) {
			ta(vo, Ka, lo);
			for (let wo = 0; wo < to.length; wo++) La(to[wo], Ka, lo, yo);
			ta(qa.anchor, Ka, lo);
			return
		}
		if (so === Static) {
			Sa(qa, Ka, lo);
			return
		}
		if (yo !== 2 && ho & 1 && Xa)
			if (yo === 0) Xa.beforeEnter(vo), ta(vo, Ka, lo), queuePostRenderEffect(() => Xa.enter(vo), fo);
			else {
				const {
					leave: wo,
					delayLeave: Ao,
					afterLeave: _o
				} = Xa, Lo = () => ta(vo, Ka, lo), Fo = () => {
					wo(vo, () => {
						Lo(), _o && _o()
					})
				};
				Ao ? Ao(vo, Lo, Fo) : Fo()
			}
		else ta(vo, Ka, lo)
	}, ya = (qa, Ka, lo, yo = !1, fo = !1) => {
		const {
			type: vo,
			props: so,
			ref: Xa,
			children: to,
			dynamicChildren: ho,
			shapeFlag: Eo,
			patchFlag: wo,
			dirs: Ao,
			cacheIndex: _o
		} = qa;
		if (wo === -2 && (fo = !1), Xa != null && setRef(Xa, null, lo, qa, !0), _o != null && (Ka.renderCache[_o] = void 0), Eo & 256) {
			Ka.ctx.deactivate(qa);
			return
		}
		const Lo = Eo & 1 && Ao,
			Fo = !isAsyncWrapper(qa);
		let jo;
		if (Fo && (jo = so && so.onVnodeBeforeUnmount) && invokeVNodeHook(jo, Ka, qa), Eo & 6) oo(qa.component, lo, yo);
		else {
			if (Eo & 128) {
				qa.suspense.unmount(lo, yo);
				return
			}
			Lo && invokeDirectiveHook(qa, null, Ka, "beforeUnmount"), Eo & 64 ? qa.type.remove(qa, Ka, lo, ro, yo) : ho && !ho.hasOnce && (vo !== Fragment || wo > 0 && wo & 64) ? ao(ho, Ka, lo, !1, !0) : (vo === Fragment && wo & 384 || !fo && Eo & 16) && ao(to, Ka, lo), yo && Ba(qa)
		}(Fo && (jo = so && so.onVnodeUnmounted) || Lo) && queuePostRenderEffect(() => {
			jo && invokeVNodeHook(jo, Ka, qa), Lo && invokeDirectiveHook(qa, null, Ka, "unmounted")
		}, lo)
	}, Ba = qa => {
		const {
			type: Ka,
			el: lo,
			anchor: yo,
			transition: fo
		} = qa;
		if (Ka === Fragment) {
			io(lo, yo);
			return
		}
		if (Ka === Static) {
			Ca(qa);
			return
		}
		const vo = () => {
			na(lo), fo && !fo.persisted && fo.afterLeave && fo.afterLeave()
		};
		if (qa.shapeFlag & 1 && fo && !fo.persisted) {
			const {
				leave: so,
				delayLeave: Xa
			} = fo, to = () => so(lo, vo);
			Xa ? Xa(qa.el, vo, to) : to()
		} else vo()
	}, io = (qa, Ka) => {
		let lo;
		for (; qa !== Ka;) lo = ua(qa), na(qa), qa = lo;
		na(Ka)
	}, oo = (qa, Ka, lo) => {
		const {
			bum: yo,
			scope: fo,
			job: vo,
			subTree: so,
			um: Xa,
			m: to,
			a: ho
		} = qa;
		invalidateMount(to), invalidateMount(ho), yo && invokeArrayFns(yo), fo.stop(), vo && (vo.flags |= 8, ya(so, qa, Ka, lo)), Xa && queuePostRenderEffect(Xa, Ka), queuePostRenderEffect(() => {
			qa.isUnmounted = !0
		}, Ka), Ka && Ka.pendingBranch && !Ka.isUnmounted && qa.asyncDep && !qa.asyncResolved && qa.suspenseId === Ka.pendingId && (Ka.deps--, Ka.deps === 0 && Ka.resolve())
	}, ao = (qa, Ka, lo, yo = !1, fo = !1, vo = 0) => {
		for (let so = vo; so < qa.length; so++) ya(qa[so], Ka, lo, yo, fo)
	}, Ia = qa => {
		if (qa.shapeFlag & 6) return Ia(qa.component.subTree);
		if (qa.shapeFlag & 128) return qa.suspense.next();
		const Ka = ua(qa.anchor || qa.el),
			lo = Ka && Ka[TeleportEndKey];
		return lo ? ua(lo) : Ka
	};
	let Na = !1;
	const za = (qa, Ka, lo) => {
			qa == null ? Ka._vnode && ya(Ka._vnode, null, null, !0) : pa(Ka._vnode || null, qa, Ka, null, null, null, lo), Ka._vnode = qa, Na || (Na = !0, flushPreFlushCbs(), flushPostFlushCbs(), Na = !1)
		},
		ro = {
			p: pa,
			um: ya,
			m: La,
			r: Ba,
			mt: fa,
			mc: Za,
			pc: Aa,
			pbc: Ja,
			n: Ia,
			o: ue
		};
	let Va, Wa;
	return Yi && ([Va, Wa] = Yi(ro)), {
		render: za,
		hydrate: Va,
		createApp: createAppAPI(za, Va)
	}
}

function resolveChildrenNamespace({
	type: ue,
	props: Yi
}, ea) {
	return ea === "svg" && ue === "foreignObject" || ea === "mathml" && ue === "annotation-xml" && Yi && Yi.encoding && Yi.encoding.includes("html") ? void 0 : ea
}

function toggleRecurse({
	effect: ue,
	job: Yi
}, ea) {
	ea ? (ue.flags |= 32, Yi.flags |= 4) : (ue.flags &= -33, Yi.flags &= -5)
}

function needTransition(ue, Yi) {
	return (!ue || ue && !ue.pendingBranch) && Yi && !Yi.persisted
}

function traverseStaticChildren(ue, Yi, ea = !1) {
	const ta = ue.children,
		na = Yi.children;
	if (isArray$4(ta) && isArray$4(na))
		for (let ra = 0; ra < ta.length; ra++) {
			const ia = ta[ra];
			let aa = na[ra];
			aa.shapeFlag & 1 && !aa.dynamicChildren && ((aa.patchFlag <= 0 || aa.patchFlag === 32) && (aa = na[ra] = cloneIfMounted(na[ra]), aa.el = ia.el), !ea && aa.patchFlag !== -2 && traverseStaticChildren(ia, aa)), aa.type === Text && (aa.el = ia.el)
		}
}

function getSequence(ue) {
	const Yi = ue.slice(),
		ea = [0];
	let ta, na, ra, ia, aa;
	const oa = ue.length;
	for (ta = 0; ta < oa; ta++) {
		const la = ue[ta];
		if (la !== 0) {
			if (na = ea[ea.length - 1], ue[na] < la) {
				Yi[ta] = na, ea.push(ta);
				continue
			}
			for (ra = 0, ia = ea.length - 1; ra < ia;) aa = ra + ia >> 1, ue[ea[aa]] < la ? ra = aa + 1 : ia = aa;
			la < ue[ea[ra]] && (ra > 0 && (Yi[ta] = ea[ra - 1]), ea[ra] = ta)
		}
	}
	for (ra = ea.length, ia = ea[ra - 1]; ra-- > 0;) ea[ra] = ia, ia = Yi[ia];
	return ea
}

function locateNonHydratedAsyncRoot(ue) {
	const Yi = ue.subTree.component;
	if (Yi) return Yi.asyncDep && !Yi.asyncResolved ? Yi : locateNonHydratedAsyncRoot(Yi)
}

function invalidateMount(ue) {
	if (ue)
		for (let Yi = 0; Yi < ue.length; Yi++) ue[Yi].flags |= 8
}
const ssrContextKey = Symbol.for("v-scx"),
	useSSRContext = () => inject(ssrContextKey);

function watchEffect(ue, Yi) {
	return doWatch(ue, null, Yi)
}

function watchPostEffect(ue, Yi) {
	return doWatch(ue, null, {
		flush: "post"
	})
}

function watchSyncEffect(ue, Yi) {
	return doWatch(ue, null, {
		flush: "sync"
	})
}

function watch(ue, Yi, ea) {
	return doWatch(ue, Yi, ea)
}

function doWatch(ue, Yi, ea = EMPTY_OBJ) {
	const {
		immediate: ta,
		deep: na,
		flush: ra,
		once: ia
	} = ea, aa = extend$1({}, ea);
	let oa;
	if (isInSSRComponentSetup)
		if (ra === "sync") {
			const ua = useSSRContext();
			oa = ua.__watcherHandles || (ua.__watcherHandles = [])
		} else if (!Yi || ta) aa.once = !0;
	else {
		const ua = () => {};
		return ua.stop = NOOP, ua.resume = NOOP, ua.pause = NOOP, ua
	}
	const la = currentInstance;
	aa.call = (ua, da, ha) => callWithAsyncErrorHandling(ua, la, da, ha);
	let sa = !1;
	ra === "post" ? aa.scheduler = ua => {
		queuePostRenderEffect(ua, la && la.suspense)
	} : ra !== "sync" && (sa = !0, aa.scheduler = (ua, da) => {
		da ? ua() : queueJob(ua)
	}), aa.augmentJob = ua => {
		Yi && (ua.flags |= 4), sa && (ua.flags |= 2, la && (ua.id = la.uid, ua.i = la))
	};
	const ca = watch$1(ue, Yi, aa);
	return oa && oa.push(ca), ca
}

function instanceWatch(ue, Yi, ea) {
	const ta = this.proxy,
		na = isString$4(ue) ? ue.includes(".") ? createPathGetter(ta, ue) : () => ta[ue] : ue.bind(ta, ta);
	let ra;
	isFunction$2(Yi) ? ra = Yi : (ra = Yi.handler, ea = Yi);
	const ia = setCurrentInstance(this),
		aa = doWatch(na, ra.bind(ta), ea);
	return ia(), aa
}

function createPathGetter(ue, Yi) {
	const ea = Yi.split(".");
	return () => {
		let ta = ue;
		for (let na = 0; na < ea.length && ta; na++) ta = ta[ea[na]];
		return ta
	}
}

function useModel(ue, Yi, ea = EMPTY_OBJ) {
	const ta = getCurrentInstance(),
		na = camelize(Yi),
		ra = hyphenate(Yi),
		ia = getModelModifiers(ue, Yi),
		aa = customRef((oa, la) => {
			let sa, ca = EMPTY_OBJ,
				ua;
			return watchSyncEffect(() => {
				const da = ue[Yi];
				hasChanged(sa, da) && (sa = da, la())
			}), {
				get() {
					return oa(), ea.get ? ea.get(sa) : sa
				},
				set(da) {
					const ha = ea.set ? ea.set(da) : da;
					if (!hasChanged(ha, sa) && !(ca !== EMPTY_OBJ && hasChanged(da, ca))) return;
					const pa = ta.vnode.props;
					pa && (Yi in pa || na in pa || ra in pa) && (`onUpdate:${Yi}` in pa || `onUpdate:${na}` in pa || `onUpdate:${ra}` in pa) || (sa = da, la()), ta.emit(`update:${Yi}`, ha), hasChanged(da, ha) && hasChanged(da, ca) && !hasChanged(ha, ua) && la(), ca = da, ua = ha
				}
			}
		});
	return aa[Symbol.iterator] = () => {
		let oa = 0;
		return {
			next() {
				return oa < 2 ? {
					value: oa++ ? ia || EMPTY_OBJ : aa,
					done: !1
				} : {
					done: !0
				}
			}
		}
	}, aa
}
const getModelModifiers = (ue, Yi) => Yi === "modelValue" || Yi === "model-value" ? ue.modelModifiers : ue[`${Yi}Modifiers`] || ue[`${camelize(Yi)}Modifiers`] || ue[`${hyphenate(Yi)}Modifiers`];

function emit(ue, Yi, ...ea) {
	if (ue.isUnmounted) return;
	const ta = ue.vnode.props || EMPTY_OBJ;
	let na = ea;
	const ra = Yi.startsWith("update:"),
		ia = ra && getModelModifiers(ta, Yi.slice(7));
	ia && (ia.trim && (na = ea.map(sa => isString$4(sa) ? sa.trim() : sa)), ia.number && (na = ea.map(looseToNumber)));
	let aa, oa = ta[aa = toHandlerKey(Yi)] || ta[aa = toHandlerKey(camelize(Yi))];
	!oa && ra && (oa = ta[aa = toHandlerKey(hyphenate(Yi))]), oa && callWithAsyncErrorHandling(oa, ue, 6, na);
	const la = ta[aa + "Once"];
	if (la) {
		if (!ue.emitted) ue.emitted = {};
		else if (ue.emitted[aa]) return;
		ue.emitted[aa] = !0, callWithAsyncErrorHandling(la, ue, 6, na)
	}
}

function normalizeEmitsOptions(ue, Yi, ea = !1) {
	const ta = Yi.emitsCache,
		na = ta.get(ue);
	if (na !== void 0) return na;
	const ra = ue.emits;
	let ia = {},
		aa = !1;
	if (!isFunction$2(ue)) {
		const oa = la => {
			const sa = normalizeEmitsOptions(la, Yi, !0);
			sa && (aa = !0, extend$1(ia, sa))
		};
		!ea && Yi.mixins.length && Yi.mixins.forEach(oa), ue.extends && oa(ue.extends), ue.mixins && ue.mixins.forEach(oa)
	}
	return !ra && !aa ? (isObject$3(ue) && ta.set(ue, null), null) : (isArray$4(ra) ? ra.forEach(oa => ia[oa] = null) : extend$1(ia, ra), isObject$3(ue) && ta.set(ue, ia), ia)
}

function isEmitListener(ue, Yi) {
	return !ue || !isOn(Yi) ? !1 : (Yi = Yi.slice(2).replace(/Once$/, ""), hasOwn$1(ue, Yi[0].toLowerCase() + Yi.slice(1)) || hasOwn$1(ue, hyphenate(Yi)) || hasOwn$1(ue, Yi))
}

function markAttrsAccessed() {}

function renderComponentRoot(ue) {
	const {
		type: Yi,
		vnode: ea,
		proxy: ta,
		withProxy: na,
		propsOptions: [ra],
		slots: ia,
		attrs: aa,
		emit: oa,
		render: la,
		renderCache: sa,
		props: ca,
		data: ua,
		setupState: da,
		ctx: ha,
		inheritAttrs: pa
	} = ue, va = setCurrentRenderingInstance(ue);
	let ba, Ea;
	try {
		if (ea.shapeFlag & 4) {
			const Ca = na || ta,
				ka = Ca;
			ba = normalizeVNode(la.call(ka, Ca, sa, ca, da, ua, ha)), Ea = aa
		} else {
			const Ca = Yi;
			ba = normalizeVNode(Ca.length > 1 ? Ca(ca, {
				attrs: aa,
				slots: ia,
				emit: oa
			}) : Ca(ca, null)), Ea = Yi.props ? aa : getFunctionalFallthrough(aa)
		}
	} catch (Ca) {
		blockStack.length = 0, handleError(Ca, ue, 1), ba = createVNode(Comment)
	}
	let Sa = ba;
	if (Ea && pa !== !1) {
		const Ca = Object.keys(Ea),
			{
				shapeFlag: ka
			} = Sa;
		Ca.length && ka & 7 && (ra && Ca.some(isModelListener) && (Ea = filterModelListeners(Ea, ra)), Sa = cloneVNode(Sa, Ea, !1, !0))
	}
	return ea.dirs && (Sa = cloneVNode(Sa, null, !1, !0), Sa.dirs = Sa.dirs ? Sa.dirs.concat(ea.dirs) : ea.dirs), ea.transition && setTransitionHooks(Sa, ea.transition), ba = Sa, setCurrentRenderingInstance(va), ba
}

function filterSingleRoot(ue, Yi = !0) {
	let ea;
	for (let ta = 0; ta < ue.length; ta++) {
		const na = ue[ta];
		if (isVNode$1(na)) {
			if (na.type !== Comment || na.children === "v-if") {
				if (ea) return;
				ea = na
			}
		} else return
	}
	return ea
}
const getFunctionalFallthrough = ue => {
		let Yi;
		for (const ea in ue)(ea === "class" || ea === "style" || isOn(ea)) && ((Yi || (Yi = {}))[ea] = ue[ea]);
		return Yi
	},
	filterModelListeners = (ue, Yi) => {
		const ea = {};
		for (const ta in ue)(!isModelListener(ta) || !(ta.slice(9) in Yi)) && (ea[ta] = ue[ta]);
		return ea
	};

function shouldUpdateComponent(ue, Yi, ea) {
	const {
		props: ta,
		children: na,
		component: ra
	} = ue, {
		props: ia,
		children: aa,
		patchFlag: oa
	} = Yi, la = ra.emitsOptions;
	if (Yi.dirs || Yi.transition) return !0;
	if (ea && oa >= 0) {
		if (oa & 1024) return !0;
		if (oa & 16) return ta ? hasPropsChanged(ta, ia, la) : !!ia;
		if (oa & 8) {
			const sa = Yi.dynamicProps;
			for (let ca = 0; ca < sa.length; ca++) {
				const ua = sa[ca];
				if (ia[ua] !== ta[ua] && !isEmitListener(la, ua)) return !0
			}
		}
	} else return (na || aa) && (!aa || !aa.$stable) ? !0 : ta === ia ? !1 : ta ? ia ? hasPropsChanged(ta, ia, la) : !0 : !!ia;
	return !1
}

function hasPropsChanged(ue, Yi, ea) {
	const ta = Object.keys(Yi);
	if (ta.length !== Object.keys(ue).length) return !0;
	for (let na = 0; na < ta.length; na++) {
		const ra = ta[na];
		if (Yi[ra] !== ue[ra] && !isEmitListener(ea, ra)) return !0
	}
	return !1
}

function updateHOCHostEl({
	vnode: ue,
	parent: Yi
}, ea) {
	for (; Yi;) {
		const ta = Yi.subTree;
		if (ta.suspense && ta.suspense.activeBranch === ue && (ta.el = ue.el), ta === ue)(ue = Yi.vnode).el = ea, Yi = Yi.parent;
		else break
	}
}
const isSuspense = ue => ue.__isSuspense;
let suspenseId = 0;
const SuspenseImpl = {
		name: "Suspense",
		__isSuspense: !0,
		process(ue, Yi, ea, ta, na, ra, ia, aa, oa, la) {
			if (ue == null) mountSuspense(Yi, ea, ta, na, ra, ia, aa, oa, la);
			else {
				if (ra && ra.deps > 0 && !ue.suspense.isInFallback) {
					Yi.suspense = ue.suspense, Yi.suspense.vnode = Yi, Yi.el = ue.el;
					return
				}
				patchSuspense(ue, Yi, ea, ta, na, ia, aa, oa, la)
			}
		},
		hydrate: hydrateSuspense,
		normalize: normalizeSuspenseChildren
	},
	Suspense = SuspenseImpl;

function triggerEvent(ue, Yi) {
	const ea = ue.props && ue.props[Yi];
	isFunction$2(ea) && ea()
}

function mountSuspense(ue, Yi, ea, ta, na, ra, ia, aa, oa) {
	const {
		p: la,
		o: {
			createElement: sa
		}
	} = oa, ca = sa("div"), ua = ue.suspense = createSuspenseBoundary(ue, na, ta, Yi, ca, ea, ra, ia, aa, oa);
	la(null, ua.pendingBranch = ue.ssContent, ca, null, ta, ua, ra, ia), ua.deps > 0 ? (triggerEvent(ue, "onPending"), triggerEvent(ue, "onFallback"), la(null, ue.ssFallback, Yi, ea, ta, null, ra, ia), setActiveBranch(ua, ue.ssFallback)) : ua.resolve(!1, !0)
}

function patchSuspense(ue, Yi, ea, ta, na, ra, ia, aa, {
	p: oa,
	um: la,
	o: {
		createElement: sa
	}
}) {
	const ca = Yi.suspense = ue.suspense;
	ca.vnode = Yi, Yi.el = ue.el;
	const ua = Yi.ssContent,
		da = Yi.ssFallback,
		{
			activeBranch: ha,
			pendingBranch: pa,
			isInFallback: va,
			isHydrating: ba
		} = ca;
	if (pa) ca.pendingBranch = ua, isSameVNodeType(ua, pa) ? (oa(pa, ua, ca.hiddenContainer, null, na, ca, ra, ia, aa), ca.deps <= 0 ? ca.resolve() : va && (ba || (oa(ha, da, ea, ta, na, null, ra, ia, aa), setActiveBranch(ca, da)))) : (ca.pendingId = suspenseId++, ba ? (ca.isHydrating = !1, ca.activeBranch = pa) : la(pa, na, ca), ca.deps = 0, ca.effects.length = 0, ca.hiddenContainer = sa("div"), va ? (oa(null, ua, ca.hiddenContainer, null, na, ca, ra, ia, aa), ca.deps <= 0 ? ca.resolve() : (oa(ha, da, ea, ta, na, null, ra, ia, aa), setActiveBranch(ca, da))) : ha && isSameVNodeType(ua, ha) ? (oa(ha, ua, ea, ta, na, ca, ra, ia, aa), ca.resolve(!0)) : (oa(null, ua, ca.hiddenContainer, null, na, ca, ra, ia, aa), ca.deps <= 0 && ca.resolve()));
	else if (ha && isSameVNodeType(ua, ha)) oa(ha, ua, ea, ta, na, ca, ra, ia, aa), setActiveBranch(ca, ua);
	else if (triggerEvent(Yi, "onPending"), ca.pendingBranch = ua, ua.shapeFlag & 512 ? ca.pendingId = ua.component.suspenseId : ca.pendingId = suspenseId++, oa(null, ua, ca.hiddenContainer, null, na, ca, ra, ia, aa), ca.deps <= 0) ca.resolve();
	else {
		const {
			timeout: Ea,
			pendingId: Sa
		} = ca;
		Ea > 0 ? setTimeout(() => {
			ca.pendingId === Sa && ca.fallback(da)
		}, Ea) : Ea === 0 && ca.fallback(da)
	}
}

function createSuspenseBoundary(ue, Yi, ea, ta, na, ra, ia, aa, oa, la, sa = !1) {
	const {
		p: ca,
		m: ua,
		um: da,
		n: ha,
		o: {
			parentNode: pa,
			remove: va
		}
	} = la;
	let ba;
	const Ea = isVNodeSuspensible(ue);
	Ea && Yi && Yi.pendingBranch && (ba = Yi.pendingId, Yi.deps++);
	const Sa = ue.props ? toNumber(ue.props.timeout) : void 0,
		Ca = ra,
		ka = {
			vnode: ue,
			parent: Yi,
			parentComponent: ea,
			namespace: ia,
			container: ta,
			hiddenContainer: na,
			deps: 0,
			pendingId: suspenseId++,
			timeout: typeof Sa == "number" ? Sa : -1,
			activeBranch: null,
			pendingBranch: null,
			isInFallback: !sa,
			isHydrating: sa,
			isUnmounted: !1,
			effects: [],
			resolve(Pa = !1, ja = !1) {
				const {
					vnode: Za,
					activeBranch: Ga,
					pendingBranch: Ja,
					pendingId: Ua,
					effects: xa,
					parentComponent: ma,
					container: fa
				} = ka;
				let ga = !1;
				ka.isHydrating ? ka.isHydrating = !1 : Pa || (ga = Ga && Ja.transition && Ja.transition.mode === "out-in", ga && (Ga.transition.afterLeave = () => {
					Ua === ka.pendingId && (ua(Ja, fa, ra === Ca ? ha(Ga) : ra, 0), queuePostFlushCb(xa))
				}), Ga && (pa(Ga.el) === fa && (ra = ha(Ga)), da(Ga, ma, ka, !0)), ga || ua(Ja, fa, ra, 0)), setActiveBranch(ka, Ja), ka.pendingBranch = null, ka.isInFallback = !1;
				let wa = ka.parent,
					Ma = !1;
				for (; wa;) {
					if (wa.pendingBranch) {
						wa.effects.push(...xa), Ma = !0;
						break
					}
					wa = wa.parent
				}!Ma && !ga && queuePostFlushCb(xa), ka.effects = [], Ea && Yi && Yi.pendingBranch && ba === Yi.pendingId && (Yi.deps--, Yi.deps === 0 && !ja && Yi.resolve()), triggerEvent(Za, "onResolve")
			},
			fallback(Pa) {
				if (!ka.pendingBranch) return;
				const {
					vnode: ja,
					activeBranch: Za,
					parentComponent: Ga,
					container: Ja,
					namespace: Ua
				} = ka;
				triggerEvent(ja, "onFallback");
				const xa = ha(Za),
					ma = () => {
						ka.isInFallback && (ca(null, Pa, Ja, xa, Ga, null, Ua, aa, oa), setActiveBranch(ka, Pa))
					},
					fa = Pa.transition && Pa.transition.mode === "out-in";
				fa && (Za.transition.afterLeave = ma), ka.isInFallback = !0, da(Za, Ga, null, !0), fa || ma()
			},
			move(Pa, ja, Za) {
				ka.activeBranch && ua(ka.activeBranch, Pa, ja, Za), ka.container = Pa
			},
			next() {
				return ka.activeBranch && ha(ka.activeBranch)
			},
			registerDep(Pa, ja, Za) {
				const Ga = !!ka.pendingBranch;
				Ga && ka.deps++;
				const Ja = Pa.vnode.el;
				Pa.asyncDep.catch(Ua => {
					handleError(Ua, Pa, 0)
				}).then(Ua => {
					if (Pa.isUnmounted || ka.isUnmounted || ka.pendingId !== Pa.suspenseId) return;
					Pa.asyncResolved = !0;
					const {
						vnode: xa
					} = Pa;
					handleSetupResult(Pa, Ua, !1), Ja && (xa.el = Ja);
					const ma = !Ja && Pa.subTree.el;
					ja(Pa, xa, pa(Ja || Pa.subTree.el), Ja ? null : ha(Pa.subTree), ka, ia, Za), ma && va(ma), updateHOCHostEl(Pa, xa.el), Ga && --ka.deps === 0 && ka.resolve()
				})
			},
			unmount(Pa, ja) {
				ka.isUnmounted = !0, ka.activeBranch && da(ka.activeBranch, ea, Pa, ja), ka.pendingBranch && da(ka.pendingBranch, ea, Pa, ja)
			}
		};
	return ka
}

function hydrateSuspense(ue, Yi, ea, ta, na, ra, ia, aa, oa) {
	const la = Yi.suspense = createSuspenseBoundary(Yi, ta, ea, ue.parentNode, document.createElement("div"), null, na, ra, ia, aa, !0),
		sa = oa(ue, la.pendingBranch = Yi.ssContent, ea, la, ra, ia);
	return la.deps === 0 && la.resolve(!1, !0), sa
}

function normalizeSuspenseChildren(ue) {
	const {
		shapeFlag: Yi,
		children: ea
	} = ue, ta = Yi & 32;
	ue.ssContent = normalizeSuspenseSlot(ta ? ea.default : ea), ue.ssFallback = ta ? normalizeSuspenseSlot(ea.fallback) : createVNode(Comment)
}

function normalizeSuspenseSlot(ue) {
	let Yi;
	if (isFunction$2(ue)) {
		const ea = isBlockTreeEnabled && ue._c;
		ea && (ue._d = !1, openBlock()), ue = ue(), ea && (ue._d = !0, Yi = currentBlock, closeBlock())
	}
	return isArray$4(ue) && (ue = filterSingleRoot(ue)), ue = normalizeVNode(ue), Yi && !ue.dynamicChildren && (ue.dynamicChildren = Yi.filter(ea => ea !== ue)), ue
}

function queueEffectWithSuspense(ue, Yi) {
	Yi && Yi.pendingBranch ? isArray$4(ue) ? Yi.effects.push(...ue) : Yi.effects.push(ue) : queuePostFlushCb(ue)
}

function setActiveBranch(ue, Yi) {
	ue.activeBranch = Yi;
	const {
		vnode: ea,
		parentComponent: ta
	} = ue;
	let na = Yi.el;
	for (; !na && Yi.component;) Yi = Yi.component.subTree, na = Yi.el;
	ea.el = na, ta && ta.subTree === ea && (ta.vnode.el = na, updateHOCHostEl(ta, na))
}

function isVNodeSuspensible(ue) {
	const Yi = ue.props && ue.props.suspensible;
	return Yi != null && Yi !== !1
}
const Fragment = Symbol.for("v-fgt"),
	Text = Symbol.for("v-txt"),
	Comment = Symbol.for("v-cmt"),
	Static = Symbol.for("v-stc"),
	blockStack = [];
let currentBlock = null;

function openBlock(ue = !1) {
	blockStack.push(currentBlock = ue ? null : [])
}

function closeBlock() {
	blockStack.pop(), currentBlock = blockStack[blockStack.length - 1] || null
}
let isBlockTreeEnabled = 1;

function setBlockTracking(ue) {
	isBlockTreeEnabled += ue, ue < 0 && currentBlock && (currentBlock.hasOnce = !0)
}

function setupBlock(ue) {
	return ue.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null, closeBlock(), isBlockTreeEnabled > 0 && currentBlock && currentBlock.push(ue), ue
}

function createElementBlock(ue, Yi, ea, ta, na, ra) {
	return setupBlock(createBaseVNode(ue, Yi, ea, ta, na, ra, !0))
}

function createBlock(ue, Yi, ea, ta, na) {
	return setupBlock(createVNode(ue, Yi, ea, ta, na, !0))
}

function isVNode$1(ue) {
	return ue ? ue.__v_isVNode === !0 : !1
}

function isSameVNodeType(ue, Yi) {
	return ue.type === Yi.type && ue.key === Yi.key
}
const normalizeKey = ({
		key: ue
	}) => ue ?? null,
	normalizeRef = ({
		ref: ue,
		ref_key: Yi,
		ref_for: ea
	}) => (typeof ue == "number" && (ue = "" + ue), ue != null ? isString$4(ue) || isRef(ue) || isFunction$2(ue) ? {
		i: currentRenderingInstance,
		r: ue,
		k: Yi,
		f: !!ea
	} : ue : null);

function createBaseVNode(ue, Yi = null, ea = null, ta = 0, na = null, ra = ue === Fragment ? 0 : 1, ia = !1, aa = !1) {
	const oa = {
		__v_isVNode: !0,
		__v_skip: !0,
		type: ue,
		props: Yi,
		key: Yi && normalizeKey(Yi),
		ref: Yi && normalizeRef(Yi),
		scopeId: currentScopeId,
		slotScopeIds: null,
		children: ea,
		component: null,
		suspense: null,
		ssContent: null,
		ssFallback: null,
		dirs: null,
		transition: null,
		el: null,
		anchor: null,
		target: null,
		targetStart: null,
		targetAnchor: null,
		staticCount: 0,
		shapeFlag: ra,
		patchFlag: ta,
		dynamicProps: na,
		dynamicChildren: null,
		appContext: null,
		ctx: currentRenderingInstance
	};
	return aa ? (normalizeChildren(oa, ea), ra & 128 && ue.normalize(oa)) : ea && (oa.shapeFlag |= isString$4(ea) ? 8 : 16), isBlockTreeEnabled > 0 && !ia && currentBlock && (oa.patchFlag > 0 || ra & 6) && oa.patchFlag !== 32 && currentBlock.push(oa), oa
}
const createVNode = _createVNode;

function _createVNode(ue, Yi = null, ea = null, ta = 0, na = null, ra = !1) {
	if ((!ue || ue === NULL_DYNAMIC_COMPONENT) && (ue = Comment), isVNode$1(ue)) {
		const aa = cloneVNode(ue, Yi, !0);
		return ea && normalizeChildren(aa, ea), isBlockTreeEnabled > 0 && !ra && currentBlock && (aa.shapeFlag & 6 ? currentBlock[currentBlock.indexOf(ue)] = aa : currentBlock.push(aa)), aa.patchFlag = -2, aa
	}
	if (isClassComponent(ue) && (ue = ue.__vccOpts), Yi) {
		Yi = guardReactiveProps(Yi);
		let {
			class: aa,
			style: oa
		} = Yi;
		aa && !isString$4(aa) && (Yi.class = normalizeClass(aa)), isObject$3(oa) && (isProxy(oa) && !isArray$4(oa) && (oa = extend$1({}, oa)), Yi.style = normalizeStyle(oa))
	}
	const ia = isString$4(ue) ? 1 : isSuspense(ue) ? 128 : isTeleport(ue) ? 64 : isObject$3(ue) ? 4 : isFunction$2(ue) ? 2 : 0;
	return createBaseVNode(ue, Yi, ea, ta, na, ia, ra, !0)
}

function guardReactiveProps(ue) {
	return ue ? isProxy(ue) || isInternalObject(ue) ? extend$1({}, ue) : ue : null
}

function cloneVNode(ue, Yi, ea = !1, ta = !1) {
	const {
		props: na,
		ref: ra,
		patchFlag: ia,
		children: aa,
		transition: oa
	} = ue, la = Yi ? mergeProps(na || {}, Yi) : na, sa = {
		__v_isVNode: !0,
		__v_skip: !0,
		type: ue.type,
		props: la,
		key: la && normalizeKey(la),
		ref: Yi && Yi.ref ? ea && ra ? isArray$4(ra) ? ra.concat(normalizeRef(Yi)) : [ra, normalizeRef(Yi)] : normalizeRef(Yi) : ra,
		scopeId: ue.scopeId,
		slotScopeIds: ue.slotScopeIds,
		children: aa,
		target: ue.target,
		targetStart: ue.targetStart,
		targetAnchor: ue.targetAnchor,
		staticCount: ue.staticCount,
		shapeFlag: ue.shapeFlag,
		patchFlag: Yi && ue.type !== Fragment ? ia === -1 ? 16 : ia | 16 : ia,
		dynamicProps: ue.dynamicProps,
		dynamicChildren: ue.dynamicChildren,
		appContext: ue.appContext,
		dirs: ue.dirs,
		transition: oa,
		component: ue.component,
		suspense: ue.suspense,
		ssContent: ue.ssContent && cloneVNode(ue.ssContent),
		ssFallback: ue.ssFallback && cloneVNode(ue.ssFallback),
		el: ue.el,
		anchor: ue.anchor,
		ctx: ue.ctx,
		ce: ue.ce
	};
	return oa && ta && setTransitionHooks(sa, oa.clone(sa)), sa
}

function createTextVNode(ue = " ", Yi = 0) {
	return createVNode(Text, null, ue, Yi)
}

function createCommentVNode(ue = "", Yi = !1) {
	return Yi ? (openBlock(), createBlock(Comment, null, ue)) : createVNode(Comment, null, ue)
}

function normalizeVNode(ue) {
	return ue == null || typeof ue == "boolean" ? createVNode(Comment) : isArray$4(ue) ? createVNode(Fragment, null, ue.slice()) : isVNode$1(ue) ? cloneIfMounted(ue) : createVNode(Text, null, String(ue))
}

function cloneIfMounted(ue) {
	return ue.el === null && ue.patchFlag !== -1 || ue.memo ? ue : cloneVNode(ue)
}

function normalizeChildren(ue, Yi) {
	let ea = 0;
	const {
		shapeFlag: ta
	} = ue;
	if (Yi == null) Yi = null;
	else if (isArray$4(Yi)) ea = 16;
	else if (typeof Yi == "object")
		if (ta & 65) {
			const na = Yi.default;
			na && (na._c && (na._d = !1), normalizeChildren(ue, na()), na._c && (na._d = !0));
			return
		} else {
			ea = 32;
			const na = Yi._;
			!na && !isInternalObject(Yi) ? Yi._ctx = currentRenderingInstance : na === 3 && currentRenderingInstance && (currentRenderingInstance.slots._ === 1 ? Yi._ = 1 : (Yi._ = 2, ue.patchFlag |= 1024))
		}
	else isFunction$2(Yi) ? (Yi = {
		default: Yi,
		_ctx: currentRenderingInstance
	}, ea = 32) : (Yi = String(Yi), ta & 64 ? (ea = 16, Yi = [createTextVNode(Yi)]) : ea = 8);
	ue.children = Yi, ue.shapeFlag |= ea
}

function mergeProps(...ue) {
	const Yi = {};
	for (let ea = 0; ea < ue.length; ea++) {
		const ta = ue[ea];
		for (const na in ta)
			if (na === "class") Yi.class !== ta.class && (Yi.class = normalizeClass([Yi.class, ta.class]));
			else if (na === "style") Yi.style = normalizeStyle([Yi.style, ta.style]);
		else if (isOn(na)) {
			const ra = Yi[na],
				ia = ta[na];
			ia && ra !== ia && !(isArray$4(ra) && ra.includes(ia)) && (Yi[na] = ra ? [].concat(ra, ia) : ia)
		} else na !== "" && (Yi[na] = ta[na])
	}
	return Yi
}

function invokeVNodeHook(ue, Yi, ea, ta = null) {
	callWithAsyncErrorHandling(ue, Yi, 7, [ea, ta])
}
const emptyAppContext = createAppContext();
let uid = 0;

function createComponentInstance(ue, Yi, ea) {
	const ta = ue.type,
		na = (Yi ? Yi.appContext : ue.appContext) || emptyAppContext,
		ra = {
			uid: uid++,
			vnode: ue,
			type: ta,
			parent: Yi,
			appContext: na,
			root: null,
			next: null,
			subTree: null,
			effect: null,
			update: null,
			job: null,
			scope: new EffectScope(!0),
			render: null,
			proxy: null,
			exposed: null,
			exposeProxy: null,
			withProxy: null,
			provides: Yi ? Yi.provides : Object.create(na.provides),
			ids: Yi ? Yi.ids : ["", 0, 0],
			accessCache: null,
			renderCache: [],
			components: null,
			directives: null,
			propsOptions: normalizePropsOptions(ta, na),
			emitsOptions: normalizeEmitsOptions(ta, na),
			emit: null,
			emitted: null,
			propsDefaults: EMPTY_OBJ,
			inheritAttrs: ta.inheritAttrs,
			ctx: EMPTY_OBJ,
			data: EMPTY_OBJ,
			props: EMPTY_OBJ,
			attrs: EMPTY_OBJ,
			slots: EMPTY_OBJ,
			refs: EMPTY_OBJ,
			setupState: EMPTY_OBJ,
			setupContext: null,
			suspense: ea,
			suspenseId: ea ? ea.pendingId : 0,
			asyncDep: null,
			asyncResolved: !1,
			isMounted: !1,
			isUnmounted: !1,
			isDeactivated: !1,
			bc: null,
			c: null,
			bm: null,
			m: null,
			bu: null,
			u: null,
			um: null,
			bum: null,
			da: null,
			a: null,
			rtg: null,
			rtc: null,
			ec: null,
			sp: null
		};
	return ra.ctx = {
		_: ra
	}, ra.root = Yi ? Yi.root : ra, ra.emit = emit.bind(null, ra), ue.ce && ue.ce(ra), ra
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance, setInSSRSetupState;
{
	const ue = getGlobalThis$1(),
		Yi = (ea, ta) => {
			let na;
			return (na = ue[ea]) || (na = ue[ea] = []), na.push(ta), ra => {
				na.length > 1 ? na.forEach(ia => ia(ra)) : na[0](ra)
			}
		};
	internalSetCurrentInstance = Yi("__VUE_INSTANCE_SETTERS__", ea => currentInstance = ea), setInSSRSetupState = Yi("__VUE_SSR_SETTERS__", ea => isInSSRComponentSetup = ea)
}
const setCurrentInstance = ue => {
		const Yi = currentInstance;
		return internalSetCurrentInstance(ue), ue.scope.on(), () => {
			ue.scope.off(), internalSetCurrentInstance(Yi)
		}
	},
	unsetCurrentInstance = () => {
		currentInstance && currentInstance.scope.off(), internalSetCurrentInstance(null)
	};

function isStatefulComponent(ue) {
	return ue.vnode.shapeFlag & 4
}
let isInSSRComponentSetup = !1;

function setupComponent(ue, Yi = !1, ea = !1) {
	Yi && setInSSRSetupState(Yi);
	const {
		props: ta,
		children: na
	} = ue.vnode, ra = isStatefulComponent(ue);
	initProps(ue, ta, ra, Yi), initSlots(ue, na, ea);
	const ia = ra ? setupStatefulComponent(ue, Yi) : void 0;
	return Yi && setInSSRSetupState(!1), ia
}

function setupStatefulComponent(ue, Yi) {
	const ea = ue.type;
	ue.accessCache = Object.create(null), ue.proxy = new Proxy(ue.ctx, PublicInstanceProxyHandlers);
	const {
		setup: ta
	} = ea;
	if (ta) {
		const na = ue.setupContext = ta.length > 1 ? createSetupContext(ue) : null,
			ra = setCurrentInstance(ue);
		pauseTracking();
		const ia = callWithErrorHandling(ta, ue, 0, [ue.props, na]);
		if (resetTracking(), ra(), isPromise$3(ia)) {
			if (isAsyncWrapper(ue) || markAsyncBoundary(ue), ia.then(unsetCurrentInstance, unsetCurrentInstance), Yi) return ia.then(aa => {
				handleSetupResult(ue, aa, Yi)
			}).catch(aa => {
				handleError(aa, ue, 0)
			});
			ue.asyncDep = ia
		} else handleSetupResult(ue, ia, Yi)
	} else finishComponentSetup(ue, Yi)
}

function handleSetupResult(ue, Yi, ea) {
	isFunction$2(Yi) ? ue.type.__ssrInlineRender ? ue.ssrRender = Yi : ue.render = Yi : isObject$3(Yi) && (ue.setupState = proxyRefs(Yi)), finishComponentSetup(ue, ea)
}
let compile$1;

function finishComponentSetup(ue, Yi, ea) {
	const ta = ue.type;
	if (!ue.render) {
		if (!Yi && compile$1 && !ta.render) {
			const na = ta.template || resolveMergedOptions(ue).template;
			if (na) {
				const {
					isCustomElement: ra,
					compilerOptions: ia
				} = ue.appContext.config, {
					delimiters: aa,
					compilerOptions: oa
				} = ta, la = extend$1(extend$1({
					isCustomElement: ra,
					delimiters: aa
				}, ia), oa);
				ta.render = compile$1(na, la)
			}
		}
		ue.render = ta.render || NOOP
	} {
		const na = setCurrentInstance(ue);
		pauseTracking();
		try {
			applyOptions(ue)
		} finally {
			resetTracking(), na()
		}
	}
}
const attrsProxyHandlers = {
	get(ue, Yi) {
		return track(ue, "get", ""), ue[Yi]
	}
};

function createSetupContext(ue) {
	const Yi = ea => {
		ue.exposed = ea || {}
	};
	return {
		attrs: new Proxy(ue.attrs, attrsProxyHandlers),
		slots: ue.slots,
		emit: ue.emit,
		expose: Yi
	}
}

function getComponentPublicInstance(ue) {
	return ue.exposed ? ue.exposeProxy || (ue.exposeProxy = new Proxy(proxyRefs(markRaw(ue.exposed)), {
		get(Yi, ea) {
			if (ea in Yi) return Yi[ea];
			if (ea in publicPropertiesMap) return publicPropertiesMap[ea](ue)
		},
		has(Yi, ea) {
			return ea in Yi || ea in publicPropertiesMap
		}
	})) : ue.proxy
}
const classifyRE$1 = /(?:^|[-_])(\w)/g,
	classify$1 = ue => ue.replace(classifyRE$1, Yi => Yi.toUpperCase()).replace(/[-_]/g, "");

function getComponentName$1(ue, Yi = !0) {
	return isFunction$2(ue) ? ue.displayName || ue.name : ue.name || Yi && ue.__name
}

function formatComponentName$1(ue, Yi, ea = !1) {
	let ta = getComponentName$1(Yi);
	if (!ta && Yi.__file) {
		const na = Yi.__file.match(/([^/\\]+)\.\w+$/);
		na && (ta = na[1])
	}
	if (!ta && ue && ue.parent) {
		const na = ra => {
			for (const ia in ra)
				if (ra[ia] === Yi) return ia
		};
		ta = na(ue.components || ue.parent.type.components) || na(ue.appContext.components)
	}
	return ta ? classify$1(ta) : ea ? "App" : "Anonymous"
}

function isClassComponent(ue) {
	return isFunction$2(ue) && "__vccOpts" in ue
}
const computed = (ue, Yi) => computed$1(ue, Yi, isInSSRComponentSetup);

function h$2(ue, Yi, ea) {
	const ta = arguments.length;
	return ta === 2 ? isObject$3(Yi) && !isArray$4(Yi) ? isVNode$1(Yi) ? createVNode(ue, null, [Yi]) : createVNode(ue, Yi) : createVNode(ue, null, Yi) : (ta > 3 ? ea = Array.prototype.slice.call(arguments, 2) : ta === 3 && isVNode$1(ea) && (ea = [ea]), createVNode(ue, Yi, ea))
}
const version$1 = "3.5.11";
/**
 * @vue/runtime-dom v3.5.11
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
let policy;
const tt$2 = typeof window < "u" && window.trustedTypes;
if (tt$2) try {
	policy = tt$2.createPolicy("vue", {
		createHTML: ue => ue
	})
} catch {}
const unsafeToTrustedHTML = policy ? ue => policy.createHTML(ue) : ue => ue,
	svgNS = "http://www.w3.org/2000/svg",
	mathmlNS = "http://www.w3.org/1998/Math/MathML",
	doc$1 = typeof document < "u" ? document : null,
	templateContainer = doc$1 && doc$1.createElement("template"),
	nodeOps = {
		insert: (ue, Yi, ea) => {
			Yi.insertBefore(ue, ea || null)
		},
		remove: ue => {
			const Yi = ue.parentNode;
			Yi && Yi.removeChild(ue)
		},
		createElement: (ue, Yi, ea, ta) => {
			const na = Yi === "svg" ? doc$1.createElementNS(svgNS, ue) : Yi === "mathml" ? doc$1.createElementNS(mathmlNS, ue) : ea ? doc$1.createElement(ue, {
				is: ea
			}) : doc$1.createElement(ue);
			return ue === "select" && ta && ta.multiple != null && na.setAttribute("multiple", ta.multiple), na
		},
		createText: ue => doc$1.createTextNode(ue),
		createComment: ue => doc$1.createComment(ue),
		setText: (ue, Yi) => {
			ue.nodeValue = Yi
		},
		setElementText: (ue, Yi) => {
			ue.textContent = Yi
		},
		parentNode: ue => ue.parentNode,
		nextSibling: ue => ue.nextSibling,
		querySelector: ue => doc$1.querySelector(ue),
		setScopeId(ue, Yi) {
			ue.setAttribute(Yi, "")
		},
		insertStaticContent(ue, Yi, ea, ta, na, ra) {
			const ia = ea ? ea.previousSibling : Yi.lastChild;
			if (na && (na === ra || na.nextSibling))
				for (; Yi.insertBefore(na.cloneNode(!0), ea), !(na === ra || !(na = na.nextSibling)););
			else {
				templateContainer.innerHTML = unsafeToTrustedHTML(ta === "svg" ? `<svg>${ue}</svg>` : ta === "mathml" ? `<math>${ue}</math>` : ue);
				const aa = templateContainer.content;
				if (ta === "svg" || ta === "mathml") {
					const oa = aa.firstChild;
					for (; oa.firstChild;) aa.appendChild(oa.firstChild);
					aa.removeChild(oa)
				}
				Yi.insertBefore(aa, ea)
			}
			return [ia ? ia.nextSibling : Yi.firstChild, ea ? ea.previousSibling : Yi.lastChild]
		}
	},
	TRANSITION = "transition",
	ANIMATION = "animation",
	vtcKey = Symbol("_vtc"),
	DOMTransitionPropsValidators = {
		name: String,
		type: String,
		css: {
			type: Boolean,
			default: !0
		},
		duration: [String, Number, Object],
		enterFromClass: String,
		enterActiveClass: String,
		enterToClass: String,
		appearFromClass: String,
		appearActiveClass: String,
		appearToClass: String,
		leaveFromClass: String,
		leaveActiveClass: String,
		leaveToClass: String
	},
	TransitionPropsValidators = extend$1({}, BaseTransitionPropsValidators, DOMTransitionPropsValidators),
	decorate$1 = ue => (ue.displayName = "Transition", ue.props = TransitionPropsValidators, ue),
	Transition = decorate$1((ue, {
		slots: Yi
	}) => h$2(BaseTransition, resolveTransitionProps(ue), Yi)),
	callHook = (ue, Yi = []) => {
		isArray$4(ue) ? ue.forEach(ea => ea(...Yi)) : ue && ue(...Yi)
	},
	hasExplicitCallback = ue => ue ? isArray$4(ue) ? ue.some(Yi => Yi.length > 1) : ue.length > 1 : !1;

function resolveTransitionProps(ue) {
	const Yi = {};
	for (const xa in ue) xa in DOMTransitionPropsValidators || (Yi[xa] = ue[xa]);
	if (ue.css === !1) return Yi;
	const {
		name: ea = "v",
		type: ta,
		duration: na,
		enterFromClass: ra = `${ea}-enter-from`,
		enterActiveClass: ia = `${ea}-enter-active`,
		enterToClass: aa = `${ea}-enter-to`,
		appearFromClass: oa = ra,
		appearActiveClass: la = ia,
		appearToClass: sa = aa,
		leaveFromClass: ca = `${ea}-leave-from`,
		leaveActiveClass: ua = `${ea}-leave-active`,
		leaveToClass: da = `${ea}-leave-to`
	} = ue, ha = normalizeDuration(na), pa = ha && ha[0], va = ha && ha[1], {
		onBeforeEnter: ba,
		onEnter: Ea,
		onEnterCancelled: Sa,
		onLeave: Ca,
		onLeaveCancelled: ka,
		onBeforeAppear: Pa = ba,
		onAppear: ja = Ea,
		onAppearCancelled: Za = Sa
	} = Yi, Ga = (xa, ma, fa) => {
		removeTransitionClass(xa, ma ? sa : aa), removeTransitionClass(xa, ma ? la : ia), fa && fa()
	}, Ja = (xa, ma) => {
		xa._isLeaving = !1, removeTransitionClass(xa, ca), removeTransitionClass(xa, da), removeTransitionClass(xa, ua), ma && ma()
	}, Ua = xa => (ma, fa) => {
		const ga = xa ? ja : Ea,
			wa = () => Ga(ma, xa, fa);
		callHook(ga, [ma, wa]), nextFrame(() => {
			removeTransitionClass(ma, xa ? oa : ra), addTransitionClass(ma, xa ? sa : aa), hasExplicitCallback(ga) || whenTransitionEnds(ma, ta, pa, wa)
		})
	};
	return extend$1(Yi, {
		onBeforeEnter(xa) {
			callHook(ba, [xa]), addTransitionClass(xa, ra), addTransitionClass(xa, ia)
		},
		onBeforeAppear(xa) {
			callHook(Pa, [xa]), addTransitionClass(xa, oa), addTransitionClass(xa, la)
		},
		onEnter: Ua(!1),
		onAppear: Ua(!0),
		onLeave(xa, ma) {
			xa._isLeaving = !0;
			const fa = () => Ja(xa, ma);
			addTransitionClass(xa, ca), addTransitionClass(xa, ua), forceReflow(), nextFrame(() => {
				xa._isLeaving && (removeTransitionClass(xa, ca), addTransitionClass(xa, da), hasExplicitCallback(Ca) || whenTransitionEnds(xa, ta, va, fa))
			}), callHook(Ca, [xa, fa])
		},
		onEnterCancelled(xa) {
			Ga(xa, !1), callHook(Sa, [xa])
		},
		onAppearCancelled(xa) {
			Ga(xa, !0), callHook(Za, [xa])
		},
		onLeaveCancelled(xa) {
			Ja(xa), callHook(ka, [xa])
		}
	})
}

function normalizeDuration(ue) {
	if (ue == null) return null;
	if (isObject$3(ue)) return [NumberOf(ue.enter), NumberOf(ue.leave)];
	{
		const Yi = NumberOf(ue);
		return [Yi, Yi]
	}
}

function NumberOf(ue) {
	return toNumber(ue)
}

function addTransitionClass(ue, Yi) {
	Yi.split(/\s+/).forEach(ea => ea && ue.classList.add(ea)), (ue[vtcKey] || (ue[vtcKey] = new Set)).add(Yi)
}

function removeTransitionClass(ue, Yi) {
	Yi.split(/\s+/).forEach(ta => ta && ue.classList.remove(ta));
	const ea = ue[vtcKey];
	ea && (ea.delete(Yi), ea.size || (ue[vtcKey] = void 0))
}

function nextFrame(ue) {
	requestAnimationFrame(() => {
		requestAnimationFrame(ue)
	})
}
let endId = 0;

function whenTransitionEnds(ue, Yi, ea, ta) {
	const na = ue._endId = ++endId,
		ra = () => {
			na === ue._endId && ta()
		};
	if (ea != null) return setTimeout(ra, ea);
	const {
		type: ia,
		timeout: aa,
		propCount: oa
	} = getTransitionInfo(ue, Yi);
	if (!ia) return ta();
	const la = ia + "end";
	let sa = 0;
	const ca = () => {
			ue.removeEventListener(la, ua), ra()
		},
		ua = da => {
			da.target === ue && ++sa >= oa && ca()
		};
	setTimeout(() => {
		sa < oa && ca()
	}, aa + 1), ue.addEventListener(la, ua)
}

function getTransitionInfo(ue, Yi) {
	const ea = window.getComputedStyle(ue),
		ta = ha => (ea[ha] || "").split(", "),
		na = ta(`${TRANSITION}Delay`),
		ra = ta(`${TRANSITION}Duration`),
		ia = getTimeout(na, ra),
		aa = ta(`${ANIMATION}Delay`),
		oa = ta(`${ANIMATION}Duration`),
		la = getTimeout(aa, oa);
	let sa = null,
		ca = 0,
		ua = 0;
	Yi === TRANSITION ? ia > 0 && (sa = TRANSITION, ca = ia, ua = ra.length) : Yi === ANIMATION ? la > 0 && (sa = ANIMATION, ca = la, ua = oa.length) : (ca = Math.max(ia, la), sa = ca > 0 ? ia > la ? TRANSITION : ANIMATION : null, ua = sa ? sa === TRANSITION ? ra.length : oa.length : 0);
	const da = sa === TRANSITION && /\b(transform|all)(,|$)/.test(ta(`${TRANSITION}Property`).toString());
	return {
		type: sa,
		timeout: ca,
		propCount: ua,
		hasTransform: da
	}
}

function getTimeout(ue, Yi) {
	for (; ue.length < Yi.length;) ue = ue.concat(ue);
	return Math.max(...Yi.map((ea, ta) => toMs(ea) + toMs(ue[ta])))
}

function toMs(ue) {
	return ue === "auto" ? 0 : Number(ue.slice(0, -1).replace(",", ".")) * 1e3
}

function forceReflow() {
	return document.body.offsetHeight
}

function patchClass(ue, Yi, ea) {
	const ta = ue[vtcKey];
	ta && (Yi = (Yi ? [Yi, ...ta] : [...ta]).join(" ")), Yi == null ? ue.removeAttribute("class") : ea ? ue.setAttribute("class", Yi) : ue.className = Yi
}
const vShowOriginalDisplay = Symbol("_vod"),
	vShowHidden = Symbol("_vsh"),
	vShow = {
		beforeMount(ue, {
			value: Yi
		}, {
			transition: ea
		}) {
			ue[vShowOriginalDisplay] = ue.style.display === "none" ? "" : ue.style.display, ea && Yi ? ea.beforeEnter(ue) : setDisplay(ue, Yi)
		},
		mounted(ue, {
			value: Yi
		}, {
			transition: ea
		}) {
			ea && Yi && ea.enter(ue)
		},
		updated(ue, {
			value: Yi,
			oldValue: ea
		}, {
			transition: ta
		}) {
			!Yi != !ea && (ta ? Yi ? (ta.beforeEnter(ue), setDisplay(ue, !0), ta.enter(ue)) : ta.leave(ue, () => {
				setDisplay(ue, !1)
			}) : setDisplay(ue, Yi))
		},
		beforeUnmount(ue, {
			value: Yi
		}) {
			setDisplay(ue, Yi)
		}
	};

function setDisplay(ue, Yi) {
	ue.style.display = Yi ? ue[vShowOriginalDisplay] : "none", ue[vShowHidden] = !Yi
}
const CSS_VAR_TEXT = Symbol("");

function useCssVars(ue) {
	const Yi = getCurrentInstance();
	if (!Yi) return;
	const ea = Yi.ut = (na = ue(Yi.proxy)) => {
			Array.from(document.querySelectorAll(`[data-v-owner="${Yi.uid}"]`)).forEach(ra => setVarsOnNode(ra, na))
		},
		ta = () => {
			const na = ue(Yi.proxy);
			Yi.ce ? setVarsOnNode(Yi.ce, na) : setVarsOnVNode(Yi.subTree, na), ea(na)
		};
	onBeforeMount(() => {
		watchPostEffect(ta)
	}), onMounted(() => {
		const na = new MutationObserver(ta);
		na.observe(Yi.subTree.el.parentNode, {
			childList: !0
		}), onUnmounted(() => na.disconnect())
	})
}

function setVarsOnVNode(ue, Yi) {
	if (ue.shapeFlag & 128) {
		const ea = ue.suspense;
		ue = ea.activeBranch, ea.pendingBranch && !ea.isHydrating && ea.effects.push(() => {
			setVarsOnVNode(ea.activeBranch, Yi)
		})
	}
	for (; ue.component;) ue = ue.component.subTree;
	if (ue.shapeFlag & 1 && ue.el) setVarsOnNode(ue.el, Yi);
	else if (ue.type === Fragment) ue.children.forEach(ea => setVarsOnVNode(ea, Yi));
	else if (ue.type === Static) {
		let {
			el: ea,
			anchor: ta
		} = ue;
		for (; ea && (setVarsOnNode(ea, Yi), ea !== ta);) ea = ea.nextSibling
	}
}

function setVarsOnNode(ue, Yi) {
	if (ue.nodeType === 1) {
		const ea = ue.style;
		let ta = "";
		for (const na in Yi) ea.setProperty(`--${na}`, Yi[na]), ta += `--${na}: ${Yi[na]};`;
		ea[CSS_VAR_TEXT] = ta
	}
}
const displayRE = /(^|;)\s*display\s*:/;

function patchStyle(ue, Yi, ea) {
	const ta = ue.style,
		na = isString$4(ea);
	let ra = !1;
	if (ea && !na) {
		if (Yi)
			if (isString$4(Yi))
				for (const ia of Yi.split(";")) {
					const aa = ia.slice(0, ia.indexOf(":")).trim();
					ea[aa] == null && setStyle(ta, aa, "")
				} else
					for (const ia in Yi) ea[ia] == null && setStyle(ta, ia, "");
		for (const ia in ea) ia === "display" && (ra = !0), setStyle(ta, ia, ea[ia])
	} else if (na) {
		if (Yi !== ea) {
			const ia = ta[CSS_VAR_TEXT];
			ia && (ea += ";" + ia), ta.cssText = ea, ra = displayRE.test(ea)
		}
	} else Yi && ue.removeAttribute("style");
	vShowOriginalDisplay in ue && (ue[vShowOriginalDisplay] = ra ? ta.display : "", ue[vShowHidden] && (ta.display = "none"))
}
const importantRE = /\s*!important$/;

function setStyle(ue, Yi, ea) {
	if (isArray$4(ea)) ea.forEach(ta => setStyle(ue, Yi, ta));
	else if (ea == null && (ea = ""), Yi.startsWith("--")) ue.setProperty(Yi, ea);
	else {
		const ta = autoPrefix(ue, Yi);
		importantRE.test(ea) ? ue.setProperty(hyphenate(ta), ea.replace(importantRE, ""), "important") : ue[ta] = ea
	}
}
const prefixes = ["Webkit", "Moz", "ms"],
	prefixCache = {};

function autoPrefix(ue, Yi) {
	const ea = prefixCache[Yi];
	if (ea) return ea;
	let ta = camelize(Yi);
	if (ta !== "filter" && ta in ue) return prefixCache[Yi] = ta;
	ta = capitalize$2(ta);
	for (let na = 0; na < prefixes.length; na++) {
		const ra = prefixes[na] + ta;
		if (ra in ue) return prefixCache[Yi] = ra
	}
	return Yi
}
const xlinkNS = "http://www.w3.org/1999/xlink";

function patchAttr(ue, Yi, ea, ta, na, ra = isSpecialBooleanAttr(Yi)) {
	ta && Yi.startsWith("xlink:") ? ea == null ? ue.removeAttributeNS(xlinkNS, Yi.slice(6, Yi.length)) : ue.setAttributeNS(xlinkNS, Yi, ea) : ea == null || ra && !includeBooleanAttr(ea) ? ue.removeAttribute(Yi) : ue.setAttribute(Yi, ra ? "" : isSymbol$1(ea) ? String(ea) : ea)
}

function patchDOMProp(ue, Yi, ea, ta) {
	if (Yi === "innerHTML" || Yi === "textContent") {
		ea != null && (ue[Yi] = Yi === "innerHTML" ? unsafeToTrustedHTML(ea) : ea);
		return
	}
	const na = ue.tagName;
	if (Yi === "value" && na !== "PROGRESS" && !na.includes("-")) {
		const ia = na === "OPTION" ? ue.getAttribute("value") || "" : ue.value,
			aa = ea == null ? ue.type === "checkbox" ? "on" : "" : String(ea);
		(ia !== aa || !("_value" in ue)) && (ue.value = aa), ea == null && ue.removeAttribute(Yi), ue._value = ea;
		return
	}
	let ra = !1;
	if (ea === "" || ea == null) {
		const ia = typeof ue[Yi];
		ia === "boolean" ? ea = includeBooleanAttr(ea) : ea == null && ia === "string" ? (ea = "", ra = !0) : ia === "number" && (ea = 0, ra = !0)
	}
	try {
		ue[Yi] = ea
	} catch {}
	ra && ue.removeAttribute(Yi)
}

function addEventListener$1(ue, Yi, ea, ta) {
	ue.addEventListener(Yi, ea, ta)
}

function removeEventListener$1(ue, Yi, ea, ta) {
	ue.removeEventListener(Yi, ea, ta)
}
const veiKey = Symbol("_vei");

function patchEvent(ue, Yi, ea, ta, na = null) {
	const ra = ue[veiKey] || (ue[veiKey] = {}),
		ia = ra[Yi];
	if (ta && ia) ia.value = ta;
	else {
		const [aa, oa] = parseName(Yi);
		if (ta) {
			const la = ra[Yi] = createInvoker(ta, na);
			addEventListener$1(ue, aa, la, oa)
		} else ia && (removeEventListener$1(ue, aa, ia, oa), ra[Yi] = void 0)
	}
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;

function parseName(ue) {
	let Yi;
	if (optionsModifierRE.test(ue)) {
		Yi = {};
		let ta;
		for (; ta = ue.match(optionsModifierRE);) ue = ue.slice(0, ue.length - ta[0].length), Yi[ta[0].toLowerCase()] = !0
	}
	return [ue[2] === ":" ? ue.slice(3) : hyphenate(ue.slice(2)), Yi]
}
let cachedNow = 0;
const p$2 = Promise.resolve(),
	getNow = () => cachedNow || (p$2.then(() => cachedNow = 0), cachedNow = Date.now());

function createInvoker(ue, Yi) {
	const ea = ta => {
		if (!ta._vts) ta._vts = Date.now();
		else if (ta._vts <= ea.attached) return;
		callWithAsyncErrorHandling(patchStopImmediatePropagation(ta, ea.value), Yi, 5, [ta])
	};
	return ea.value = ue, ea.attached = getNow(), ea
}

function patchStopImmediatePropagation(ue, Yi) {
	if (isArray$4(Yi)) {
		const ea = ue.stopImmediatePropagation;
		return ue.stopImmediatePropagation = () => {
			ea.call(ue), ue._stopped = !0
		}, Yi.map(ta => na => !na._stopped && ta && ta(na))
	} else return Yi
}
const isNativeOn = ue => ue.charCodeAt(0) === 111 && ue.charCodeAt(1) === 110 && ue.charCodeAt(2) > 96 && ue.charCodeAt(2) < 123,
	patchProp = (ue, Yi, ea, ta, na, ra) => {
		const ia = na === "svg";
		Yi === "class" ? patchClass(ue, ta, ia) : Yi === "style" ? patchStyle(ue, ea, ta) : isOn(Yi) ? isModelListener(Yi) || patchEvent(ue, Yi, ea, ta, ra) : (Yi[0] === "." ? (Yi = Yi.slice(1), !0) : Yi[0] === "^" ? (Yi = Yi.slice(1), !1) : shouldSetAsProp(ue, Yi, ta, ia)) ? (patchDOMProp(ue, Yi, ta), !ue.tagName.includes("-") && (Yi === "value" || Yi === "checked" || Yi === "selected") && patchAttr(ue, Yi, ta, ia, ra, Yi !== "value")) : ue._isVueCE && (/[A-Z]/.test(Yi) || !isString$4(ta)) ? patchDOMProp(ue, camelize(Yi), ta) : (Yi === "true-value" ? ue._trueValue = ta : Yi === "false-value" && (ue._falseValue = ta), patchAttr(ue, Yi, ta, ia))
	};

function shouldSetAsProp(ue, Yi, ea, ta) {
	if (ta) return !!(Yi === "innerHTML" || Yi === "textContent" || Yi in ue && isNativeOn(Yi) && isFunction$2(ea));
	if (Yi === "spellcheck" || Yi === "draggable" || Yi === "translate" || Yi === "form" || Yi === "list" && ue.tagName === "INPUT" || Yi === "type" && ue.tagName === "TEXTAREA") return !1;
	if (Yi === "width" || Yi === "height") {
		const na = ue.tagName;
		if (na === "IMG" || na === "VIDEO" || na === "CANVAS" || na === "SOURCE") return !1
	}
	return isNativeOn(Yi) && isString$4(ea) ? !1 : Yi in ue
}
const positionMap = new WeakMap,
	newPositionMap = new WeakMap,
	moveCbKey = Symbol("_moveCb"),
	enterCbKey = Symbol("_enterCb"),
	decorate = ue => (delete ue.props.mode, ue),
	TransitionGroupImpl = decorate({
		name: "TransitionGroup",
		props: extend$1({}, TransitionPropsValidators, {
			tag: String,
			moveClass: String
		}),
		setup(ue, {
			slots: Yi
		}) {
			const ea = getCurrentInstance(),
				ta = useTransitionState();
			let na, ra;
			return onUpdated(() => {
				if (!na.length) return;
				const ia = ue.moveClass || `${ue.name||"v"}-move`;
				if (!hasCSSTransform(na[0].el, ea.vnode.el, ia)) return;
				na.forEach(callPendingCbs), na.forEach(recordPosition);
				const aa = na.filter(applyTranslation);
				forceReflow(), aa.forEach(oa => {
					const la = oa.el,
						sa = la.style;
					addTransitionClass(la, ia), sa.transform = sa.webkitTransform = sa.transitionDuration = "";
					const ca = la[moveCbKey] = ua => {
						ua && ua.target !== la || (!ua || /transform$/.test(ua.propertyName)) && (la.removeEventListener("transitionend", ca), la[moveCbKey] = null, removeTransitionClass(la, ia))
					};
					la.addEventListener("transitionend", ca)
				})
			}), () => {
				const ia = toRaw(ue),
					aa = resolveTransitionProps(ia);
				let oa = ia.tag || Fragment;
				if (na = [], ra)
					for (let la = 0; la < ra.length; la++) {
						const sa = ra[la];
						sa.el && sa.el instanceof Element && (na.push(sa), setTransitionHooks(sa, resolveTransitionHooks(sa, aa, ta, ea)), positionMap.set(sa, sa.el.getBoundingClientRect()))
					}
				ra = Yi.default ? getTransitionRawChildren(Yi.default()) : [];
				for (let la = 0; la < ra.length; la++) {
					const sa = ra[la];
					sa.key != null && setTransitionHooks(sa, resolveTransitionHooks(sa, aa, ta, ea))
				}
				return createVNode(oa, null, ra)
			}
		}
	}),
	TransitionGroup = TransitionGroupImpl;

function callPendingCbs(ue) {
	const Yi = ue.el;
	Yi[moveCbKey] && Yi[moveCbKey](), Yi[enterCbKey] && Yi[enterCbKey]()
}

function recordPosition(ue) {
	newPositionMap.set(ue, ue.el.getBoundingClientRect())
}

function applyTranslation(ue) {
	const Yi = positionMap.get(ue),
		ea = newPositionMap.get(ue),
		ta = Yi.left - ea.left,
		na = Yi.top - ea.top;
	if (ta || na) {
		const ra = ue.el.style;
		return ra.transform = ra.webkitTransform = `translate(${ta}px,${na}px)`, ra.transitionDuration = "0s", ue
	}
}

function hasCSSTransform(ue, Yi, ea) {
	const ta = ue.cloneNode(),
		na = ue[vtcKey];
	na && na.forEach(aa => {
		aa.split(/\s+/).forEach(oa => oa && ta.classList.remove(oa))
	}), ea.split(/\s+/).forEach(aa => aa && ta.classList.add(aa)), ta.style.display = "none";
	const ra = Yi.nodeType === 1 ? Yi : Yi.parentNode;
	ra.appendChild(ta);
	const {
		hasTransform: ia
	} = getTransitionInfo(ta);
	return ra.removeChild(ta), ia
}
const getModelAssigner = ue => {
	const Yi = ue.props["onUpdate:modelValue"] || !1;
	return isArray$4(Yi) ? ea => invokeArrayFns(Yi, ea) : Yi
};

function onCompositionStart(ue) {
	ue.target.composing = !0
}

function onCompositionEnd(ue) {
	const Yi = ue.target;
	Yi.composing && (Yi.composing = !1, Yi.dispatchEvent(new Event("input")))
}
const assignKey = Symbol("_assign"),
	vModelText = {
		created(ue, {
			modifiers: {
				lazy: Yi,
				trim: ea,
				number: ta
			}
		}, na) {
			ue[assignKey] = getModelAssigner(na);
			const ra = ta || na.props && na.props.type === "number";
			addEventListener$1(ue, Yi ? "change" : "input", ia => {
				if (ia.target.composing) return;
				let aa = ue.value;
				ea && (aa = aa.trim()), ra && (aa = looseToNumber(aa)), ue[assignKey](aa)
			}), ea && addEventListener$1(ue, "change", () => {
				ue.value = ue.value.trim()
			}), Yi || (addEventListener$1(ue, "compositionstart", onCompositionStart), addEventListener$1(ue, "compositionend", onCompositionEnd), addEventListener$1(ue, "change", onCompositionEnd))
		},
		mounted(ue, {
			value: Yi
		}) {
			ue.value = Yi ?? ""
		},
		beforeUpdate(ue, {
			value: Yi,
			oldValue: ea,
			modifiers: {
				lazy: ta,
				trim: na,
				number: ra
			}
		}, ia) {
			if (ue[assignKey] = getModelAssigner(ia), ue.composing) return;
			const aa = (ra || ue.type === "number") && !/^0\d/.test(ue.value) ? looseToNumber(ue.value) : ue.value,
				oa = Yi ?? "";
			aa !== oa && (document.activeElement === ue && ue.type !== "range" && (ta && Yi === ea || na && ue.value.trim() === oa) || (ue.value = oa))
		}
	},
	vModelCheckbox = {
		deep: !0,
		created(ue, Yi, ea) {
			ue[assignKey] = getModelAssigner(ea), addEventListener$1(ue, "change", () => {
				const ta = ue._modelValue,
					na = getValue(ue),
					ra = ue.checked,
					ia = ue[assignKey];
				if (isArray$4(ta)) {
					const aa = looseIndexOf(ta, na),
						oa = aa !== -1;
					if (ra && !oa) ia(ta.concat(na));
					else if (!ra && oa) {
						const la = [...ta];
						la.splice(aa, 1), ia(la)
					}
				} else if (isSet(ta)) {
					const aa = new Set(ta);
					ra ? aa.add(na) : aa.delete(na), ia(aa)
				} else ia(getCheckboxValue(ue, ra))
			})
		},
		mounted: setChecked,
		beforeUpdate(ue, Yi, ea) {
			ue[assignKey] = getModelAssigner(ea), setChecked(ue, Yi, ea)
		}
	};

function setChecked(ue, {
	value: Yi
}, ea) {
	ue._modelValue = Yi;
	let ta;
	isArray$4(Yi) ? ta = looseIndexOf(Yi, ea.props.value) > -1 : isSet(Yi) ? ta = Yi.has(ea.props.value) : ta = looseEqual(Yi, getCheckboxValue(ue, !0)), ue.checked !== ta && (ue.checked = ta)
}
const vModelRadio = {
		created(ue, {
			value: Yi
		}, ea) {
			ue.checked = looseEqual(Yi, ea.props.value), ue[assignKey] = getModelAssigner(ea), addEventListener$1(ue, "change", () => {
				ue[assignKey](getValue(ue))
			})
		},
		beforeUpdate(ue, {
			value: Yi,
			oldValue: ea
		}, ta) {
			ue[assignKey] = getModelAssigner(ta), Yi !== ea && (ue.checked = looseEqual(Yi, ta.props.value))
		}
	},
	vModelSelect = {
		deep: !0,
		created(ue, {
			value: Yi,
			modifiers: {
				number: ea
			}
		}, ta) {
			const na = isSet(Yi);
			addEventListener$1(ue, "change", () => {
				const ra = Array.prototype.filter.call(ue.options, ia => ia.selected).map(ia => ea ? looseToNumber(getValue(ia)) : getValue(ia));
				ue[assignKey](ue.multiple ? na ? new Set(ra) : ra : ra[0]), ue._assigning = !0, nextTick(() => {
					ue._assigning = !1
				})
			}), ue[assignKey] = getModelAssigner(ta)
		},
		mounted(ue, {
			value: Yi
		}) {
			setSelected(ue, Yi)
		},
		beforeUpdate(ue, Yi, ea) {
			ue[assignKey] = getModelAssigner(ea)
		},
		updated(ue, {
			value: Yi
		}) {
			ue._assigning || setSelected(ue, Yi)
		}
	};

function setSelected(ue, Yi) {
	const ea = ue.multiple,
		ta = isArray$4(Yi);
	if (!(ea && !ta && !isSet(Yi))) {
		for (let na = 0, ra = ue.options.length; na < ra; na++) {
			const ia = ue.options[na],
				aa = getValue(ia);
			if (ea)
				if (ta) {
					const oa = typeof aa;
					oa === "string" || oa === "number" ? ia.selected = Yi.some(la => String(la) === String(aa)) : ia.selected = looseIndexOf(Yi, aa) > -1
				} else ia.selected = Yi.has(aa);
			else if (looseEqual(getValue(ia), Yi)) {
				ue.selectedIndex !== na && (ue.selectedIndex = na);
				return
			}
		}!ea && ue.selectedIndex !== -1 && (ue.selectedIndex = -1)
	}
}

function getValue(ue) {
	return "_value" in ue ? ue._value : ue.value
}

function getCheckboxValue(ue, Yi) {
	const ea = Yi ? "_trueValue" : "_falseValue";
	return ea in ue ? ue[ea] : Yi
}
const vModelDynamic = {
	created(ue, Yi, ea) {
		callModelHook(ue, Yi, ea, null, "created")
	},
	mounted(ue, Yi, ea) {
		callModelHook(ue, Yi, ea, null, "mounted")
	},
	beforeUpdate(ue, Yi, ea, ta) {
		callModelHook(ue, Yi, ea, ta, "beforeUpdate")
	},
	updated(ue, Yi, ea, ta) {
		callModelHook(ue, Yi, ea, ta, "updated")
	}
};

function resolveDynamicModel(ue, Yi) {
	switch (ue) {
		case "SELECT":
			return vModelSelect;
		case "TEXTAREA":
			return vModelText;
		default:
			switch (Yi) {
				case "checkbox":
					return vModelCheckbox;
				case "radio":
					return vModelRadio;
				default:
					return vModelText
			}
	}
}

function callModelHook(ue, Yi, ea, ta, na) {
	const ia = resolveDynamicModel(ue.tagName, ea.props && ea.props.type)[na];
	ia && ia(ue, Yi, ea, ta)
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"],
	modifierGuards = {
		stop: ue => ue.stopPropagation(),
		prevent: ue => ue.preventDefault(),
		self: ue => ue.target !== ue.currentTarget,
		ctrl: ue => !ue.ctrlKey,
		shift: ue => !ue.shiftKey,
		alt: ue => !ue.altKey,
		meta: ue => !ue.metaKey,
		left: ue => "button" in ue && ue.button !== 0,
		middle: ue => "button" in ue && ue.button !== 1,
		right: ue => "button" in ue && ue.button !== 2,
		exact: (ue, Yi) => systemModifiers.some(ea => ue[`${ea}Key`] && !Yi.includes(ea))
	},
	withModifiers = (ue, Yi) => {
		const ea = ue._withMods || (ue._withMods = {}),
			ta = Yi.join(".");
		return ea[ta] || (ea[ta] = (na, ...ra) => {
			for (let ia = 0; ia < Yi.length; ia++) {
				const aa = modifierGuards[Yi[ia]];
				if (aa && aa(na, Yi)) return
			}
			return ue(na, ...ra)
		})
	},
	keyNames = {
		esc: "escape",
		space: " ",
		up: "arrow-up",
		left: "arrow-left",
		right: "arrow-right",
		down: "arrow-down",
		delete: "backspace"
	},
	withKeys = (ue, Yi) => {
		const ea = ue._withKeys || (ue._withKeys = {}),
			ta = Yi.join(".");
		return ea[ta] || (ea[ta] = na => {
			if (!("key" in na)) return;
			const ra = hyphenate(na.key);
			if (Yi.some(ia => ia === ra || keyNames[ia] === ra)) return ue(na)
		})
	},
	rendererOptions = extend$1({
		patchProp
	}, nodeOps);
let renderer, enabledHydration = !1;

function ensureRenderer() {
	return renderer || (renderer = createRenderer(rendererOptions))
}

function ensureHydrationRenderer() {
	return renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions), enabledHydration = !0, renderer
}
const createApp = (...ue) => {
		const Yi = ensureRenderer().createApp(...ue),
			{
				mount: ea
			} = Yi;
		return Yi.mount = ta => {
			const na = normalizeContainer(ta);
			if (!na) return;
			const ra = Yi._component;
			!isFunction$2(ra) && !ra.render && !ra.template && (ra.template = na.innerHTML), na.nodeType === 1 && (na.textContent = "");
			const ia = ea(na, !1, resolveRootNamespace(na));
			return na instanceof Element && (na.removeAttribute("v-cloak"), na.setAttribute("data-v-app", "")), ia
		}, Yi
	},
	createSSRApp = (...ue) => {
		const Yi = ensureHydrationRenderer().createApp(...ue),
			{
				mount: ea
			} = Yi;
		return Yi.mount = ta => {
			const na = normalizeContainer(ta);
			if (na) return ea(na, !0, resolveRootNamespace(na))
		}, Yi
	};

function resolveRootNamespace(ue) {
	if (ue instanceof SVGElement) return "svg";
	if (typeof MathMLElement == "function" && ue instanceof MathMLElement) return "mathml"
}

function normalizeContainer(ue) {
	return isString$4(ue) ? document.querySelector(ue) : ue
}
const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
	suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
	JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;

function jsonParseTransform(ue, Yi) {
	if (ue === "__proto__" || ue === "constructor" && Yi && typeof Yi == "object" && "prototype" in Yi) {
		warnKeyDropped(ue);
		return
	}
	return Yi
}

function warnKeyDropped(ue) {
	console.warn(`[destr] Dropping "${ue}" key to prevent prototype pollution.`)
}

function destr(ue, Yi = {}) {
	if (typeof ue != "string") return ue;
	const ea = ue.trim();
	if (ue[0] === '"' && ue.endsWith('"') && !ue.includes("\\")) return ea.slice(1, -1);
	if (ea.length <= 9) {
		const ta = ea.toLowerCase();
		if (ta === "true") return !0;
		if (ta === "false") return !1;
		if (ta === "undefined") return;
		if (ta === "null") return null;
		if (ta === "nan") return Number.NaN;
		if (ta === "infinity") return Number.POSITIVE_INFINITY;
		if (ta === "-infinity") return Number.NEGATIVE_INFINITY
	}
	if (!JsonSigRx.test(ue)) {
		if (Yi.strict) throw new SyntaxError("[destr] Invalid JSON");
		return ue
	}
	try {
		if (suspectProtoRx.test(ue) || suspectConstructorRx.test(ue)) {
			if (Yi.strict) throw new Error("[destr] Possible prototype pollution");
			return JSON.parse(ue, jsonParseTransform)
		}
		return JSON.parse(ue)
	} catch (ta) {
		if (Yi.strict) throw ta;
		return ue
	}
}
const HASH_RE$1 = /#/g,
	AMPERSAND_RE$1 = /&/g,
	SLASH_RE$1 = /\//g,
	EQUAL_RE$1 = /=/g,
	PLUS_RE$1 = /\+/g,
	ENC_CARET_RE$1 = /%5e/gi,
	ENC_BACKTICK_RE$1 = /%60/gi,
	ENC_PIPE_RE$1 = /%7c/gi,
	ENC_SPACE_RE$1 = /%20/gi;

function encode$3(ue) {
	return encodeURI("" + ue).replace(ENC_PIPE_RE$1, "|")
}

function encodeQueryValue$1(ue) {
	return encode$3(typeof ue == "string" ? ue : JSON.stringify(ue)).replace(PLUS_RE$1, "%2B").replace(ENC_SPACE_RE$1, "+").replace(HASH_RE$1, "%23").replace(AMPERSAND_RE$1, "%26").replace(ENC_BACKTICK_RE$1, "`").replace(ENC_CARET_RE$1, "^").replace(SLASH_RE$1, "%2F")
}

function encodeQueryKey$1(ue) {
	return encodeQueryValue$1(ue).replace(EQUAL_RE$1, "%3D")
}

function decode$2(ue = "") {
	try {
		return decodeURIComponent("" + ue)
	} catch {
		return "" + ue
	}
}

function decodeQueryKey(ue) {
	return decode$2(ue.replace(PLUS_RE$1, " "))
}

function decodeQueryValue(ue) {
	return decode$2(ue.replace(PLUS_RE$1, " "))
}

function parseQuery$1(ue = "") {
	const Yi = {};
	ue[0] === "?" && (ue = ue.slice(1));
	for (const ea of ue.split("&")) {
		const ta = ea.match(/([^=]+)=?(.*)/) || [];
		if (ta.length < 2) continue;
		const na = decodeQueryKey(ta[1]);
		if (na === "__proto__" || na === "constructor") continue;
		const ra = decodeQueryValue(ta[2] || "");
		Yi[na] === void 0 ? Yi[na] = ra : Array.isArray(Yi[na]) ? Yi[na].push(ra) : Yi[na] = [Yi[na], ra]
	}
	return Yi
}

function encodeQueryItem(ue, Yi) {
	return (typeof Yi == "number" || typeof Yi == "boolean") && (Yi = String(Yi)), Yi ? Array.isArray(Yi) ? Yi.map(ea => `${encodeQueryKey$1(ue)}=${encodeQueryValue$1(ea)}`).join("&") : `${encodeQueryKey$1(ue)}=${encodeQueryValue$1(Yi)}` : encodeQueryKey$1(ue)
}

function stringifyQuery$1(ue) {
	return Object.keys(ue).filter(Yi => ue[Yi] !== void 0).map(Yi => encodeQueryItem(Yi, ue[Yi])).filter(Boolean).join("&")
}
const PROTOCOL_STRICT_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/,
	PROTOCOL_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{2})?/,
	PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/,
	PROTOCOL_SCRIPT_RE = /^[\s\0]*(blob|data|javascript|vbscript):$/i,
	TRAILING_SLASH_RE$1 = /\/$|\/\?|\/#/,
	JOIN_LEADING_SLASH_RE = /^\.?\//;

function hasProtocol(ue, Yi = {}) {
	return typeof Yi == "boolean" && (Yi = {
		acceptRelative: Yi
	}), Yi.strict ? PROTOCOL_STRICT_REGEX.test(ue) : PROTOCOL_REGEX.test(ue) || (Yi.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(ue) : !1)
}

function isScriptProtocol(ue) {
	return !!ue && PROTOCOL_SCRIPT_RE.test(ue)
}

function hasTrailingSlash(ue = "", Yi) {
	return Yi ? TRAILING_SLASH_RE$1.test(ue) : ue.endsWith("/")
}

function withoutTrailingSlash(ue = "", Yi) {
	if (!Yi) return (hasTrailingSlash(ue) ? ue.slice(0, -1) : ue) || "/";
	if (!hasTrailingSlash(ue, !0)) return ue || "/";
	let ea = ue,
		ta = "";
	const na = ue.indexOf("#");
	na >= 0 && (ea = ue.slice(0, na), ta = ue.slice(na));
	const [ra, ...ia] = ea.split("?");
	return ((ra.endsWith("/") ? ra.slice(0, -1) : ra) || "/") + (ia.length > 0 ? `?${ia.join("?")}` : "") + ta
}

function withTrailingSlash(ue = "", Yi) {
	if (!Yi) return ue.endsWith("/") ? ue : ue + "/";
	if (hasTrailingSlash(ue, !0)) return ue || "/";
	let ea = ue,
		ta = "";
	const na = ue.indexOf("#");
	if (na >= 0 && (ea = ue.slice(0, na), ta = ue.slice(na), !ea)) return ta;
	const [ra, ...ia] = ea.split("?");
	return ra + "/" + (ia.length > 0 ? `?${ia.join("?")}` : "") + ta
}

function hasLeadingSlash(ue = "") {
	return ue.startsWith("/")
}

function withLeadingSlash(ue = "") {
	return hasLeadingSlash(ue) ? ue : "/" + ue
}

function withBase(ue, Yi) {
	if (isEmptyURL(Yi) || hasProtocol(ue)) return ue;
	const ea = withoutTrailingSlash(Yi);
	return ue.startsWith(ea) ? ue : joinURL(ea, ue)
}

function withoutBase(ue, Yi) {
	if (isEmptyURL(Yi)) return ue;
	const ea = withoutTrailingSlash(Yi);
	if (!ue.startsWith(ea)) return ue;
	const ta = ue.slice(ea.length);
	return ta[0] === "/" ? ta : "/" + ta
}

function withQuery(ue, Yi) {
	const ea = parseURL$1(ue),
		ta = {
			...parseQuery$1(ea.search),
			...Yi
		};
	return ea.search = stringifyQuery$1(ta), stringifyParsedURL(ea)
}

function isEmptyURL(ue) {
	return !ue || ue === "/"
}

function isNonEmptyURL(ue) {
	return ue && ue !== "/"
}

function joinURL(ue, ...Yi) {
	let ea = ue || "";
	for (const ta of Yi.filter(na => isNonEmptyURL(na)))
		if (ea) {
			const na = ta.replace(JOIN_LEADING_SLASH_RE, "");
			ea = withTrailingSlash(ea) + na
		} else ea = ta;
	return ea
}

function joinRelativeURL(...ue) {
	var ia, aa, oa, la;
	const Yi = /\/(?!\/)/,
		ea = ue.filter(Boolean),
		ta = [];
	let na = 0;
	for (const sa of ea)
		if (!(!sa || sa === "/")) {
			for (const [ca, ua] of sa.split(Yi).entries())
				if (!(!ua || ua === ".")) {
					if (ua === "..") {
						if (ta.length === 1 && hasProtocol(ta[0])) continue;
						ta.pop(), na--;
						continue
					}
					if (ca === 1 && ((ia = ta[ta.length - 1]) != null && ia.endsWith(":/"))) {
						ta[ta.length - 1] += "/" + ua;
						continue
					}
					ta.push(ua), na++
				}
		} let ra = ta.join("/");
	return na >= 0 ? (aa = ea[0]) != null && aa.startsWith("/") && !ra.startsWith("/") ? ra = "/" + ra : (oa = ea[0]) != null && oa.startsWith("./") && !ra.startsWith("./") && (ra = "./" + ra) : ra = "../".repeat(-1 * na) + ra, (la = ea[ea.length - 1]) != null && la.endsWith("/") && !ra.endsWith("/") && (ra += "/"), ra
}

function isEqual$1(ue, Yi, ea = {}) {
	return ea.trailingSlash || (ue = withTrailingSlash(ue), Yi = withTrailingSlash(Yi)), ea.leadingSlash || (ue = withLeadingSlash(ue), Yi = withLeadingSlash(Yi)), ea.encoding || (ue = decode$2(ue), Yi = decode$2(Yi)), ue === Yi
}
const protocolRelative = Symbol.for("ufo:protocolRelative");

function parseURL$1(ue = "", Yi) {
	const ea = ue.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i);
	if (ea) {
		const [, ca, ua = ""] = ea;
		return {
			protocol: ca.toLowerCase(),
			pathname: ua,
			href: ca + ua,
			auth: "",
			host: "",
			search: "",
			hash: ""
		}
	}
	if (!hasProtocol(ue, {
			acceptRelative: !0
		})) return parsePath(ue);
	const [, ta = "", na, ra = ""] = ue.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
	let [, ia = "", aa = ""] = ra.match(/([^#/?]*)(.*)?/) || [];
	ta === "file:" && (aa = aa.replace(/\/(?=[A-Za-z]:)/, ""));
	const {
		pathname: oa,
		search: la,
		hash: sa
	} = parsePath(aa);
	return {
		protocol: ta.toLowerCase(),
		auth: na ? na.slice(0, Math.max(0, na.length - 1)) : "",
		host: ia,
		pathname: oa,
		search: la,
		hash: sa,
		[protocolRelative]: !ta
	}
}

function parsePath(ue = "") {
	const [Yi = "", ea = "", ta = ""] = (ue.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
	return {
		pathname: Yi,
		search: ea,
		hash: ta
	}
}

function stringifyParsedURL(ue) {
	const Yi = ue.pathname || "",
		ea = ue.search ? (ue.search.startsWith("?") ? "" : "?") + ue.search : "",
		ta = ue.hash || "",
		na = ue.auth ? ue.auth + "@" : "",
		ra = ue.host || "";
	return (ue.protocol || ue[protocolRelative] ? (ue.protocol || "") + "//" : "") + na + ra + Yi + ea + ta
}
class FetchError extends Error {
	constructor(Yi, ea) {
		super(Yi, ea), this.name = "FetchError", ea != null && ea.cause && !this.cause && (this.cause = ea.cause)
	}
}

function createFetchError(ue) {
	var oa, la, sa, ca, ua;
	const Yi = ((oa = ue.error) == null ? void 0 : oa.message) || ((la = ue.error) == null ? void 0 : la.toString()) || "",
		ea = ((sa = ue.request) == null ? void 0 : sa.method) || ((ca = ue.options) == null ? void 0 : ca.method) || "GET",
		ta = ((ua = ue.request) == null ? void 0 : ua.url) || String(ue.request) || "/",
		na = `[${ea}] ${JSON.stringify(ta)}`,
		ra = ue.response ? `${ue.response.status} ${ue.response.statusText}` : "<no response>",
		ia = `${na}: ${ra}${Yi?` ${Yi}`:""}`,
		aa = new FetchError(ia, ue.error ? {
			cause: ue.error
		} : void 0);
	for (const da of ["request", "options", "response"]) Object.defineProperty(aa, da, {
		get() {
			return ue[da]
		}
	});
	for (const [da, ha] of [
			["data", "_data"],
			["status", "status"],
			["statusCode", "status"],
			["statusText", "statusText"],
			["statusMessage", "statusText"]
		]) Object.defineProperty(aa, da, {
		get() {
			return ue.response && ue.response[ha]
		}
	});
	return aa
}
const payloadMethods = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]));

function isPayloadMethod(ue = "GET") {
	return payloadMethods.has(ue.toUpperCase())
}

function isJSONSerializable(ue) {
	if (ue === void 0) return !1;
	const Yi = typeof ue;
	return Yi === "string" || Yi === "number" || Yi === "boolean" || Yi === null ? !0 : Yi !== "object" ? !1 : Array.isArray(ue) ? !0 : ue.buffer ? !1 : ue.constructor && ue.constructor.name === "Object" || typeof ue.toJSON == "function"
}
const textTypes = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"]),
	JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;

function detectResponseType(ue = "") {
	if (!ue) return "json";
	const Yi = ue.split(";").shift() || "";
	return JSON_RE.test(Yi) ? "json" : textTypes.has(Yi) || Yi.startsWith("text/") ? "text" : "blob"
}

function mergeFetchOptions(ue, Yi, ea = globalThis.Headers) {
	const ta = {
		...Yi,
		...ue
	};
	if (Yi != null && Yi.params && (ue != null && ue.params) && (ta.params = {
			...Yi == null ? void 0 : Yi.params,
			...ue == null ? void 0 : ue.params
		}), Yi != null && Yi.query && (ue != null && ue.query) && (ta.query = {
			...Yi == null ? void 0 : Yi.query,
			...ue == null ? void 0 : ue.query
		}), Yi != null && Yi.headers && (ue != null && ue.headers)) {
		ta.headers = new ea((Yi == null ? void 0 : Yi.headers) || {});
		for (const [na, ra] of new ea((ue == null ? void 0 : ue.headers) || {})) ta.headers.set(na, ra)
	}
	return ta
}
const retryStatusCodes = new Set([408, 409, 425, 429, 500, 502, 503, 504]),
	nullBodyResponses = new Set([101, 204, 205, 304]);

function createFetch(ue = {}) {
	const {
		fetch: Yi = globalThis.fetch,
		Headers: ea = globalThis.Headers,
		AbortController: ta = globalThis.AbortController
	} = ue;
	async function na(aa) {
		const oa = aa.error && aa.error.name === "AbortError" && !aa.options.timeout || !1;
		if (aa.options.retry !== !1 && !oa) {
			let sa;
			typeof aa.options.retry == "number" ? sa = aa.options.retry : sa = isPayloadMethod(aa.options.method) ? 0 : 1;
			const ca = aa.response && aa.response.status || 500;
			if (sa > 0 && (Array.isArray(aa.options.retryStatusCodes) ? aa.options.retryStatusCodes.includes(ca) : retryStatusCodes.has(ca))) {
				const ua = aa.options.retryDelay || 0;
				return ua > 0 && await new Promise(da => setTimeout(da, ua)), ra(aa.request, {
					...aa.options,
					retry: sa - 1
				})
			}
		}
		const la = createFetchError(aa);
		throw Error.captureStackTrace && Error.captureStackTrace(la, ra), la
	}
	const ra = async function(oa, la = {}) {
		var da;
		const sa = {
			request: oa,
			options: mergeFetchOptions(la, ue.defaults, ea),
			response: void 0,
			error: void 0
		};
		sa.options.method = (da = sa.options.method) == null ? void 0 : da.toUpperCase(), sa.options.onRequest && await sa.options.onRequest(sa), typeof sa.request == "string" && (sa.options.baseURL && (sa.request = withBase(sa.request, sa.options.baseURL)), (sa.options.query || sa.options.params) && (sa.request = withQuery(sa.request, {
			...sa.options.params,
			...sa.options.query
		}))), sa.options.body && isPayloadMethod(sa.options.method) && (isJSONSerializable(sa.options.body) ? (sa.options.body = typeof sa.options.body == "string" ? sa.options.body : JSON.stringify(sa.options.body), sa.options.headers = new ea(sa.options.headers || {}), sa.options.headers.has("content-type") || sa.options.headers.set("content-type", "application/json"), sa.options.headers.has("accept") || sa.options.headers.set("accept", "application/json")) : ("pipeTo" in sa.options.body && typeof sa.options.body.pipeTo == "function" || typeof sa.options.body.pipe == "function") && ("duplex" in sa.options || (sa.options.duplex = "half")));
		let ca;
		if (!sa.options.signal && sa.options.timeout) {
			const ha = new ta;
			ca = setTimeout(() => ha.abort(), sa.options.timeout), sa.options.signal = ha.signal
		}
		try {
			sa.response = await Yi(sa.request, sa.options)
		} catch (ha) {
			return sa.error = ha, sa.options.onRequestError && await sa.options.onRequestError(sa), await na(sa)
		} finally {
			ca && clearTimeout(ca)
		}
		if (sa.response.body && !nullBodyResponses.has(sa.response.status) && sa.options.method !== "HEAD") {
			const ha = (sa.options.parseResponse ? "json" : sa.options.responseType) || detectResponseType(sa.response.headers.get("content-type") || "");
			switch (ha) {
				case "json": {
					const pa = await sa.response.text(),
						va = sa.options.parseResponse || destr;
					sa.response._data = va(pa);
					break
				}
				case "stream": {
					sa.response._data = sa.response.body;
					break
				}
				default:
					sa.response._data = await sa.response[ha]()
			}
		}
		return sa.options.onResponse && await sa.options.onResponse(sa), !sa.options.ignoreResponseError && sa.response.status >= 400 && sa.response.status < 600 ? (sa.options.onResponseError && await sa.options.onResponseError(sa), await na(sa)) : sa.response
	}, ia = async function(oa, la) {
		return (await ra(oa, la))._data
	};
	return ia.raw = ra, ia.native = (...aa) => Yi(...aa), ia.create = (aa = {}) => createFetch({
		...ue,
		defaults: {
			...ue.defaults,
			...aa
		}
	}), ia
}
const _globalThis$2 = function() {
		if (typeof globalThis < "u") return globalThis;
		if (typeof self < "u") return self;
		if (typeof window < "u") return window;
		if (typeof global$1 < "u") return global$1;
		throw new Error("unable to locate global object")
	}(),
	fetch$1 = _globalThis$2.fetch || (() => Promise.reject(new Error("[ofetch] global.fetch is not supported!"))),
	Headers$1 = _globalThis$2.Headers,
	AbortController$1 = _globalThis$2.AbortController,
	ofetch = createFetch({
		fetch: fetch$1,
		Headers: Headers$1,
		AbortController: AbortController$1
	}),
	$fetch$1 = ofetch,
	useRuntimeConfig$1 = () => {
		var ue;
		return ((ue = window == null ? void 0 : window.__NUXT__) == null ? void 0 : ue.config) || {}
	},
	appConfig = useRuntimeConfig$1().app,
	baseURL = () => appConfig.baseURL,
	buildAssetsDir = () => appConfig.buildAssetsDir,
	buildAssetsURL = (...ue) => joinRelativeURL(publicAssetsURL(), buildAssetsDir(), ...ue),
	publicAssetsURL = (...ue) => {
		const Yi = appConfig.cdnURL || appConfig.baseURL;
		return ue.length ? joinRelativeURL(Yi, ...ue) : Yi
	};
globalThis.__buildAssetsURL = buildAssetsURL, globalThis.__publicAssetsURL = publicAssetsURL;
globalThis.$fetch || (globalThis.$fetch = $fetch$1.create({
	baseURL: baseURL()
}));

function flatHooks(ue, Yi = {}, ea) {
	for (const ta in ue) {
		const na = ue[ta],
			ra = ea ? `${ea}:${ta}` : ta;
		typeof na == "object" && na !== null ? flatHooks(na, Yi, ra) : typeof na == "function" && (Yi[ra] = na)
	}
	return Yi
}
const defaultTask = {
		run: ue => ue()
	},
	_createTask = () => defaultTask,
	createTask = typeof console.createTask < "u" ? console.createTask : _createTask;

function serialTaskCaller(ue, Yi) {
	const ea = Yi.shift(),
		ta = createTask(ea);
	return ue.reduce((na, ra) => na.then(() => ta.run(() => ra(...Yi))), Promise.resolve())
}

function parallelTaskCaller(ue, Yi) {
	const ea = Yi.shift(),
		ta = createTask(ea);
	return Promise.all(ue.map(na => ta.run(() => na(...Yi))))
}

function callEachWith(ue, Yi) {
	for (const ea of [...ue]) ea(Yi)
}
class Hookable {
	constructor() {
		this._hooks = {}, this._before = void 0, this._after = void 0, this._deprecatedMessages = void 0, this._deprecatedHooks = {}, this.hook = this.hook.bind(this), this.callHook = this.callHook.bind(this), this.callHookWith = this.callHookWith.bind(this)
	}
	hook(Yi, ea, ta = {}) {
		if (!Yi || typeof ea != "function") return () => {};
		const na = Yi;
		let ra;
		for (; this._deprecatedHooks[Yi];) ra = this._deprecatedHooks[Yi], Yi = ra.to;
		if (ra && !ta.allowDeprecated) {
			let ia = ra.message;
			ia || (ia = `${na} hook has been deprecated` + (ra.to ? `, please use ${ra.to}` : "")), this._deprecatedMessages || (this._deprecatedMessages = new Set), this._deprecatedMessages.has(ia) || (console.warn(ia), this._deprecatedMessages.add(ia))
		}
		if (!ea.name) try {
			Object.defineProperty(ea, "name", {
				get: () => "_" + Yi.replace(/\W+/g, "_") + "_hook_cb",
				configurable: !0
			})
		} catch {}
		return this._hooks[Yi] = this._hooks[Yi] || [], this._hooks[Yi].push(ea), () => {
			ea && (this.removeHook(Yi, ea), ea = void 0)
		}
	}
	hookOnce(Yi, ea) {
		let ta, na = (...ra) => (typeof ta == "function" && ta(), ta = void 0, na = void 0, ea(...ra));
		return ta = this.hook(Yi, na), ta
	}
	removeHook(Yi, ea) {
		if (this._hooks[Yi]) {
			const ta = this._hooks[Yi].indexOf(ea);
			ta !== -1 && this._hooks[Yi].splice(ta, 1), this._hooks[Yi].length === 0 && delete this._hooks[Yi]
		}
	}
	deprecateHook(Yi, ea) {
		this._deprecatedHooks[Yi] = typeof ea == "string" ? {
			to: ea
		} : ea;
		const ta = this._hooks[Yi] || [];
		delete this._hooks[Yi];
		for (const na of ta) this.hook(Yi, na)
	}
	deprecateHooks(Yi) {
		Object.assign(this._deprecatedHooks, Yi);
		for (const ea in Yi) this.deprecateHook(ea, Yi[ea])
	}
	addHooks(Yi) {
		const ea = flatHooks(Yi),
			ta = Object.keys(ea).map(na => this.hook(na, ea[na]));
		return () => {
			for (const na of ta.splice(0, ta.length)) na()
		}
	}
	removeHooks(Yi) {
		const ea = flatHooks(Yi);
		for (const ta in ea) this.removeHook(ta, ea[ta])
	}
	removeAllHooks() {
		for (const Yi in this._hooks) delete this._hooks[Yi]
	}
	callHook(Yi, ...ea) {
		return ea.unshift(Yi), this.callHookWith(serialTaskCaller, Yi, ...ea)
	}
	callHookParallel(Yi, ...ea) {
		return ea.unshift(Yi), this.callHookWith(parallelTaskCaller, Yi, ...ea)
	}
	callHookWith(Yi, ea, ...ta) {
		const na = this._before || this._after ? {
			name: ea,
			args: ta,
			context: {}
		} : void 0;
		this._before && callEachWith(this._before, na);
		const ra = Yi(ea in this._hooks ? [...this._hooks[ea]] : [], ta);
		return ra instanceof Promise ? ra.finally(() => {
			this._after && na && callEachWith(this._after, na)
		}) : (this._after && na && callEachWith(this._after, na), ra)
	}
	beforeEach(Yi) {
		return this._before = this._before || [], this._before.push(Yi), () => {
			if (this._before !== void 0) {
				const ea = this._before.indexOf(Yi);
				ea !== -1 && this._before.splice(ea, 1)
			}
		}
	}
	afterEach(Yi) {
		return this._after = this._after || [], this._after.push(Yi), () => {
			if (this._after !== void 0) {
				const ea = this._after.indexOf(Yi);
				ea !== -1 && this._after.splice(ea, 1)
			}
		}
	}
}

function createHooks() {
	return new Hookable
}

function createContext(ue = {}) {
	let Yi, ea = !1;
	const ta = ia => {
		if (Yi && Yi !== ia) throw new Error("Context conflict")
	};
	let na;
	if (ue.asyncContext) {
		const ia = ue.AsyncLocalStorage || globalThis.AsyncLocalStorage;
		ia ? na = new ia : console.warn("[unctx] `AsyncLocalStorage` is not provided.")
	}
	const ra = () => {
		if (na && Yi === void 0) {
			const ia = na.getStore();
			if (ia !== void 0) return ia
		}
		return Yi
	};
	return {
		use: () => {
			const ia = ra();
			if (ia === void 0) throw new Error("Context is not available");
			return ia
		},
		tryUse: () => ra(),
		set: (ia, aa) => {
			aa || ta(ia), Yi = ia, ea = !0
		},
		unset: () => {
			Yi = void 0, ea = !1
		},
		call: (ia, aa) => {
			ta(ia), Yi = ia;
			try {
				return na ? na.run(ia, aa) : aa()
			} finally {
				ea || (Yi = void 0)
			}
		},
		async callAsync(ia, aa) {
			Yi = ia;
			const oa = () => {
					Yi = ia
				},
				la = () => Yi === ia ? oa : void 0;
			asyncHandlers.add(la);
			try {
				const sa = na ? na.run(ia, aa) : aa();
				return ea || (Yi = void 0), await sa
			} finally {
				asyncHandlers.delete(la)
			}
		}
	}
}

function createNamespace(ue = {}) {
	const Yi = {};
	return {
		get(ea, ta = {}) {
			return Yi[ea] || (Yi[ea] = createContext({
				...ue,
				...ta
			})), Yi[ea], Yi[ea]
		}
	}
}
const _globalThis$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof global$1 < "u" ? global$1 : typeof window < "u" ? window : {},
	globalKey$1 = "__unctx__",
	defaultNamespace = _globalThis$1[globalKey$1] || (_globalThis$1[globalKey$1] = createNamespace()),
	getContext = (ue, Yi = {}) => defaultNamespace.get(ue, Yi),
	asyncHandlersKey = "__unctx_async_handlers__",
	asyncHandlers = _globalThis$1[asyncHandlersKey] || (_globalThis$1[asyncHandlersKey] = new Set);

function executeAsync(ue) {
	const Yi = [];
	for (const na of asyncHandlers) {
		const ra = na();
		ra && Yi.push(ra)
	}
	const ea = () => {
		for (const na of Yi) na()
	};
	let ta = ue();
	return ta && typeof ta == "object" && "catch" in ta && (ta = ta.catch(na => {
		throw ea(), na
	})), [ta, ea]
}
const appPageTransition = !1,
	appKeepalive = !1,
	nuxtLinkDefaults = {
		componentName: "NuxtLink",
		prefetch: !0,
		prefetchOn: {
			visibility: !0
		}
	},
	nuxtDefaultErrorValue = null,
	vueAppRootContainer = "#__blum",
	appId = "nuxt-app",
	outdatedBuildInterval = 36e5,
	chunkErrorEvent = "vite:preloadError";

function getNuxtAppCtx(ue = appId) {
	return getContext(ue, {
		asyncContext: !1
	})
}
const NuxtPluginIndicator = "__nuxt_plugin";

function createNuxtApp(ue) {
	var na;
	let Yi = 0;
	const ea = {
		_id: ue.id || appId || "nuxt-app",
		_scope: effectScope(),
		provide: void 0,
		globalName: "nuxt",
		versions: {
			get nuxt() {
				return "3.13.2"
			},
			get vue() {
				return ea.vueApp.version
			}
		},
		payload: shallowReactive({
			...((na = ue.ssrContext) == null ? void 0 : na.payload) || {},
			data: shallowReactive({}),
			state: reactive({}),
			once: new Set,
			_errors: shallowReactive({})
		}),
		static: {
			data: {}
		},
		runWithContext(ra) {
			return ea._scope.active && !getCurrentScope$1() ? ea._scope.run(() => callWithNuxt(ea, ra)) : callWithNuxt(ea, ra)
		},
		isHydrating: !0,
		deferHydration() {
			if (!ea.isHydrating) return () => {};
			Yi++;
			let ra = !1;
			return () => {
				if (!ra && (ra = !0, Yi--, Yi === 0)) return ea.isHydrating = !1, ea.callHook("app:suspense:resolve")
			}
		},
		_asyncDataPromises: {},
		_asyncData: shallowReactive({}),
		_payloadRevivers: {},
		...ue
	};
	{
		const ra = window.__NUXT__;
		if (ra)
			for (const ia in ra) switch (ia) {
				case "data":
				case "state":
				case "_errors":
					Object.assign(ea.payload[ia], ra[ia]);
					break;
				default:
					ea.payload[ia] = ra[ia]
			}
	}
	ea.hooks = createHooks(), ea.hook = ea.hooks.hook, ea.callHook = ea.hooks.callHook, ea.provide = (ra, ia) => {
		const aa = "$" + ra;
		defineGetter$1(ea, aa, ia), defineGetter$1(ea.vueApp.config.globalProperties, aa, ia)
	}, defineGetter$1(ea.vueApp, "$nuxt", ea), defineGetter$1(ea.vueApp.config.globalProperties, "$nuxt", ea);
	{
		window.addEventListener(chunkErrorEvent, ia => {
			ea.callHook("app:chunkError", {
				error: ia.payload
			}), (ea.isHydrating || ia.payload.message.includes("Unable to preload CSS")) && ia.preventDefault()
		}), window.useNuxtApp = window.useNuxtApp || useNuxtApp;
		const ra = ea.hook("app:error", (...ia) => {
			console.error("[nuxt] error caught during app initialization", ...ia)
		});
		ea.hook("app:mounted", ra)
	}
	const ta = ea.payload.config;
	return ea.provide("config", ta), ea
}

function registerPluginHooks(ue, Yi) {
	Yi.hooks && ue.hooks.addHooks(Yi.hooks)
}
async function applyPlugin(ue, Yi) {
	if (typeof Yi == "function") {
		const {
			provide: ea
		} = await ue.runWithContext(() => Yi(ue)) || {};
		if (ea && typeof ea == "object")
			for (const ta in ea) ue.provide(ta, ea[ta])
	}
}
async function applyPlugins(ue, Yi) {
	const ea = [],
		ta = [],
		na = [],
		ra = [];
	let ia = 0;
	async function aa(oa) {
		var sa;
		const la = ((sa = oa.dependsOn) == null ? void 0 : sa.filter(ca => Yi.some(ua => ua._name === ca) && !ea.includes(ca))) ?? [];
		if (la.length > 0) ta.push([new Set(la), oa]);
		else {
			const ca = applyPlugin(ue, oa).then(async () => {
				oa._name && (ea.push(oa._name), await Promise.all(ta.map(async ([ua, da]) => {
					ua.has(oa._name) && (ua.delete(oa._name), ua.size === 0 && (ia++, await aa(da)))
				})))
			});
			oa.parallel ? na.push(ca.catch(ua => ra.push(ua))) : await ca
		}
	}
	for (const oa of Yi) registerPluginHooks(ue, oa);
	for (const oa of Yi) await aa(oa);
	if (await Promise.all(na), ia)
		for (let oa = 0; oa < ia; oa++) await Promise.all(na);
	if (ra.length) throw ra[0]
}

function defineNuxtPlugin(ue) {
	if (typeof ue == "function") return ue;
	const Yi = ue._name || ue.name;
	return delete ue.name, Object.assign(ue.setup || (() => {}), ue, {
		[NuxtPluginIndicator]: !0,
		_name: Yi
	})
}

function callWithNuxt(ue, Yi, ea) {
	const ta = () => Yi();
	return getNuxtAppCtx(ue._id).set(ue), ue.vueApp.runWithContext(ta)
}

function tryUseNuxtApp(ue) {
	var ea;
	let Yi;
	return hasInjectionContext() && (Yi = (ea = getCurrentInstance()) == null ? void 0 : ea.appContext.app.$nuxt), Yi = Yi || getNuxtAppCtx(ue).tryUse(), Yi || null
}

function useNuxtApp(ue) {
	const Yi = tryUseNuxtApp(ue);
	if (!Yi) throw new Error("[nuxt] instance unavailable");
	return Yi
}

function useRuntimeConfig(ue) {
	return useNuxtApp().$config
}

function defineGetter$1(ue, Yi, ea) {
	Object.defineProperty(ue, Yi, {
		get: () => ea
	})
}
var buffer$1 = {},
	base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup$1 = [],
	revLookup = [],
	Arr = typeof Uint8Array < "u" ? Uint8Array : Array,
	code$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$3 = 0, len = code$3.length; i$3 < len; ++i$3) lookup$1[i$3] = code$3[i$3], revLookup[code$3.charCodeAt(i$3)] = i$3;
revLookup[45] = 62;
revLookup[95] = 63;

function getLens(ue) {
	var Yi = ue.length;
	if (Yi % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
	var ea = ue.indexOf("=");
	ea === -1 && (ea = Yi);
	var ta = ea === Yi ? 0 : 4 - ea % 4;
	return [ea, ta]
}

function byteLength(ue) {
	var Yi = getLens(ue),
		ea = Yi[0],
		ta = Yi[1];
	return (ea + ta) * 3 / 4 - ta
}

function _byteLength(ue, Yi, ea) {
	return (Yi + ea) * 3 / 4 - ea
}

function toByteArray(ue) {
	var Yi, ea = getLens(ue),
		ta = ea[0],
		na = ea[1],
		ra = new Arr(_byteLength(ue, ta, na)),
		ia = 0,
		aa = na > 0 ? ta - 4 : ta,
		oa;
	for (oa = 0; oa < aa; oa += 4) Yi = revLookup[ue.charCodeAt(oa)] << 18 | revLookup[ue.charCodeAt(oa + 1)] << 12 | revLookup[ue.charCodeAt(oa + 2)] << 6 | revLookup[ue.charCodeAt(oa + 3)], ra[ia++] = Yi >> 16 & 255, ra[ia++] = Yi >> 8 & 255, ra[ia++] = Yi & 255;
	return na === 2 && (Yi = revLookup[ue.charCodeAt(oa)] << 2 | revLookup[ue.charCodeAt(oa + 1)] >> 4, ra[ia++] = Yi & 255), na === 1 && (Yi = revLookup[ue.charCodeAt(oa)] << 10 | revLookup[ue.charCodeAt(oa + 1)] << 4 | revLookup[ue.charCodeAt(oa + 2)] >> 2, ra[ia++] = Yi >> 8 & 255, ra[ia++] = Yi & 255), ra
}

function tripletToBase64(ue) {
	return lookup$1[ue >> 18 & 63] + lookup$1[ue >> 12 & 63] + lookup$1[ue >> 6 & 63] + lookup$1[ue & 63]
}

function encodeChunk(ue, Yi, ea) {
	for (var ta, na = [], ra = Yi; ra < ea; ra += 3) ta = (ue[ra] << 16 & 16711680) + (ue[ra + 1] << 8 & 65280) + (ue[ra + 2] & 255), na.push(tripletToBase64(ta));
	return na.join("")
}

function fromByteArray(ue) {
	for (var Yi, ea = ue.length, ta = ea % 3, na = [], ra = 16383, ia = 0, aa = ea - ta; ia < aa; ia += ra) na.push(encodeChunk(ue, ia, ia + ra > aa ? aa : ia + ra));
	return ta === 1 ? (Yi = ue[ea - 1], na.push(lookup$1[Yi >> 2] + lookup$1[Yi << 4 & 63] + "==")) : ta === 2 && (Yi = (ue[ea - 2] << 8) + ue[ea - 1], na.push(lookup$1[Yi >> 10] + lookup$1[Yi >> 4 & 63] + lookup$1[Yi << 2 & 63] + "=")), na.join("")
}
var ieee754 = {}; /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(ue, Yi, ea, ta, na) {
	var ra, ia, aa = na * 8 - ta - 1,
		oa = (1 << aa) - 1,
		la = oa >> 1,
		sa = -7,
		ca = ea ? na - 1 : 0,
		ua = ea ? -1 : 1,
		da = ue[Yi + ca];
	for (ca += ua, ra = da & (1 << -sa) - 1, da >>= -sa, sa += aa; sa > 0; ra = ra * 256 + ue[Yi + ca], ca += ua, sa -= 8);
	for (ia = ra & (1 << -sa) - 1, ra >>= -sa, sa += ta; sa > 0; ia = ia * 256 + ue[Yi + ca], ca += ua, sa -= 8);
	if (ra === 0) ra = 1 - la;
	else {
		if (ra === oa) return ia ? NaN : (da ? -1 : 1) * (1 / 0);
		ia = ia + Math.pow(2, ta), ra = ra - la
	}
	return (da ? -1 : 1) * ia * Math.pow(2, ra - ta)
};
ieee754.write = function(ue, Yi, ea, ta, na, ra) {
	var ia, aa, oa, la = ra * 8 - na - 1,
		sa = (1 << la) - 1,
		ca = sa >> 1,
		ua = na === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
		da = ta ? 0 : ra - 1,
		ha = ta ? 1 : -1,
		pa = Yi < 0 || Yi === 0 && 1 / Yi < 0 ? 1 : 0;
	for (Yi = Math.abs(Yi), isNaN(Yi) || Yi === 1 / 0 ? (aa = isNaN(Yi) ? 1 : 0, ia = sa) : (ia = Math.floor(Math.log(Yi) / Math.LN2), Yi * (oa = Math.pow(2, -ia)) < 1 && (ia--, oa *= 2), ia + ca >= 1 ? Yi += ua / oa : Yi += ua * Math.pow(2, 1 - ca), Yi * oa >= 2 && (ia++, oa /= 2), ia + ca >= sa ? (aa = 0, ia = sa) : ia + ca >= 1 ? (aa = (Yi * oa - 1) * Math.pow(2, na), ia = ia + ca) : (aa = Yi * Math.pow(2, ca - 1) * Math.pow(2, na), ia = 0)); na >= 8; ue[ea + da] = aa & 255, da += ha, aa /= 256, na -= 8);
	for (ia = ia << na | aa, la += na; la > 0; ue[ea + da] = ia & 255, da += ha, ia /= 256, la -= 8);
	ue[ea + da - ha] |= pa * 128
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(ue) {
	const Yi = base64Js,
		ea = ieee754,
		ta = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
	ue.Buffer = sa, ue.SlowBuffer = ka, ue.INSPECT_MAX_BYTES = 50;
	const na = 2147483647;
	ue.kMaxLength = na;
	const {
		Uint8Array: ra,
		ArrayBuffer: ia,
		SharedArrayBuffer: aa
	} = globalThis;
	sa.TYPED_ARRAY_SUPPORT = oa(), !sa.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");

	function oa() {
		try {
			const eo = new ra(1),
				Oa = {
					foo: function() {
						return 42
					}
				};
			return Object.setPrototypeOf(Oa, ra.prototype), Object.setPrototypeOf(eo, Oa), eo.foo() === 42
		} catch {
			return !1
		}
	}
	Object.defineProperty(sa.prototype, "parent", {
		enumerable: !0,
		get: function() {
			if (sa.isBuffer(this)) return this.buffer
		}
	}), Object.defineProperty(sa.prototype, "offset", {
		enumerable: !0,
		get: function() {
			if (sa.isBuffer(this)) return this.byteOffset
		}
	});

	function la(eo) {
		if (eo > na) throw new RangeError('The value "' + eo + '" is invalid for option "size"');
		const Oa = new ra(eo);
		return Object.setPrototypeOf(Oa, sa.prototype), Oa
	}

	function sa(eo, Oa, Da) {
		if (typeof eo == "number") {
			if (typeof Oa == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
			return ha(eo)
		}
		return ca(eo, Oa, Da)
	}
	sa.poolSize = 8192;

	function ca(eo, Oa, Da) {
		if (typeof eo == "string") return pa(eo, Oa);
		if (ia.isView(eo)) return ba(eo);
		if (eo == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof eo);
		if (Ao(eo, ia) || eo && Ao(eo.buffer, ia) || typeof aa < "u" && (Ao(eo, aa) || eo && Ao(eo.buffer, aa))) return Ea(eo, Oa, Da);
		if (typeof eo == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
		const Qa = eo.valueOf && eo.valueOf();
		if (Qa != null && Qa !== eo) return sa.from(Qa, Oa, Da);
		const uo = Sa(eo);
		if (uo) return uo;
		if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof eo[Symbol.toPrimitive] == "function") return sa.from(eo[Symbol.toPrimitive]("string"), Oa, Da);
		throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof eo)
	}
	sa.from = function(eo, Oa, Da) {
		return ca(eo, Oa, Da)
	}, Object.setPrototypeOf(sa.prototype, ra.prototype), Object.setPrototypeOf(sa, ra);

	function ua(eo) {
		if (typeof eo != "number") throw new TypeError('"size" argument must be of type number');
		if (eo < 0) throw new RangeError('The value "' + eo + '" is invalid for option "size"')
	}

	function da(eo, Oa, Da) {
		return ua(eo), eo <= 0 ? la(eo) : Oa !== void 0 ? typeof Da == "string" ? la(eo).fill(Oa, Da) : la(eo).fill(Oa) : la(eo)
	}
	sa.alloc = function(eo, Oa, Da) {
		return da(eo, Oa, Da)
	};

	function ha(eo) {
		return ua(eo), la(eo < 0 ? 0 : Ca(eo) | 0)
	}
	sa.allocUnsafe = function(eo) {
		return ha(eo)
	}, sa.allocUnsafeSlow = function(eo) {
		return ha(eo)
	};

	function pa(eo, Oa) {
		if ((typeof Oa != "string" || Oa === "") && (Oa = "utf8"), !sa.isEncoding(Oa)) throw new TypeError("Unknown encoding: " + Oa);
		const Da = Pa(eo, Oa) | 0;
		let Qa = la(Da);
		const uo = Qa.write(eo, Oa);
		return uo !== Da && (Qa = Qa.slice(0, uo)), Qa
	}

	function va(eo) {
		const Oa = eo.length < 0 ? 0 : Ca(eo.length) | 0,
			Da = la(Oa);
		for (let Qa = 0; Qa < Oa; Qa += 1) Da[Qa] = eo[Qa] & 255;
		return Da
	}

	function ba(eo) {
		if (Ao(eo, ra)) {
			const Oa = new ra(eo);
			return Ea(Oa.buffer, Oa.byteOffset, Oa.byteLength)
		}
		return va(eo)
	}

	function Ea(eo, Oa, Da) {
		if (Oa < 0 || eo.byteLength < Oa) throw new RangeError('"offset" is outside of buffer bounds');
		if (eo.byteLength < Oa + (Da || 0)) throw new RangeError('"length" is outside of buffer bounds');
		let Qa;
		return Oa === void 0 && Da === void 0 ? Qa = new ra(eo) : Da === void 0 ? Qa = new ra(eo, Oa) : Qa = new ra(eo, Oa, Da), Object.setPrototypeOf(Qa, sa.prototype), Qa
	}

	function Sa(eo) {
		if (sa.isBuffer(eo)) {
			const Oa = Ca(eo.length) | 0,
				Da = la(Oa);
			return Da.length === 0 || eo.copy(Da, 0, 0, Oa), Da
		}
		if (eo.length !== void 0) return typeof eo.length != "number" || _o(eo.length) ? la(0) : va(eo);
		if (eo.type === "Buffer" && Array.isArray(eo.data)) return va(eo.data)
	}

	function Ca(eo) {
		if (eo >= na) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + na.toString(16) + " bytes");
		return eo | 0
	}

	function ka(eo) {
		return +eo != eo && (eo = 0), sa.alloc(+eo)
	}
	sa.isBuffer = function(Oa) {
		return Oa != null && Oa._isBuffer === !0 && Oa !== sa.prototype
	}, sa.compare = function(Oa, Da) {
		if (Ao(Oa, ra) && (Oa = sa.from(Oa, Oa.offset, Oa.byteLength)), Ao(Da, ra) && (Da = sa.from(Da, Da.offset, Da.byteLength)), !sa.isBuffer(Oa) || !sa.isBuffer(Da)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
		if (Oa === Da) return 0;
		let Qa = Oa.length,
			uo = Da.length;
		for (let bo = 0, So = Math.min(Qa, uo); bo < So; ++bo)
			if (Oa[bo] !== Da[bo]) {
				Qa = Oa[bo], uo = Da[bo];
				break
			} return Qa < uo ? -1 : uo < Qa ? 1 : 0
	}, sa.isEncoding = function(Oa) {
		switch (String(Oa).toLowerCase()) {
			case "hex":
			case "utf8":
			case "utf-8":
			case "ascii":
			case "latin1":
			case "binary":
			case "base64":
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le":
				return !0;
			default:
				return !1
		}
	}, sa.concat = function(Oa, Da) {
		if (!Array.isArray(Oa)) throw new TypeError('"list" argument must be an Array of Buffers');
		if (Oa.length === 0) return sa.alloc(0);
		let Qa;
		if (Da === void 0)
			for (Da = 0, Qa = 0; Qa < Oa.length; ++Qa) Da += Oa[Qa].length;
		const uo = sa.allocUnsafe(Da);
		let bo = 0;
		for (Qa = 0; Qa < Oa.length; ++Qa) {
			let So = Oa[Qa];
			if (Ao(So, ra)) bo + So.length > uo.length ? (sa.isBuffer(So) || (So = sa.from(So)), So.copy(uo, bo)) : ra.prototype.set.call(uo, So, bo);
			else if (sa.isBuffer(So)) So.copy(uo, bo);
			else throw new TypeError('"list" argument must be an Array of Buffers');
			bo += So.length
		}
		return uo
	};

	function Pa(eo, Oa) {
		if (sa.isBuffer(eo)) return eo.length;
		if (ia.isView(eo) || Ao(eo, ia)) return eo.byteLength;
		if (typeof eo != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof eo);
		const Da = eo.length,
			Qa = arguments.length > 2 && arguments[2] === !0;
		if (!Qa && Da === 0) return 0;
		let uo = !1;
		for (;;) switch (Oa) {
			case "ascii":
			case "latin1":
			case "binary":
				return Da;
			case "utf8":
			case "utf-8":
				return Xa(eo).length;
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le":
				return Da * 2;
			case "hex":
				return Da >>> 1;
			case "base64":
				return Eo(eo).length;
			default:
				if (uo) return Qa ? -1 : Xa(eo).length;
				Oa = ("" + Oa).toLowerCase(), uo = !0
		}
	}
	sa.byteLength = Pa;

	function ja(eo, Oa, Da) {
		let Qa = !1;
		if ((Oa === void 0 || Oa < 0) && (Oa = 0), Oa > this.length || ((Da === void 0 || Da > this.length) && (Da = this.length), Da <= 0) || (Da >>>= 0, Oa >>>= 0, Da <= Oa)) return "";
		for (eo || (eo = "utf8");;) switch (eo) {
			case "hex":
				return ya(this, Oa, Da);
			case "utf8":
			case "utf-8":
				return Ma(this, Oa, Da);
			case "ascii":
				return Ta(this, Oa, Da);
			case "latin1":
			case "binary":
				return La(this, Oa, Da);
			case "base64":
				return wa(this, Oa, Da);
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le":
				return Ba(this, Oa, Da);
			default:
				if (Qa) throw new TypeError("Unknown encoding: " + eo);
				eo = (eo + "").toLowerCase(), Qa = !0
		}
	}
	sa.prototype._isBuffer = !0;

	function Za(eo, Oa, Da) {
		const Qa = eo[Oa];
		eo[Oa] = eo[Da], eo[Da] = Qa
	}
	sa.prototype.swap16 = function() {
		const Oa = this.length;
		if (Oa % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
		for (let Da = 0; Da < Oa; Da += 2) Za(this, Da, Da + 1);
		return this
	}, sa.prototype.swap32 = function() {
		const Oa = this.length;
		if (Oa % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
		for (let Da = 0; Da < Oa; Da += 4) Za(this, Da, Da + 3), Za(this, Da + 1, Da + 2);
		return this
	}, sa.prototype.swap64 = function() {
		const Oa = this.length;
		if (Oa % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
		for (let Da = 0; Da < Oa; Da += 8) Za(this, Da, Da + 7), Za(this, Da + 1, Da + 6), Za(this, Da + 2, Da + 5), Za(this, Da + 3, Da + 4);
		return this
	}, sa.prototype.toString = function() {
		const Oa = this.length;
		return Oa === 0 ? "" : arguments.length === 0 ? Ma(this, 0, Oa) : ja.apply(this, arguments)
	}, sa.prototype.toLocaleString = sa.prototype.toString, sa.prototype.equals = function(Oa) {
		if (!sa.isBuffer(Oa)) throw new TypeError("Argument must be a Buffer");
		return this === Oa ? !0 : sa.compare(this, Oa) === 0
	}, sa.prototype.inspect = function() {
		let Oa = "";
		const Da = ue.INSPECT_MAX_BYTES;
		return Oa = this.toString("hex", 0, Da).replace(/(.{2})/g, "$1 ").trim(), this.length > Da && (Oa += " ... "), "<Buffer " + Oa + ">"
	}, ta && (sa.prototype[ta] = sa.prototype.inspect), sa.prototype.compare = function(Oa, Da, Qa, uo, bo) {
		if (Ao(Oa, ra) && (Oa = sa.from(Oa, Oa.offset, Oa.byteLength)), !sa.isBuffer(Oa)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Oa);
		if (Da === void 0 && (Da = 0), Qa === void 0 && (Qa = Oa ? Oa.length : 0), uo === void 0 && (uo = 0), bo === void 0 && (bo = this.length), Da < 0 || Qa > Oa.length || uo < 0 || bo > this.length) throw new RangeError("out of range index");
		if (uo >= bo && Da >= Qa) return 0;
		if (uo >= bo) return -1;
		if (Da >= Qa) return 1;
		if (Da >>>= 0, Qa >>>= 0, uo >>>= 0, bo >>>= 0, this === Oa) return 0;
		let So = bo - uo,
			Wo = Qa - Da;
		const Po = Math.min(So, Wo),
			Ro = this.slice(uo, bo),
			Ho = Oa.slice(Da, Qa);
		for (let Oo = 0; Oo < Po; ++Oo)
			if (Ro[Oo] !== Ho[Oo]) {
				So = Ro[Oo], Wo = Ho[Oo];
				break
			} return So < Wo ? -1 : Wo < So ? 1 : 0
	};

	function Ga(eo, Oa, Da, Qa, uo) {
		if (eo.length === 0) return -1;
		if (typeof Da == "string" ? (Qa = Da, Da = 0) : Da > 2147483647 ? Da = 2147483647 : Da < -2147483648 && (Da = -2147483648), Da = +Da, _o(Da) && (Da = uo ? 0 : eo.length - 1), Da < 0 && (Da = eo.length + Da), Da >= eo.length) {
			if (uo) return -1;
			Da = eo.length - 1
		} else if (Da < 0)
			if (uo) Da = 0;
			else return -1;
		if (typeof Oa == "string" && (Oa = sa.from(Oa, Qa)), sa.isBuffer(Oa)) return Oa.length === 0 ? -1 : Ja(eo, Oa, Da, Qa, uo);
		if (typeof Oa == "number") return Oa = Oa & 255, typeof ra.prototype.indexOf == "function" ? uo ? ra.prototype.indexOf.call(eo, Oa, Da) : ra.prototype.lastIndexOf.call(eo, Oa, Da) : Ja(eo, [Oa], Da, Qa, uo);
		throw new TypeError("val must be string, number or Buffer")
	}

	function Ja(eo, Oa, Da, Qa, uo) {
		let bo = 1,
			So = eo.length,
			Wo = Oa.length;
		if (Qa !== void 0 && (Qa = String(Qa).toLowerCase(), Qa === "ucs2" || Qa === "ucs-2" || Qa === "utf16le" || Qa === "utf-16le")) {
			if (eo.length < 2 || Oa.length < 2) return -1;
			bo = 2, So /= 2, Wo /= 2, Da /= 2
		}

		function Po(Ho, Oo) {
			return bo === 1 ? Ho[Oo] : Ho.readUInt16BE(Oo * bo)
		}
		let Ro;
		if (uo) {
			let Ho = -1;
			for (Ro = Da; Ro < So; Ro++)
				if (Po(eo, Ro) === Po(Oa, Ho === -1 ? 0 : Ro - Ho)) {
					if (Ho === -1 && (Ho = Ro), Ro - Ho + 1 === Wo) return Ho * bo
				} else Ho !== -1 && (Ro -= Ro - Ho), Ho = -1
		} else
			for (Da + Wo > So && (Da = So - Wo), Ro = Da; Ro >= 0; Ro--) {
				let Ho = !0;
				for (let Oo = 0; Oo < Wo; Oo++)
					if (Po(eo, Ro + Oo) !== Po(Oa, Oo)) {
						Ho = !1;
						break
					} if (Ho) return Ro
			}
		return -1
	}
	sa.prototype.includes = function(Oa, Da, Qa) {
		return this.indexOf(Oa, Da, Qa) !== -1
	}, sa.prototype.indexOf = function(Oa, Da, Qa) {
		return Ga(this, Oa, Da, Qa, !0)
	}, sa.prototype.lastIndexOf = function(Oa, Da, Qa) {
		return Ga(this, Oa, Da, Qa, !1)
	};

	function Ua(eo, Oa, Da, Qa) {
		Da = Number(Da) || 0;
		const uo = eo.length - Da;
		Qa ? (Qa = Number(Qa), Qa > uo && (Qa = uo)) : Qa = uo;
		const bo = Oa.length;
		Qa > bo / 2 && (Qa = bo / 2);
		let So;
		for (So = 0; So < Qa; ++So) {
			const Wo = parseInt(Oa.substr(So * 2, 2), 16);
			if (_o(Wo)) return So;
			eo[Da + So] = Wo
		}
		return So
	}

	function xa(eo, Oa, Da, Qa) {
		return wo(Xa(Oa, eo.length - Da), eo, Da, Qa)
	}

	function ma(eo, Oa, Da, Qa) {
		return wo(to(Oa), eo, Da, Qa)
	}

	function fa(eo, Oa, Da, Qa) {
		return wo(Eo(Oa), eo, Da, Qa)
	}

	function ga(eo, Oa, Da, Qa) {
		return wo(ho(Oa, eo.length - Da), eo, Da, Qa)
	}
	sa.prototype.write = function(Oa, Da, Qa, uo) {
		if (Da === void 0) uo = "utf8", Qa = this.length, Da = 0;
		else if (Qa === void 0 && typeof Da == "string") uo = Da, Qa = this.length, Da = 0;
		else if (isFinite(Da)) Da = Da >>> 0, isFinite(Qa) ? (Qa = Qa >>> 0, uo === void 0 && (uo = "utf8")) : (uo = Qa, Qa = void 0);
		else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
		const bo = this.length - Da;
		if ((Qa === void 0 || Qa > bo) && (Qa = bo), Oa.length > 0 && (Qa < 0 || Da < 0) || Da > this.length) throw new RangeError("Attempt to write outside buffer bounds");
		uo || (uo = "utf8");
		let So = !1;
		for (;;) switch (uo) {
			case "hex":
				return Ua(this, Oa, Da, Qa);
			case "utf8":
			case "utf-8":
				return xa(this, Oa, Da, Qa);
			case "ascii":
			case "latin1":
			case "binary":
				return ma(this, Oa, Da, Qa);
			case "base64":
				return fa(this, Oa, Da, Qa);
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le":
				return ga(this, Oa, Da, Qa);
			default:
				if (So) throw new TypeError("Unknown encoding: " + uo);
				uo = ("" + uo).toLowerCase(), So = !0
		}
	}, sa.prototype.toJSON = function() {
		return {
			type: "Buffer",
			data: Array.prototype.slice.call(this._arr || this, 0)
		}
	};

	function wa(eo, Oa, Da) {
		return Oa === 0 && Da === eo.length ? Yi.fromByteArray(eo) : Yi.fromByteArray(eo.slice(Oa, Da))
	}

	function Ma(eo, Oa, Da) {
		Da = Math.min(eo.length, Da);
		const Qa = [];
		let uo = Oa;
		for (; uo < Da;) {
			const bo = eo[uo];
			let So = null,
				Wo = bo > 239 ? 4 : bo > 223 ? 3 : bo > 191 ? 2 : 1;
			if (uo + Wo <= Da) {
				let Po, Ro, Ho, Oo;
				switch (Wo) {
					case 1:
						bo < 128 && (So = bo);
						break;
					case 2:
						Po = eo[uo + 1], (Po & 192) === 128 && (Oo = (bo & 31) << 6 | Po & 63, Oo > 127 && (So = Oo));
						break;
					case 3:
						Po = eo[uo + 1], Ro = eo[uo + 2], (Po & 192) === 128 && (Ro & 192) === 128 && (Oo = (bo & 15) << 12 | (Po & 63) << 6 | Ro & 63, Oo > 2047 && (Oo < 55296 || Oo > 57343) && (So = Oo));
						break;
					case 4:
						Po = eo[uo + 1], Ro = eo[uo + 2], Ho = eo[uo + 3], (Po & 192) === 128 && (Ro & 192) === 128 && (Ho & 192) === 128 && (Oo = (bo & 15) << 18 | (Po & 63) << 12 | (Ro & 63) << 6 | Ho & 63, Oo > 65535 && Oo < 1114112 && (So = Oo))
				}
			}
			So === null ? (So = 65533, Wo = 1) : So > 65535 && (So -= 65536, Qa.push(So >>> 10 & 1023 | 55296), So = 56320 | So & 1023), Qa.push(So), uo += Wo
		}
		return Ra(Qa)
	}
	const Aa = 4096;

	function Ra(eo) {
		const Oa = eo.length;
		if (Oa <= Aa) return String.fromCharCode.apply(String, eo);
		let Da = "",
			Qa = 0;
		for (; Qa < Oa;) Da += String.fromCharCode.apply(String, eo.slice(Qa, Qa += Aa));
		return Da
	}

	function Ta(eo, Oa, Da) {
		let Qa = "";
		Da = Math.min(eo.length, Da);
		for (let uo = Oa; uo < Da; ++uo) Qa += String.fromCharCode(eo[uo] & 127);
		return Qa
	}

	function La(eo, Oa, Da) {
		let Qa = "";
		Da = Math.min(eo.length, Da);
		for (let uo = Oa; uo < Da; ++uo) Qa += String.fromCharCode(eo[uo]);
		return Qa
	}

	function ya(eo, Oa, Da) {
		const Qa = eo.length;
		(!Oa || Oa < 0) && (Oa = 0), (!Da || Da < 0 || Da > Qa) && (Da = Qa);
		let uo = "";
		for (let bo = Oa; bo < Da; ++bo) uo += Lo[eo[bo]];
		return uo
	}

	function Ba(eo, Oa, Da) {
		const Qa = eo.slice(Oa, Da);
		let uo = "";
		for (let bo = 0; bo < Qa.length - 1; bo += 2) uo += String.fromCharCode(Qa[bo] + Qa[bo + 1] * 256);
		return uo
	}
	sa.prototype.slice = function(Oa, Da) {
		const Qa = this.length;
		Oa = ~~Oa, Da = Da === void 0 ? Qa : ~~Da, Oa < 0 ? (Oa += Qa, Oa < 0 && (Oa = 0)) : Oa > Qa && (Oa = Qa), Da < 0 ? (Da += Qa, Da < 0 && (Da = 0)) : Da > Qa && (Da = Qa), Da < Oa && (Da = Oa);
		const uo = this.subarray(Oa, Da);
		return Object.setPrototypeOf(uo, sa.prototype), uo
	};

	function io(eo, Oa, Da) {
		if (eo % 1 !== 0 || eo < 0) throw new RangeError("offset is not uint");
		if (eo + Oa > Da) throw new RangeError("Trying to access beyond buffer length")
	}
	sa.prototype.readUintLE = sa.prototype.readUIntLE = function(Oa, Da, Qa) {
		Oa = Oa >>> 0, Da = Da >>> 0, Qa || io(Oa, Da, this.length);
		let uo = this[Oa],
			bo = 1,
			So = 0;
		for (; ++So < Da && (bo *= 256);) uo += this[Oa + So] * bo;
		return uo
	}, sa.prototype.readUintBE = sa.prototype.readUIntBE = function(Oa, Da, Qa) {
		Oa = Oa >>> 0, Da = Da >>> 0, Qa || io(Oa, Da, this.length);
		let uo = this[Oa + --Da],
			bo = 1;
		for (; Da > 0 && (bo *= 256);) uo += this[Oa + --Da] * bo;
		return uo
	}, sa.prototype.readUint8 = sa.prototype.readUInt8 = function(Oa, Da) {
		return Oa = Oa >>> 0, Da || io(Oa, 1, this.length), this[Oa]
	}, sa.prototype.readUint16LE = sa.prototype.readUInt16LE = function(Oa, Da) {
		return Oa = Oa >>> 0, Da || io(Oa, 2, this.length), this[Oa] | this[Oa + 1] << 8
	}, sa.prototype.readUint16BE = sa.prototype.readUInt16BE = function(Oa, Da) {
		return Oa = Oa >>> 0, Da || io(Oa, 2, this.length), this[Oa] << 8 | this[Oa + 1]
	}, sa.prototype.readUint32LE = sa.prototype.readUInt32LE = function(Oa, Da) {
		return Oa = Oa >>> 0, Da || io(Oa, 4, this.length), (this[Oa] | this[Oa + 1] << 8 | this[Oa + 2] << 16) + this[Oa + 3] * 16777216
	}, sa.prototype.readUint32BE = sa.prototype.readUInt32BE = function(Oa, Da) {
		return Oa = Oa >>> 0, Da || io(Oa, 4, this.length), this[Oa] * 16777216 + (this[Oa + 1] << 16 | this[Oa + 2] << 8 | this[Oa + 3])
	}, sa.prototype.readBigUInt64LE = Fo(function(Oa) {
		Oa = Oa >>> 0, yo(Oa, "offset");
		const Da = this[Oa],
			Qa = this[Oa + 7];
		(Da === void 0 || Qa === void 0) && fo(Oa, this.length - 8);
		const uo = Da + this[++Oa] * 2 ** 8 + this[++Oa] * 2 ** 16 + this[++Oa] * 2 ** 24,
			bo = this[++Oa] + this[++Oa] * 2 ** 8 + this[++Oa] * 2 ** 16 + Qa * 2 ** 24;
		return BigInt(uo) + (BigInt(bo) << BigInt(32))
	}), sa.prototype.readBigUInt64BE = Fo(function(Oa) {
		Oa = Oa >>> 0, yo(Oa, "offset");
		const Da = this[Oa],
			Qa = this[Oa + 7];
		(Da === void 0 || Qa === void 0) && fo(Oa, this.length - 8);
		const uo = Da * 2 ** 24 + this[++Oa] * 2 ** 16 + this[++Oa] * 2 ** 8 + this[++Oa],
			bo = this[++Oa] * 2 ** 24 + this[++Oa] * 2 ** 16 + this[++Oa] * 2 ** 8 + Qa;
		return (BigInt(uo) << BigInt(32)) + BigInt(bo)
	}), sa.prototype.readIntLE = function(Oa, Da, Qa) {
		Oa = Oa >>> 0, Da = Da >>> 0, Qa || io(Oa, Da, this.length);
		let uo = this[Oa],
			bo = 1,
			So = 0;
		for (; ++So < Da && (bo *= 256);) uo += this[Oa + So] * bo;
		return bo *= 128, uo >= bo && (uo -= Math.pow(2, 8 * Da)), uo
	}, sa.prototype.readIntBE = function(Oa, Da, Qa) {
		Oa = Oa >>> 0, Da = Da >>> 0, Qa || io(Oa, Da, this.length);
		let uo = Da,
			bo = 1,
			So = this[Oa + --uo];
		for (; uo > 0 && (bo *= 256);) So += this[Oa + --uo] * bo;
		return bo *= 128, So >= bo && (So -= Math.pow(2, 8 * Da)), So
	}, sa.prototype.readInt8 = function(Oa, Da) {
		return Oa = Oa >>> 0, Da || io(Oa, 1, this.length), this[Oa] & 128 ? (255 - this[Oa] + 1) * -1 : this[Oa]
	}, sa.prototype.readInt16LE = function(Oa, Da) {
		Oa = Oa >>> 0, Da || io(Oa, 2, this.length);
		const Qa = this[Oa] | this[Oa + 1] << 8;
		return Qa & 32768 ? Qa | 4294901760 : Qa
	}, sa.prototype.readInt16BE = function(Oa, Da) {
		Oa = Oa >>> 0, Da || io(Oa, 2, this.length);
		const Qa = this[Oa + 1] | this[Oa] << 8;
		return Qa & 32768 ? Qa | 4294901760 : Qa
	}, sa.prototype.readInt32LE = function(Oa, Da) {
		return Oa = Oa >>> 0, Da || io(Oa, 4, this.length), this[Oa] | this[Oa + 1] << 8 | this[Oa + 2] << 16 | this[Oa + 3] << 24
	}, sa.prototype.readInt32BE = function(Oa, Da) {
		return Oa = Oa >>> 0, Da || io(Oa, 4, this.length), this[Oa] << 24 | this[Oa + 1] << 16 | this[Oa + 2] << 8 | this[Oa + 3]
	}, sa.prototype.readBigInt64LE = Fo(function(Oa) {
		Oa = Oa >>> 0, yo(Oa, "offset");
		const Da = this[Oa],
			Qa = this[Oa + 7];
		(Da === void 0 || Qa === void 0) && fo(Oa, this.length - 8);
		const uo = this[Oa + 4] + this[Oa + 5] * 2 ** 8 + this[Oa + 6] * 2 ** 16 + (Qa << 24);
		return (BigInt(uo) << BigInt(32)) + BigInt(Da + this[++Oa] * 2 ** 8 + this[++Oa] * 2 ** 16 + this[++Oa] * 2 ** 24)
	}), sa.prototype.readBigInt64BE = Fo(function(Oa) {
		Oa = Oa >>> 0, yo(Oa, "offset");
		const Da = this[Oa],
			Qa = this[Oa + 7];
		(Da === void 0 || Qa === void 0) && fo(Oa, this.length - 8);
		const uo = (Da << 24) + this[++Oa] * 2 ** 16 + this[++Oa] * 2 ** 8 + this[++Oa];
		return (BigInt(uo) << BigInt(32)) + BigInt(this[++Oa] * 2 ** 24 + this[++Oa] * 2 ** 16 + this[++Oa] * 2 ** 8 + Qa)
	}), sa.prototype.readFloatLE = function(Oa, Da) {
		return Oa = Oa >>> 0, Da || io(Oa, 4, this.length), ea.read(this, Oa, !0, 23, 4)
	}, sa.prototype.readFloatBE = function(Oa, Da) {
		return Oa = Oa >>> 0, Da || io(Oa, 4, this.length), ea.read(this, Oa, !1, 23, 4)
	}, sa.prototype.readDoubleLE = function(Oa, Da) {
		return Oa = Oa >>> 0, Da || io(Oa, 8, this.length), ea.read(this, Oa, !0, 52, 8)
	}, sa.prototype.readDoubleBE = function(Oa, Da) {
		return Oa = Oa >>> 0, Da || io(Oa, 8, this.length), ea.read(this, Oa, !1, 52, 8)
	};

	function oo(eo, Oa, Da, Qa, uo, bo) {
		if (!sa.isBuffer(eo)) throw new TypeError('"buffer" argument must be a Buffer instance');
		if (Oa > uo || Oa < bo) throw new RangeError('"value" argument is out of bounds');
		if (Da + Qa > eo.length) throw new RangeError("Index out of range")
	}
	sa.prototype.writeUintLE = sa.prototype.writeUIntLE = function(Oa, Da, Qa, uo) {
		if (Oa = +Oa, Da = Da >>> 0, Qa = Qa >>> 0, !uo) {
			const Wo = Math.pow(2, 8 * Qa) - 1;
			oo(this, Oa, Da, Qa, Wo, 0)
		}
		let bo = 1,
			So = 0;
		for (this[Da] = Oa & 255; ++So < Qa && (bo *= 256);) this[Da + So] = Oa / bo & 255;
		return Da + Qa
	}, sa.prototype.writeUintBE = sa.prototype.writeUIntBE = function(Oa, Da, Qa, uo) {
		if (Oa = +Oa, Da = Da >>> 0, Qa = Qa >>> 0, !uo) {
			const Wo = Math.pow(2, 8 * Qa) - 1;
			oo(this, Oa, Da, Qa, Wo, 0)
		}
		let bo = Qa - 1,
			So = 1;
		for (this[Da + bo] = Oa & 255; --bo >= 0 && (So *= 256);) this[Da + bo] = Oa / So & 255;
		return Da + Qa
	}, sa.prototype.writeUint8 = sa.prototype.writeUInt8 = function(Oa, Da, Qa) {
		return Oa = +Oa, Da = Da >>> 0, Qa || oo(this, Oa, Da, 1, 255, 0), this[Da] = Oa & 255, Da + 1
	}, sa.prototype.writeUint16LE = sa.prototype.writeUInt16LE = function(Oa, Da, Qa) {
		return Oa = +Oa, Da = Da >>> 0, Qa || oo(this, Oa, Da, 2, 65535, 0), this[Da] = Oa & 255, this[Da + 1] = Oa >>> 8, Da + 2
	}, sa.prototype.writeUint16BE = sa.prototype.writeUInt16BE = function(Oa, Da, Qa) {
		return Oa = +Oa, Da = Da >>> 0, Qa || oo(this, Oa, Da, 2, 65535, 0), this[Da] = Oa >>> 8, this[Da + 1] = Oa & 255, Da + 2
	}, sa.prototype.writeUint32LE = sa.prototype.writeUInt32LE = function(Oa, Da, Qa) {
		return Oa = +Oa, Da = Da >>> 0, Qa || oo(this, Oa, Da, 4, 4294967295, 0), this[Da + 3] = Oa >>> 24, this[Da + 2] = Oa >>> 16, this[Da + 1] = Oa >>> 8, this[Da] = Oa & 255, Da + 4
	}, sa.prototype.writeUint32BE = sa.prototype.writeUInt32BE = function(Oa, Da, Qa) {
		return Oa = +Oa, Da = Da >>> 0, Qa || oo(this, Oa, Da, 4, 4294967295, 0), this[Da] = Oa >>> 24, this[Da + 1] = Oa >>> 16, this[Da + 2] = Oa >>> 8, this[Da + 3] = Oa & 255, Da + 4
	};

	function ao(eo, Oa, Da, Qa, uo) {
		lo(Oa, Qa, uo, eo, Da, 7);
		let bo = Number(Oa & BigInt(4294967295));
		eo[Da++] = bo, bo = bo >> 8, eo[Da++] = bo, bo = bo >> 8, eo[Da++] = bo, bo = bo >> 8, eo[Da++] = bo;
		let So = Number(Oa >> BigInt(32) & BigInt(4294967295));
		return eo[Da++] = So, So = So >> 8, eo[Da++] = So, So = So >> 8, eo[Da++] = So, So = So >> 8, eo[Da++] = So, Da
	}

	function Ia(eo, Oa, Da, Qa, uo) {
		lo(Oa, Qa, uo, eo, Da, 7);
		let bo = Number(Oa & BigInt(4294967295));
		eo[Da + 7] = bo, bo = bo >> 8, eo[Da + 6] = bo, bo = bo >> 8, eo[Da + 5] = bo, bo = bo >> 8, eo[Da + 4] = bo;
		let So = Number(Oa >> BigInt(32) & BigInt(4294967295));
		return eo[Da + 3] = So, So = So >> 8, eo[Da + 2] = So, So = So >> 8, eo[Da + 1] = So, So = So >> 8, eo[Da] = So, Da + 8
	}
	sa.prototype.writeBigUInt64LE = Fo(function(Oa, Da = 0) {
		return ao(this, Oa, Da, BigInt(0), BigInt("0xffffffffffffffff"))
	}), sa.prototype.writeBigUInt64BE = Fo(function(Oa, Da = 0) {
		return Ia(this, Oa, Da, BigInt(0), BigInt("0xffffffffffffffff"))
	}), sa.prototype.writeIntLE = function(Oa, Da, Qa, uo) {
		if (Oa = +Oa, Da = Da >>> 0, !uo) {
			const Po = Math.pow(2, 8 * Qa - 1);
			oo(this, Oa, Da, Qa, Po - 1, -Po)
		}
		let bo = 0,
			So = 1,
			Wo = 0;
		for (this[Da] = Oa & 255; ++bo < Qa && (So *= 256);) Oa < 0 && Wo === 0 && this[Da + bo - 1] !== 0 && (Wo = 1), this[Da + bo] = (Oa / So >> 0) - Wo & 255;
		return Da + Qa
	}, sa.prototype.writeIntBE = function(Oa, Da, Qa, uo) {
		if (Oa = +Oa, Da = Da >>> 0, !uo) {
			const Po = Math.pow(2, 8 * Qa - 1);
			oo(this, Oa, Da, Qa, Po - 1, -Po)
		}
		let bo = Qa - 1,
			So = 1,
			Wo = 0;
		for (this[Da + bo] = Oa & 255; --bo >= 0 && (So *= 256);) Oa < 0 && Wo === 0 && this[Da + bo + 1] !== 0 && (Wo = 1), this[Da + bo] = (Oa / So >> 0) - Wo & 255;
		return Da + Qa
	}, sa.prototype.writeInt8 = function(Oa, Da, Qa) {
		return Oa = +Oa, Da = Da >>> 0, Qa || oo(this, Oa, Da, 1, 127, -128), Oa < 0 && (Oa = 255 + Oa + 1), this[Da] = Oa & 255, Da + 1
	}, sa.prototype.writeInt16LE = function(Oa, Da, Qa) {
		return Oa = +Oa, Da = Da >>> 0, Qa || oo(this, Oa, Da, 2, 32767, -32768), this[Da] = Oa & 255, this[Da + 1] = Oa >>> 8, Da + 2
	}, sa.prototype.writeInt16BE = function(Oa, Da, Qa) {
		return Oa = +Oa, Da = Da >>> 0, Qa || oo(this, Oa, Da, 2, 32767, -32768), this[Da] = Oa >>> 8, this[Da + 1] = Oa & 255, Da + 2
	}, sa.prototype.writeInt32LE = function(Oa, Da, Qa) {
		return Oa = +Oa, Da = Da >>> 0, Qa || oo(this, Oa, Da, 4, 2147483647, -2147483648), this[Da] = Oa & 255, this[Da + 1] = Oa >>> 8, this[Da + 2] = Oa >>> 16, this[Da + 3] = Oa >>> 24, Da + 4
	}, sa.prototype.writeInt32BE = function(Oa, Da, Qa) {
		return Oa = +Oa, Da = Da >>> 0, Qa || oo(this, Oa, Da, 4, 2147483647, -2147483648), Oa < 0 && (Oa = 4294967295 + Oa + 1), this[Da] = Oa >>> 24, this[Da + 1] = Oa >>> 16, this[Da + 2] = Oa >>> 8, this[Da + 3] = Oa & 255, Da + 4
	}, sa.prototype.writeBigInt64LE = Fo(function(Oa, Da = 0) {
		return ao(this, Oa, Da, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
	}), sa.prototype.writeBigInt64BE = Fo(function(Oa, Da = 0) {
		return Ia(this, Oa, Da, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
	});

	function Na(eo, Oa, Da, Qa, uo, bo) {
		if (Da + Qa > eo.length) throw new RangeError("Index out of range");
		if (Da < 0) throw new RangeError("Index out of range")
	}

	function za(eo, Oa, Da, Qa, uo) {
		return Oa = +Oa, Da = Da >>> 0, uo || Na(eo, Oa, Da, 4), ea.write(eo, Oa, Da, Qa, 23, 4), Da + 4
	}
	sa.prototype.writeFloatLE = function(Oa, Da, Qa) {
		return za(this, Oa, Da, !0, Qa)
	}, sa.prototype.writeFloatBE = function(Oa, Da, Qa) {
		return za(this, Oa, Da, !1, Qa)
	};

	function ro(eo, Oa, Da, Qa, uo) {
		return Oa = +Oa, Da = Da >>> 0, uo || Na(eo, Oa, Da, 8), ea.write(eo, Oa, Da, Qa, 52, 8), Da + 8
	}
	sa.prototype.writeDoubleLE = function(Oa, Da, Qa) {
		return ro(this, Oa, Da, !0, Qa)
	}, sa.prototype.writeDoubleBE = function(Oa, Da, Qa) {
		return ro(this, Oa, Da, !1, Qa)
	}, sa.prototype.copy = function(Oa, Da, Qa, uo) {
		if (!sa.isBuffer(Oa)) throw new TypeError("argument should be a Buffer");
		if (Qa || (Qa = 0), !uo && uo !== 0 && (uo = this.length), Da >= Oa.length && (Da = Oa.length), Da || (Da = 0), uo > 0 && uo < Qa && (uo = Qa), uo === Qa || Oa.length === 0 || this.length === 0) return 0;
		if (Da < 0) throw new RangeError("targetStart out of bounds");
		if (Qa < 0 || Qa >= this.length) throw new RangeError("Index out of range");
		if (uo < 0) throw new RangeError("sourceEnd out of bounds");
		uo > this.length && (uo = this.length), Oa.length - Da < uo - Qa && (uo = Oa.length - Da + Qa);
		const bo = uo - Qa;
		return this === Oa && typeof ra.prototype.copyWithin == "function" ? this.copyWithin(Da, Qa, uo) : ra.prototype.set.call(Oa, this.subarray(Qa, uo), Da), bo
	}, sa.prototype.fill = function(Oa, Da, Qa, uo) {
		if (typeof Oa == "string") {
			if (typeof Da == "string" ? (uo = Da, Da = 0, Qa = this.length) : typeof Qa == "string" && (uo = Qa, Qa = this.length), uo !== void 0 && typeof uo != "string") throw new TypeError("encoding must be a string");
			if (typeof uo == "string" && !sa.isEncoding(uo)) throw new TypeError("Unknown encoding: " + uo);
			if (Oa.length === 1) {
				const So = Oa.charCodeAt(0);
				(uo === "utf8" && So < 128 || uo === "latin1") && (Oa = So)
			}
		} else typeof Oa == "number" ? Oa = Oa & 255 : typeof Oa == "boolean" && (Oa = Number(Oa));
		if (Da < 0 || this.length < Da || this.length < Qa) throw new RangeError("Out of range index");
		if (Qa <= Da) return this;
		Da = Da >>> 0, Qa = Qa === void 0 ? this.length : Qa >>> 0, Oa || (Oa = 0);
		let bo;
		if (typeof Oa == "number")
			for (bo = Da; bo < Qa; ++bo) this[bo] = Oa;
		else {
			const So = sa.isBuffer(Oa) ? Oa : sa.from(Oa, uo),
				Wo = So.length;
			if (Wo === 0) throw new TypeError('The value "' + Oa + '" is invalid for argument "value"');
			for (bo = 0; bo < Qa - Da; ++bo) this[bo + Da] = So[bo % Wo]
		}
		return this
	};
	const Va = {};

	function Wa(eo, Oa, Da) {
		Va[eo] = class extends Da {
			constructor() {
				super(), Object.defineProperty(this, "message", {
					value: Oa.apply(this, arguments),
					writable: !0,
					configurable: !0
				}), this.name = `${this.name} [${eo}]`, this.stack, delete this.name
			}
			get code() {
				return eo
			}
			set code(uo) {
				Object.defineProperty(this, "code", {
					configurable: !0,
					enumerable: !0,
					value: uo,
					writable: !0
				})
			}
			toString() {
				return `${this.name} [${eo}]: ${this.message}`
			}
		}
	}
	Wa("ERR_BUFFER_OUT_OF_BOUNDS", function(eo) {
		return eo ? `${eo} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
	}, RangeError), Wa("ERR_INVALID_ARG_TYPE", function(eo, Oa) {
		return `The "${eo}" argument must be of type number. Received type ${typeof Oa}`
	}, TypeError), Wa("ERR_OUT_OF_RANGE", function(eo, Oa, Da) {
		let Qa = `The value of "${eo}" is out of range.`,
			uo = Da;
		return Number.isInteger(Da) && Math.abs(Da) > 2 ** 32 ? uo = qa(String(Da)) : typeof Da == "bigint" && (uo = String(Da), (Da > BigInt(2) ** BigInt(32) || Da < -(BigInt(2) ** BigInt(32))) && (uo = qa(uo)), uo += "n"), Qa += ` It must be ${Oa}. Received ${uo}`, Qa
	}, RangeError);

	function qa(eo) {
		let Oa = "",
			Da = eo.length;
		const Qa = eo[0] === "-" ? 1 : 0;
		for (; Da >= Qa + 4; Da -= 3) Oa = `_${eo.slice(Da-3,Da)}${Oa}`;
		return `${eo.slice(0,Da)}${Oa}`
	}

	function Ka(eo, Oa, Da) {
		yo(Oa, "offset"), (eo[Oa] === void 0 || eo[Oa + Da] === void 0) && fo(Oa, eo.length - (Da + 1))
	}

	function lo(eo, Oa, Da, Qa, uo, bo) {
		if (eo > Da || eo < Oa) {
			const So = typeof Oa == "bigint" ? "n" : "";
			let Wo;
			throw Oa === 0 || Oa === BigInt(0) ? Wo = `>= 0${So} and < 2${So} ** ${(bo+1)*8}${So}` : Wo = `>= -(2${So} ** ${(bo+1)*8-1}${So}) and < 2 ** ${(bo+1)*8-1}${So}`, new Va.ERR_OUT_OF_RANGE("value", Wo, eo)
		}
		Ka(Qa, uo, bo)
	}

	function yo(eo, Oa) {
		if (typeof eo != "number") throw new Va.ERR_INVALID_ARG_TYPE(Oa, "number", eo)
	}

	function fo(eo, Oa, Da) {
		throw Math.floor(eo) !== eo ? (yo(eo, Da), new Va.ERR_OUT_OF_RANGE("offset", "an integer", eo)) : Oa < 0 ? new Va.ERR_BUFFER_OUT_OF_BOUNDS : new Va.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${Oa}`, eo)
	}
	const vo = /[^+/0-9A-Za-z-_]/g;

	function so(eo) {
		if (eo = eo.split("=")[0], eo = eo.trim().replace(vo, ""), eo.length < 2) return "";
		for (; eo.length % 4 !== 0;) eo = eo + "=";
		return eo
	}

	function Xa(eo, Oa) {
		Oa = Oa || 1 / 0;
		let Da;
		const Qa = eo.length;
		let uo = null;
		const bo = [];
		for (let So = 0; So < Qa; ++So) {
			if (Da = eo.charCodeAt(So), Da > 55295 && Da < 57344) {
				if (!uo) {
					if (Da > 56319) {
						(Oa -= 3) > -1 && bo.push(239, 191, 189);
						continue
					} else if (So + 1 === Qa) {
						(Oa -= 3) > -1 && bo.push(239, 191, 189);
						continue
					}
					uo = Da;
					continue
				}
				if (Da < 56320) {
					(Oa -= 3) > -1 && bo.push(239, 191, 189), uo = Da;
					continue
				}
				Da = (uo - 55296 << 10 | Da - 56320) + 65536
			} else uo && (Oa -= 3) > -1 && bo.push(239, 191, 189);
			if (uo = null, Da < 128) {
				if ((Oa -= 1) < 0) break;
				bo.push(Da)
			} else if (Da < 2048) {
				if ((Oa -= 2) < 0) break;
				bo.push(Da >> 6 | 192, Da & 63 | 128)
			} else if (Da < 65536) {
				if ((Oa -= 3) < 0) break;
				bo.push(Da >> 12 | 224, Da >> 6 & 63 | 128, Da & 63 | 128)
			} else if (Da < 1114112) {
				if ((Oa -= 4) < 0) break;
				bo.push(Da >> 18 | 240, Da >> 12 & 63 | 128, Da >> 6 & 63 | 128, Da & 63 | 128)
			} else throw new Error("Invalid code point")
		}
		return bo
	}

	function to(eo) {
		const Oa = [];
		for (let Da = 0; Da < eo.length; ++Da) Oa.push(eo.charCodeAt(Da) & 255);
		return Oa
	}

	function ho(eo, Oa) {
		let Da, Qa, uo;
		const bo = [];
		for (let So = 0; So < eo.length && !((Oa -= 2) < 0); ++So) Da = eo.charCodeAt(So), Qa = Da >> 8, uo = Da % 256, bo.push(uo), bo.push(Qa);
		return bo
	}

	function Eo(eo) {
		return Yi.toByteArray(so(eo))
	}

	function wo(eo, Oa, Da, Qa) {
		let uo;
		for (uo = 0; uo < Qa && !(uo + Da >= Oa.length || uo >= eo.length); ++uo) Oa[uo + Da] = eo[uo];
		return uo
	}

	function Ao(eo, Oa) {
		return eo instanceof Oa || eo != null && eo.constructor != null && eo.constructor.name != null && eo.constructor.name === Oa.name
	}

	function _o(eo) {
		return eo !== eo
	}
	const Lo = function() {
		const eo = "0123456789abcdef",
			Oa = new Array(256);
		for (let Da = 0; Da < 16; ++Da) {
			const Qa = Da * 16;
			for (let uo = 0; uo < 16; ++uo) Oa[Qa + uo] = eo[Da] + eo[uo]
		}
		return Oa
	}();

	function Fo(eo) {
		return typeof BigInt > "u" ? jo : eo
	}

	function jo() {
		throw new Error("BigInt not supported")
	}
})(buffer$1);
const Buffer = buffer$1.Buffer,
	Blob$2 = buffer$1.Blob,
	BlobOptions = buffer$1.BlobOptions,
	Buffer$1 = buffer$1.Buffer,
	File$1 = buffer$1.File,
	FileOptions = buffer$1.FileOptions,
	INSPECT_MAX_BYTES = buffer$1.INSPECT_MAX_BYTES,
	SlowBuffer = buffer$1.SlowBuffer,
	TranscodeEncoding = buffer$1.TranscodeEncoding,
	atob$1 = buffer$1.atob,
	btoa$1 = buffer$1.btoa,
	constants$1 = buffer$1.constants,
	isAscii = buffer$1.isAscii,
	isUtf8 = buffer$1.isUtf8,
	kMaxLength = buffer$1.kMaxLength,
	kStringMaxLength = buffer$1.kStringMaxLength,
	resolveObjectURL = buffer$1.resolveObjectURL,
	transcode = buffer$1.transcode,
	dist$2 = Object.freeze(Object.defineProperty({
		__proto__: null,
		Blob: Blob$2,
		BlobOptions,
		Buffer: Buffer$1,
		File: File$1,
		FileOptions,
		INSPECT_MAX_BYTES,
		SlowBuffer,
		TranscodeEncoding,
		atob: atob$1,
		btoa: btoa$1,
		constants: constants$1,
		default: Buffer,
		isAscii,
		isUtf8,
		kMaxLength,
		kStringMaxLength,
		resolveObjectURL,
		transcode
	}, Symbol.toStringTag, {
		value: "Module"
	}));

function _createMatcher(ue, Yi) {
	return {
		ctx: {
			table: ue
		},
		matchAll: ea => _matchRoutes(ea, ue)
	}
}

function _createTableFromExport(ue) {
	const Yi = {};
	for (const ea in ue) Yi[ea] = ea === "dynamic" ? new Map(Object.entries(ue[ea]).map(([ta, na]) => [ta, _createTableFromExport(na)])) : new Map(Object.entries(ue[ea]));
	return Yi
}

function createMatcherFromExport(ue) {
	return _createMatcher(_createTableFromExport(ue))
}

function _matchRoutes(ue, Yi, ea) {
	ue.endsWith("/") && (ue = ue.slice(0, -1) || "/");
	const ta = [];
	for (const [ra, ia] of _sortRoutesMap(Yi.wildcard))(ue === ra || ue.startsWith(ra + "/")) && ta.push(ia);
	for (const [ra, ia] of _sortRoutesMap(Yi.dynamic))
		if (ue.startsWith(ra + "/")) {
			const aa = "/" + ue.slice(ra.length).split("/").splice(2).join("/");
			ta.push(..._matchRoutes(aa, ia))
		} const na = Yi.static.get(ue);
	return na && ta.push(na), ta.filter(Boolean)
}

function _sortRoutesMap(ue) {
	return [...ue.entries()].sort((Yi, ea) => Yi[0].length - ea[0].length)
}

function isPlainObject$3(ue) {
	if (ue === null || typeof ue != "object") return !1;
	const Yi = Object.getPrototypeOf(ue);
	return Yi !== null && Yi !== Object.prototype && Object.getPrototypeOf(Yi) !== null || Symbol.iterator in ue ? !1 : Symbol.toStringTag in ue ? Object.prototype.toString.call(ue) === "[object Module]" : !0
}

function _defu(ue, Yi, ea = ".", ta) {
	if (!isPlainObject$3(Yi)) return _defu(ue, {}, ea, ta);
	const na = Object.assign({}, Yi);
	for (const ra in ue) {
		if (ra === "__proto__" || ra === "constructor") continue;
		const ia = ue[ra];
		ia != null && (ta && ta(na, ra, ia, ea) || (Array.isArray(ia) && Array.isArray(na[ra]) ? na[ra] = [...ia, ...na[ra]] : isPlainObject$3(ia) && isPlainObject$3(na[ra]) ? na[ra] = _defu(ia, na[ra], (ea ? `${ea}.` : "") + ra.toString(), ta) : na[ra] = ia))
	}
	return na
}

function createDefu(ue) {
	return (...Yi) => Yi.reduce((ea, ta) => _defu(ea, ta, "", ue), {})
}
const defu = createDefu();

function hasProp$1(ue, Yi) {
	try {
		return Yi in ue
	} catch {
		return !1
	}
}
var __defProp$2$1 = Object.defineProperty,
	__defNormalProp$2 = (ue, Yi, ea) => Yi in ue ? __defProp$2$1(ue, Yi, {
		enumerable: !0,
		configurable: !0,
		writable: !0,
		value: ea
	}) : ue[Yi] = ea,
	__publicField$2 = (ue, Yi, ea) => (__defNormalProp$2(ue, typeof Yi != "symbol" ? Yi + "" : Yi, ea), ea);
class H3Error extends Error {
	constructor(Yi, ea = {}) {
		super(Yi, ea), __publicField$2(this, "statusCode", 500), __publicField$2(this, "fatal", !1), __publicField$2(this, "unhandled", !1), __publicField$2(this, "statusMessage"), __publicField$2(this, "data"), __publicField$2(this, "cause"), ea.cause && !this.cause && (this.cause = ea.cause)
	}
	toJSON() {
		const Yi = {
			message: this.message,
			statusCode: sanitizeStatusCode(this.statusCode, 500)
		};
		return this.statusMessage && (Yi.statusMessage = sanitizeStatusMessage(this.statusMessage)), this.data !== void 0 && (Yi.data = this.data), Yi
	}
}
__publicField$2(H3Error, "__h3_error__", !0);

function createError$1(ue) {
	if (typeof ue == "string") return new H3Error(ue);
	if (isError$1(ue)) return ue;
	const Yi = new H3Error(ue.message ?? ue.statusMessage ?? "", {
		cause: ue.cause || ue
	});
	if (hasProp$1(ue, "stack")) try {
		Object.defineProperty(Yi, "stack", {
			get() {
				return ue.stack
			}
		})
	} catch {
		try {
			Yi.stack = ue.stack
		} catch {}
	}
	if (ue.data && (Yi.data = ue.data), ue.statusCode ? Yi.statusCode = sanitizeStatusCode(ue.statusCode, Yi.statusCode) : ue.status && (Yi.statusCode = sanitizeStatusCode(ue.status, Yi.statusCode)), ue.statusMessage ? Yi.statusMessage = ue.statusMessage : ue.statusText && (Yi.statusMessage = ue.statusText), Yi.statusMessage) {
		const ea = Yi.statusMessage;
		sanitizeStatusMessage(Yi.statusMessage) !== ea && console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.")
	}
	return ue.fatal !== void 0 && (Yi.fatal = ue.fatal), ue.unhandled !== void 0 && (Yi.unhandled = ue.unhandled), Yi
}

function isError$1(ue) {
	var Yi;
	return ((Yi = ue == null ? void 0 : ue.constructor) == null ? void 0 : Yi.__h3_error__) === !0
}
const DISALLOWED_STATUS_CHARS = /[^\u0009\u0020-\u007E]/g;

function sanitizeStatusMessage(ue = "") {
	return ue.replace(DISALLOWED_STATUS_CHARS, "")
}

function sanitizeStatusCode(ue, Yi = 200) {
	return !ue || (typeof ue == "string" && (ue = Number.parseInt(ue, 10)), ue < 100 || ue > 999) ? Yi : ue
}
typeof setImmediate > "u" || setImmediate;
const LayoutMetaSymbol = Symbol("layout-meta"),
	PageRouteSymbol = Symbol("route"),
	useRouter = () => {
		var ue;
		return (ue = useNuxtApp()) == null ? void 0 : ue.$router
	},
	useRoute = () => hasInjectionContext() ? inject(PageRouteSymbol, useNuxtApp()._route) : useNuxtApp()._route;

function defineNuxtRouteMiddleware(ue) {
	return ue
}
const addRouteMiddleware = (ue, Yi, ea = {}) => {
		const ta = useNuxtApp(),
			na = ea.global || typeof ue != "string",
			ra = Yi;
		if (!ra) {
			console.warn("[nuxt] No route middleware passed to `addRouteMiddleware`.", ue);
			return
		}
		na ? ta._middleware.global.push(ra) : ta._middleware.named[ue] = ra
	},
	isProcessingMiddleware = () => {
		try {
			if (useNuxtApp()._processingMiddleware) return !0
		} catch {
			return !1
		}
		return !1
	},
	navigateTo = (ue, Yi) => {
		ue || (ue = "/");
		const ea = typeof ue == "string" ? ue : "path" in ue ? resolveRouteObject(ue) : useRouter().resolve(ue).href;
		if (Yi != null && Yi.open) {
			const {
				target: oa = "_blank",
				windowFeatures: la = {}
			} = Yi.open, sa = Object.entries(la).filter(([ca, ua]) => ua !== void 0).map(([ca, ua]) => `${ca.toLowerCase()}=${ua}`).join(", ");
			return open(ea, oa, sa), Promise.resolve()
		}
		const ta = hasProtocol(ea, {
				acceptRelative: !0
			}),
			na = (Yi == null ? void 0 : Yi.external) || ta;
		if (na) {
			if (!(Yi != null && Yi.external)) throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.");
			const {
				protocol: oa
			} = new URL(ea, window.location.href);
			if (oa && isScriptProtocol(oa)) throw new Error(`Cannot navigate to a URL with '${oa}' protocol.`)
		}
		const ra = isProcessingMiddleware();
		if (!na && ra) return ue;
		const ia = useRouter(),
			aa = useNuxtApp();
		return na ? (aa._scope.stop(), Yi != null && Yi.replace ? location.replace(ea) : location.href = ea, ra ? aa.isHydrating ? new Promise(() => {}) : !1 : Promise.resolve()) : Yi != null && Yi.replace ? ia.replace(ue) : ia.push(ue)
	};

function resolveRouteObject(ue) {
	return withQuery(ue.path || "", ue.query || {}) + (ue.hash || "")
}
const NUXT_ERROR_SIGNATURE = "__nuxt_error",
	useError = () => toRef(useNuxtApp().payload, "error"),
	showError = ue => {
		const Yi = createError(ue);
		try {
			const ea = useNuxtApp(),
				ta = useError();
			ea.hooks.callHook("app:error", Yi), ta.value = ta.value || Yi
		} catch {
			throw Yi
		}
		return Yi
	},
	clearError = async (ue = {}) => {
		const Yi = useNuxtApp(),
			ea = useError();
		Yi.callHook("app:error:cleared", ue), ue.redirect && await useRouter().replace(ue.redirect), ea.value = nuxtDefaultErrorValue
	}, isNuxtError = ue => !!ue && typeof ue == "object" && NUXT_ERROR_SIGNATURE in ue, createError = ue => {
		const Yi = createError$1(ue);
		return Object.defineProperty(Yi, NUXT_ERROR_SIGNATURE, {
			value: !0,
			configurable: !1,
			writable: !1
		}), Yi
	};

function decode64(ue) {
	const Yi = asciiToBinary(ue),
		ea = new ArrayBuffer(Yi.length),
		ta = new DataView(ea);
	for (let na = 0; na < ea.byteLength; na++) ta.setUint8(na, Yi.charCodeAt(na));
	return ea
}
const KEY_STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

function asciiToBinary(ue) {
	ue.length % 4 === 0 && (ue = ue.replace(/==?$/, ""));
	let Yi = "",
		ea = 0,
		ta = 0;
	for (let na = 0; na < ue.length; na++) ea <<= 6, ea |= KEY_STRING.indexOf(ue[na]), ta += 6, ta === 24 && (Yi += String.fromCharCode((ea & 16711680) >> 16), Yi += String.fromCharCode((ea & 65280) >> 8), Yi += String.fromCharCode(ea & 255), ea = ta = 0);
	return ta === 12 ? (ea >>= 4, Yi += String.fromCharCode(ea)) : ta === 18 && (ea >>= 2, Yi += String.fromCharCode((ea & 65280) >> 8), Yi += String.fromCharCode(ea & 255)), Yi
}
const UNDEFINED = -1,
	HOLE = -2,
	NAN = -3,
	POSITIVE_INFINITY = -4,
	NEGATIVE_INFINITY = -5,
	NEGATIVE_ZERO = -6;

function parse$2(ue, Yi) {
	return unflatten(JSON.parse(ue), Yi)
}

function unflatten(ue, Yi) {
	if (typeof ue == "number") return na(ue, !0);
	if (!Array.isArray(ue) || ue.length === 0) throw new Error("Invalid input");
	const ea = ue,
		ta = Array(ea.length);

	function na(ra, ia = !1) {
		if (ra === UNDEFINED) return;
		if (ra === NAN) return NaN;
		if (ra === POSITIVE_INFINITY) return 1 / 0;
		if (ra === NEGATIVE_INFINITY) return -1 / 0;
		if (ra === NEGATIVE_ZERO) return -0;
		if (ia) throw new Error("Invalid input");
		if (ra in ta) return ta[ra];
		const aa = ea[ra];
		if (!aa || typeof aa != "object") ta[ra] = aa;
		else if (Array.isArray(aa))
			if (typeof aa[0] == "string") {
				const oa = aa[0],
					la = Yi == null ? void 0 : Yi[oa];
				if (la) return ta[ra] = la(na(aa[1]));
				switch (oa) {
					case "Date":
						ta[ra] = new Date(aa[1]);
						break;
					case "Set":
						const sa = new Set;
						ta[ra] = sa;
						for (let da = 1; da < aa.length; da += 1) sa.add(na(aa[da]));
						break;
					case "Map":
						const ca = new Map;
						ta[ra] = ca;
						for (let da = 1; da < aa.length; da += 2) ca.set(na(aa[da]), na(aa[da + 1]));
						break;
					case "RegExp":
						ta[ra] = new RegExp(aa[1], aa[2]);
						break;
					case "Object":
						ta[ra] = Object(aa[1]);
						break;
					case "BigInt":
						ta[ra] = BigInt(aa[1]);
						break;
					case "null":
						const ua = Object.create(null);
						ta[ra] = ua;
						for (let da = 1; da < aa.length; da += 2) ua[aa[da]] = na(aa[da + 1]);
						break;
					case "Int8Array":
					case "Uint8Array":
					case "Uint8ClampedArray":
					case "Int16Array":
					case "Uint16Array":
					case "Int32Array":
					case "Uint32Array":
					case "Float32Array":
					case "Float64Array":
					case "BigInt64Array":
					case "BigUint64Array": {
						const da = globalThis[oa],
							ha = aa[1],
							pa = decode64(ha),
							va = new da(pa);
						ta[ra] = va;
						break
					}
					case "ArrayBuffer": {
						const da = aa[1],
							ha = decode64(da);
						ta[ra] = ha;
						break
					}
					default:
						throw new Error(`Unknown type ${oa}`)
				}
			} else {
				const oa = new Array(aa.length);
				ta[ra] = oa;
				for (let la = 0; la < aa.length; la += 1) {
					const sa = aa[la];
					sa !== HOLE && (oa[la] = na(sa))
				}
			}
		else {
			const oa = {};
			ta[ra] = oa;
			for (const la in aa) {
				const sa = aa[la];
				oa[la] = na(sa)
			}
		}
		return ta[ra]
	}
	return na(0)
}
const TagsWithInnerContent = new Set(["title", "titleTemplate", "script", "style", "noscript"]),
	HasElementTags = new Set(["base", "meta", "link", "style", "script", "noscript"]),
	ValidHeadTags = new Set(["title", "titleTemplate", "templateParams", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"]),
	UniqueTags = new Set(["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"]),
	TagConfigKeys = new Set(["tagPosition", "tagPriority", "tagDuplicateStrategy", "children", "innerHTML", "textContent", "processTemplateParams"]),
	IsBrowser = typeof window < "u";

function defineHeadPlugin(ue) {
	return ue
}

function hashCode(ue) {
	let Yi = 9;
	for (let ea = 0; ea < ue.length;) Yi = Math.imul(Yi ^ ue.charCodeAt(ea++), 9 ** 9);
	return ((Yi ^ Yi >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase()
}

function hashTag(ue) {
	if (ue._h) return ue._h;
	if (ue._d) return hashCode(ue._d);
	let Yi = `${ue.tag}:${ue.textContent||ue.innerHTML||""}:`;
	for (const ea in ue.props) Yi += `${ea}:${String(ue.props[ea])},`;
	return hashCode(Yi)
}

function thenable(ue, Yi) {
	return ue instanceof Promise ? ue.then(Yi) : Yi(ue)
}

function normaliseTag(ue, Yi, ea, ta) {
	const na = ta || normaliseProps(typeof Yi == "object" && typeof Yi != "function" && !(Yi instanceof Promise) ? {
		...Yi
	} : {
		[ue === "script" || ue === "noscript" || ue === "style" ? "innerHTML" : "textContent"]: Yi
	}, ue === "templateParams" || ue === "titleTemplate");
	if (na instanceof Promise) return na.then(ia => normaliseTag(ue, Yi, ea, ia));
	const ra = {
		tag: ue,
		props: na
	};
	for (const ia of TagConfigKeys) {
		const aa = ra.props[ia] !== void 0 ? ra.props[ia] : ea[ia];
		aa !== void 0 && ((!(ia === "innerHTML" || ia === "textContent" || ia === "children") || TagsWithInnerContent.has(ra.tag)) && (ra[ia === "children" ? "innerHTML" : ia] = aa), delete ra.props[ia])
	}
	return ra.props.body && (ra.tagPosition = "bodyClose", delete ra.props.body), ra.tag === "script" && typeof ra.innerHTML == "object" && (ra.innerHTML = JSON.stringify(ra.innerHTML), ra.props.type = ra.props.type || "application/json"), Array.isArray(ra.props.content) ? ra.props.content.map(ia => ({
		...ra,
		props: {
			...ra.props,
			content: ia
		}
	})) : ra
}

function normaliseStyleClassProps(ue, Yi) {
	var ta;
	const ea = ue === "class" ? " " : ";";
	return Yi && typeof Yi == "object" && !Array.isArray(Yi) && (Yi = Object.entries(Yi).filter(([, na]) => na).map(([na, ra]) => ue === "style" ? `${na}:${ra}` : na)), (ta = String(Array.isArray(Yi) ? Yi.join(ea) : Yi)) == null ? void 0 : ta.split(ea).filter(na => !!na.trim()).join(ea)
}

function nestedNormaliseProps(ue, Yi, ea, ta) {
	for (let na = ta; na < ea.length; na += 1) {
		const ra = ea[na];
		if (ra === "class" || ra === "style") {
			ue[ra] = normaliseStyleClassProps(ra, ue[ra]);
			continue
		}
		if (ue[ra] instanceof Promise) return ue[ra].then(ia => (ue[ra] = ia, nestedNormaliseProps(ue, Yi, ea, na)));
		if (!Yi && !TagConfigKeys.has(ra)) {
			const ia = String(ue[ra]),
				aa = ra.startsWith("data-");
			ia === "true" || ia === "" ? ue[ra] = aa ? "true" : !0 : ue[ra] || (aa && ia === "false" ? ue[ra] = "false" : delete ue[ra])
		}
	}
}

function normaliseProps(ue, Yi = !1) {
	const ea = nestedNormaliseProps(ue, Yi, Object.keys(ue), 0);
	return ea instanceof Promise ? ea.then(() => ue) : ue
}
const TagEntityBits = 10;

function nestedNormaliseEntryTags(ue, Yi, ea) {
	for (let ta = ea; ta < Yi.length; ta += 1) {
		const na = Yi[ta];
		if (na instanceof Promise) return na.then(ra => (Yi[ta] = ra, nestedNormaliseEntryTags(ue, Yi, ta)));
		Array.isArray(na) ? ue.push(...na) : ue.push(na)
	}
}

function normaliseEntryTags(ue) {
	const Yi = [],
		ea = ue.resolvedInput;
	for (const na in ea) {
		if (!Object.prototype.hasOwnProperty.call(ea, na)) continue;
		const ra = ea[na];
		if (!(ra === void 0 || !ValidHeadTags.has(na))) {
			if (Array.isArray(ra)) {
				for (const ia of ra) Yi.push(normaliseTag(na, ia, ue));
				continue
			}
			Yi.push(normaliseTag(na, ra, ue))
		}
	}
	if (Yi.length === 0) return [];
	const ta = [];
	return thenable(nestedNormaliseEntryTags(ta, Yi, 0), () => ta.map((na, ra) => (na._e = ue._i, ue.mode && (na._m = ue.mode), na._p = (ue._i << TagEntityBits) + ra, na)))
}
const NetworkEvents = new Set(["onload", "onerror", "onabort", "onprogress", "onloadstart"]),
	TAG_WEIGHTS = {
		base: -10,
		title: 10
	},
	TAG_ALIASES = {
		critical: -80,
		high: -10,
		low: 20
	};

function tagWeight(ue) {
	const Yi = ue.tagPriority;
	if (typeof Yi == "number") return Yi;
	let ea = 100;
	return ue.tag === "meta" ? ue.props["http-equiv"] === "content-security-policy" ? ea = -30 : ue.props.charset ? ea = -20 : ue.props.name === "viewport" && (ea = -15) : ue.tag === "link" && ue.props.rel === "preconnect" ? ea = 20 : ue.tag in TAG_WEIGHTS && (ea = TAG_WEIGHTS[ue.tag]), Yi && Yi in TAG_ALIASES ? ea + TAG_ALIASES[Yi] : ea
}
const SortModifiers = [{
		prefix: "before:",
		offset: -1
	}, {
		prefix: "after:",
		offset: 1
	}],
	allowedMetaProperties = ["name", "property", "http-equiv"];

function tagDedupeKey(ue) {
	const {
		props: Yi,
		tag: ea
	} = ue;
	if (UniqueTags.has(ea)) return ea;
	if (ea === "link" && Yi.rel === "canonical") return "canonical";
	if (Yi.charset) return "charset";
	if (Yi.id) return `${ea}:id:${Yi.id}`;
	for (const ta of allowedMetaProperties)
		if (Yi[ta] !== void 0) return `${ea}:${ta}:${Yi[ta]}`;
	return !1
}
const sepSub = "%separator";

function sub$1(ue, Yi) {
	var ta;
	let ea;
	if (Yi === "s" || Yi === "pageTitle") ea = ue.pageTitle;
	else if (Yi.includes(".")) {
		const na = Yi.indexOf(".");
		ea = (ta = ue[Yi.substring(0, na)]) == null ? void 0 : ta[Yi.substring(na + 1)]
	} else ea = ue[Yi];
	return ea !== void 0 ? (ea || "").replace(/"/g, '\\"') : void 0
}
const sepSubRe = new RegExp(`${sepSub}(?:\\s*${sepSub})*`, "g");

function processTemplateParams(ue, Yi, ea) {
	if (typeof ue != "string" || !ue.includes("%")) return ue;
	let ta = ue;
	try {
		ta = decodeURI(ue)
	} catch {}
	const na = ta.match(/%\w+(?:\.\w+)?/g);
	if (!na) return ue;
	const ra = ue.includes(sepSub);
	return ue = ue.replace(/%\w+(?:\.\w+)?/g, ia => {
		if (ia === sepSub || !na.includes(ia)) return ia;
		const aa = sub$1(Yi, ia.slice(1));
		return aa !== void 0 ? aa : ia
	}).trim(), ra && (ue.endsWith(sepSub) && (ue = ue.slice(0, -sepSub.length)), ue.startsWith(sepSub) && (ue = ue.slice(sepSub.length)), ue = ue.replace(sepSubRe, ea).trim()), ue
}

function resolveTitleTemplate(ue, Yi) {
	return ue == null ? Yi || null : typeof ue == "function" ? ue(Yi) : ue
}
async function renderDOMHead(ue, Yi = {}) {
	const ea = Yi.document || ue.resolvedOptions.document;
	if (!ea || !ue.dirty) return;
	const ta = {
		shouldRender: !0,
		tags: []
	};
	if (await ue.hooks.callHook("dom:beforeRender", ta), !!ta.shouldRender) return ue._domUpdatePromise || (ue._domUpdatePromise = new Promise(async na => {
		var ca;
		const ra = (await ue.resolveTags()).map(ua => ({
			tag: ua,
			id: HasElementTags.has(ua.tag) ? hashTag(ua) : ua.tag,
			shouldRender: !0
		}));
		let ia = ue._dom;
		if (!ia) {
			ia = {
				elMap: {
					htmlAttrs: ea.documentElement,
					bodyAttrs: ea.body
				}
			};
			const ua = new Set;
			for (const da of ["body", "head"]) {
				const ha = (ca = ea[da]) == null ? void 0 : ca.children;
				for (const pa of ha) {
					const va = pa.tagName.toLowerCase();
					if (!HasElementTags.has(va)) continue;
					const ba = {
							tag: va,
							props: await normaliseProps(pa.getAttributeNames().reduce((ka, Pa) => ({
								...ka,
								[Pa]: pa.getAttribute(Pa)
							}), {})),
							innerHTML: pa.innerHTML
						},
						Ea = tagDedupeKey(ba);
					let Sa = Ea,
						Ca = 1;
					for (; Sa && ua.has(Sa);) Sa = `${Ea}:${Ca++}`;
					Sa && (ba._d = Sa, ua.add(Sa)), ia.elMap[pa.getAttribute("data-hid") || hashTag(ba)] = pa
				}
			}
		}
		ia.pendingSideEffects = {
			...ia.sideEffects
		}, ia.sideEffects = {};

		function aa(ua, da, ha) {
			const pa = `${ua}:${da}`;
			ia.sideEffects[pa] = ha, delete ia.pendingSideEffects[pa]
		}

		function oa({
			id: ua,
			$el: da,
			tag: ha
		}) {
			const pa = ha.tag.endsWith("Attrs");
			if (ia.elMap[ua] = da, pa || (ha.textContent && ha.textContent !== da.textContent && (da.textContent = ha.textContent), ha.innerHTML && ha.innerHTML !== da.innerHTML && (da.innerHTML = ha.innerHTML), aa(ua, "el", () => {
					var va;
					(va = ia.elMap[ua]) == null || va.remove(), delete ia.elMap[ua]
				})), ha._eventHandlers)
				for (const va in ha._eventHandlers) Object.prototype.hasOwnProperty.call(ha._eventHandlers, va) && da.getAttribute(`data-${va}`) !== "" && ((ha.tag === "bodyAttrs" ? ea.defaultView : da).addEventListener(va.substring(2), ha._eventHandlers[va].bind(da)), da.setAttribute(`data-${va}`, ""));
			for (const va in ha.props) {
				if (!Object.prototype.hasOwnProperty.call(ha.props, va)) continue;
				const ba = ha.props[va],
					Ea = `attr:${va}`;
				if (va === "class") {
					if (!ba) continue;
					for (const Sa of ba.split(" ")) pa && aa(ua, `${Ea}:${Sa}`, () => da.classList.remove(Sa)), !da.classList.contains(Sa) && da.classList.add(Sa)
				} else if (va === "style") {
					if (!ba) continue;
					for (const Sa of ba.split(";")) {
						const Ca = Sa.indexOf(":"),
							ka = Sa.substring(0, Ca).trim(),
							Pa = Sa.substring(Ca + 1).trim();
						aa(ua, `${Ea}:${ka}`, () => {
							da.style.removeProperty(ka)
						}), da.style.setProperty(ka, Pa)
					}
				} else da.getAttribute(va) !== ba && da.setAttribute(va, ba === !0 ? "" : String(ba)), pa && aa(ua, Ea, () => da.removeAttribute(va))
			}
		}
		const la = [],
			sa = {
				bodyClose: void 0,
				bodyOpen: void 0,
				head: void 0
			};
		for (const ua of ra) {
			const {
				tag: da,
				shouldRender: ha,
				id: pa
			} = ua;
			if (ha) {
				if (da.tag === "title") {
					ea.title = da.textContent;
					continue
				}
				ua.$el = ua.$el || ia.elMap[pa], ua.$el ? oa(ua) : HasElementTags.has(da.tag) && la.push(ua)
			}
		}
		for (const ua of la) {
			const da = ua.tag.tagPosition || "head";
			ua.$el = ea.createElement(ua.tag.tag), oa(ua), sa[da] = sa[da] || ea.createDocumentFragment(), sa[da].appendChild(ua.$el)
		}
		for (const ua of ra) await ue.hooks.callHook("dom:renderTag", ua, ea, aa);
		sa.head && ea.head.appendChild(sa.head), sa.bodyOpen && ea.body.insertBefore(sa.bodyOpen, ea.body.firstChild), sa.bodyClose && ea.body.appendChild(sa.bodyClose);
		for (const ua in ia.pendingSideEffects) ia.pendingSideEffects[ua]();
		ue._dom = ia, await ue.hooks.callHook("dom:rendered", {
			renders: ra
		}), na()
	}).finally(() => {
		ue._domUpdatePromise = void 0, ue.dirty = !1
	})), ue._domUpdatePromise
}

function debouncedRenderDOMHead(ue, Yi = {}) {
	const ea = Yi.delayFn || (ta => setTimeout(ta, 10));
	return ue._domDebouncedUpdatePromise = ue._domDebouncedUpdatePromise || new Promise(ta => ea(() => renderDOMHead(ue, Yi).then(() => {
		delete ue._domDebouncedUpdatePromise, ta()
	})))
}

function DomPlugin(ue) {
	return Yi => {
		var ta, na;
		const ea = ((na = (ta = Yi.resolvedOptions.document) == null ? void 0 : ta.head.querySelector('script[id="unhead:payload"]')) == null ? void 0 : na.innerHTML) || !1;
		return ea && Yi.push(JSON.parse(ea)), {
			mode: "client",
			hooks: {
				"entries:updated": ra => {
					debouncedRenderDOMHead(ra, ue)
				}
			}
		}
	}
}
const UsesMergeStrategy = new Set(["templateParams", "htmlAttrs", "bodyAttrs"]),
	DedupePlugin = {
		hooks: {
			"tag:normalise": ({
				tag: ue
			}) => {
				ue.props.hid && (ue.key = ue.props.hid, delete ue.props.hid), ue.props.vmid && (ue.key = ue.props.vmid, delete ue.props.vmid), ue.props.key && (ue.key = ue.props.key, delete ue.props.key);
				const Yi = tagDedupeKey(ue);
				Yi && !Yi.startsWith("meta:og:") && !Yi.startsWith("meta:twitter:") && delete ue.key;
				const ea = Yi || (ue.key ? `${ue.tag}:${ue.key}` : !1);
				ea && (ue._d = ea)
			},
			"tags:resolve": ue => {
				const Yi = Object.create(null);
				for (const ta of ue.tags) {
					const na = (ta.key ? `${ta.tag}:${ta.key}` : ta._d) || hashTag(ta),
						ra = Yi[na];
					if (ra) {
						let aa = ta == null ? void 0 : ta.tagDuplicateStrategy;
						if (!aa && UsesMergeStrategy.has(ta.tag) && (aa = "merge"), aa === "merge") {
							const oa = ra.props;
							oa.style && ta.props.style && (oa.style[oa.style.length - 1] !== ";" && (oa.style += ";"), ta.props.style = `${oa.style} ${ta.props.style}`), oa.class && ta.props.class ? ta.props.class = `${oa.class} ${ta.props.class}` : oa.class && (ta.props.class = oa.class), Yi[na].props = {
								...oa,
								...ta.props
							};
							continue
						} else if (ta._e === ra._e) {
							ra._duped = ra._duped || [], ta._d = `${ra._d}:${ra._duped.length+1}`, ra._duped.push(ta);
							continue
						} else if (tagWeight(ta) > tagWeight(ra)) continue
					}
					if (!(ta.innerHTML || ta.textContent || Object.keys(ta.props).length !== 0) && HasElementTags.has(ta.tag)) {
						delete Yi[na];
						continue
					}
					Yi[na] = ta
				}
				const ea = [];
				for (const ta in Yi) {
					const na = Yi[ta],
						ra = na._duped;
					ea.push(na), ra && (delete na._duped, ea.push(...ra))
				}
				ue.tags = ea, ue.tags = ue.tags.filter(ta => !(ta.tag === "meta" && (ta.props.name || ta.props.property) && !ta.props.content))
			}
		}
	},
	ValidEventTags = new Set(["script", "link", "bodyAttrs"]),
	EventHandlersPlugin = ue => ({
		hooks: {
			"tags:resolve": Yi => {
				for (const ea of Yi.tags) {
					if (!ValidEventTags.has(ea.tag)) continue;
					const ta = ea.props;
					for (const na in ta) {
						if (na[0] !== "o" || na[1] !== "n" || !Object.prototype.hasOwnProperty.call(ta, na)) continue;
						const ra = ta[na];
						typeof ra == "function" && (ue.ssr && NetworkEvents.has(na) ? ta[na] = `this.dataset.${na}fired = true` : delete ta[na], ea._eventHandlers = ea._eventHandlers || {}, ea._eventHandlers[na] = ra)
					}
					ue.ssr && ea._eventHandlers && (ea.props.src || ea.props.href) && (ea.key = ea.key || hashCode(ea.props.src || ea.props.href))
				}
			},
			"dom:renderTag": ({
				$el: Yi,
				tag: ea
			}) => {
				var na, ra;
				const ta = Yi == null ? void 0 : Yi.dataset;
				if (ta)
					for (const ia in ta) {
						if (!ia.endsWith("fired")) continue;
						const aa = ia.slice(0, -5);
						NetworkEvents.has(aa) && ((ra = (na = ea._eventHandlers) == null ? void 0 : na[aa]) == null || ra.call(Yi, new Event(aa.substring(2))))
					}
			}
		}
	}),
	DupeableTags = new Set(["link", "style", "script", "noscript"]),
	HashKeyedPlugin = {
		hooks: {
			"tag:normalise": ({
				tag: ue
			}) => {
				ue.key && DupeableTags.has(ue.tag) && (ue.props["data-hid"] = ue._h = hashCode(ue.key))
			}
		}
	},
	PayloadPlugin = {
		mode: "server",
		hooks: {
			"tags:beforeResolve": ue => {
				const Yi = {};
				let ea = !1;
				for (const ta of ue.tags) ta._m !== "server" || ta.tag !== "titleTemplate" && ta.tag !== "templateParams" && ta.tag !== "title" || (Yi[ta.tag] = ta.tag === "title" || ta.tag === "titleTemplate" ? ta.textContent : ta.props, ea = !0);
				ea && ue.tags.push({
					tag: "script",
					innerHTML: JSON.stringify(Yi),
					props: {
						id: "unhead:payload",
						type: "application/json"
					}
				})
			}
		}
	},
	SortPlugin = {
		hooks: {
			"tags:resolve": ue => {
				var Yi;
				for (const ea of ue.tags)
					if (typeof ea.tagPriority == "string")
						for (const {
								prefix: ta,
								offset: na
							}
							of SortModifiers) {
							if (!ea.tagPriority.startsWith(ta)) continue;
							const ra = ea.tagPriority.substring(ta.length),
								ia = (Yi = ue.tags.find(aa => aa._d === ra)) == null ? void 0 : Yi._p;
							if (ia !== void 0) {
								ea._p = ia + na;
								break
							}
						}
				ue.tags.sort((ea, ta) => {
					const na = tagWeight(ea),
						ra = tagWeight(ta);
					return na < ra ? -1 : na > ra ? 1 : ea._p - ta._p
				})
			}
		}
	},
	SupportedAttrs = {
		meta: "content",
		link: "href",
		htmlAttrs: "lang"
	},
	contentAttrs = ["innerHTML", "textContent"],
	TemplateParamsPlugin = ue => ({
		hooks: {
			"tags:resolve": Yi => {
				var ia;
				const {
					tags: ea
				} = Yi;
				let ta;
				for (let aa = 0; aa < ea.length; aa += 1) ea[aa].tag === "templateParams" && (ta = Yi.tags.splice(aa, 1)[0].props, aa -= 1);
				const na = ta || {},
					ra = na.separator || "|";
				delete na.separator, na.pageTitle = processTemplateParams(na.pageTitle || ((ia = ea.find(aa => aa.tag === "title")) == null ? void 0 : ia.textContent) || "", na, ra);
				for (const aa of ea) {
					if (aa.processTemplateParams === !1) continue;
					const oa = SupportedAttrs[aa.tag];
					if (oa && typeof aa.props[oa] == "string") aa.props[oa] = processTemplateParams(aa.props[oa], na, ra);
					else if (aa.processTemplateParams || aa.tag === "titleTemplate" || aa.tag === "title")
						for (const la of contentAttrs) typeof aa[la] == "string" && (aa[la] = processTemplateParams(aa[la], na, ra))
				}
				ue._templateParams = na, ue._separator = ra
			},
			"tags:afterResolve": ({
				tags: Yi
			}) => {
				let ea;
				for (let ta = 0; ta < Yi.length; ta += 1) {
					const na = Yi[ta];
					na.tag === "title" && na.processTemplateParams !== !1 && (ea = na)
				}
				ea != null && ea.textContent && (ea.textContent = processTemplateParams(ea.textContent, ue._templateParams, ue._separator))
			}
		}
	}),
	TitleTemplatePlugin = {
		hooks: {
			"tags:resolve": ue => {
				const {
					tags: Yi
				} = ue;
				let ea, ta;
				for (let na = 0; na < Yi.length; na += 1) {
					const ra = Yi[na];
					ra.tag === "title" ? ea = ra : ra.tag === "titleTemplate" && (ta = ra)
				}
				if (ta && ea) {
					const na = resolveTitleTemplate(ta.textContent, ea.textContent);
					na !== null ? ea.textContent = na || ea.textContent : ue.tags.splice(ue.tags.indexOf(ea), 1)
				} else if (ta) {
					const na = resolveTitleTemplate(ta.textContent);
					na !== null && (ta.textContent = na, ta.tag = "title", ta = void 0)
				}
				ta && ue.tags.splice(ue.tags.indexOf(ta), 1)
			}
		}
	},
	XSSPlugin = {
		hooks: {
			"tags:afterResolve": ue => {
				for (const Yi of ue.tags) typeof Yi.innerHTML == "string" && (Yi.innerHTML && (Yi.props.type === "application/ld+json" || Yi.props.type === "application/json") ? Yi.innerHTML = Yi.innerHTML.replace(/</g, "\\u003C") : Yi.innerHTML = Yi.innerHTML.replace(new RegExp(`</${Yi.tag}`, "g"), `<\\/${Yi.tag}`))
			}
		}
	};
let activeHead;

function createHead$1(ue = {}) {
	const Yi = createHeadCore(ue);
	return Yi.use(DomPlugin()), activeHead = Yi
}

function filterMode(ue, Yi) {
	return !ue || ue === "server" && Yi || ue === "client" && !Yi
}

function createHeadCore(ue = {}) {
	const Yi = createHooks();
	Yi.addHooks(ue.hooks || {}), ue.document = ue.document || (IsBrowser ? document : void 0);
	const ea = !ue.document,
		ta = () => {
			aa.dirty = !0, Yi.callHook("entries:updated", aa)
		};
	let na = 0,
		ra = [];
	const ia = [],
		aa = {
			plugins: ia,
			dirty: !1,
			resolvedOptions: ue,
			hooks: Yi,
			headEntries() {
				return ra
			},
			use(oa) {
				const la = typeof oa == "function" ? oa(aa) : oa;
				(!la.key || !ia.some(sa => sa.key === la.key)) && (ia.push(la), filterMode(la.mode, ea) && Yi.addHooks(la.hooks || {}))
			},
			push(oa, la) {
				la == null || delete la.head;
				const sa = {
					_i: na++,
					input: oa,
					...la
				};
				return filterMode(sa.mode, ea) && (ra.push(sa), ta()), {
					dispose() {
						ra = ra.filter(ca => ca._i !== sa._i), ta()
					},
					patch(ca) {
						for (const ua of ra) ua._i === sa._i && (ua.input = sa.input = ca);
						ta()
					}
				}
			},
			async resolveTags() {
				const oa = {
					tags: [],
					entries: [...ra]
				};
				await Yi.callHook("entries:resolve", oa);
				for (const la of oa.entries) {
					const sa = la.resolvedInput || la.input;
					if (la.resolvedInput = await (la.transform ? la.transform(sa) : sa), la.resolvedInput)
						for (const ca of await normaliseEntryTags(la)) {
							const ua = {
								tag: ca,
								entry: la,
								resolvedOptions: aa.resolvedOptions
							};
							await Yi.callHook("tag:normalise", ua), oa.tags.push(ua.tag)
						}
				}
				return await Yi.callHook("tags:beforeResolve", oa), await Yi.callHook("tags:resolve", oa), await Yi.callHook("tags:afterResolve", oa), oa.tags
			},
			ssr: ea
		};
	return [DedupePlugin, PayloadPlugin, EventHandlersPlugin, HashKeyedPlugin, SortPlugin, TemplateParamsPlugin, TitleTemplatePlugin, XSSPlugin, ...(ue == null ? void 0 : ue.plugins) || []].forEach(oa => aa.use(oa)), aa.hooks.callHook("init", aa), aa
}

function getActiveHead() {
	return activeHead
}
const Vue3 = version$1[0] === "3";

function resolveUnref(ue) {
	return typeof ue == "function" ? ue() : unref(ue)
}

function resolveUnrefHeadInput(ue) {
	if (ue instanceof Promise || ue instanceof Date || ue instanceof RegExp) return ue;
	const Yi = resolveUnref(ue);
	if (!ue || !Yi) return Yi;
	if (Array.isArray(Yi)) return Yi.map(ea => resolveUnrefHeadInput(ea));
	if (typeof Yi == "object") {
		const ea = {};
		for (const ta in Yi)
			if (Object.prototype.hasOwnProperty.call(Yi, ta)) {
				if (ta === "titleTemplate" || ta[0] === "o" && ta[1] === "n") {
					ea[ta] = unref(Yi[ta]);
					continue
				}
				ea[ta] = resolveUnrefHeadInput(Yi[ta])
			} return ea
	}
	return Yi
}
const VueReactivityPlugin = {
		hooks: {
			"entries:resolve": ue => {
				for (const Yi of ue.entries) Yi.resolvedInput = resolveUnrefHeadInput(Yi.input)
			}
		}
	},
	headSymbol = "usehead";

function vueInstall(ue) {
	return {
		install(ea) {
			Vue3 && (ea.config.globalProperties.$unhead = ue, ea.config.globalProperties.$head = ue, ea.provide(headSymbol, ue))
		}
	}.install
}

function createHead(ue = {}) {
	ue.domDelayFn = ue.domDelayFn || (ea => nextTick(() => setTimeout(() => ea(), 0)));
	const Yi = createHead$1(ue);
	return Yi.use(VueReactivityPlugin), Yi.install = vueInstall(Yi), Yi
}
const _global$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global$1 < "u" ? global$1 : typeof self < "u" ? self : {},
	globalKey = "__unhead_injection_handler__";

function setHeadInjectionHandler(ue) {
	_global$1[globalKey] = ue
}

function injectHead() {
	if (globalKey in _global$1) return _global$1[globalKey]();
	const ue = inject(headSymbol);
	return ue || getActiveHead()
}

function useHead(ue, Yi = {}) {
	const ea = Yi.head || injectHead();
	if (ea) return ea.ssr ? ea.push(ue, Yi) : clientUseHead(ea, ue, Yi)
}

function clientUseHead(ue, Yi, ea = {}) {
	const ta = ref$1(!1),
		na = ref$1({});
	watchEffect(() => {
		na.value = ta.value ? {} : resolveUnrefHeadInput(Yi)
	});
	const ra = ue.push(na.value, ea);
	return watch(na, aa => {
		ra.patch(aa)
	}), getCurrentInstance() && (onBeforeUnmount(() => {
		ra.dispose()
	}), onDeactivated(() => {
		ta.value = !0
	}), onActivated(() => {
		ta.value = !1
	})), ra
}
let manifest, matcher;

function fetchManifest() {
	return manifest = $fetch(buildAssetsURL(`builds/meta/${useRuntimeConfig().app.buildId}.json`), {
		responseType: "json"
	}), manifest.then(ue => {
		matcher = createMatcherFromExport(ue.matcher)
	}).catch(ue => {
		console.error("[nuxt] Error fetching app manifest.", ue)
	}), manifest
}

function getAppManifest() {
	return manifest || fetchManifest()
}
async function getRouteRules(ue) {
	if (await getAppManifest(), !matcher) return console.error("[nuxt] Error creating app manifest matcher.", matcher), {};
	try {
		return defu({}, ...matcher.matchAll(ue).reverse())
	} catch (Yi) {
		return console.error("[nuxt] Error matching route rules.", Yi), {}
	}
}
async function loadPayload(ue, Yi = {}) {
	const ea = await _getPayloadURL(ue, Yi),
		ta = useNuxtApp(),
		na = ta._payloadCache = ta._payloadCache || {};
	return ea in na || (na[ea] = isPrerendered(ue).then(ra => ra ? _importPayload(ea).then(ia => ia || (delete na[ea], null)) : (na[ea] = null, null))), na[ea]
}
const filename = "_payload.json";
async function _getPayloadURL(ue, Yi = {}) {
	const ea = new URL(ue, "http://localhost");
	if (ea.host !== "localhost" || hasProtocol(ea.pathname, {
			acceptRelative: !0
		})) throw new Error("Payload URL must not include hostname: " + ue);
	const ta = useRuntimeConfig(),
		na = Yi.hash || (Yi.fresh ? Date.now() : ta.app.buildId),
		ra = ta.app.cdnURL,
		ia = ra && await isPrerendered(ue) ? ra : ta.app.baseURL;
	return joinURL(ia, ea.pathname, filename + (na ? `?${na}` : ""))
}
async function _importPayload(ue) {
	const Yi = fetch(ue).then(ea => ea.text().then(parsePayload));
	try {
		return await Yi
	} catch (ea) {
		console.warn("[nuxt] Cannot load payload ", ue, ea)
	}
	return null
}
async function isPrerendered(ue = useRoute().path) {
	if (ue = withoutTrailingSlash(ue), (await getAppManifest()).prerendered.includes(ue)) return !0;
	const ea = await getRouteRules(ue);
	return !!ea.prerender && !ea.redirect
}
let payloadCache = null;
async function getNuxtClientPayload() {
	var ta;
	if (payloadCache) return payloadCache;
	const ue = document.getElementById("__NUXT_DATA__");
	if (!ue) return {};
	const Yi = await parsePayload(ue.textContent || ""),
		ea = ue.dataset.src ? await _importPayload(ue.dataset.src) : void 0;
	return payloadCache = {
		...Yi,
		...ea,
		...window.__NUXT__
	}, (ta = payloadCache.config) != null && ta.public && (payloadCache.config.public = reactive(payloadCache.config.public)), payloadCache
}
async function parsePayload(ue) {
	return await parse$2(ue, useNuxtApp()._payloadRevivers)
}

function definePayloadReviver(ue, Yi) {
	useNuxtApp()._payloadRevivers[ue] = Yi
}
const revivers = {
		NuxtError: ue => createError(ue),
		EmptyShallowRef: ue => shallowRef(ue === "_" ? void 0 : ue === "0n" ? BigInt(0) : destr(ue)),
		EmptyRef: ue => ref$1(ue === "_" ? void 0 : ue === "0n" ? BigInt(0) : destr(ue)),
		ShallowRef: ue => shallowRef(ue),
		ShallowReactive: ue => shallowReactive(ue),
		Ref: ue => ref$1(ue),
		Reactive: ue => reactive(ue)
	},
	revive_payload_client_4sVQNw7RlN = defineNuxtPlugin({
		name: "nuxt:revive-payload:client",
		order: -30,
		async setup(ue) {
			let Yi, ea;
			for (const ta in revivers) definePayloadReviver(ta, revivers[ta]);
			Object.assign(ue.payload, ([Yi, ea] = executeAsync(() => ue.runWithContext(getNuxtClientPayload)), Yi = await Yi, ea(), Yi)), window.__NUXT__ = ue.payload
		}
	}),
	unheadPlugins = [],
	unhead_KgADcZ0jPj = defineNuxtPlugin({
		name: "nuxt:head",
		enforce: "pre",
		setup(ue) {
			const Yi = createHead({
				plugins: unheadPlugins
			});
			setHeadInjectionHandler(() => useNuxtApp().vueApp._context.provides.usehead), ue.vueApp.use(Yi);
			{
				let ea = !0;
				const ta = async () => {
					ea = !1, await renderDOMHead(Yi)
				};
				Yi.hooks.hook("dom:beforeRender", na => {
					na.shouldRender = !ea
				}), ue.hooks.hook("page:start", () => {
					ea = !0
				}), ue.hooks.hook("page:finish", () => {
					ue.isHydrating || ta()
				}), ue.hooks.hook("app:error", ta), ue.hooks.hook("app:suspense:resolve", ta)
			}
		}
	});
/*!
 * vue-router v4.4.5
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */
const isBrowser$1 = typeof document < "u";

function isRouteComponent(ue) {
	return typeof ue == "object" || "displayName" in ue || "props" in ue || "__vccOpts" in ue
}

function isESModule(ue) {
	return ue.__esModule || ue[Symbol.toStringTag] === "Module" || ue.default && isRouteComponent(ue.default)
}
const assign$1 = Object.assign;

function applyToParams(ue, Yi) {
	const ea = {};
	for (const ta in Yi) {
		const na = Yi[ta];
		ea[ta] = isArray$3(na) ? na.map(ue) : ue(na)
	}
	return ea
}
const noop$2 = () => {},
	isArray$3 = Array.isArray,
	HASH_RE = /#/g,
	AMPERSAND_RE = /&/g,
	SLASH_RE = /\//g,
	EQUAL_RE = /=/g,
	IM_RE = /\?/g,
	PLUS_RE = /\+/g,
	ENC_BRACKET_OPEN_RE = /%5B/g,
	ENC_BRACKET_CLOSE_RE = /%5D/g,
	ENC_CARET_RE = /%5E/g,
	ENC_BACKTICK_RE = /%60/g,
	ENC_CURLY_OPEN_RE = /%7B/g,
	ENC_PIPE_RE = /%7C/g,
	ENC_CURLY_CLOSE_RE = /%7D/g,
	ENC_SPACE_RE = /%20/g;

function commonEncode(ue) {
	return encodeURI("" + ue).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]")
}

function encodeHash(ue) {
	return commonEncode(ue).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^")
}

function encodeQueryValue(ue) {
	return commonEncode(ue).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^")
}

function encodeQueryKey(ue) {
	return encodeQueryValue(ue).replace(EQUAL_RE, "%3D")
}

function encodePath(ue) {
	return commonEncode(ue).replace(HASH_RE, "%23").replace(IM_RE, "%3F")
}

function encodeParam(ue) {
	return ue == null ? "" : encodePath(ue).replace(SLASH_RE, "%2F")
}

function decode$1(ue) {
	try {
		return decodeURIComponent("" + ue)
	} catch {}
	return "" + ue
}
const TRAILING_SLASH_RE = /\/$/,
	removeTrailingSlash$1 = ue => ue.replace(TRAILING_SLASH_RE, "");

function parseURL(ue, Yi, ea = "/") {
	let ta, na = {},
		ra = "",
		ia = "";
	const aa = Yi.indexOf("#");
	let oa = Yi.indexOf("?");
	return aa < oa && aa >= 0 && (oa = -1), oa > -1 && (ta = Yi.slice(0, oa), ra = Yi.slice(oa + 1, aa > -1 ? aa : Yi.length), na = ue(ra)), aa > -1 && (ta = ta || Yi.slice(0, aa), ia = Yi.slice(aa, Yi.length)), ta = resolveRelativePath(ta ?? Yi, ea), {
		fullPath: ta + (ra && "?") + ra + ia,
		path: ta,
		query: na,
		hash: decode$1(ia)
	}
}

function stringifyURL(ue, Yi) {
	const ea = Yi.query ? ue(Yi.query) : "";
	return Yi.path + (ea && "?") + ea + (Yi.hash || "")
}

function stripBase(ue, Yi) {
	return !Yi || !ue.toLowerCase().startsWith(Yi.toLowerCase()) ? ue : ue.slice(Yi.length) || "/"
}

function isSameRouteLocation(ue, Yi, ea) {
	const ta = Yi.matched.length - 1,
		na = ea.matched.length - 1;
	return ta > -1 && ta === na && isSameRouteRecord(Yi.matched[ta], ea.matched[na]) && isSameRouteLocationParams(Yi.params, ea.params) && ue(Yi.query) === ue(ea.query) && Yi.hash === ea.hash
}

function isSameRouteRecord(ue, Yi) {
	return (ue.aliasOf || ue) === (Yi.aliasOf || Yi)
}

function isSameRouteLocationParams(ue, Yi) {
	if (Object.keys(ue).length !== Object.keys(Yi).length) return !1;
	for (const ea in ue)
		if (!isSameRouteLocationParamsValue(ue[ea], Yi[ea])) return !1;
	return !0
}

function isSameRouteLocationParamsValue(ue, Yi) {
	return isArray$3(ue) ? isEquivalentArray(ue, Yi) : isArray$3(Yi) ? isEquivalentArray(Yi, ue) : ue === Yi
}

function isEquivalentArray(ue, Yi) {
	return isArray$3(Yi) ? ue.length === Yi.length && ue.every((ea, ta) => ea === Yi[ta]) : ue.length === 1 && ue[0] === Yi
}

function resolveRelativePath(ue, Yi) {
	if (ue.startsWith("/")) return ue;
	if (!ue) return Yi;
	const ea = Yi.split("/"),
		ta = ue.split("/"),
		na = ta[ta.length - 1];
	(na === ".." || na === ".") && ta.push("");
	let ra = ea.length - 1,
		ia, aa;
	for (ia = 0; ia < ta.length; ia++)
		if (aa = ta[ia], aa !== ".")
			if (aa === "..") ra > 1 && ra--;
			else break;
	return ea.slice(0, ra).join("/") + "/" + ta.slice(ia).join("/")
}
const START_LOCATION_NORMALIZED = {
	path: "/",
	name: void 0,
	params: {},
	query: {},
	hash: "",
	fullPath: "/",
	matched: [],
	meta: {},
	redirectedFrom: void 0
};
var NavigationType;
(function(ue) {
	ue.pop = "pop", ue.push = "push"
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(ue) {
	ue.back = "back", ue.forward = "forward", ue.unknown = ""
})(NavigationDirection || (NavigationDirection = {}));

function normalizeBase(ue) {
	if (!ue)
		if (isBrowser$1) {
			const Yi = document.querySelector("base");
			ue = Yi && Yi.getAttribute("href") || "/", ue = ue.replace(/^\w+:\/\/[^\/]+/, "")
		} else ue = "/";
	return ue[0] !== "/" && ue[0] !== "#" && (ue = "/" + ue), removeTrailingSlash$1(ue)
}
const BEFORE_HASH_RE = /^[^#]+#/;

function createHref(ue, Yi) {
	return ue.replace(BEFORE_HASH_RE, "#") + Yi
}

function getElementPosition(ue, Yi) {
	const ea = document.documentElement.getBoundingClientRect(),
		ta = ue.getBoundingClientRect();
	return {
		behavior: Yi.behavior,
		left: ta.left - ea.left - (Yi.left || 0),
		top: ta.top - ea.top - (Yi.top || 0)
	}
}
const computeScrollPosition = () => ({
	left: window.scrollX,
	top: window.scrollY
});

function scrollToPosition(ue) {
	let Yi;
	if ("el" in ue) {
		const ea = ue.el,
			ta = typeof ea == "string" && ea.startsWith("#"),
			na = typeof ea == "string" ? ta ? document.getElementById(ea.slice(1)) : document.querySelector(ea) : ea;
		if (!na) return;
		Yi = getElementPosition(na, ue)
	} else Yi = ue;
	"scrollBehavior" in document.documentElement.style ? window.scrollTo(Yi) : window.scrollTo(Yi.left != null ? Yi.left : window.scrollX, Yi.top != null ? Yi.top : window.scrollY)
}

function getScrollKey(ue, Yi) {
	return (history.state ? history.state.position - Yi : -1) + ue
}
const scrollPositions = new Map;

function saveScrollPosition(ue, Yi) {
	scrollPositions.set(ue, Yi)
}

function getSavedScrollPosition(ue) {
	const Yi = scrollPositions.get(ue);
	return scrollPositions.delete(ue), Yi
}
let createBaseLocation = () => location.protocol + "//" + location.host;

function createCurrentLocation$1(ue, Yi) {
	const {
		pathname: ea,
		search: ta,
		hash: na
	} = Yi, ra = ue.indexOf("#");
	if (ra > -1) {
		let aa = na.includes(ue.slice(ra)) ? ue.slice(ra).length : 1,
			oa = na.slice(aa);
		return oa[0] !== "/" && (oa = "/" + oa), stripBase(oa, "")
	}
	return stripBase(ea, ue) + ta + na
}

function useHistoryListeners(ue, Yi, ea, ta) {
	let na = [],
		ra = [],
		ia = null;
	const aa = ({
		state: ua
	}) => {
		const da = createCurrentLocation$1(ue, location),
			ha = ea.value,
			pa = Yi.value;
		let va = 0;
		if (ua) {
			if (ea.value = da, Yi.value = ua, ia && ia === ha) {
				ia = null;
				return
			}
			va = pa ? ua.position - pa.position : 0
		} else ta(da);
		na.forEach(ba => {
			ba(ea.value, ha, {
				delta: va,
				type: NavigationType.pop,
				direction: va ? va > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
			})
		})
	};

	function oa() {
		ia = ea.value
	}

	function la(ua) {
		na.push(ua);
		const da = () => {
			const ha = na.indexOf(ua);
			ha > -1 && na.splice(ha, 1)
		};
		return ra.push(da), da
	}

	function sa() {
		const {
			history: ua
		} = window;
		ua.state && ua.replaceState(assign$1({}, ua.state, {
			scroll: computeScrollPosition()
		}), "")
	}

	function ca() {
		for (const ua of ra) ua();
		ra = [], window.removeEventListener("popstate", aa), window.removeEventListener("beforeunload", sa)
	}
	return window.addEventListener("popstate", aa), window.addEventListener("beforeunload", sa, {
		passive: !0
	}), {
		pauseListeners: oa,
		listen: la,
		destroy: ca
	}
}

function buildState(ue, Yi, ea, ta = !1, na = !1) {
	return {
		back: ue,
		current: Yi,
		forward: ea,
		replaced: ta,
		position: window.history.length,
		scroll: na ? computeScrollPosition() : null
	}
}

function useHistoryStateNavigation(ue) {
	const {
		history: Yi,
		location: ea
	} = window, ta = {
		value: createCurrentLocation$1(ue, ea)
	}, na = {
		value: Yi.state
	};
	na.value || ra(ta.value, {
		back: null,
		current: ta.value,
		forward: null,
		position: Yi.length - 1,
		replaced: !0,
		scroll: null
	}, !0);

	function ra(oa, la, sa) {
		const ca = ue.indexOf("#"),
			ua = ca > -1 ? (ea.host && document.querySelector("base") ? ue : ue.slice(ca)) + oa : createBaseLocation() + ue + oa;
		try {
			Yi[sa ? "replaceState" : "pushState"](la, "", ua), na.value = la
		} catch (da) {
			console.error(da), ea[sa ? "replace" : "assign"](ua)
		}
	}

	function ia(oa, la) {
		const sa = assign$1({}, Yi.state, buildState(na.value.back, oa, na.value.forward, !0), la, {
			position: na.value.position
		});
		ra(oa, sa, !0), ta.value = oa
	}

	function aa(oa, la) {
		const sa = assign$1({}, na.value, Yi.state, {
			forward: oa,
			scroll: computeScrollPosition()
		});
		ra(sa.current, sa, !0);
		const ca = assign$1({}, buildState(ta.value, oa, null), {
			position: sa.position + 1
		}, la);
		ra(oa, ca, !1), ta.value = oa
	}
	return {
		location: ta,
		state: na,
		push: aa,
		replace: ia
	}
}

function createWebHistory(ue) {
	ue = normalizeBase(ue);
	const Yi = useHistoryStateNavigation(ue),
		ea = useHistoryListeners(ue, Yi.state, Yi.location, Yi.replace);

	function ta(ra, ia = !0) {
		ia || ea.pauseListeners(), history.go(ra)
	}
	const na = assign$1({
		location: "",
		base: ue,
		go: ta,
		createHref: createHref.bind(null, ue)
	}, Yi, ea);
	return Object.defineProperty(na, "location", {
		enumerable: !0,
		get: () => Yi.location.value
	}), Object.defineProperty(na, "state", {
		enumerable: !0,
		get: () => Yi.state.value
	}), na
}

function createWebHashHistory(ue) {
	return ue = location.host ? ue || location.pathname + location.search : "", ue.includes("#") || (ue += "#"), createWebHistory(ue)
}

function isRouteLocation(ue) {
	return typeof ue == "string" || ue && typeof ue == "object"
}

function isRouteName(ue) {
	return typeof ue == "string" || typeof ue == "symbol"
}
const NavigationFailureSymbol = Symbol("");
var NavigationFailureType;
(function(ue) {
	ue[ue.aborted = 4] = "aborted", ue[ue.cancelled = 8] = "cancelled", ue[ue.duplicated = 16] = "duplicated"
})(NavigationFailureType || (NavigationFailureType = {}));

function createRouterError(ue, Yi) {
	return assign$1(new Error, {
		type: ue,
		[NavigationFailureSymbol]: !0
	}, Yi)
}

function isNavigationFailure(ue, Yi) {
	return ue instanceof Error && NavigationFailureSymbol in ue && (Yi == null || !!(ue.type & Yi))
}
const BASE_PARAM_PATTERN = "[^/]+?",
	BASE_PATH_PARSER_OPTIONS = {
		sensitive: !1,
		strict: !1,
		start: !0,
		end: !0
	},
	REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;

function tokensToParser(ue, Yi) {
	const ea = assign$1({}, BASE_PATH_PARSER_OPTIONS, Yi),
		ta = [];
	let na = ea.start ? "^" : "";
	const ra = [];
	for (const la of ue) {
		const sa = la.length ? [] : [90];
		ea.strict && !la.length && (na += "/");
		for (let ca = 0; ca < la.length; ca++) {
			const ua = la[ca];
			let da = 40 + (ea.sensitive ? .25 : 0);
			if (ua.type === 0) ca || (na += "/"), na += ua.value.replace(REGEX_CHARS_RE, "\\$&"), da += 40;
			else if (ua.type === 1) {
				const {
					value: ha,
					repeatable: pa,
					optional: va,
					regexp: ba
				} = ua;
				ra.push({
					name: ha,
					repeatable: pa,
					optional: va
				});
				const Ea = ba || BASE_PARAM_PATTERN;
				if (Ea !== BASE_PARAM_PATTERN) {
					da += 10;
					try {
						new RegExp(`(${Ea})`)
					} catch (Ca) {
						throw new Error(`Invalid custom RegExp for param "${ha}" (${Ea}): ` + Ca.message)
					}
				}
				let Sa = pa ? `((?:${Ea})(?:/(?:${Ea}))*)` : `(${Ea})`;
				ca || (Sa = va && la.length < 2 ? `(?:/${Sa})` : "/" + Sa), va && (Sa += "?"), na += Sa, da += 20, va && (da += -8), pa && (da += -20), Ea === ".*" && (da += -50)
			}
			sa.push(da)
		}
		ta.push(sa)
	}
	if (ea.strict && ea.end) {
		const la = ta.length - 1;
		ta[la][ta[la].length - 1] += .7000000000000001
	}
	ea.strict || (na += "/?"), ea.end ? na += "$" : ea.strict && (na += "(?:/|$)");
	const ia = new RegExp(na, ea.sensitive ? "" : "i");

	function aa(la) {
		const sa = la.match(ia),
			ca = {};
		if (!sa) return null;
		for (let ua = 1; ua < sa.length; ua++) {
			const da = sa[ua] || "",
				ha = ra[ua - 1];
			ca[ha.name] = da && ha.repeatable ? da.split("/") : da
		}
		return ca
	}

	function oa(la) {
		let sa = "",
			ca = !1;
		for (const ua of ue) {
			(!ca || !sa.endsWith("/")) && (sa += "/"), ca = !1;
			for (const da of ua)
				if (da.type === 0) sa += da.value;
				else if (da.type === 1) {
				const {
					value: ha,
					repeatable: pa,
					optional: va
				} = da, ba = ha in la ? la[ha] : "";
				if (isArray$3(ba) && !pa) throw new Error(`Provided param "${ha}" is an array but it is not repeatable (* or + modifiers)`);
				const Ea = isArray$3(ba) ? ba.join("/") : ba;
				if (!Ea)
					if (va) ua.length < 2 && (sa.endsWith("/") ? sa = sa.slice(0, -1) : ca = !0);
					else throw new Error(`Missing required param "${ha}"`);
				sa += Ea
			}
		}
		return sa || "/"
	}
	return {
		re: ia,
		score: ta,
		keys: ra,
		parse: aa,
		stringify: oa
	}
}

function compareScoreArray(ue, Yi) {
	let ea = 0;
	for (; ea < ue.length && ea < Yi.length;) {
		const ta = Yi[ea] - ue[ea];
		if (ta) return ta;
		ea++
	}
	return ue.length < Yi.length ? ue.length === 1 && ue[0] === 80 ? -1 : 1 : ue.length > Yi.length ? Yi.length === 1 && Yi[0] === 80 ? 1 : -1 : 0
}

function comparePathParserScore(ue, Yi) {
	let ea = 0;
	const ta = ue.score,
		na = Yi.score;
	for (; ea < ta.length && ea < na.length;) {
		const ra = compareScoreArray(ta[ea], na[ea]);
		if (ra) return ra;
		ea++
	}
	if (Math.abs(na.length - ta.length) === 1) {
		if (isLastScoreNegative(ta)) return 1;
		if (isLastScoreNegative(na)) return -1
	}
	return na.length - ta.length
}

function isLastScoreNegative(ue) {
	const Yi = ue[ue.length - 1];
	return ue.length > 0 && Yi[Yi.length - 1] < 0
}
const ROOT_TOKEN = {
		type: 0,
		value: ""
	},
	VALID_PARAM_RE = /[a-zA-Z0-9_]/;

function tokenizePath(ue) {
	if (!ue) return [
		[]
	];
	if (ue === "/") return [
		[ROOT_TOKEN]
	];
	if (!ue.startsWith("/")) throw new Error(`Invalid path "${ue}"`);

	function Yi(da) {
		throw new Error(`ERR (${ea})/"${la}": ${da}`)
	}
	let ea = 0,
		ta = ea;
	const na = [];
	let ra;

	function ia() {
		ra && na.push(ra), ra = []
	}
	let aa = 0,
		oa, la = "",
		sa = "";

	function ca() {
		la && (ea === 0 ? ra.push({
			type: 0,
			value: la
		}) : ea === 1 || ea === 2 || ea === 3 ? (ra.length > 1 && (oa === "*" || oa === "+") && Yi(`A repeatable param (${la}) must be alone in its segment. eg: '/:ids+.`), ra.push({
			type: 1,
			value: la,
			regexp: sa,
			repeatable: oa === "*" || oa === "+",
			optional: oa === "*" || oa === "?"
		})) : Yi("Invalid state to consume buffer"), la = "")
	}

	function ua() {
		la += oa
	}
	for (; aa < ue.length;) {
		if (oa = ue[aa++], oa === "\\" && ea !== 2) {
			ta = ea, ea = 4;
			continue
		}
		switch (ea) {
			case 0:
				oa === "/" ? (la && ca(), ia()) : oa === ":" ? (ca(), ea = 1) : ua();
				break;
			case 4:
				ua(), ea = ta;
				break;
			case 1:
				oa === "(" ? ea = 2 : VALID_PARAM_RE.test(oa) ? ua() : (ca(), ea = 0, oa !== "*" && oa !== "?" && oa !== "+" && aa--);
				break;
			case 2:
				oa === ")" ? sa[sa.length - 1] == "\\" ? sa = sa.slice(0, -1) + oa : ea = 3 : sa += oa;
				break;
			case 3:
				ca(), ea = 0, oa !== "*" && oa !== "?" && oa !== "+" && aa--, sa = "";
				break;
			default:
				Yi("Unknown state");
				break
		}
	}
	return ea === 2 && Yi(`Unfinished custom RegExp for param "${la}"`), ca(), ia(), na
}

function createRouteRecordMatcher(ue, Yi, ea) {
	const ta = tokensToParser(tokenizePath(ue.path), ea),
		na = assign$1(ta, {
			record: ue,
			parent: Yi,
			children: [],
			alias: []
		});
	return Yi && !na.record.aliasOf == !Yi.record.aliasOf && Yi.children.push(na), na
}

function createRouterMatcher(ue, Yi) {
	const ea = [],
		ta = new Map;
	Yi = mergeOptions$1({
		strict: !1,
		end: !0,
		sensitive: !1
	}, Yi);

	function na(ca) {
		return ta.get(ca)
	}

	function ra(ca, ua, da) {
		const ha = !da,
			pa = normalizeRouteRecord(ca);
		pa.aliasOf = da && da.record;
		const va = mergeOptions$1(Yi, ca),
			ba = [pa];
		if ("alias" in ca) {
			const Ca = typeof ca.alias == "string" ? [ca.alias] : ca.alias;
			for (const ka of Ca) ba.push(normalizeRouteRecord(assign$1({}, pa, {
				components: da ? da.record.components : pa.components,
				path: ka,
				aliasOf: da ? da.record : pa
			})))
		}
		let Ea, Sa;
		for (const Ca of ba) {
			const {
				path: ka
			} = Ca;
			if (ua && ka[0] !== "/") {
				const Pa = ua.record.path,
					ja = Pa[Pa.length - 1] === "/" ? "" : "/";
				Ca.path = ua.record.path + (ka && ja + ka)
			}
			if (Ea = createRouteRecordMatcher(Ca, ua, va), da ? da.alias.push(Ea) : (Sa = Sa || Ea, Sa !== Ea && Sa.alias.push(Ea), ha && ca.name && !isAliasRecord(Ea) && ia(ca.name)), isMatchable(Ea) && oa(Ea), pa.children) {
				const Pa = pa.children;
				for (let ja = 0; ja < Pa.length; ja++) ra(Pa[ja], Ea, da && da.children[ja])
			}
			da = da || Ea
		}
		return Sa ? () => {
			ia(Sa)
		} : noop$2
	}

	function ia(ca) {
		if (isRouteName(ca)) {
			const ua = ta.get(ca);
			ua && (ta.delete(ca), ea.splice(ea.indexOf(ua), 1), ua.children.forEach(ia), ua.alias.forEach(ia))
		} else {
			const ua = ea.indexOf(ca);
			ua > -1 && (ea.splice(ua, 1), ca.record.name && ta.delete(ca.record.name), ca.children.forEach(ia), ca.alias.forEach(ia))
		}
	}

	function aa() {
		return ea
	}

	function oa(ca) {
		const ua = findInsertionIndex(ca, ea);
		ea.splice(ua, 0, ca), ca.record.name && !isAliasRecord(ca) && ta.set(ca.record.name, ca)
	}

	function la(ca, ua) {
		let da, ha = {},
			pa, va;
		if ("name" in ca && ca.name) {
			if (da = ta.get(ca.name), !da) throw createRouterError(1, {
				location: ca
			});
			va = da.record.name, ha = assign$1(paramsFromLocation(ua.params, da.keys.filter(Sa => !Sa.optional).concat(da.parent ? da.parent.keys.filter(Sa => Sa.optional) : []).map(Sa => Sa.name)), ca.params && paramsFromLocation(ca.params, da.keys.map(Sa => Sa.name))), pa = da.stringify(ha)
		} else if (ca.path != null) pa = ca.path, da = ea.find(Sa => Sa.re.test(pa)), da && (ha = da.parse(pa), va = da.record.name);
		else {
			if (da = ua.name ? ta.get(ua.name) : ea.find(Sa => Sa.re.test(ua.path)), !da) throw createRouterError(1, {
				location: ca,
				currentLocation: ua
			});
			va = da.record.name, ha = assign$1({}, ua.params, ca.params), pa = da.stringify(ha)
		}
		const ba = [];
		let Ea = da;
		for (; Ea;) ba.unshift(Ea.record), Ea = Ea.parent;
		return {
			name: va,
			path: pa,
			params: ha,
			matched: ba,
			meta: mergeMetaFields(ba)
		}
	}
	ue.forEach(ca => ra(ca));

	function sa() {
		ea.length = 0, ta.clear()
	}
	return {
		addRoute: ra,
		resolve: la,
		removeRoute: ia,
		clearRoutes: sa,
		getRoutes: aa,
		getRecordMatcher: na
	}
}

function paramsFromLocation(ue, Yi) {
	const ea = {};
	for (const ta of Yi) ta in ue && (ea[ta] = ue[ta]);
	return ea
}

function normalizeRouteRecord(ue) {
	const Yi = {
		path: ue.path,
		redirect: ue.redirect,
		name: ue.name,
		meta: ue.meta || {},
		aliasOf: ue.aliasOf,
		beforeEnter: ue.beforeEnter,
		props: normalizeRecordProps(ue),
		children: ue.children || [],
		instances: {},
		leaveGuards: new Set,
		updateGuards: new Set,
		enterCallbacks: {},
		components: "components" in ue ? ue.components || null : ue.component && {
			default: ue.component
		}
	};
	return Object.defineProperty(Yi, "mods", {
		value: {}
	}), Yi
}

function normalizeRecordProps(ue) {
	const Yi = {},
		ea = ue.props || !1;
	if ("component" in ue) Yi.default = ea;
	else
		for (const ta in ue.components) Yi[ta] = typeof ea == "object" ? ea[ta] : ea;
	return Yi
}

function isAliasRecord(ue) {
	for (; ue;) {
		if (ue.record.aliasOf) return !0;
		ue = ue.parent
	}
	return !1
}

function mergeMetaFields(ue) {
	return ue.reduce((Yi, ea) => assign$1(Yi, ea.meta), {})
}

function mergeOptions$1(ue, Yi) {
	const ea = {};
	for (const ta in ue) ea[ta] = ta in Yi ? Yi[ta] : ue[ta];
	return ea
}

function findInsertionIndex(ue, Yi) {
	let ea = 0,
		ta = Yi.length;
	for (; ea !== ta;) {
		const ra = ea + ta >> 1;
		comparePathParserScore(ue, Yi[ra]) < 0 ? ta = ra : ea = ra + 1
	}
	const na = getInsertionAncestor(ue);
	return na && (ta = Yi.lastIndexOf(na, ta - 1)), ta
}

function getInsertionAncestor(ue) {
	let Yi = ue;
	for (; Yi = Yi.parent;)
		if (isMatchable(Yi) && comparePathParserScore(ue, Yi) === 0) return Yi
}

function isMatchable({
	record: ue
}) {
	return !!(ue.name || ue.components && Object.keys(ue.components).length || ue.redirect)
}

function parseQuery(ue) {
	const Yi = {};
	if (ue === "" || ue === "?") return Yi;
	const ta = (ue[0] === "?" ? ue.slice(1) : ue).split("&");
	for (let na = 0; na < ta.length; ++na) {
		const ra = ta[na].replace(PLUS_RE, " "),
			ia = ra.indexOf("="),
			aa = decode$1(ia < 0 ? ra : ra.slice(0, ia)),
			oa = ia < 0 ? null : decode$1(ra.slice(ia + 1));
		if (aa in Yi) {
			let la = Yi[aa];
			isArray$3(la) || (la = Yi[aa] = [la]), la.push(oa)
		} else Yi[aa] = oa
	}
	return Yi
}

function stringifyQuery(ue) {
	let Yi = "";
	for (let ea in ue) {
		const ta = ue[ea];
		if (ea = encodeQueryKey(ea), ta == null) {
			ta !== void 0 && (Yi += (Yi.length ? "&" : "") + ea);
			continue
		}(isArray$3(ta) ? ta.map(ra => ra && encodeQueryValue(ra)) : [ta && encodeQueryValue(ta)]).forEach(ra => {
			ra !== void 0 && (Yi += (Yi.length ? "&" : "") + ea, ra != null && (Yi += "=" + ra))
		})
	}
	return Yi
}

function normalizeQuery(ue) {
	const Yi = {};
	for (const ea in ue) {
		const ta = ue[ea];
		ta !== void 0 && (Yi[ea] = isArray$3(ta) ? ta.map(na => na == null ? null : "" + na) : ta == null ? ta : "" + ta)
	}
	return Yi
}
const matchedRouteKey = Symbol(""),
	viewDepthKey = Symbol(""),
	routerKey = Symbol(""),
	routeLocationKey = Symbol(""),
	routerViewLocationKey = Symbol("");

function useCallbacks() {
	let ue = [];

	function Yi(ta) {
		return ue.push(ta), () => {
			const na = ue.indexOf(ta);
			na > -1 && ue.splice(na, 1)
		}
	}

	function ea() {
		ue = []
	}
	return {
		add: Yi,
		list: () => ue.slice(),
		reset: ea
	}
}

function guardToPromiseFn(ue, Yi, ea, ta, na, ra = ia => ia()) {
	const ia = ta && (ta.enterCallbacks[na] = ta.enterCallbacks[na] || []);
	return () => new Promise((aa, oa) => {
		const la = ua => {
				ua === !1 ? oa(createRouterError(4, {
					from: ea,
					to: Yi
				})) : ua instanceof Error ? oa(ua) : isRouteLocation(ua) ? oa(createRouterError(2, {
					from: Yi,
					to: ua
				})) : (ia && ta.enterCallbacks[na] === ia && typeof ua == "function" && ia.push(ua), aa())
			},
			sa = ra(() => ue.call(ta && ta.instances[na], Yi, ea, la));
		let ca = Promise.resolve(sa);
		ue.length < 3 && (ca = ca.then(la)), ca.catch(ua => oa(ua))
	})
}

function extractComponentsGuards(ue, Yi, ea, ta, na = ra => ra()) {
	const ra = [];
	for (const ia of ue)
		for (const aa in ia.components) {
			let oa = ia.components[aa];
			if (!(Yi !== "beforeRouteEnter" && !ia.instances[aa]))
				if (isRouteComponent(oa)) {
					const sa = (oa.__vccOpts || oa)[Yi];
					sa && ra.push(guardToPromiseFn(sa, ea, ta, ia, aa, na))
				} else {
					let la = oa();
					ra.push(() => la.then(sa => {
						if (!sa) throw new Error(`Couldn't resolve component "${aa}" at "${ia.path}"`);
						const ca = isESModule(sa) ? sa.default : sa;
						ia.mods[aa] = sa, ia.components[aa] = ca;
						const da = (ca.__vccOpts || ca)[Yi];
						return da && guardToPromiseFn(da, ea, ta, ia, aa, na)()
					}))
				}
		}
	return ra
}

function useLink(ue) {
	const Yi = inject(routerKey),
		ea = inject(routeLocationKey),
		ta = computed(() => {
			const oa = unref(ue.to);
			return Yi.resolve(oa)
		}),
		na = computed(() => {
			const {
				matched: oa
			} = ta.value, {
				length: la
			} = oa, sa = oa[la - 1], ca = ea.matched;
			if (!sa || !ca.length) return -1;
			const ua = ca.findIndex(isSameRouteRecord.bind(null, sa));
			if (ua > -1) return ua;
			const da = getOriginalPath(oa[la - 2]);
			return la > 1 && getOriginalPath(sa) === da && ca[ca.length - 1].path !== da ? ca.findIndex(isSameRouteRecord.bind(null, oa[la - 2])) : ua
		}),
		ra = computed(() => na.value > -1 && includesParams(ea.params, ta.value.params)),
		ia = computed(() => na.value > -1 && na.value === ea.matched.length - 1 && isSameRouteLocationParams(ea.params, ta.value.params));

	function aa(oa = {}) {
		return guardEvent(oa) ? Yi[unref(ue.replace) ? "replace" : "push"](unref(ue.to)).catch(noop$2) : Promise.resolve()
	}
	return {
		route: ta,
		href: computed(() => ta.value.href),
		isActive: ra,
		isExactActive: ia,
		navigate: aa
	}
}
const RouterLinkImpl = defineComponent({
		name: "RouterLink",
		compatConfig: {
			MODE: 3
		},
		props: {
			to: {
				type: [String, Object],
				required: !0
			},
			replace: Boolean,
			activeClass: String,
			exactActiveClass: String,
			custom: Boolean,
			ariaCurrentValue: {
				type: String,
				default: "page"
			}
		},
		useLink,
		setup(ue, {
			slots: Yi
		}) {
			const ea = reactive(useLink(ue)),
				{
					options: ta
				} = inject(routerKey),
				na = computed(() => ({
					[getLinkClass(ue.activeClass, ta.linkActiveClass, "router-link-active")]: ea.isActive,
					[getLinkClass(ue.exactActiveClass, ta.linkExactActiveClass, "router-link-exact-active")]: ea.isExactActive
				}));
			return () => {
				const ra = Yi.default && Yi.default(ea);
				return ue.custom ? ra : h$2("a", {
					"aria-current": ea.isExactActive ? ue.ariaCurrentValue : null,
					href: ea.href,
					onClick: ea.navigate,
					class: na.value
				}, ra)
			}
		}
	}),
	RouterLink = RouterLinkImpl;

function guardEvent(ue) {
	if (!(ue.metaKey || ue.altKey || ue.ctrlKey || ue.shiftKey) && !ue.defaultPrevented && !(ue.button !== void 0 && ue.button !== 0)) {
		if (ue.currentTarget && ue.currentTarget.getAttribute) {
			const Yi = ue.currentTarget.getAttribute("target");
			if (/\b_blank\b/i.test(Yi)) return
		}
		return ue.preventDefault && ue.preventDefault(), !0
	}
}

function includesParams(ue, Yi) {
	for (const ea in Yi) {
		const ta = Yi[ea],
			na = ue[ea];
		if (typeof ta == "string") {
			if (ta !== na) return !1
		} else if (!isArray$3(na) || na.length !== ta.length || ta.some((ra, ia) => ra !== na[ia])) return !1
	}
	return !0
}

function getOriginalPath(ue) {
	return ue ? ue.aliasOf ? ue.aliasOf.path : ue.path : ""
}
const getLinkClass = (ue, Yi, ea) => ue ?? Yi ?? ea,
	RouterViewImpl = defineComponent({
		name: "RouterView",
		inheritAttrs: !1,
		props: {
			name: {
				type: String,
				default: "default"
			},
			route: Object
		},
		compatConfig: {
			MODE: 3
		},
		setup(ue, {
			attrs: Yi,
			slots: ea
		}) {
			const ta = inject(routerViewLocationKey),
				na = computed(() => ue.route || ta.value),
				ra = inject(viewDepthKey, 0),
				ia = computed(() => {
					let la = unref(ra);
					const {
						matched: sa
					} = na.value;
					let ca;
					for (;
						(ca = sa[la]) && !ca.components;) la++;
					return la
				}),
				aa = computed(() => na.value.matched[ia.value]);
			provide(viewDepthKey, computed(() => ia.value + 1)), provide(matchedRouteKey, aa), provide(routerViewLocationKey, na);
			const oa = ref$1();
			return watch(() => [oa.value, aa.value, ue.name], ([la, sa, ca], [ua, da, ha]) => {
				sa && (sa.instances[ca] = la, da && da !== sa && la && la === ua && (sa.leaveGuards.size || (sa.leaveGuards = da.leaveGuards), sa.updateGuards.size || (sa.updateGuards = da.updateGuards))), la && sa && (!da || !isSameRouteRecord(sa, da) || !ua) && (sa.enterCallbacks[ca] || []).forEach(pa => pa(la))
			}, {
				flush: "post"
			}), () => {
				const la = na.value,
					sa = ue.name,
					ca = aa.value,
					ua = ca && ca.components[sa];
				if (!ua) return normalizeSlot(ea.default, {
					Component: ua,
					route: la
				});
				const da = ca.props[sa],
					ha = da ? da === !0 ? la.params : typeof da == "function" ? da(la) : da : null,
					va = h$2(ua, assign$1({}, ha, Yi, {
						onVnodeUnmounted: ba => {
							ba.component.isUnmounted && (ca.instances[sa] = null)
						},
						ref: oa
					}));
				return normalizeSlot(ea.default, {
					Component: va,
					route: la
				}) || va
			}
		}
	});

function normalizeSlot(ue, Yi) {
	if (!ue) return null;
	const ea = ue(Yi);
	return ea.length === 1 ? ea[0] : ea
}
const RouterView = RouterViewImpl;

function createRouter(ue) {
	const Yi = createRouterMatcher(ue.routes, ue),
		ea = ue.parseQuery || parseQuery,
		ta = ue.stringifyQuery || stringifyQuery,
		na = ue.history,
		ra = useCallbacks(),
		ia = useCallbacks(),
		aa = useCallbacks(),
		oa = shallowRef(START_LOCATION_NORMALIZED);
	let la = START_LOCATION_NORMALIZED;
	isBrowser$1 && ue.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
	const sa = applyToParams.bind(null, Ia => "" + Ia),
		ca = applyToParams.bind(null, encodeParam),
		ua = applyToParams.bind(null, decode$1);

	function da(Ia, Na) {
		let za, ro;
		return isRouteName(Ia) ? (za = Yi.getRecordMatcher(Ia), ro = Na) : ro = Ia, Yi.addRoute(ro, za)
	}

	function ha(Ia) {
		const Na = Yi.getRecordMatcher(Ia);
		Na && Yi.removeRoute(Na)
	}

	function pa() {
		return Yi.getRoutes().map(Ia => Ia.record)
	}

	function va(Ia) {
		return !!Yi.getRecordMatcher(Ia)
	}

	function ba(Ia, Na) {
		if (Na = assign$1({}, Na || oa.value), typeof Ia == "string") {
			const Ka = parseURL(ea, Ia, Na.path),
				lo = Yi.resolve({
					path: Ka.path
				}, Na),
				yo = na.createHref(Ka.fullPath);
			return assign$1(Ka, lo, {
				params: ua(lo.params),
				hash: decode$1(Ka.hash),
				redirectedFrom: void 0,
				href: yo
			})
		}
		let za;
		if (Ia.path != null) za = assign$1({}, Ia, {
			path: parseURL(ea, Ia.path, Na.path).path
		});
		else {
			const Ka = assign$1({}, Ia.params);
			for (const lo in Ka) Ka[lo] == null && delete Ka[lo];
			za = assign$1({}, Ia, {
				params: ca(Ka)
			}), Na.params = ca(Na.params)
		}
		const ro = Yi.resolve(za, Na),
			Va = Ia.hash || "";
		ro.params = sa(ua(ro.params));
		const Wa = stringifyURL(ta, assign$1({}, Ia, {
				hash: encodeHash(Va),
				path: ro.path
			})),
			qa = na.createHref(Wa);
		return assign$1({
			fullPath: Wa,
			hash: Va,
			query: ta === stringifyQuery ? normalizeQuery(Ia.query) : Ia.query || {}
		}, ro, {
			redirectedFrom: void 0,
			href: qa
		})
	}

	function Ea(Ia) {
		return typeof Ia == "string" ? parseURL(ea, Ia, oa.value.path) : assign$1({}, Ia)
	}

	function Sa(Ia, Na) {
		if (la !== Ia) return createRouterError(8, {
			from: Na,
			to: Ia
		})
	}

	function Ca(Ia) {
		return ja(Ia)
	}

	function ka(Ia) {
		return Ca(assign$1(Ea(Ia), {
			replace: !0
		}))
	}

	function Pa(Ia) {
		const Na = Ia.matched[Ia.matched.length - 1];
		if (Na && Na.redirect) {
			const {
				redirect: za
			} = Na;
			let ro = typeof za == "function" ? za(Ia) : za;
			return typeof ro == "string" && (ro = ro.includes("?") || ro.includes("#") ? ro = Ea(ro) : {
				path: ro
			}, ro.params = {}), assign$1({
				query: Ia.query,
				hash: Ia.hash,
				params: ro.path != null ? {} : Ia.params
			}, ro)
		}
	}

	function ja(Ia, Na) {
		const za = la = ba(Ia),
			ro = oa.value,
			Va = Ia.state,
			Wa = Ia.force,
			qa = Ia.replace === !0,
			Ka = Pa(za);
		if (Ka) return ja(assign$1(Ea(Ka), {
			state: typeof Ka == "object" ? assign$1({}, Va, Ka.state) : Va,
			force: Wa,
			replace: qa
		}), Na || za);
		const lo = za;
		lo.redirectedFrom = Na;
		let yo;
		return !Wa && isSameRouteLocation(ta, ro, za) && (yo = createRouterError(16, {
			to: lo,
			from: ro
		}), La(ro, ro, !0, !1)), (yo ? Promise.resolve(yo) : Ja(lo, ro)).catch(fo => isNavigationFailure(fo) ? isNavigationFailure(fo, 2) ? fo : Ta(fo) : Aa(fo, lo, ro)).then(fo => {
			if (fo) {
				if (isNavigationFailure(fo, 2)) return ja(assign$1({
					replace: qa
				}, Ea(fo.to), {
					state: typeof fo.to == "object" ? assign$1({}, Va, fo.to.state) : Va,
					force: Wa
				}), Na || lo)
			} else fo = xa(lo, ro, !0, qa, Va);
			return Ua(lo, ro, fo), fo
		})
	}

	function Za(Ia, Na) {
		const za = Sa(Ia, Na);
		return za ? Promise.reject(za) : Promise.resolve()
	}

	function Ga(Ia) {
		const Na = io.values().next().value;
		return Na && typeof Na.runWithContext == "function" ? Na.runWithContext(Ia) : Ia()
	}

	function Ja(Ia, Na) {
		let za;
		const [ro, Va, Wa] = extractChangingRecords(Ia, Na);
		za = extractComponentsGuards(ro.reverse(), "beforeRouteLeave", Ia, Na);
		for (const Ka of ro) Ka.leaveGuards.forEach(lo => {
			za.push(guardToPromiseFn(lo, Ia, Na))
		});
		const qa = Za.bind(null, Ia, Na);
		return za.push(qa), ao(za).then(() => {
			za = [];
			for (const Ka of ra.list()) za.push(guardToPromiseFn(Ka, Ia, Na));
			return za.push(qa), ao(za)
		}).then(() => {
			za = extractComponentsGuards(Va, "beforeRouteUpdate", Ia, Na);
			for (const Ka of Va) Ka.updateGuards.forEach(lo => {
				za.push(guardToPromiseFn(lo, Ia, Na))
			});
			return za.push(qa), ao(za)
		}).then(() => {
			za = [];
			for (const Ka of Wa)
				if (Ka.beforeEnter)
					if (isArray$3(Ka.beforeEnter))
						for (const lo of Ka.beforeEnter) za.push(guardToPromiseFn(lo, Ia, Na));
					else za.push(guardToPromiseFn(Ka.beforeEnter, Ia, Na));
			return za.push(qa), ao(za)
		}).then(() => (Ia.matched.forEach(Ka => Ka.enterCallbacks = {}), za = extractComponentsGuards(Wa, "beforeRouteEnter", Ia, Na, Ga), za.push(qa), ao(za))).then(() => {
			za = [];
			for (const Ka of ia.list()) za.push(guardToPromiseFn(Ka, Ia, Na));
			return za.push(qa), ao(za)
		}).catch(Ka => isNavigationFailure(Ka, 8) ? Ka : Promise.reject(Ka))
	}

	function Ua(Ia, Na, za) {
		aa.list().forEach(ro => Ga(() => ro(Ia, Na, za)))
	}

	function xa(Ia, Na, za, ro, Va) {
		const Wa = Sa(Ia, Na);
		if (Wa) return Wa;
		const qa = Na === START_LOCATION_NORMALIZED,
			Ka = isBrowser$1 ? history.state : {};
		za && (ro || qa ? na.replace(Ia.fullPath, assign$1({
			scroll: qa && Ka && Ka.scroll
		}, Va)) : na.push(Ia.fullPath, Va)), oa.value = Ia, La(Ia, Na, za, qa), Ta()
	}
	let ma;

	function fa() {
		ma || (ma = na.listen((Ia, Na, za) => {
			if (!oo.listening) return;
			const ro = ba(Ia),
				Va = Pa(ro);
			if (Va) {
				ja(assign$1(Va, {
					replace: !0
				}), ro).catch(noop$2);
				return
			}
			la = ro;
			const Wa = oa.value;
			isBrowser$1 && saveScrollPosition(getScrollKey(Wa.fullPath, za.delta), computeScrollPosition()), Ja(ro, Wa).catch(qa => isNavigationFailure(qa, 12) ? qa : isNavigationFailure(qa, 2) ? (ja(qa.to, ro).then(Ka => {
				isNavigationFailure(Ka, 20) && !za.delta && za.type === NavigationType.pop && na.go(-1, !1)
			}).catch(noop$2), Promise.reject()) : (za.delta && na.go(-za.delta, !1), Aa(qa, ro, Wa))).then(qa => {
				qa = qa || xa(ro, Wa, !1), qa && (za.delta && !isNavigationFailure(qa, 8) ? na.go(-za.delta, !1) : za.type === NavigationType.pop && isNavigationFailure(qa, 20) && na.go(-1, !1)), Ua(ro, Wa, qa)
			}).catch(noop$2)
		}))
	}
	let ga = useCallbacks(),
		wa = useCallbacks(),
		Ma;

	function Aa(Ia, Na, za) {
		Ta(Ia);
		const ro = wa.list();
		return ro.length ? ro.forEach(Va => Va(Ia, Na, za)) : console.error(Ia), Promise.reject(Ia)
	}

	function Ra() {
		return Ma && oa.value !== START_LOCATION_NORMALIZED ? Promise.resolve() : new Promise((Ia, Na) => {
			ga.add([Ia, Na])
		})
	}

	function Ta(Ia) {
		return Ma || (Ma = !Ia, fa(), ga.list().forEach(([Na, za]) => Ia ? za(Ia) : Na()), ga.reset()), Ia
	}

	function La(Ia, Na, za, ro) {
		const {
			scrollBehavior: Va
		} = ue;
		if (!isBrowser$1 || !Va) return Promise.resolve();
		const Wa = !za && getSavedScrollPosition(getScrollKey(Ia.fullPath, 0)) || (ro || !za) && history.state && history.state.scroll || null;
		return nextTick().then(() => Va(Ia, Na, Wa)).then(qa => qa && scrollToPosition(qa)).catch(qa => Aa(qa, Ia, Na))
	}
	const ya = Ia => na.go(Ia);
	let Ba;
	const io = new Set,
		oo = {
			currentRoute: oa,
			listening: !0,
			addRoute: da,
			removeRoute: ha,
			clearRoutes: Yi.clearRoutes,
			hasRoute: va,
			getRoutes: pa,
			resolve: ba,
			options: ue,
			push: Ca,
			replace: ka,
			go: ya,
			back: () => ya(-1),
			forward: () => ya(1),
			beforeEach: ra.add,
			beforeResolve: ia.add,
			afterEach: aa.add,
			onError: wa.add,
			isReady: Ra,
			install(Ia) {
				const Na = this;
				Ia.component("RouterLink", RouterLink), Ia.component("RouterView", RouterView), Ia.config.globalProperties.$router = Na, Object.defineProperty(Ia.config.globalProperties, "$route", {
					enumerable: !0,
					get: () => unref(oa)
				}), isBrowser$1 && !Ba && oa.value === START_LOCATION_NORMALIZED && (Ba = !0, Ca(na.location).catch(Va => {}));
				const za = {};
				for (const Va in START_LOCATION_NORMALIZED) Object.defineProperty(za, Va, {
					get: () => oa.value[Va],
					enumerable: !0
				});
				Ia.provide(routerKey, Na), Ia.provide(routeLocationKey, shallowReactive(za)), Ia.provide(routerViewLocationKey, oa);
				const ro = Ia.unmount;
				io.add(Ia), Ia.unmount = function() {
					io.delete(Ia), io.size < 1 && (la = START_LOCATION_NORMALIZED, ma && ma(), ma = null, oa.value = START_LOCATION_NORMALIZED, Ba = !1, Ma = !1), ro()
				}
			}
		};

	function ao(Ia) {
		return Ia.reduce((Na, za) => Na.then(() => Ga(za)), Promise.resolve())
	}
	return oo
}

function extractChangingRecords(ue, Yi) {
	const ea = [],
		ta = [],
		na = [],
		ra = Math.max(Yi.matched.length, ue.matched.length);
	for (let ia = 0; ia < ra; ia++) {
		const aa = Yi.matched[ia];
		aa && (ue.matched.find(la => isSameRouteRecord(la, aa)) ? ta.push(aa) : ea.push(aa));
		const oa = ue.matched[ia];
		oa && (Yi.matched.find(la => isSameRouteRecord(la, oa)) || na.push(oa))
	}
	return [ea, ta, na]
}
const interpolatePath = (ue, Yi) => Yi.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, ea => {
		var ta;
		return ((ta = ue.params[ea.slice(1)]) == null ? void 0 : ta.toString()) || ""
	}),
	generateRouteKey$1 = (ue, Yi) => {
		const ea = ue.route.matched.find(na => {
				var ra;
				return ((ra = na.components) == null ? void 0 : ra.default) === ue.Component.type
			}),
			ta = Yi ?? (ea == null ? void 0 : ea.meta.key) ?? (ea && interpolatePath(ue.route, ea));
		return typeof ta == "function" ? ta(ue.route) : ta
	},
	wrapInKeepAlive = (ue, Yi) => ({
		default: () => ue ? h$2(KeepAlive, ue === !0 ? {} : ue, Yi) : Yi
	});

function toArray$1(ue) {
	return Array.isArray(ue) ? ue : [ue]
}
const useStateKeyPrefix = "$s";

function useState(...ue) {
	const Yi = typeof ue[ue.length - 1] == "string" ? ue.pop() : void 0;
	typeof ue[0] != "string" && ue.unshift(Yi);
	const [ea, ta] = ue;
	if (!ea || typeof ea != "string") throw new TypeError("[nuxt] [useState] key must be a string: " + ea);
	if (ta !== void 0 && typeof ta != "function") throw new Error("[nuxt] [useState] init must be a function: " + ta);
	const na = useStateKeyPrefix + ea,
		ra = useNuxtApp(),
		ia = toRef(ra.payload.state, na);
	if (ia.value === void 0 && ta) {
		const aa = ta();
		if (isRef(aa)) return ra.payload.state[na] = aa, aa;
		ia.value = aa
	}
	return ia
}
const uuid = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, ue => {
		const Yi = Math.random() * 16 | 0;
		return (ue === "x" ? Yi : Yi & 3 | 8).toString(16)
	}),
	useLogger = () => {
		const ue = useState(() => uuid(), "$3ZR42Myp58"),
			Yi = useState(() => new Date().getTime(), "$k7XsdoM3cz"),
			ea = useNuxtApp().$sentry;
		return {
			_flow: {
				init: () => {
					ea && ea.setContext("session", {
						id: ue.value
					})
				}
			},
			configureUser: na => {
				ea && (na ? ea.setUser({
					id: na.id,
					username: na.username
				}) : ea.setUser(null))
			},
			getSessionId: () => ue.value,
			error: (na, ra) => {
				console.error(na, ra), ea && ea.captureException(new Error(na), {
					extra: ra
				})
			},
			warn: (na, ra) => {
				console.warn(na, ra), ea && ea.captureMessage(na, {
					level: "warning",
					extra: ra
				})
			},
			info: (na, ra) => {
				console.info(na, ra), ea && ea.captureMessage(na, {
					level: "info",
					extra: ra
				})
			},
			debug: (na, ra) => {
				console.debug(na, ra), ea && ea.captureMessage(na, {
					level: "debug",
					extra: ra
				})
			},
			getMsFromStart: () => new Date().getTime() - Yi.value
		}
	},
	err = (ue, Yi) => (useLogger().error(ue, Yi), showError({
		statusMessage: ue,
		fatal: !0
	})),
	scriptRel = "modulepreload",
	assetsURL = function(ue, Yi) {
		return new URL(ue, Yi).href
	},
	seen = {},
	__vitePreload = function(Yi, ea, ta) {
		let na = Promise.resolve();
		if (ea && ea.length > 0) {
			const ia = document.getElementsByTagName("link"),
				aa = document.querySelector("meta[property=csp-nonce]"),
				oa = (aa == null ? void 0 : aa.nonce) || (aa == null ? void 0 : aa.getAttribute("nonce"));
			na = Promise.allSettled(ea.map(la => {
				if (la = assetsURL(la, ta), la in seen) return;
				seen[la] = !0;
				const sa = la.endsWith(".css"),
					ca = sa ? '[rel="stylesheet"]' : "";
				if (!!ta)
					for (let ha = ia.length - 1; ha >= 0; ha--) {
						const pa = ia[ha];
						if (pa.href === la && (!sa || pa.rel === "stylesheet")) return
					} else if (document.querySelector(`link[href="${la}"]${ca}`)) return;
				const da = document.createElement("link");
				if (da.rel = sa ? "stylesheet" : scriptRel, sa || (da.as = "script"), da.crossOrigin = "", da.href = la, oa && da.setAttribute("nonce", oa), document.head.appendChild(da), sa) return new Promise((ha, pa) => {
					da.addEventListener("load", ha), da.addEventListener("error", () => pa(new Error(`Unable to preload CSS for ${la}`)))
				})
			}))
		}

		function ra(ia) {
			const aa = new Event("vite:preloadError", {
				cancelable: !0
			});
			if (aa.payload = ia, window.dispatchEvent(aa), !aa.defaultPrevented) throw ia
		}
		return na.then(ia => {
			for (const aa of ia || []) aa.status === "rejected" && ra(aa.reason);
			return Yi().catch(ra)
		})
	},
	__nuxt_page_meta$2 = {
		validate: () => useRuntimeConfig().public.ENVIRONMENT !== "prod"
	},
	__nuxt_page_meta$1 = {
		validate: () => !1
	},
	__nuxt_page_meta = {
		validate: ue => {
			const Yi = ue.params.slug;
			return Yi === void 0 || typeof Yi == "string" || Array.isArray(Yi) && Yi.length === 1
		}
	},
	_routes = [{
		name: "daily-reward",
		path: "/daily-reward",
		component: () => __vitePreload(() => import("./iLYf0Sq1.js"), __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8]), import.meta.url)
	}, {
		name: "debug",
		path: "/debug",
		meta: __nuxt_page_meta$2 || {},
		component: () => __vitePreload(() => import("./TmoCDlCt.js"), __vite__mapDeps([9, 10, 4, 5, 11]), import.meta.url)
	}, {
		name: "frens",
		path: "/frens",
		component: () => __vitePreload(() => import("./DOLXq3pz.js"), __vite__mapDeps([12, 13, 14, 1, 15, 16, 17, 18, 19, 20, 21, 22, 4, 5, 6, 7, 23, 24, 25, 26, 10, 27, 28, 29, 30, 31]), import.meta.url)
	}, {
		name: "game",
		path: "/game",
		component: () => __vitePreload(() => import("./Cer4ew5n.js"), __vite__mapDeps([32, 29, 18, 19, 30, 2, 3, 4, 5, 23, 24, 13, 14, 1, 15, 25, 26, 10, 27, 28, 33]), import.meta.url)
	}, {
		name: "index",
		path: "/",
		component: () => __vitePreload(() => import("./D7SOA-Jp.js"), __vite__mapDeps([34, 2, 3, 20, 21, 35, 36, 37, 13, 14, 1, 15, 38, 4, 5, 39, 40, 16, 17, 6, 7, 41]), import.meta.url)
	}, {
		name: "preview",
		path: "/preview",
		meta: __nuxt_page_meta$1 || {},
		component: () => __vitePreload(() => import("./BkffHi65.js"), __vite__mapDeps([42, 25, 4, 5, 14, 26, 43, 39, 40, 44, 18, 19, 45, 6, 7, 29, 30, 46, 47]), import.meta.url)
	}, {
		name: "tasks",
		path: "/tasks",
		component: () => __vitePreload(() => import("./DEH-KEtj.js"), __vite__mapDeps([48, 49, 4, 5, 6, 7, 50, 13, 14, 1, 15, 18, 19, 25, 26, 10, 44, 45, 51, 22, 36, 20, 21, 37, 52]), import.meta.url)
	}, {
		name: __nuxt_page_meta == null ? void 0 : __nuxt_page_meta.name,
		path: "/tribe/:slug(.*)*",
		meta: __nuxt_page_meta || {},
		component: () => __vitePreload(() => import("./Dds7imDr.js"), __vite__mapDeps([53, 54]), import.meta.url),
		children: [{
			name: "tribe-slug",
			path: "",
			component: () => __vitePreload(() => import("./Wc3ymD1D.js"), __vite__mapDeps([55, 20, 21, 35, 36, 37, 13, 14, 1, 15, 38, 56, 57, 4, 5, 25, 26, 58, 59, 60, 61, 62, 24, 10, 27, 18, 19, 63, 64, 65]), import.meta.url)
		}, {
			name: "tribe-slug-leaderboard",
			path: "leaderboard",
			component: () => __vitePreload(() => import("./Bd4Cy6he.js"), __vite__mapDeps([66, 59, 60, 61, 13, 14, 1, 15, 62, 67, 63, 20, 21, 64, 6, 7, 68, 69]), import.meta.url)
		}]
	}, {
		name: "tribe-join",
		path: "/tribe/join",
		component: () => __vitePreload(() => import("./COaImu1A.js"), __vite__mapDeps([70, 57, 4, 5, 25, 14, 26, 58, 71, 72, 35, 36, 20, 21, 37, 13, 1, 15, 38, 60, 61, 73, 74, 56, 49, 6, 7, 50, 18, 19, 75, 10, 76, 29, 30, 77]), import.meta.url)
	}, {
		name: "tribe-join-list",
		path: "/tribe/join/list",
		component: () => __vitePreload(() => import("./Ci9s3BIe.js"), __vite__mapDeps([78, 63, 20, 21, 64, 18, 19, 13, 14, 1, 15, 72, 35, 36, 37, 38, 60, 61, 73, 29, 30, 79]), import.meta.url)
	}, {
		name: "tribe-join-new",
		path: "/tribe/join/new",
		component: () => __vitePreload(() => import("./BpA4NLmK.js"), __vite__mapDeps([80, 75, 10, 76, 44, 18, 19, 14, 45, 4, 5, 6, 7, 13, 1, 15, 29, 30, 81]), import.meta.url)
	}, {
		name: "tribe-top",
		path: "/tribe/top",
		component: () => __vitePreload(() => import("./BodZrVwd.js"), __vite__mapDeps([82, 71, 72, 35, 36, 20, 21, 37, 13, 14, 1, 15, 38, 60, 61, 73, 74, 67, 63, 64, 6, 7, 68, 83]), import.meta.url)
	}, {
		name: "wallet-id",
		path: "/wallet/:id()",
		component: () => __vitePreload(() => import("./T8wHmvvD.js"), __vite__mapDeps([84, 29, 18, 19, 30, 85, 15, 56, 86, 20, 21, 87]), import.meta.url)
	}, {
		name: "wallet",
		path: "/wallet",
		component: () => __vitePreload(() => import("./BRN8SaId.js"), __vite__mapDeps([88, 29, 18, 19, 30, 49, 4, 5, 6, 7, 50, 13, 14, 1, 15, 51, 85, 56, 86, 25, 26, 20, 21, 89]), import.meta.url)
	}, {
		name: "welcome",
		path: "/welcome",
		component: () => __vitePreload(() => import("./4gvLoaua.js"), __vite__mapDeps([90, 43, 39, 14, 40, 4, 5, 25, 26, 44, 18, 19, 45, 6, 7, 29, 30, 46, 91]), import.meta.url)
	}],
	_wrapIf = (ue, Yi, ea) => (Yi = Yi === !0 ? {} : Yi, {
		default: () => {
			var ta;
			return Yi ? h$2(ue, Yi, ea) : (ta = ea.default) == null ? void 0 : ta.call(ea)
		}
	});

function generateRouteKey(ue) {
	const Yi = (ue == null ? void 0 : ue.meta.key) ?? ue.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, ea => {
		var ta;
		return ((ta = ue.params[ea.slice(1)]) == null ? void 0 : ta.toString()) || ""
	});
	return typeof Yi == "function" ? Yi(ue) : Yi
}

function isChangingPage(ue, Yi) {
	return ue === Yi || Yi === START_LOCATION_NORMALIZED ? !1 : generateRouteKey(ue) !== generateRouteKey(Yi) ? !0 : !ue.matched.every((ta, na) => {
		var ra, ia;
		return ta.components && ta.components.default === ((ia = (ra = Yi.matched[na]) == null ? void 0 : ra.components) == null ? void 0 : ia.default)
	})
}
const routerOptions0 = {
	scrollBehavior(ue, Yi, ea) {
		var la;
		const ta = useNuxtApp(),
			na = ((la = useRouter().options) == null ? void 0 : la.scrollBehaviorType) ?? "auto";
		let ra = ea || void 0;
		const ia = typeof ue.meta.scrollToTop == "function" ? ue.meta.scrollToTop(ue, Yi) : ue.meta.scrollToTop;
		if (!ra && Yi && ue && ia !== !1 && isChangingPage(ue, Yi) && (ra = {
				left: 0,
				top: 0
			}), ue.path === Yi.path) return Yi.hash && !ue.hash ? {
			left: 0,
			top: 0
		} : ue.hash ? {
			el: ue.hash,
			top: _getHashElementScrollMarginTop(ue.hash),
			behavior: na
		} : !1;
		const aa = sa => !!(sa.meta.pageTransition ?? appPageTransition),
			oa = aa(Yi) && aa(ue) ? "page:transition:finish" : "page:finish";
		return new Promise(sa => {
			ta.hooks.hookOnce(oa, async () => {
				await new Promise(ca => setTimeout(ca, 0)), ue.hash && (ra = {
					el: ue.hash,
					top: _getHashElementScrollMarginTop(ue.hash),
					behavior: na
				}), sa(ra)
			})
		})
	}
};

function _getHashElementScrollMarginTop(ue) {
	try {
		const Yi = document.querySelector(ue);
		if (Yi) return (Number.parseFloat(getComputedStyle(Yi).scrollMarginTop) || 0) + (Number.parseFloat(getComputedStyle(document.documentElement).scrollPaddingTop) || 0)
	} catch {}
	return 0
}
const configRouterOptions = {
		hashMode: !1,
		scrollBehaviorType: "auto"
	},
	routerOptions = {
		...configRouterOptions,
		...routerOptions0
	},
	validate = async ue => {
		var oa;
		let Yi, ea;
		if (!((oa = ue.meta) != null && oa.validate)) return;
		const ta = useNuxtApp(),
			na = useRouter(),
			ra = ([Yi, ea] = executeAsync(() => Promise.resolve(ue.meta.validate(ue))), Yi = await Yi, ea(), Yi);
		if (ra === !0) return;
		const ia = createError({
				statusCode: ra && ra.statusCode || 404,
				statusMessage: ra && ra.statusMessage || `Page Not Found: ${ue.fullPath}`,
				data: {
					path: ue.fullPath
				}
			}),
			aa = na.beforeResolve(la => {
				if (aa(), la === ue) {
					const sa = na.afterEach(async () => {
						sa(), await ta.runWithContext(() => showError(ia)), window == null || window.history.pushState({}, "", ue.fullPath)
					});
					return !1
				}
			})
	};
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function getDefaultExportFromCjs$1(ue) {
	return ue && ue.__esModule && Object.prototype.hasOwnProperty.call(ue, "default") ? ue.default : ue
}

function getAugmentedNamespace(ue) {
	if (ue.__esModule) return ue;
	var Yi = ue.default;
	if (typeof Yi == "function") {
		var ea = function ta() {
			return this instanceof ta ? Reflect.construct(Yi, arguments, this.constructor) : Yi.apply(this, arguments)
		};
		ea.prototype = Yi.prototype
	} else ea = {};
	return Object.defineProperty(ea, "__esModule", {
		value: !0
	}), Object.keys(ue).forEach(function(ta) {
		var na = Object.getOwnPropertyDescriptor(ue, ta);
		Object.defineProperty(ea, ta, na.get ? na : {
			enumerable: !0,
			get: function() {
				return ue[ta]
			}
		})
	}), ea
}
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect$1;
(function(ue) {
	(function(Yi) {
		var ea = typeof globalThis == "object" ? globalThis : typeof commonjsGlobal == "object" ? commonjsGlobal : typeof self == "object" ? self : typeof this == "object" ? this : aa(),
			ta = na(ue);
		typeof ea.Reflect < "u" && (ta = na(ea.Reflect, ta)), Yi(ta, ea), typeof ea.Reflect > "u" && (ea.Reflect = ue);

		function na(oa, la) {
			return function(sa, ca) {
				Object.defineProperty(oa, sa, {
					configurable: !0,
					writable: !0,
					value: ca
				}), la && la(sa, ca)
			}
		}

		function ra() {
			try {
				return Function("return this;")()
			} catch {}
		}

		function ia() {
			try {
				return (0, eval)("(function() { return this; })()")
			} catch {}
		}

		function aa() {
			return ra() || ia()
		}
	})(function(Yi, ea) {
		var ta = Object.prototype.hasOwnProperty,
			na = typeof Symbol == "function",
			ra = na && typeof Symbol.toPrimitive < "u" ? Symbol.toPrimitive : "@@toPrimitive",
			ia = na && typeof Symbol.iterator < "u" ? Symbol.iterator : "@@iterator",
			aa = typeof Object.create == "function",
			oa = {
				__proto__: []
			}
		instanceof Array, la = !aa && !oa, sa = {
			create: aa ? function() {
				return eo(Object.create(null))
			} : oa ? function() {
				return eo({
					__proto__: null
				})
			} : function() {
				return eo({})
			},
			has: la ? function(Oa, Da) {
				return ta.call(Oa, Da)
			} : function(Oa, Da) {
				return Da in Oa
			},
			get: la ? function(Oa, Da) {
				return ta.call(Oa, Da) ? Oa[Da] : void 0
			} : function(Oa, Da) {
				return Oa[Da]
			}
		}, ca = Object.getPrototypeOf(Function), ua = typeof Map == "function" && typeof Map.prototype.entries == "function" ? Map : Lo(), da = typeof Set == "function" && typeof Set.prototype.entries == "function" ? Set : Fo(), ha = typeof WeakMap == "function" ? WeakMap : jo(), pa = na ? Symbol.for("@reflect-metadata:registry") : void 0, va = Eo(), ba = wo(va);

		function Ea(Oa, Da, Qa, uo) {
			if (ya(Qa)) {
				if (!Va(Oa)) throw new TypeError;
				if (!qa(Da)) throw new TypeError;
				return xa(Oa, Da)
			} else {
				if (!Va(Oa)) throw new TypeError;
				if (!oo(Da)) throw new TypeError;
				if (!oo(uo) && !ya(uo) && !Ba(uo)) throw new TypeError;
				return Ba(uo) && (uo = void 0), Qa = ro(Qa), ma(Oa, Da, Qa, uo)
			}
		}
		Yi("decorate", Ea);

		function Sa(Oa, Da) {
			function Qa(uo, bo) {
				if (!oo(uo)) throw new TypeError;
				if (!ya(bo) && !Ka(bo)) throw new TypeError;
				Aa(Oa, Da, uo, bo)
			}
			return Qa
		}
		Yi("metadata", Sa);

		function Ca(Oa, Da, Qa, uo) {
			if (!oo(Qa)) throw new TypeError;
			return ya(uo) || (uo = ro(uo)), Aa(Oa, Da, Qa, uo)
		}
		Yi("defineMetadata", Ca);

		function ka(Oa, Da, Qa) {
			if (!oo(Da)) throw new TypeError;
			return ya(Qa) || (Qa = ro(Qa)), fa(Oa, Da, Qa)
		}
		Yi("hasMetadata", ka);

		function Pa(Oa, Da, Qa) {
			if (!oo(Da)) throw new TypeError;
			return ya(Qa) || (Qa = ro(Qa)), ga(Oa, Da, Qa)
		}
		Yi("hasOwnMetadata", Pa);

		function ja(Oa, Da, Qa) {
			if (!oo(Da)) throw new TypeError;
			return ya(Qa) || (Qa = ro(Qa)), wa(Oa, Da, Qa)
		}
		Yi("getMetadata", ja);

		function Za(Oa, Da, Qa) {
			if (!oo(Da)) throw new TypeError;
			return ya(Qa) || (Qa = ro(Qa)), Ma(Oa, Da, Qa)
		}
		Yi("getOwnMetadata", Za);

		function Ga(Oa, Da) {
			if (!oo(Oa)) throw new TypeError;
			return ya(Da) || (Da = ro(Da)), Ra(Oa, Da)
		}
		Yi("getMetadataKeys", Ga);

		function Ja(Oa, Da) {
			if (!oo(Oa)) throw new TypeError;
			return ya(Da) || (Da = ro(Da)), Ta(Oa, Da)
		}
		Yi("getOwnMetadataKeys", Ja);

		function Ua(Oa, Da, Qa) {
			if (!oo(Da)) throw new TypeError;
			if (ya(Qa) || (Qa = ro(Qa)), !oo(Da)) throw new TypeError;
			ya(Qa) || (Qa = ro(Qa));
			var uo = _o(Da, Qa, !1);
			return ya(uo) ? !1 : uo.OrdinaryDeleteMetadata(Oa, Da, Qa)
		}
		Yi("deleteMetadata", Ua);

		function xa(Oa, Da) {
			for (var Qa = Oa.length - 1; Qa >= 0; --Qa) {
				var uo = Oa[Qa],
					bo = uo(Da);
				if (!ya(bo) && !Ba(bo)) {
					if (!qa(bo)) throw new TypeError;
					Da = bo
				}
			}
			return Da
		}

		function ma(Oa, Da, Qa, uo) {
			for (var bo = Oa.length - 1; bo >= 0; --bo) {
				var So = Oa[bo],
					Wo = So(Da, Qa, uo);
				if (!ya(Wo) && !Ba(Wo)) {
					if (!oo(Wo)) throw new TypeError;
					uo = Wo
				}
			}
			return uo
		}

		function fa(Oa, Da, Qa) {
			var uo = ga(Oa, Da, Qa);
			if (uo) return !0;
			var bo = to(Da);
			return Ba(bo) ? !1 : fa(Oa, bo, Qa)
		}

		function ga(Oa, Da, Qa) {
			var uo = _o(Da, Qa, !1);
			return ya(uo) ? !1 : Na(uo.OrdinaryHasOwnMetadata(Oa, Da, Qa))
		}

		function wa(Oa, Da, Qa) {
			var uo = ga(Oa, Da, Qa);
			if (uo) return Ma(Oa, Da, Qa);
			var bo = to(Da);
			if (!Ba(bo)) return wa(Oa, bo, Qa)
		}

		function Ma(Oa, Da, Qa) {
			var uo = _o(Da, Qa, !1);
			if (!ya(uo)) return uo.OrdinaryGetOwnMetadata(Oa, Da, Qa)
		}

		function Aa(Oa, Da, Qa, uo) {
			var bo = _o(Qa, uo, !0);
			bo.OrdinaryDefineOwnMetadata(Oa, Da, Qa, uo)
		}

		function Ra(Oa, Da) {
			var Qa = Ta(Oa, Da),
				uo = to(Oa);
			if (uo === null) return Qa;
			var bo = Ra(uo, Da);
			if (bo.length <= 0) return Qa;
			if (Qa.length <= 0) return bo;
			for (var So = new da, Wo = [], Po = 0, Ro = Qa; Po < Ro.length; Po++) {
				var Ho = Ro[Po],
					Oo = So.has(Ho);
				Oo || (So.add(Ho), Wo.push(Ho))
			}
			for (var No = 0, ps = bo; No < ps.length; No++) {
				var Ho = ps[No],
					Oo = So.has(Ho);
				Oo || (So.add(Ho), Wo.push(Ho))
			}
			return Wo
		}

		function Ta(Oa, Da) {
			var Qa = _o(Oa, Da, !1);
			return Qa ? Qa.OrdinaryOwnMetadataKeys(Oa, Da) : []
		}

		function La(Oa) {
			if (Oa === null) return 1;
			switch (typeof Oa) {
				case "undefined":
					return 0;
				case "boolean":
					return 2;
				case "string":
					return 3;
				case "symbol":
					return 4;
				case "number":
					return 5;
				case "object":
					return Oa === null ? 1 : 6;
				default:
					return 6
			}
		}

		function ya(Oa) {
			return Oa === void 0
		}

		function Ba(Oa) {
			return Oa === null
		}

		function io(Oa) {
			return typeof Oa == "symbol"
		}

		function oo(Oa) {
			return typeof Oa == "object" ? Oa !== null : typeof Oa == "function"
		}

		function ao(Oa, Da) {
			switch (La(Oa)) {
				case 0:
					return Oa;
				case 1:
					return Oa;
				case 2:
					return Oa;
				case 3:
					return Oa;
				case 4:
					return Oa;
				case 5:
					return Oa
			}
			var Qa = "string",
				uo = yo(Oa, ra);
			if (uo !== void 0) {
				var bo = uo.call(Oa, Qa);
				if (oo(bo)) throw new TypeError;
				return bo
			}
			return Ia(Oa)
		}

		function Ia(Oa, Da) {
			var Qa, uo;
			{
				var bo = Oa.toString;
				if (Wa(bo)) {
					var uo = bo.call(Oa);
					if (!oo(uo)) return uo
				}
				var Qa = Oa.valueOf;
				if (Wa(Qa)) {
					var uo = Qa.call(Oa);
					if (!oo(uo)) return uo
				}
			}
			throw new TypeError
		}

		function Na(Oa) {
			return !!Oa
		}

		function za(Oa) {
			return "" + Oa
		}

		function ro(Oa) {
			var Da = ao(Oa);
			return io(Da) ? Da : za(Da)
		}

		function Va(Oa) {
			return Array.isArray ? Array.isArray(Oa) : Oa instanceof Object ? Oa instanceof Array : Object.prototype.toString.call(Oa) === "[object Array]"
		}

		function Wa(Oa) {
			return typeof Oa == "function"
		}

		function qa(Oa) {
			return typeof Oa == "function"
		}

		function Ka(Oa) {
			switch (La(Oa)) {
				case 3:
					return !0;
				case 4:
					return !0;
				default:
					return !1
			}
		}

		function lo(Oa, Da) {
			return Oa === Da || Oa !== Oa && Da !== Da
		}

		function yo(Oa, Da) {
			var Qa = Oa[Da];
			if (Qa != null) {
				if (!Wa(Qa)) throw new TypeError;
				return Qa
			}
		}

		function fo(Oa) {
			var Da = yo(Oa, ia);
			if (!Wa(Da)) throw new TypeError;
			var Qa = Da.call(Oa);
			if (!oo(Qa)) throw new TypeError;
			return Qa
		}

		function vo(Oa) {
			return Oa.value
		}

		function so(Oa) {
			var Da = Oa.next();
			return Da.done ? !1 : Da
		}

		function Xa(Oa) {
			var Da = Oa.return;
			Da && Da.call(Oa)
		}

		function to(Oa) {
			var Da = Object.getPrototypeOf(Oa);
			if (typeof Oa != "function" || Oa === ca || Da !== ca) return Da;
			var Qa = Oa.prototype,
				uo = Qa && Object.getPrototypeOf(Qa);
			if (uo == null || uo === Object.prototype) return Da;
			var bo = uo.constructor;
			return typeof bo != "function" || bo === Oa ? Da : bo
		}

		function ho() {
			var Oa;
			!ya(pa) && typeof ea.Reflect < "u" && !(pa in ea.Reflect) && typeof ea.Reflect.defineMetadata == "function" && (Oa = Ao(ea.Reflect));
			var Da, Qa, uo, bo = new ha,
				So = {
					registerProvider: Wo,
					getProvider: Ro,
					setProvider: Oo
				};
			return So;

			function Wo(No) {
				if (!Object.isExtensible(So)) throw new Error("Cannot add provider to a frozen registry.");
				switch (!0) {
					case Oa === No:
						break;
					case ya(Da):
						Da = No;
						break;
					case Da === No:
						break;
					case ya(Qa):
						Qa = No;
						break;
					case Qa === No:
						break;
					default:
						uo === void 0 && (uo = new da), uo.add(No);
						break
				}
			}

			function Po(No, ps) {
				if (!ya(Da)) {
					if (Da.isProviderFor(No, ps)) return Da;
					if (!ya(Qa)) {
						if (Qa.isProviderFor(No, ps)) return Da;
						if (!ya(uo))
							for (var Ko = fo(uo);;) {
								var Go = so(Ko);
								if (!Go) return;
								var bs = vo(Go);
								if (bs.isProviderFor(No, ps)) return Xa(Ko), bs
							}
					}
				}
				if (!ya(Oa) && Oa.isProviderFor(No, ps)) return Oa
			}

			function Ro(No, ps) {
				var Ko = bo.get(No),
					Go;
				return ya(Ko) || (Go = Ko.get(ps)), ya(Go) && (Go = Po(No, ps), ya(Go) || (ya(Ko) && (Ko = new ua, bo.set(No, Ko)), Ko.set(ps, Go))), Go
			}

			function Ho(No) {
				if (ya(No)) throw new TypeError;
				return Da === No || Qa === No || !ya(uo) && uo.has(No)
			}

			function Oo(No, ps, Ko) {
				if (!Ho(Ko)) throw new Error("Metadata provider not registered.");
				var Go = Ro(No, ps);
				if (Go !== Ko) {
					if (!ya(Go)) return !1;
					var bs = bo.get(No);
					ya(bs) && (bs = new ua, bo.set(No, bs)), bs.set(ps, Ko)
				}
				return !0
			}
		}

		function Eo() {
			var Oa;
			return !ya(pa) && oo(ea.Reflect) && Object.isExtensible(ea.Reflect) && (Oa = ea.Reflect[pa]), ya(Oa) && (Oa = ho()), !ya(pa) && oo(ea.Reflect) && Object.isExtensible(ea.Reflect) && Object.defineProperty(ea.Reflect, pa, {
				enumerable: !1,
				configurable: !1,
				writable: !1,
				value: Oa
			}), Oa
		}

		function wo(Oa) {
			var Da = new ha,
				Qa = {
					isProviderFor: function(Ho, Oo) {
						var No = Da.get(Ho);
						return ya(No) ? !1 : No.has(Oo)
					},
					OrdinaryDefineOwnMetadata: Wo,
					OrdinaryHasOwnMetadata: bo,
					OrdinaryGetOwnMetadata: So,
					OrdinaryOwnMetadataKeys: Po,
					OrdinaryDeleteMetadata: Ro
				};
			return va.registerProvider(Qa), Qa;

			function uo(Ho, Oo, No) {
				var ps = Da.get(Ho),
					Ko = !1;
				if (ya(ps)) {
					if (!No) return;
					ps = new ua, Da.set(Ho, ps), Ko = !0
				}
				var Go = ps.get(Oo);
				if (ya(Go)) {
					if (!No) return;
					if (Go = new ua, ps.set(Oo, Go), !Oa.setProvider(Ho, Oo, Qa)) throw ps.delete(Oo), Ko && Da.delete(Ho), new Error("Wrong provider for target.")
				}
				return Go
			}

			function bo(Ho, Oo, No) {
				var ps = uo(Oo, No, !1);
				return ya(ps) ? !1 : Na(ps.has(Ho))
			}

			function So(Ho, Oo, No) {
				var ps = uo(Oo, No, !1);
				if (!ya(ps)) return ps.get(Ho)
			}

			function Wo(Ho, Oo, No, ps) {
				var Ko = uo(No, ps, !0);
				Ko.set(Ho, Oo)
			}

			function Po(Ho, Oo) {
				var No = [],
					ps = uo(Ho, Oo, !1);
				if (ya(ps)) return No;
				for (var Ko = ps.keys(), Go = fo(Ko), bs = 0;;) {
					var vs = so(Go);
					if (!vs) return No.length = bs, No;
					var ls = vo(vs);
					try {
						No[bs] = ls
					} catch (Es) {
						try {
							Xa(Go)
						} finally {
							throw Es
						}
					}
					bs++
				}
			}

			function Ro(Ho, Oo, No) {
				var ps = uo(Oo, No, !1);
				if (ya(ps) || !ps.delete(Ho)) return !1;
				if (ps.size === 0) {
					var Ko = Da.get(Oo);
					ya(Ko) || (Ko.delete(No), Ko.size === 0 && Da.delete(Ko))
				}
				return !0
			}
		}

		function Ao(Oa) {
			var Da = Oa.defineMetadata,
				Qa = Oa.hasOwnMetadata,
				uo = Oa.getOwnMetadata,
				bo = Oa.getOwnMetadataKeys,
				So = Oa.deleteMetadata,
				Wo = new ha,
				Po = {
					isProviderFor: function(Ro, Ho) {
						var Oo = Wo.get(Ro);
						return !ya(Oo) && Oo.has(Ho) ? !0 : bo(Ro, Ho).length ? (ya(Oo) && (Oo = new da, Wo.set(Ro, Oo)), Oo.add(Ho), !0) : !1
					},
					OrdinaryDefineOwnMetadata: Da,
					OrdinaryHasOwnMetadata: Qa,
					OrdinaryGetOwnMetadata: uo,
					OrdinaryOwnMetadataKeys: bo,
					OrdinaryDeleteMetadata: So
				};
			return Po
		}

		function _o(Oa, Da, Qa) {
			var uo = va.getProvider(Oa, Da);
			if (!ya(uo)) return uo;
			if (Qa) {
				if (va.setProvider(Oa, Da, ba)) return ba;
				throw new Error("Illegal state.")
			}
		}

		function Lo() {
			var Oa = {},
				Da = [],
				Qa = function() {
					function Po(Ro, Ho, Oo) {
						this._index = 0, this._keys = Ro, this._values = Ho, this._selector = Oo
					}
					return Po.prototype["@@iterator"] = function() {
						return this
					}, Po.prototype[ia] = function() {
						return this
					}, Po.prototype.next = function() {
						var Ro = this._index;
						if (Ro >= 0 && Ro < this._keys.length) {
							var Ho = this._selector(this._keys[Ro], this._values[Ro]);
							return Ro + 1 >= this._keys.length ? (this._index = -1, this._keys = Da, this._values = Da) : this._index++, {
								value: Ho,
								done: !1
							}
						}
						return {
							value: void 0,
							done: !0
						}
					}, Po.prototype.throw = function(Ro) {
						throw this._index >= 0 && (this._index = -1, this._keys = Da, this._values = Da), Ro
					}, Po.prototype.return = function(Ro) {
						return this._index >= 0 && (this._index = -1, this._keys = Da, this._values = Da), {
							value: Ro,
							done: !0
						}
					}, Po
				}(),
				uo = function() {
					function Po() {
						this._keys = [], this._values = [], this._cacheKey = Oa, this._cacheIndex = -2
					}
					return Object.defineProperty(Po.prototype, "size", {
						get: function() {
							return this._keys.length
						},
						enumerable: !0,
						configurable: !0
					}), Po.prototype.has = function(Ro) {
						return this._find(Ro, !1) >= 0
					}, Po.prototype.get = function(Ro) {
						var Ho = this._find(Ro, !1);
						return Ho >= 0 ? this._values[Ho] : void 0
					}, Po.prototype.set = function(Ro, Ho) {
						var Oo = this._find(Ro, !0);
						return this._values[Oo] = Ho, this
					}, Po.prototype.delete = function(Ro) {
						var Ho = this._find(Ro, !1);
						if (Ho >= 0) {
							for (var Oo = this._keys.length, No = Ho + 1; No < Oo; No++) this._keys[No - 1] = this._keys[No], this._values[No - 1] = this._values[No];
							return this._keys.length--, this._values.length--, lo(Ro, this._cacheKey) && (this._cacheKey = Oa, this._cacheIndex = -2), !0
						}
						return !1
					}, Po.prototype.clear = function() {
						this._keys.length = 0, this._values.length = 0, this._cacheKey = Oa, this._cacheIndex = -2
					}, Po.prototype.keys = function() {
						return new Qa(this._keys, this._values, bo)
					}, Po.prototype.values = function() {
						return new Qa(this._keys, this._values, So)
					}, Po.prototype.entries = function() {
						return new Qa(this._keys, this._values, Wo)
					}, Po.prototype["@@iterator"] = function() {
						return this.entries()
					}, Po.prototype[ia] = function() {
						return this.entries()
					}, Po.prototype._find = function(Ro, Ho) {
						if (!lo(this._cacheKey, Ro)) {
							this._cacheIndex = -1;
							for (var Oo = 0; Oo < this._keys.length; Oo++)
								if (lo(this._keys[Oo], Ro)) {
									this._cacheIndex = Oo;
									break
								}
						}
						return this._cacheIndex < 0 && Ho && (this._cacheIndex = this._keys.length, this._keys.push(Ro), this._values.push(void 0)), this._cacheIndex
					}, Po
				}();
			return uo;

			function bo(Po, Ro) {
				return Po
			}

			function So(Po, Ro) {
				return Ro
			}

			function Wo(Po, Ro) {
				return [Po, Ro]
			}
		}

		function Fo() {
			var Oa = function() {
				function Da() {
					this._map = new ua
				}
				return Object.defineProperty(Da.prototype, "size", {
					get: function() {
						return this._map.size
					},
					enumerable: !0,
					configurable: !0
				}), Da.prototype.has = function(Qa) {
					return this._map.has(Qa)
				}, Da.prototype.add = function(Qa) {
					return this._map.set(Qa, Qa), this
				}, Da.prototype.delete = function(Qa) {
					return this._map.delete(Qa)
				}, Da.prototype.clear = function() {
					this._map.clear()
				}, Da.prototype.keys = function() {
					return this._map.keys()
				}, Da.prototype.values = function() {
					return this._map.keys()
				}, Da.prototype.entries = function() {
					return this._map.entries()
				}, Da.prototype["@@iterator"] = function() {
					return this.keys()
				}, Da.prototype[ia] = function() {
					return this.keys()
				}, Da
			}();
			return Oa
		}

		function jo() {
			var Oa = 16,
				Da = sa.create(),
				Qa = uo();
			return function() {
				function Ro() {
					this._key = uo()
				}
				return Ro.prototype.has = function(Ho) {
					var Oo = bo(Ho, !1);
					return Oo !== void 0 ? sa.has(Oo, this._key) : !1
				}, Ro.prototype.get = function(Ho) {
					var Oo = bo(Ho, !1);
					return Oo !== void 0 ? sa.get(Oo, this._key) : void 0
				}, Ro.prototype.set = function(Ho, Oo) {
					var No = bo(Ho, !0);
					return No[this._key] = Oo, this
				}, Ro.prototype.delete = function(Ho) {
					var Oo = bo(Ho, !1);
					return Oo !== void 0 ? delete Oo[this._key] : !1
				}, Ro.prototype.clear = function() {
					this._key = uo()
				}, Ro
			}();

			function uo() {
				var Ro;
				do Ro = "@@WeakMap@@" + Po(); while (sa.has(Da, Ro));
				return Da[Ro] = !0, Ro
			}

			function bo(Ro, Ho) {
				if (!ta.call(Ro, Qa)) {
					if (!Ho) return;
					Object.defineProperty(Ro, Qa, {
						value: sa.create()
					})
				}
				return Ro[Qa]
			}

			function So(Ro, Ho) {
				for (var Oo = 0; Oo < Ho; ++Oo) Ro[Oo] = Math.random() * 255 | 0;
				return Ro
			}

			function Wo(Ro) {
				if (typeof Uint8Array == "function") {
					var Ho = new Uint8Array(Ro);
					return typeof crypto < "u" ? crypto.getRandomValues(Ho) : typeof msCrypto < "u" ? msCrypto.getRandomValues(Ho) : So(Ho, Ro), Ho
				}
				return So(new Array(Ro), Ro)
			}

			function Po() {
				var Ro = Wo(Oa);
				Ro[6] = Ro[6] & 79 | 64, Ro[8] = Ro[8] & 191 | 128;
				for (var Ho = "", Oo = 0; Oo < Oa; ++Oo) {
					var No = Ro[Oo];
					(Oo === 4 || Oo === 6 || Oo === 8) && (Ho += "-"), No < 16 && (Ho += "0"), Ho += No.toString(16).toLowerCase()
				}
				return Ho
			}
		}

		function eo(Oa) {
			return Oa.__ = void 0, delete Oa.__, Oa
		}
	})
})(Reflect$1 || (Reflect$1 = {}));

function getDefaultExportFromCjs(ue) {
	return ue && ue.__esModule && Object.prototype.hasOwnProperty.call(ue, "default") ? ue.default : ue
}
var browser$d = {
		exports: {}
	},
	process = browser$d.exports = {},
	cachedSetTimeout, cachedClearTimeout;

function defaultSetTimout() {
	throw new Error("setTimeout has not been defined")
}

function defaultClearTimeout() {
	throw new Error("clearTimeout has not been defined")
}(function() {
	try {
		typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout
	} catch {
		cachedSetTimeout = defaultSetTimout
	}
	try {
		typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout
	} catch {
		cachedClearTimeout = defaultClearTimeout
	}
})();

function runTimeout(ue) {
	if (cachedSetTimeout === setTimeout) return setTimeout(ue, 0);
	if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, setTimeout(ue, 0);
	try {
		return cachedSetTimeout(ue, 0)
	} catch {
		try {
			return cachedSetTimeout.call(null, ue, 0)
		} catch {
			return cachedSetTimeout.call(this, ue, 0)
		}
	}
}

function runClearTimeout(ue) {
	if (cachedClearTimeout === clearTimeout) return clearTimeout(ue);
	if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, clearTimeout(ue);
	try {
		return cachedClearTimeout(ue)
	} catch {
		try {
			return cachedClearTimeout.call(null, ue)
		} catch {
			return cachedClearTimeout.call(this, ue)
		}
	}
}
var queue = [],
	draining = !1,
	currentQueue, queueIndex = -1;

function cleanUpNextTick() {
	!draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue())
}

function drainQueue() {
	if (!draining) {
		var ue = runTimeout(cleanUpNextTick);
		draining = !0;
		for (var Yi = queue.length; Yi;) {
			for (currentQueue = queue, queue = []; ++queueIndex < Yi;) currentQueue && currentQueue[queueIndex].run();
			queueIndex = -1, Yi = queue.length
		}
		currentQueue = null, draining = !1, runClearTimeout(ue)
	}
}
process.nextTick = function(ue) {
	var Yi = new Array(arguments.length - 1);
	if (arguments.length > 1)
		for (var ea = 1; ea < arguments.length; ea++) Yi[ea - 1] = arguments[ea];
	queue.push(new Item(ue, Yi)), queue.length === 1 && !draining && runTimeout(drainQueue)
};

function Item(ue, Yi) {
	this.fun = ue, this.array = Yi
}
Item.prototype.run = function() {
	this.fun.apply(null, this.array)
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};

function noop$1() {}
process.on = noop$1;
process.addListener = noop$1;
process.once = noop$1;
process.off = noop$1;
process.removeListener = noop$1;
process.removeAllListeners = noop$1;
process.emit = noop$1;
process.prependListener = noop$1;
process.prependOnceListener = noop$1;
process.listeners = function(ue) {
	return []
};
process.binding = function(ue) {
	throw new Error("process.binding is not supported")
};
process.cwd = function() {
	return "/"
};
process.chdir = function(ue) {
	throw new Error("process.chdir is not supported")
};
process.umask = function() {
	return 0
};
var browserExports = browser$d.exports;
const process$1 = getDefaultExportFromCjs(browserExports);

function bind(ue, Yi) {
	return function() {
		return ue.apply(Yi, arguments)
	}
}
const {
	toString
} = Object.prototype, {
	getPrototypeOf
} = Object, kindOf = (ue => Yi => {
	const ea = toString.call(Yi);
	return ue[ea] || (ue[ea] = ea.slice(8, -1).toLowerCase())
})(Object.create(null)), kindOfTest = ue => (ue = ue.toLowerCase(), Yi => kindOf(Yi) === ue), typeOfTest = ue => Yi => typeof Yi === ue, {
	isArray: isArray$2
} = Array, isUndefined = typeOfTest("undefined");

function isBuffer(ue) {
	return ue !== null && !isUndefined(ue) && ue.constructor !== null && !isUndefined(ue.constructor) && isFunction$1(ue.constructor.isBuffer) && ue.constructor.isBuffer(ue)
}
const isArrayBuffer = kindOfTest("ArrayBuffer");

function isArrayBufferView(ue) {
	let Yi;
	return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? Yi = ArrayBuffer.isView(ue) : Yi = ue && ue.buffer && isArrayBuffer(ue.buffer), Yi
}
const isString$3 = typeOfTest("string"),
	isFunction$1 = typeOfTest("function"),
	isNumber$2 = typeOfTest("number"),
	isObject$2 = ue => ue !== null && typeof ue == "object",
	isBoolean$2 = ue => ue === !0 || ue === !1,
	isPlainObject$2 = ue => {
		if (kindOf(ue) !== "object") return !1;
		const Yi = getPrototypeOf(ue);
		return (Yi === null || Yi === Object.prototype || Object.getPrototypeOf(Yi) === null) && !(Symbol.toStringTag in ue) && !(Symbol.iterator in ue)
	},
	isDate$2 = kindOfTest("Date"),
	isFile = kindOfTest("File"),
	isBlob = kindOfTest("Blob"),
	isFileList = kindOfTest("FileList"),
	isStream = ue => isObject$2(ue) && isFunction$1(ue.pipe),
	isFormData = ue => {
		let Yi;
		return ue && (typeof FormData == "function" && ue instanceof FormData || isFunction$1(ue.append) && ((Yi = kindOf(ue)) === "formdata" || Yi === "object" && isFunction$1(ue.toString) && ue.toString() === "[object FormData]"))
	},
	isURLSearchParams = kindOfTest("URLSearchParams"),
	[isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest),
	trim = ue => ue.trim ? ue.trim() : ue.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");

function forEach(ue, Yi, {
	allOwnKeys: ea = !1
} = {}) {
	if (ue === null || typeof ue > "u") return;
	let ta, na;
	if (typeof ue != "object" && (ue = [ue]), isArray$2(ue))
		for (ta = 0, na = ue.length; ta < na; ta++) Yi.call(null, ue[ta], ta, ue);
	else {
		const ra = ea ? Object.getOwnPropertyNames(ue) : Object.keys(ue),
			ia = ra.length;
		let aa;
		for (ta = 0; ta < ia; ta++) aa = ra[ta], Yi.call(null, ue[aa], aa, ue)
	}
}

function findKey(ue, Yi) {
	Yi = Yi.toLowerCase();
	const ea = Object.keys(ue);
	let ta = ea.length,
		na;
	for (; ta-- > 0;)
		if (na = ea[ta], Yi === na.toLowerCase()) return na;
	return null
}
const _global = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global$1,
	isContextDefined = ue => !isUndefined(ue) && ue !== _global;

function merge() {
	const {
		caseless: ue
	} = isContextDefined(this) && this || {}, Yi = {}, ea = (ta, na) => {
		const ra = ue && findKey(Yi, na) || na;
		isPlainObject$2(Yi[ra]) && isPlainObject$2(ta) ? Yi[ra] = merge(Yi[ra], ta) : isPlainObject$2(ta) ? Yi[ra] = merge({}, ta) : isArray$2(ta) ? Yi[ra] = ta.slice() : Yi[ra] = ta
	};
	for (let ta = 0, na = arguments.length; ta < na; ta++) arguments[ta] && forEach(arguments[ta], ea);
	return Yi
}
const extend = (ue, Yi, ea, {
		allOwnKeys: ta
	} = {}) => (forEach(Yi, (na, ra) => {
		ea && isFunction$1(na) ? ue[ra] = bind(na, ea) : ue[ra] = na
	}, {
		allOwnKeys: ta
	}), ue),
	stripBOM = ue => (ue.charCodeAt(0) === 65279 && (ue = ue.slice(1)), ue),
	inherits = (ue, Yi, ea, ta) => {
		ue.prototype = Object.create(Yi.prototype, ta), ue.prototype.constructor = ue, Object.defineProperty(ue, "super", {
			value: Yi.prototype
		}), ea && Object.assign(ue.prototype, ea)
	},
	toFlatObject = (ue, Yi, ea, ta) => {
		let na, ra, ia;
		const aa = {};
		if (Yi = Yi || {}, ue == null) return Yi;
		do {
			for (na = Object.getOwnPropertyNames(ue), ra = na.length; ra-- > 0;) ia = na[ra], (!ta || ta(ia, ue, Yi)) && !aa[ia] && (Yi[ia] = ue[ia], aa[ia] = !0);
			ue = ea !== !1 && getPrototypeOf(ue)
		} while (ue && (!ea || ea(ue, Yi)) && ue !== Object.prototype);
		return Yi
	},
	endsWith = (ue, Yi, ea) => {
		ue = String(ue), (ea === void 0 || ea > ue.length) && (ea = ue.length), ea -= Yi.length;
		const ta = ue.indexOf(Yi, ea);
		return ta !== -1 && ta === ea
	},
	toArray = ue => {
		if (!ue) return null;
		if (isArray$2(ue)) return ue;
		let Yi = ue.length;
		if (!isNumber$2(Yi)) return null;
		const ea = new Array(Yi);
		for (; Yi-- > 0;) ea[Yi] = ue[Yi];
		return ea
	},
	isTypedArray$1 = (ue => Yi => ue && Yi instanceof ue)(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array)),
	forEachEntry = (ue, Yi) => {
		const ta = (ue && ue[Symbol.iterator]).call(ue);
		let na;
		for (;
			(na = ta.next()) && !na.done;) {
			const ra = na.value;
			Yi.call(ue, ra[0], ra[1])
		}
	},
	matchAll = (ue, Yi) => {
		let ea;
		const ta = [];
		for (;
			(ea = ue.exec(Yi)) !== null;) ta.push(ea);
		return ta
	},
	isHTMLForm = kindOfTest("HTMLFormElement"),
	toCamelCase = ue => ue.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(ea, ta, na) {
		return ta.toUpperCase() + na
	}),
	hasOwnProperty$1 = (({
		hasOwnProperty: ue
	}) => (Yi, ea) => ue.call(Yi, ea))(Object.prototype),
	isRegExp$2 = kindOfTest("RegExp"),
	reduceDescriptors = (ue, Yi) => {
		const ea = Object.getOwnPropertyDescriptors(ue),
			ta = {};
		forEach(ea, (na, ra) => {
			let ia;
			(ia = Yi(na, ra, ue)) !== !1 && (ta[ra] = ia || na)
		}), Object.defineProperties(ue, ta)
	},
	freezeMethods = ue => {
		reduceDescriptors(ue, (Yi, ea) => {
			if (isFunction$1(ue) && ["arguments", "caller", "callee"].indexOf(ea) !== -1) return !1;
			const ta = ue[ea];
			if (isFunction$1(ta)) {
				if (Yi.enumerable = !1, "writable" in Yi) {
					Yi.writable = !1;
					return
				}
				Yi.set || (Yi.set = () => {
					throw Error("Can not rewrite read-only method '" + ea + "'")
				})
			}
		})
	},
	toObjectSet = (ue, Yi) => {
		const ea = {},
			ta = na => {
				na.forEach(ra => {
					ea[ra] = !0
				})
			};
		return isArray$2(ue) ? ta(ue) : ta(String(ue).split(Yi)), ea
	},
	noop = () => {},
	toFiniteNumber = (ue, Yi) => ue != null && Number.isFinite(ue = +ue) ? ue : Yi,
	ALPHA = "abcdefghijklmnopqrstuvwxyz",
	DIGIT = "0123456789",
	ALPHABET = {
		DIGIT,
		ALPHA,
		ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
	},
	generateString = (ue = 16, Yi = ALPHABET.ALPHA_DIGIT) => {
		let ea = "";
		const {
			length: ta
		} = Yi;
		for (; ue--;) ea += Yi[Math.random() * ta | 0];
		return ea
	};

function isSpecCompliantForm(ue) {
	return !!(ue && isFunction$1(ue.append) && ue[Symbol.toStringTag] === "FormData" && ue[Symbol.iterator])
}
const toJSONObject = ue => {
		const Yi = new Array(10),
			ea = (ta, na) => {
				if (isObject$2(ta)) {
					if (Yi.indexOf(ta) >= 0) return;
					if (!("toJSON" in ta)) {
						Yi[na] = ta;
						const ra = isArray$2(ta) ? [] : {};
						return forEach(ta, (ia, aa) => {
							const oa = ea(ia, na + 1);
							!isUndefined(oa) && (ra[aa] = oa)
						}), Yi[na] = void 0, ra
					}
				}
				return ta
			};
		return ea(ue, 0)
	},
	isAsyncFn = kindOfTest("AsyncFunction"),
	isThenable$1 = ue => ue && (isObject$2(ue) || isFunction$1(ue)) && isFunction$1(ue.then) && isFunction$1(ue.catch),
	_setImmediate = ((ue, Yi) => ue ? setImmediate : Yi ? ((ea, ta) => (_global.addEventListener("message", ({
		source: na,
		data: ra
	}) => {
		na === _global && ra === ea && ta.length && ta.shift()()
	}, !1), na => {
		ta.push(na), _global.postMessage(ea, "*")
	}))(`axios@${Math.random()}`, []) : ea => setTimeout(ea))(typeof setImmediate == "function", isFunction$1(_global.postMessage)),
	asap = typeof queueMicrotask < "u" ? queueMicrotask.bind(_global) : typeof process$1 < "u" && process$1.nextTick || _setImmediate,
	utils$5 = {
		isArray: isArray$2,
		isArrayBuffer,
		isBuffer,
		isFormData,
		isArrayBufferView,
		isString: isString$3,
		isNumber: isNumber$2,
		isBoolean: isBoolean$2,
		isObject: isObject$2,
		isPlainObject: isPlainObject$2,
		isReadableStream,
		isRequest,
		isResponse,
		isHeaders,
		isUndefined,
		isDate: isDate$2,
		isFile,
		isBlob,
		isRegExp: isRegExp$2,
		isFunction: isFunction$1,
		isStream,
		isURLSearchParams,
		isTypedArray: isTypedArray$1,
		isFileList,
		forEach,
		merge,
		extend,
		trim,
		stripBOM,
		inherits,
		toFlatObject,
		kindOf,
		kindOfTest,
		endsWith,
		toArray,
		forEachEntry,
		matchAll,
		isHTMLForm,
		hasOwnProperty: hasOwnProperty$1,
		hasOwnProp: hasOwnProperty$1,
		reduceDescriptors,
		freezeMethods,
		toObjectSet,
		toCamelCase,
		noop,
		toFiniteNumber,
		findKey,
		global: _global,
		isContextDefined,
		ALPHABET,
		generateString,
		isSpecCompliantForm,
		toJSONObject,
		isAsyncFn,
		isThenable: isThenable$1,
		setImmediate: _setImmediate,
		asap
	};

function AxiosError$1(ue, Yi, ea, ta, na) {
	Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = ue, this.name = "AxiosError", Yi && (this.code = Yi), ea && (this.config = ea), ta && (this.request = ta), na && (this.response = na, this.status = na.status ? na.status : null)
}
utils$5.inherits(AxiosError$1, Error, {
	toJSON: function() {
		return {
			message: this.message,
			name: this.name,
			description: this.description,
			number: this.number,
			fileName: this.fileName,
			lineNumber: this.lineNumber,
			columnNumber: this.columnNumber,
			stack: this.stack,
			config: utils$5.toJSONObject(this.config),
			code: this.code,
			status: this.status
		}
	}
});
const prototype$1 = AxiosError$1.prototype,
	descriptors = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(ue => {
	descriptors[ue] = {
		value: ue
	}
});
Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", {
	value: !0
});
AxiosError$1.from = (ue, Yi, ea, ta, na, ra) => {
	const ia = Object.create(prototype$1);
	return utils$5.toFlatObject(ue, ia, function(oa) {
		return oa !== Error.prototype
	}, aa => aa !== "isAxiosError"), AxiosError$1.call(ia, ue.message, Yi, ea, ta, na), ia.cause = ue, ia.name = ue.name, ra && Object.assign(ia, ra), ia
};
const httpAdapter = null;

function isVisitable(ue) {
	return utils$5.isPlainObject(ue) || utils$5.isArray(ue)
}

function removeBrackets(ue) {
	return utils$5.endsWith(ue, "[]") ? ue.slice(0, -2) : ue
}

function renderKey(ue, Yi, ea) {
	return ue ? ue.concat(Yi).map(function(na, ra) {
		return na = removeBrackets(na), !ea && ra ? "[" + na + "]" : na
	}).join(ea ? "." : "") : Yi
}

function isFlatArray(ue) {
	return utils$5.isArray(ue) && !ue.some(isVisitable)
}
const predicates = utils$5.toFlatObject(utils$5, {}, null, function(Yi) {
	return /^is[A-Z]/.test(Yi)
});

function toFormData$1(ue, Yi, ea) {
	if (!utils$5.isObject(ue)) throw new TypeError("target must be an object");
	Yi = Yi || new FormData, ea = utils$5.toFlatObject(ea, {
		metaTokens: !0,
		dots: !1,
		indexes: !1
	}, !1, function(pa, va) {
		return !utils$5.isUndefined(va[pa])
	});
	const ta = ea.metaTokens,
		na = ea.visitor || sa,
		ra = ea.dots,
		ia = ea.indexes,
		oa = (ea.Blob || typeof Blob < "u" && Blob) && utils$5.isSpecCompliantForm(Yi);
	if (!utils$5.isFunction(na)) throw new TypeError("visitor must be a function");

	function la(ha) {
		if (ha === null) return "";
		if (utils$5.isDate(ha)) return ha.toISOString();
		if (!oa && utils$5.isBlob(ha)) throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
		return utils$5.isArrayBuffer(ha) || utils$5.isTypedArray(ha) ? oa && typeof Blob == "function" ? new Blob([ha]) : Buffer.from(ha) : ha
	}

	function sa(ha, pa, va) {
		let ba = ha;
		if (ha && !va && typeof ha == "object") {
			if (utils$5.endsWith(pa, "{}")) pa = ta ? pa : pa.slice(0, -2), ha = JSON.stringify(ha);
			else if (utils$5.isArray(ha) && isFlatArray(ha) || (utils$5.isFileList(ha) || utils$5.endsWith(pa, "[]")) && (ba = utils$5.toArray(ha))) return pa = removeBrackets(pa), ba.forEach(function(Sa, Ca) {
				!(utils$5.isUndefined(Sa) || Sa === null) && Yi.append(ia === !0 ? renderKey([pa], Ca, ra) : ia === null ? pa : pa + "[]", la(Sa))
			}), !1
		}
		return isVisitable(ha) ? !0 : (Yi.append(renderKey(va, pa, ra), la(ha)), !1)
	}
	const ca = [],
		ua = Object.assign(predicates, {
			defaultVisitor: sa,
			convertValue: la,
			isVisitable
		});

	function da(ha, pa) {
		if (!utils$5.isUndefined(ha)) {
			if (ca.indexOf(ha) !== -1) throw Error("Circular reference detected in " + pa.join("."));
			ca.push(ha), utils$5.forEach(ha, function(ba, Ea) {
				(!(utils$5.isUndefined(ba) || ba === null) && na.call(Yi, ba, utils$5.isString(Ea) ? Ea.trim() : Ea, pa, ua)) === !0 && da(ba, pa ? pa.concat(Ea) : [Ea])
			}), ca.pop()
		}
	}
	if (!utils$5.isObject(ue)) throw new TypeError("data must be an object");
	return da(ue), Yi
}

function encode$2(ue) {
	const Yi = {
		"!": "%21",
		"'": "%27",
		"(": "%28",
		")": "%29",
		"~": "%7E",
		"%20": "+",
		"%00": "\0"
	};
	return encodeURIComponent(ue).replace(/[!'()~]|%20|%00/g, function(ta) {
		return Yi[ta]
	})
}

function AxiosURLSearchParams(ue, Yi) {
	this._pairs = [], ue && toFormData$1(ue, this, Yi)
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function(Yi, ea) {
	this._pairs.push([Yi, ea])
};
prototype.toString = function(Yi) {
	const ea = Yi ? function(ta) {
		return Yi.call(this, ta, encode$2)
	} : encode$2;
	return this._pairs.map(function(na) {
		return ea(na[0]) + "=" + ea(na[1])
	}, "").join("&")
};

function encode$1(ue) {
	return encodeURIComponent(ue).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}

function buildURL(ue, Yi, ea) {
	if (!Yi) return ue;
	const ta = ea && ea.encode || encode$1,
		na = ea && ea.serialize;
	let ra;
	if (na ? ra = na(Yi, ea) : ra = utils$5.isURLSearchParams(Yi) ? Yi.toString() : new AxiosURLSearchParams(Yi, ea).toString(ta), ra) {
		const ia = ue.indexOf("#");
		ia !== -1 && (ue = ue.slice(0, ia)), ue += (ue.indexOf("?") === -1 ? "?" : "&") + ra
	}
	return ue
}
class InterceptorManager {
	constructor() {
		this.handlers = []
	}
	use(Yi, ea, ta) {
		return this.handlers.push({
			fulfilled: Yi,
			rejected: ea,
			synchronous: ta ? ta.synchronous : !1,
			runWhen: ta ? ta.runWhen : null
		}), this.handlers.length - 1
	}
	eject(Yi) {
		this.handlers[Yi] && (this.handlers[Yi] = null)
	}
	clear() {
		this.handlers && (this.handlers = [])
	}
	forEach(Yi) {
		utils$5.forEach(this.handlers, function(ta) {
			ta !== null && Yi(ta)
		})
	}
}
const transitionalDefaults = {
		silentJSONParsing: !0,
		forcedJSONParsing: !0,
		clarifyTimeoutError: !1
	},
	URLSearchParams$1 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams,
	FormData$1 = typeof FormData < "u" ? FormData : null,
	Blob$1 = typeof Blob < "u" ? Blob : null,
	platform$1 = {
		isBrowser: !0,
		classes: {
			URLSearchParams: URLSearchParams$1,
			FormData: FormData$1,
			Blob: Blob$1
		},
		protocols: ["http", "https", "file", "blob", "url", "data"]
	},
	hasBrowserEnv = typeof window < "u" && typeof document < "u",
	_navigator = typeof navigator == "object" && navigator || void 0,
	hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0),
	hasStandardBrowserWebWorkerEnv = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function",
	origin = hasBrowserEnv && window.location.href || "http://localhost",
	utils$4 = Object.freeze(Object.defineProperty({
		__proto__: null,
		hasBrowserEnv,
		hasStandardBrowserEnv,
		hasStandardBrowserWebWorkerEnv,
		navigator: _navigator,
		origin
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	platform = {
		...utils$4,
		...platform$1
	};

function toURLEncodedForm(ue, Yi) {
	return toFormData$1(ue, new platform.classes.URLSearchParams, Object.assign({
		visitor: function(ea, ta, na, ra) {
			return platform.isNode && utils$5.isBuffer(ea) ? (this.append(ta, ea.toString("base64")), !1) : ra.defaultVisitor.apply(this, arguments)
		}
	}, Yi))
}

function parsePropPath(ue) {
	return utils$5.matchAll(/\w+|\[(\w*)]/g, ue).map(Yi => Yi[0] === "[]" ? "" : Yi[1] || Yi[0])
}

function arrayToObject(ue) {
	const Yi = {},
		ea = Object.keys(ue);
	let ta;
	const na = ea.length;
	let ra;
	for (ta = 0; ta < na; ta++) ra = ea[ta], Yi[ra] = ue[ra];
	return Yi
}

function formDataToJSON(ue) {
	function Yi(ea, ta, na, ra) {
		let ia = ea[ra++];
		if (ia === "__proto__") return !0;
		const aa = Number.isFinite(+ia),
			oa = ra >= ea.length;
		return ia = !ia && utils$5.isArray(na) ? na.length : ia, oa ? (utils$5.hasOwnProp(na, ia) ? na[ia] = [na[ia], ta] : na[ia] = ta, !aa) : ((!na[ia] || !utils$5.isObject(na[ia])) && (na[ia] = []), Yi(ea, ta, na[ia], ra) && utils$5.isArray(na[ia]) && (na[ia] = arrayToObject(na[ia])), !aa)
	}
	if (utils$5.isFormData(ue) && utils$5.isFunction(ue.entries)) {
		const ea = {};
		return utils$5.forEachEntry(ue, (ta, na) => {
			Yi(parsePropPath(ta), na, ea, 0)
		}), ea
	}
	return null
}

function stringifySafely(ue, Yi, ea) {
	if (utils$5.isString(ue)) try {
		return (Yi || JSON.parse)(ue), utils$5.trim(ue)
	} catch (ta) {
		if (ta.name !== "SyntaxError") throw ta
	}
	return (0, JSON.stringify)(ue)
}
const defaults$1 = {
	transitional: transitionalDefaults,
	adapter: ["xhr", "http", "fetch"],
	transformRequest: [function(Yi, ea) {
		const ta = ea.getContentType() || "",
			na = ta.indexOf("application/json") > -1,
			ra = utils$5.isObject(Yi);
		if (ra && utils$5.isHTMLForm(Yi) && (Yi = new FormData(Yi)), utils$5.isFormData(Yi)) return na ? JSON.stringify(formDataToJSON(Yi)) : Yi;
		if (utils$5.isArrayBuffer(Yi) || utils$5.isBuffer(Yi) || utils$5.isStream(Yi) || utils$5.isFile(Yi) || utils$5.isBlob(Yi) || utils$5.isReadableStream(Yi)) return Yi;
		if (utils$5.isArrayBufferView(Yi)) return Yi.buffer;
		if (utils$5.isURLSearchParams(Yi)) return ea.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), Yi.toString();
		let aa;
		if (ra) {
			if (ta.indexOf("application/x-www-form-urlencoded") > -1) return toURLEncodedForm(Yi, this.formSerializer).toString();
			if ((aa = utils$5.isFileList(Yi)) || ta.indexOf("multipart/form-data") > -1) {
				const oa = this.env && this.env.FormData;
				return toFormData$1(aa ? {
					"files[]": Yi
				} : Yi, oa && new oa, this.formSerializer)
			}
		}
		return ra || na ? (ea.setContentType("application/json", !1), stringifySafely(Yi)) : Yi
	}],
	transformResponse: [function(Yi) {
		const ea = this.transitional || defaults$1.transitional,
			ta = ea && ea.forcedJSONParsing,
			na = this.responseType === "json";
		if (utils$5.isResponse(Yi) || utils$5.isReadableStream(Yi)) return Yi;
		if (Yi && utils$5.isString(Yi) && (ta && !this.responseType || na)) {
			const ia = !(ea && ea.silentJSONParsing) && na;
			try {
				return JSON.parse(Yi)
			} catch (aa) {
				if (ia) throw aa.name === "SyntaxError" ? AxiosError$1.from(aa, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response) : aa
			}
		}
		return Yi
	}],
	timeout: 0,
	xsrfCookieName: "XSRF-TOKEN",
	xsrfHeaderName: "X-XSRF-TOKEN",
	maxContentLength: -1,
	maxBodyLength: -1,
	env: {
		FormData: platform.classes.FormData,
		Blob: platform.classes.Blob
	},
	validateStatus: function(Yi) {
		return Yi >= 200 && Yi < 300
	},
	headers: {
		common: {
			Accept: "application/json, text/plain, */*",
			"Content-Type": void 0
		}
	}
};
utils$5.forEach(["delete", "get", "head", "post", "put", "patch"], ue => {
	defaults$1.headers[ue] = {}
});
const ignoreDuplicateOf = utils$5.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]),
	parseHeaders = ue => {
		const Yi = {};
		let ea, ta, na;
		return ue && ue.split(`
`).forEach(function(ia) {
			na = ia.indexOf(":"), ea = ia.substring(0, na).trim().toLowerCase(), ta = ia.substring(na + 1).trim(), !(!ea || Yi[ea] && ignoreDuplicateOf[ea]) && (ea === "set-cookie" ? Yi[ea] ? Yi[ea].push(ta) : Yi[ea] = [ta] : Yi[ea] = Yi[ea] ? Yi[ea] + ", " + ta : ta)
		}), Yi
	},
	$internals = Symbol("internals");

function normalizeHeader(ue) {
	return ue && String(ue).trim().toLowerCase()
}

function normalizeValue(ue) {
	return ue === !1 || ue == null ? ue : utils$5.isArray(ue) ? ue.map(normalizeValue) : String(ue)
}

function parseTokens(ue) {
	const Yi = Object.create(null),
		ea = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
	let ta;
	for (; ta = ea.exec(ue);) Yi[ta[1]] = ta[2];
	return Yi
}
const isValidHeaderName = ue => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(ue.trim());

function matchHeaderValue(ue, Yi, ea, ta, na) {
	if (utils$5.isFunction(ta)) return ta.call(this, Yi, ea);
	if (na && (Yi = ea), !!utils$5.isString(Yi)) {
		if (utils$5.isString(ta)) return Yi.indexOf(ta) !== -1;
		if (utils$5.isRegExp(ta)) return ta.test(Yi)
	}
}

function formatHeader(ue) {
	return ue.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (Yi, ea, ta) => ea.toUpperCase() + ta)
}

function buildAccessors(ue, Yi) {
	const ea = utils$5.toCamelCase(" " + Yi);
	["get", "set", "has"].forEach(ta => {
		Object.defineProperty(ue, ta + ea, {
			value: function(na, ra, ia) {
				return this[ta].call(this, Yi, na, ra, ia)
			},
			configurable: !0
		})
	})
}
let AxiosHeaders$1 = class {
	constructor(Yi) {
		Yi && this.set(Yi)
	}
	set(Yi, ea, ta) {
		const na = this;

		function ra(aa, oa, la) {
			const sa = normalizeHeader(oa);
			if (!sa) throw new Error("header name must be a non-empty string");
			const ca = utils$5.findKey(na, sa);
			(!ca || na[ca] === void 0 || la === !0 || la === void 0 && na[ca] !== !1) && (na[ca || oa] = normalizeValue(aa))
		}
		const ia = (aa, oa) => utils$5.forEach(aa, (la, sa) => ra(la, sa, oa));
		if (utils$5.isPlainObject(Yi) || Yi instanceof this.constructor) ia(Yi, ea);
		else if (utils$5.isString(Yi) && (Yi = Yi.trim()) && !isValidHeaderName(Yi)) ia(parseHeaders(Yi), ea);
		else if (utils$5.isHeaders(Yi))
			for (const [aa, oa] of Yi.entries()) ra(oa, aa, ta);
		else Yi != null && ra(ea, Yi, ta);
		return this
	}
	get(Yi, ea) {
		if (Yi = normalizeHeader(Yi), Yi) {
			const ta = utils$5.findKey(this, Yi);
			if (ta) {
				const na = this[ta];
				if (!ea) return na;
				if (ea === !0) return parseTokens(na);
				if (utils$5.isFunction(ea)) return ea.call(this, na, ta);
				if (utils$5.isRegExp(ea)) return ea.exec(na);
				throw new TypeError("parser must be boolean|regexp|function")
			}
		}
	}
	has(Yi, ea) {
		if (Yi = normalizeHeader(Yi), Yi) {
			const ta = utils$5.findKey(this, Yi);
			return !!(ta && this[ta] !== void 0 && (!ea || matchHeaderValue(this, this[ta], ta, ea)))
		}
		return !1
	}
	delete(Yi, ea) {
		const ta = this;
		let na = !1;

		function ra(ia) {
			if (ia = normalizeHeader(ia), ia) {
				const aa = utils$5.findKey(ta, ia);
				aa && (!ea || matchHeaderValue(ta, ta[aa], aa, ea)) && (delete ta[aa], na = !0)
			}
		}
		return utils$5.isArray(Yi) ? Yi.forEach(ra) : ra(Yi), na
	}
	clear(Yi) {
		const ea = Object.keys(this);
		let ta = ea.length,
			na = !1;
		for (; ta--;) {
			const ra = ea[ta];
			(!Yi || matchHeaderValue(this, this[ra], ra, Yi, !0)) && (delete this[ra], na = !0)
		}
		return na
	}
	normalize(Yi) {
		const ea = this,
			ta = {};
		return utils$5.forEach(this, (na, ra) => {
			const ia = utils$5.findKey(ta, ra);
			if (ia) {
				ea[ia] = normalizeValue(na), delete ea[ra];
				return
			}
			const aa = Yi ? formatHeader(ra) : String(ra).trim();
			aa !== ra && delete ea[ra], ea[aa] = normalizeValue(na), ta[aa] = !0
		}), this
	}
	concat(...Yi) {
		return this.constructor.concat(this, ...Yi)
	}
	toJSON(Yi) {
		const ea = Object.create(null);
		return utils$5.forEach(this, (ta, na) => {
			ta != null && ta !== !1 && (ea[na] = Yi && utils$5.isArray(ta) ? ta.join(", ") : ta)
		}), ea
	} [Symbol.iterator]() {
		return Object.entries(this.toJSON())[Symbol.iterator]()
	}
	toString() {
		return Object.entries(this.toJSON()).map(([Yi, ea]) => Yi + ": " + ea).join(`
`)
	}
	get[Symbol.toStringTag]() {
		return "AxiosHeaders"
	}
	static from(Yi) {
		return Yi instanceof this ? Yi : new this(Yi)
	}
	static concat(Yi, ...ea) {
		const ta = new this(Yi);
		return ea.forEach(na => ta.set(na)), ta
	}
	static accessor(Yi) {
		const ta = (this[$internals] = this[$internals] = {
				accessors: {}
			}).accessors,
			na = this.prototype;

		function ra(ia) {
			const aa = normalizeHeader(ia);
			ta[aa] || (buildAccessors(na, ia), ta[aa] = !0)
		}
		return utils$5.isArray(Yi) ? Yi.forEach(ra) : ra(Yi), this
	}
};
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$5.reduceDescriptors(AxiosHeaders$1.prototype, ({
	value: ue
}, Yi) => {
	let ea = Yi[0].toUpperCase() + Yi.slice(1);
	return {
		get: () => ue,
		set(ta) {
			this[ea] = ta
		}
	}
});
utils$5.freezeMethods(AxiosHeaders$1);

function transformData(ue, Yi) {
	const ea = this || defaults$1,
		ta = Yi || ea,
		na = AxiosHeaders$1.from(ta.headers);
	let ra = ta.data;
	return utils$5.forEach(ue, function(aa) {
		ra = aa.call(ea, ra, na.normalize(), Yi ? Yi.status : void 0)
	}), na.normalize(), ra
}

function isCancel$1(ue) {
	return !!(ue && ue.__CANCEL__)
}

function CanceledError$1(ue, Yi, ea) {
	AxiosError$1.call(this, ue ?? "canceled", AxiosError$1.ERR_CANCELED, Yi, ea), this.name = "CanceledError"
}
utils$5.inherits(CanceledError$1, AxiosError$1, {
	__CANCEL__: !0
});

function settle(ue, Yi, ea) {
	const ta = ea.config.validateStatus;
	!ea.status || !ta || ta(ea.status) ? ue(ea) : Yi(new AxiosError$1("Request failed with status code " + ea.status, [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(ea.status / 100) - 4], ea.config, ea.request, ea))
}

function parseProtocol(ue) {
	const Yi = /^([-+\w]{1,25})(:?\/\/|:)/.exec(ue);
	return Yi && Yi[1] || ""
}

function speedometer(ue, Yi) {
	ue = ue || 10;
	const ea = new Array(ue),
		ta = new Array(ue);
	let na = 0,
		ra = 0,
		ia;
	return Yi = Yi !== void 0 ? Yi : 1e3,
		function(oa) {
			const la = Date.now(),
				sa = ta[ra];
			ia || (ia = la), ea[na] = oa, ta[na] = la;
			let ca = ra,
				ua = 0;
			for (; ca !== na;) ua += ea[ca++], ca = ca % ue;
			if (na = (na + 1) % ue, na === ra && (ra = (ra + 1) % ue), la - ia < Yi) return;
			const da = sa && la - sa;
			return da ? Math.round(ua * 1e3 / da) : void 0
		}
}

function throttle$2(ue, Yi) {
	let ea = 0,
		ta = 1e3 / Yi,
		na, ra;
	const ia = (la, sa = Date.now()) => {
		ea = sa, na = null, ra && (clearTimeout(ra), ra = null), ue.apply(null, la)
	};
	return [(...la) => {
		const sa = Date.now(),
			ca = sa - ea;
		ca >= ta ? ia(la, sa) : (na = la, ra || (ra = setTimeout(() => {
			ra = null, ia(na)
		}, ta - ca)))
	}, () => na && ia(na)]
}
const progressEventReducer = (ue, Yi, ea = 3) => {
		let ta = 0;
		const na = speedometer(50, 250);
		return throttle$2(ra => {
			const ia = ra.loaded,
				aa = ra.lengthComputable ? ra.total : void 0,
				oa = ia - ta,
				la = na(oa),
				sa = ia <= aa;
			ta = ia;
			const ca = {
				loaded: ia,
				total: aa,
				progress: aa ? ia / aa : void 0,
				bytes: oa,
				rate: la || void 0,
				estimated: la && aa && sa ? (aa - ia) / la : void 0,
				event: ra,
				lengthComputable: aa != null,
				[Yi ? "download" : "upload"]: !0
			};
			ue(ca)
		}, ea)
	},
	progressEventDecorator = (ue, Yi) => {
		const ea = ue != null;
		return [ta => Yi[0]({
			lengthComputable: ea,
			total: ue,
			loaded: ta
		}), Yi[1]]
	},
	asyncDecorator = ue => (...Yi) => utils$5.asap(() => ue(...Yi)),
	isURLSameOrigin = platform.hasStandardBrowserEnv ? function() {
		const Yi = platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent),
			ea = document.createElement("a");
		let ta;

		function na(ra) {
			let ia = ra;
			return Yi && (ea.setAttribute("href", ia), ia = ea.href), ea.setAttribute("href", ia), {
				href: ea.href,
				protocol: ea.protocol ? ea.protocol.replace(/:$/, "") : "",
				host: ea.host,
				search: ea.search ? ea.search.replace(/^\?/, "") : "",
				hash: ea.hash ? ea.hash.replace(/^#/, "") : "",
				hostname: ea.hostname,
				port: ea.port,
				pathname: ea.pathname.charAt(0) === "/" ? ea.pathname : "/" + ea.pathname
			}
		}
		return ta = na(window.location.href),
			function(ia) {
				const aa = utils$5.isString(ia) ? na(ia) : ia;
				return aa.protocol === ta.protocol && aa.host === ta.host
			}
	}() : function() {
		return function() {
			return !0
		}
	}(),
	cookies = platform.hasStandardBrowserEnv ? {
		write(ue, Yi, ea, ta, na, ra) {
			const ia = [ue + "=" + encodeURIComponent(Yi)];
			utils$5.isNumber(ea) && ia.push("expires=" + new Date(ea).toGMTString()), utils$5.isString(ta) && ia.push("path=" + ta), utils$5.isString(na) && ia.push("domain=" + na), ra === !0 && ia.push("secure"), document.cookie = ia.join("; ")
		},
		read(ue) {
			const Yi = document.cookie.match(new RegExp("(^|;\\s*)(" + ue + ")=([^;]*)"));
			return Yi ? decodeURIComponent(Yi[3]) : null
		},
		remove(ue) {
			this.write(ue, "", Date.now() - 864e5)
		}
	} : {
		write() {},
		read() {
			return null
		},
		remove() {}
	};

function isAbsoluteURL(ue) {
	return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(ue)
}

function combineURLs(ue, Yi) {
	return Yi ? ue.replace(/\/?\/$/, "") + "/" + Yi.replace(/^\/+/, "") : ue
}

function buildFullPath(ue, Yi) {
	return ue && !isAbsoluteURL(Yi) ? combineURLs(ue, Yi) : Yi
}
const headersToObject = ue => ue instanceof AxiosHeaders$1 ? {
	...ue
} : ue;

function mergeConfig$1(ue, Yi) {
	Yi = Yi || {};
	const ea = {};

	function ta(la, sa, ca) {
		return utils$5.isPlainObject(la) && utils$5.isPlainObject(sa) ? utils$5.merge.call({
			caseless: ca
		}, la, sa) : utils$5.isPlainObject(sa) ? utils$5.merge({}, sa) : utils$5.isArray(sa) ? sa.slice() : sa
	}

	function na(la, sa, ca) {
		if (utils$5.isUndefined(sa)) {
			if (!utils$5.isUndefined(la)) return ta(void 0, la, ca)
		} else return ta(la, sa, ca)
	}

	function ra(la, sa) {
		if (!utils$5.isUndefined(sa)) return ta(void 0, sa)
	}

	function ia(la, sa) {
		if (utils$5.isUndefined(sa)) {
			if (!utils$5.isUndefined(la)) return ta(void 0, la)
		} else return ta(void 0, sa)
	}

	function aa(la, sa, ca) {
		if (ca in Yi) return ta(la, sa);
		if (ca in ue) return ta(void 0, la)
	}
	const oa = {
		url: ra,
		method: ra,
		data: ra,
		baseURL: ia,
		transformRequest: ia,
		transformResponse: ia,
		paramsSerializer: ia,
		timeout: ia,
		timeoutMessage: ia,
		withCredentials: ia,
		withXSRFToken: ia,
		adapter: ia,
		responseType: ia,
		xsrfCookieName: ia,
		xsrfHeaderName: ia,
		onUploadProgress: ia,
		onDownloadProgress: ia,
		decompress: ia,
		maxContentLength: ia,
		maxBodyLength: ia,
		beforeRedirect: ia,
		transport: ia,
		httpAgent: ia,
		httpsAgent: ia,
		cancelToken: ia,
		socketPath: ia,
		responseEncoding: ia,
		validateStatus: aa,
		headers: (la, sa) => na(headersToObject(la), headersToObject(sa), !0)
	};
	return utils$5.forEach(Object.keys(Object.assign({}, ue, Yi)), function(sa) {
		const ca = oa[sa] || na,
			ua = ca(ue[sa], Yi[sa], sa);
		utils$5.isUndefined(ua) && ca !== aa || (ea[sa] = ua)
	}), ea
}
const resolveConfig = ue => {
		const Yi = mergeConfig$1({}, ue);
		let {
			data: ea,
			withXSRFToken: ta,
			xsrfHeaderName: na,
			xsrfCookieName: ra,
			headers: ia,
			auth: aa
		} = Yi;
		Yi.headers = ia = AxiosHeaders$1.from(ia), Yi.url = buildURL(buildFullPath(Yi.baseURL, Yi.url), ue.params, ue.paramsSerializer), aa && ia.set("Authorization", "Basic " + btoa((aa.username || "") + ":" + (aa.password ? unescape(encodeURIComponent(aa.password)) : "")));
		let oa;
		if (utils$5.isFormData(ea)) {
			if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) ia.setContentType(void 0);
			else if ((oa = ia.getContentType()) !== !1) {
				const [la, ...sa] = oa ? oa.split(";").map(ca => ca.trim()).filter(Boolean) : [];
				ia.setContentType([la || "multipart/form-data", ...sa].join("; "))
			}
		}
		if (platform.hasStandardBrowserEnv && (ta && utils$5.isFunction(ta) && (ta = ta(Yi)), ta || ta !== !1 && isURLSameOrigin(Yi.url))) {
			const la = na && ra && cookies.read(ra);
			la && ia.set(na, la)
		}
		return Yi
	},
	isXHRAdapterSupported = typeof XMLHttpRequest < "u",
	xhrAdapter = isXHRAdapterSupported && function(ue) {
		return new Promise(function(ea, ta) {
			const na = resolveConfig(ue);
			let ra = na.data;
			const ia = AxiosHeaders$1.from(na.headers).normalize();
			let {
				responseType: aa,
				onUploadProgress: oa,
				onDownloadProgress: la
			} = na, sa, ca, ua, da, ha;

			function pa() {
				da && da(), ha && ha(), na.cancelToken && na.cancelToken.unsubscribe(sa), na.signal && na.signal.removeEventListener("abort", sa)
			}
			let va = new XMLHttpRequest;
			va.open(na.method.toUpperCase(), na.url, !0), va.timeout = na.timeout;

			function ba() {
				if (!va) return;
				const Sa = AxiosHeaders$1.from("getAllResponseHeaders" in va && va.getAllResponseHeaders()),
					ka = {
						data: !aa || aa === "text" || aa === "json" ? va.responseText : va.response,
						status: va.status,
						statusText: va.statusText,
						headers: Sa,
						config: ue,
						request: va
					};
				settle(function(ja) {
					ea(ja), pa()
				}, function(ja) {
					ta(ja), pa()
				}, ka), va = null
			}
			"onloadend" in va ? va.onloadend = ba : va.onreadystatechange = function() {
				!va || va.readyState !== 4 || va.status === 0 && !(va.responseURL && va.responseURL.indexOf("file:") === 0) || setTimeout(ba)
			}, va.onabort = function() {
				va && (ta(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, ue, va)), va = null)
			}, va.onerror = function() {
				ta(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, ue, va)), va = null
			}, va.ontimeout = function() {
				let Ca = na.timeout ? "timeout of " + na.timeout + "ms exceeded" : "timeout exceeded";
				const ka = na.transitional || transitionalDefaults;
				na.timeoutErrorMessage && (Ca = na.timeoutErrorMessage), ta(new AxiosError$1(Ca, ka.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED, ue, va)), va = null
			}, ra === void 0 && ia.setContentType(null), "setRequestHeader" in va && utils$5.forEach(ia.toJSON(), function(Ca, ka) {
				va.setRequestHeader(ka, Ca)
			}), utils$5.isUndefined(na.withCredentials) || (va.withCredentials = !!na.withCredentials), aa && aa !== "json" && (va.responseType = na.responseType), la && ([ua, ha] = progressEventReducer(la, !0), va.addEventListener("progress", ua)), oa && va.upload && ([ca, da] = progressEventReducer(oa), va.upload.addEventListener("progress", ca), va.upload.addEventListener("loadend", da)), (na.cancelToken || na.signal) && (sa = Sa => {
				va && (ta(!Sa || Sa.type ? new CanceledError$1(null, ue, va) : Sa), va.abort(), va = null)
			}, na.cancelToken && na.cancelToken.subscribe(sa), na.signal && (na.signal.aborted ? sa() : na.signal.addEventListener("abort", sa)));
			const Ea = parseProtocol(na.url);
			if (Ea && platform.protocols.indexOf(Ea) === -1) {
				ta(new AxiosError$1("Unsupported protocol " + Ea + ":", AxiosError$1.ERR_BAD_REQUEST, ue));
				return
			}
			va.send(ra || null)
		})
	},
	composeSignals = (ue, Yi) => {
		const {
			length: ea
		} = ue = ue ? ue.filter(Boolean) : [];
		if (Yi || ea) {
			let ta = new AbortController,
				na;
			const ra = function(la) {
				if (!na) {
					na = !0, aa();
					const sa = la instanceof Error ? la : this.reason;
					ta.abort(sa instanceof AxiosError$1 ? sa : new CanceledError$1(sa instanceof Error ? sa.message : sa))
				}
			};
			let ia = Yi && setTimeout(() => {
				ia = null, ra(new AxiosError$1(`timeout ${Yi} of ms exceeded`, AxiosError$1.ETIMEDOUT))
			}, Yi);
			const aa = () => {
				ue && (ia && clearTimeout(ia), ia = null, ue.forEach(la => {
					la.unsubscribe ? la.unsubscribe(ra) : la.removeEventListener("abort", ra)
				}), ue = null)
			};
			ue.forEach(la => la.addEventListener("abort", ra));
			const {
				signal: oa
			} = ta;
			return oa.unsubscribe = () => utils$5.asap(aa), oa
		}
	},
	streamChunk = function*(ue, Yi) {
		let ea = ue.byteLength;
		if (ea < Yi) {
			yield ue;
			return
		}
		let ta = 0,
			na;
		for (; ta < ea;) na = ta + Yi, yield ue.slice(ta, na), ta = na
	},
	readBytes = async function*(ue, Yi) {
		for await (const ea of readStream(ue)) yield* streamChunk(ea, Yi)
	}, readStream = async function*(ue) {
		if (ue[Symbol.asyncIterator]) {
			yield* ue;
			return
		}
		const Yi = ue.getReader();
		try {
			for (;;) {
				const {
					done: ea,
					value: ta
				} = await Yi.read();
				if (ea) break;
				yield ta
			}
		} finally {
			await Yi.cancel()
		}
	}, trackStream = (ue, Yi, ea, ta) => {
		const na = readBytes(ue, Yi);
		let ra = 0,
			ia, aa = oa => {
				ia || (ia = !0, ta && ta(oa))
			};
		return new ReadableStream({
			async pull(oa) {
				try {
					const {
						done: la,
						value: sa
					} = await na.next();
					if (la) {
						aa(), oa.close();
						return
					}
					let ca = sa.byteLength;
					if (ea) {
						let ua = ra += ca;
						ea(ua)
					}
					oa.enqueue(new Uint8Array(sa))
				} catch (la) {
					throw aa(la), la
				}
			},
			cancel(oa) {
				return aa(oa), na.return()
			}
		}, {
			highWaterMark: 2
		})
	}, isFetchSupported = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", isReadableStreamSupported = isFetchSupported && typeof ReadableStream == "function", encodeText = isFetchSupported && (typeof TextEncoder == "function" ? (ue => Yi => ue.encode(Yi))(new TextEncoder) : async ue => new Uint8Array(await new Response(ue).arrayBuffer())), test = (ue, ...Yi) => {
		try {
			return !!ue(...Yi)
		} catch {
			return !1
		}
	}, supportsRequestStream = isReadableStreamSupported && test(() => {
		let ue = !1;
		const Yi = new Request(platform.origin, {
			body: new ReadableStream,
			method: "POST",
			get duplex() {
				return ue = !0, "half"
			}
		}).headers.has("Content-Type");
		return ue && !Yi
	}), DEFAULT_CHUNK_SIZE = 64 * 1024, supportsResponseStream = isReadableStreamSupported && test(() => utils$5.isReadableStream(new Response("").body)), resolvers = {
		stream: supportsResponseStream && (ue => ue.body)
	};
isFetchSupported && (ue => {
	["text", "arrayBuffer", "blob", "formData", "stream"].forEach(Yi => {
		!resolvers[Yi] && (resolvers[Yi] = utils$5.isFunction(ue[Yi]) ? ea => ea[Yi]() : (ea, ta) => {
			throw new AxiosError$1(`Response type '${Yi}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, ta)
		})
	})
})(new Response);
const getBodyLength = async ue => {
	if (ue == null) return 0;
	if (utils$5.isBlob(ue)) return ue.size;
	if (utils$5.isSpecCompliantForm(ue)) return (await new Request(platform.origin, {
		method: "POST",
		body: ue
	}).arrayBuffer()).byteLength;
	if (utils$5.isArrayBufferView(ue) || utils$5.isArrayBuffer(ue)) return ue.byteLength;
	if (utils$5.isURLSearchParams(ue) && (ue = ue + ""), utils$5.isString(ue)) return (await encodeText(ue)).byteLength
}, resolveBodyLength = async (ue, Yi) => {
	const ea = utils$5.toFiniteNumber(ue.getContentLength());
	return ea ?? getBodyLength(Yi)
}, fetchAdapter = isFetchSupported && (async ue => {
	let {
		url: Yi,
		method: ea,
		data: ta,
		signal: na,
		cancelToken: ra,
		timeout: ia,
		onDownloadProgress: aa,
		onUploadProgress: oa,
		responseType: la,
		headers: sa,
		withCredentials: ca = "same-origin",
		fetchOptions: ua
	} = resolveConfig(ue);
	la = la ? (la + "").toLowerCase() : "text";
	let da = composeSignals([na, ra && ra.toAbortSignal()], ia),
		ha;
	const pa = da && da.unsubscribe && (() => {
		da.unsubscribe()
	});
	let va;
	try {
		if (oa && supportsRequestStream && ea !== "get" && ea !== "head" && (va = await resolveBodyLength(sa, ta)) !== 0) {
			let ka = new Request(Yi, {
					method: "POST",
					body: ta,
					duplex: "half"
				}),
				Pa;
			if (utils$5.isFormData(ta) && (Pa = ka.headers.get("content-type")) && sa.setContentType(Pa), ka.body) {
				const [ja, Za] = progressEventDecorator(va, progressEventReducer(asyncDecorator(oa)));
				ta = trackStream(ka.body, DEFAULT_CHUNK_SIZE, ja, Za)
			}
		}
		utils$5.isString(ca) || (ca = ca ? "include" : "omit");
		const ba = "credentials" in Request.prototype;
		ha = new Request(Yi, {
			...ua,
			signal: da,
			method: ea.toUpperCase(),
			headers: sa.normalize().toJSON(),
			body: ta,
			duplex: "half",
			credentials: ba ? ca : void 0
		});
		let Ea = await fetch(ha);
		const Sa = supportsResponseStream && (la === "stream" || la === "response");
		if (supportsResponseStream && (aa || Sa && pa)) {
			const ka = {};
			["status", "statusText", "headers"].forEach(Ga => {
				ka[Ga] = Ea[Ga]
			});
			const Pa = utils$5.toFiniteNumber(Ea.headers.get("content-length")),
				[ja, Za] = aa && progressEventDecorator(Pa, progressEventReducer(asyncDecorator(aa), !0)) || [];
			Ea = new Response(trackStream(Ea.body, DEFAULT_CHUNK_SIZE, ja, () => {
				Za && Za(), pa && pa()
			}), ka)
		}
		la = la || "text";
		let Ca = await resolvers[utils$5.findKey(resolvers, la) || "text"](Ea, ue);
		return !Sa && pa && pa(), await new Promise((ka, Pa) => {
			settle(ka, Pa, {
				data: Ca,
				headers: AxiosHeaders$1.from(Ea.headers),
				status: Ea.status,
				statusText: Ea.statusText,
				config: ue,
				request: ha
			})
		})
	} catch (ba) {
		throw pa && pa(), ba && ba.name === "TypeError" && /fetch/i.test(ba.message) ? Object.assign(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, ue, ha), {
			cause: ba.cause || ba
		}) : AxiosError$1.from(ba, ba && ba.code, ue, ha)
	}
}), knownAdapters = {
	http: httpAdapter,
	xhr: xhrAdapter,
	fetch: fetchAdapter
};
utils$5.forEach(knownAdapters, (ue, Yi) => {
	if (ue) {
		try {
			Object.defineProperty(ue, "name", {
				value: Yi
			})
		} catch {}
		Object.defineProperty(ue, "adapterName", {
			value: Yi
		})
	}
});
const renderReason = ue => `- ${ue}`,
	isResolvedHandle = ue => utils$5.isFunction(ue) || ue === null || ue === !1,
	adapters = {
		getAdapter: ue => {
			ue = utils$5.isArray(ue) ? ue : [ue];
			const {
				length: Yi
			} = ue;
			let ea, ta;
			const na = {};
			for (let ra = 0; ra < Yi; ra++) {
				ea = ue[ra];
				let ia;
				if (ta = ea, !isResolvedHandle(ea) && (ta = knownAdapters[(ia = String(ea)).toLowerCase()], ta === void 0)) throw new AxiosError$1(`Unknown adapter '${ia}'`);
				if (ta) break;
				na[ia || "#" + ra] = ta
			}
			if (!ta) {
				const ra = Object.entries(na).map(([aa, oa]) => `adapter ${aa} ` + (oa === !1 ? "is not supported by the environment" : "is not available in the build"));
				let ia = Yi ? ra.length > 1 ? `since :
` + ra.map(renderReason).join(`
`) : " " + renderReason(ra[0]) : "as no adapter specified";
				throw new AxiosError$1("There is no suitable adapter to dispatch the request " + ia, "ERR_NOT_SUPPORT")
			}
			return ta
		},
		adapters: knownAdapters
	};

function throwIfCancellationRequested(ue) {
	if (ue.cancelToken && ue.cancelToken.throwIfRequested(), ue.signal && ue.signal.aborted) throw new CanceledError$1(null, ue)
}

function dispatchRequest(ue) {
	return throwIfCancellationRequested(ue), ue.headers = AxiosHeaders$1.from(ue.headers), ue.data = transformData.call(ue, ue.transformRequest), ["post", "put", "patch"].indexOf(ue.method) !== -1 && ue.headers.setContentType("application/x-www-form-urlencoded", !1), adapters.getAdapter(ue.adapter || defaults$1.adapter)(ue).then(function(ta) {
		return throwIfCancellationRequested(ue), ta.data = transformData.call(ue, ue.transformResponse, ta), ta.headers = AxiosHeaders$1.from(ta.headers), ta
	}, function(ta) {
		return isCancel$1(ta) || (throwIfCancellationRequested(ue), ta && ta.response && (ta.response.data = transformData.call(ue, ue.transformResponse, ta.response), ta.response.headers = AxiosHeaders$1.from(ta.response.headers))), Promise.reject(ta)
	})
}
const VERSION$3 = "1.7.7",
	validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((ue, Yi) => {
	validators$1[ue] = function(ta) {
		return typeof ta === ue || "a" + (Yi < 1 ? "n " : " ") + ue
	}
});
const deprecatedWarnings = {};
validators$1.transitional = function(Yi, ea, ta) {
	function na(ra, ia) {
		return "[Axios v" + VERSION$3 + "] Transitional option '" + ra + "'" + ia + (ta ? ". " + ta : "")
	}
	return (ra, ia, aa) => {
		if (Yi === !1) throw new AxiosError$1(na(ia, " has been removed" + (ea ? " in " + ea : "")), AxiosError$1.ERR_DEPRECATED);
		return ea && !deprecatedWarnings[ia] && (deprecatedWarnings[ia] = !0, console.warn(na(ia, " has been deprecated since v" + ea + " and will be removed in the near future"))), Yi ? Yi(ra, ia, aa) : !0
	}
};

function assertOptions(ue, Yi, ea) {
	if (typeof ue != "object") throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
	const ta = Object.keys(ue);
	let na = ta.length;
	for (; na-- > 0;) {
		const ra = ta[na],
			ia = Yi[ra];
		if (ia) {
			const aa = ue[ra],
				oa = aa === void 0 || ia(aa, ra, ue);
			if (oa !== !0) throw new AxiosError$1("option " + ra + " must be " + oa, AxiosError$1.ERR_BAD_OPTION_VALUE);
			continue
		}
		if (ea !== !0) throw new AxiosError$1("Unknown option " + ra, AxiosError$1.ERR_BAD_OPTION)
	}
}
const validator = {
		assertOptions,
		validators: validators$1
	},
	validators = validator.validators;
let Axios$1 = class {
	constructor(Yi) {
		this.defaults = Yi, this.interceptors = {
			request: new InterceptorManager,
			response: new InterceptorManager
		}
	}
	async request(Yi, ea) {
		try {
			return await this._request(Yi, ea)
		} catch (ta) {
			if (ta instanceof Error) {
				let na;
				Error.captureStackTrace ? Error.captureStackTrace(na = {}) : na = new Error;
				const ra = na.stack ? na.stack.replace(/^.+\n/, "") : "";
				try {
					ta.stack ? ra && !String(ta.stack).endsWith(ra.replace(/^.+\n.+\n/, "")) && (ta.stack += `
` + ra) : ta.stack = ra
				} catch {}
			}
			throw ta
		}
	}
	_request(Yi, ea) {
		typeof Yi == "string" ? (ea = ea || {}, ea.url = Yi) : ea = Yi || {}, ea = mergeConfig$1(this.defaults, ea);
		const {
			transitional: ta,
			paramsSerializer: na,
			headers: ra
		} = ea;
		ta !== void 0 && validator.assertOptions(ta, {
			silentJSONParsing: validators.transitional(validators.boolean),
			forcedJSONParsing: validators.transitional(validators.boolean),
			clarifyTimeoutError: validators.transitional(validators.boolean)
		}, !1), na != null && (utils$5.isFunction(na) ? ea.paramsSerializer = {
			serialize: na
		} : validator.assertOptions(na, {
			encode: validators.function,
			serialize: validators.function
		}, !0)), ea.method = (ea.method || this.defaults.method || "get").toLowerCase();
		let ia = ra && utils$5.merge(ra.common, ra[ea.method]);
		ra && utils$5.forEach(["delete", "get", "head", "post", "put", "patch", "common"], ha => {
			delete ra[ha]
		}), ea.headers = AxiosHeaders$1.concat(ia, ra);
		const aa = [];
		let oa = !0;
		this.interceptors.request.forEach(function(pa) {
			typeof pa.runWhen == "function" && pa.runWhen(ea) === !1 || (oa = oa && pa.synchronous, aa.unshift(pa.fulfilled, pa.rejected))
		});
		const la = [];
		this.interceptors.response.forEach(function(pa) {
			la.push(pa.fulfilled, pa.rejected)
		});
		let sa, ca = 0,
			ua;
		if (!oa) {
			const ha = [dispatchRequest.bind(this), void 0];
			for (ha.unshift.apply(ha, aa), ha.push.apply(ha, la), ua = ha.length, sa = Promise.resolve(ea); ca < ua;) sa = sa.then(ha[ca++], ha[ca++]);
			return sa
		}
		ua = aa.length;
		let da = ea;
		for (ca = 0; ca < ua;) {
			const ha = aa[ca++],
				pa = aa[ca++];
			try {
				da = ha(da)
			} catch (va) {
				pa.call(this, va);
				break
			}
		}
		try {
			sa = dispatchRequest.call(this, da)
		} catch (ha) {
			return Promise.reject(ha)
		}
		for (ca = 0, ua = la.length; ca < ua;) sa = sa.then(la[ca++], la[ca++]);
		return sa
	}
	getUri(Yi) {
		Yi = mergeConfig$1(this.defaults, Yi);
		const ea = buildFullPath(Yi.baseURL, Yi.url);
		return buildURL(ea, Yi.params, Yi.paramsSerializer)
	}
};
utils$5.forEach(["delete", "get", "head", "options"], function(Yi) {
	Axios$1.prototype[Yi] = function(ea, ta) {
		return this.request(mergeConfig$1(ta || {}, {
			method: Yi,
			url: ea,
			data: (ta || {}).data
		}))
	}
});
utils$5.forEach(["post", "put", "patch"], function(Yi) {
	function ea(ta) {
		return function(ra, ia, aa) {
			return this.request(mergeConfig$1(aa || {}, {
				method: Yi,
				headers: ta ? {
					"Content-Type": "multipart/form-data"
				} : {},
				url: ra,
				data: ia
			}))
		}
	}
	Axios$1.prototype[Yi] = ea(), Axios$1.prototype[Yi + "Form"] = ea(!0)
});
let CancelToken$1 = class Js {
	constructor(Yi) {
		if (typeof Yi != "function") throw new TypeError("executor must be a function.");
		let ea;
		this.promise = new Promise(function(ra) {
			ea = ra
		});
		const ta = this;
		this.promise.then(na => {
			if (!ta._listeners) return;
			let ra = ta._listeners.length;
			for (; ra-- > 0;) ta._listeners[ra](na);
			ta._listeners = null
		}), this.promise.then = na => {
			let ra;
			const ia = new Promise(aa => {
				ta.subscribe(aa), ra = aa
			}).then(na);
			return ia.cancel = function() {
				ta.unsubscribe(ra)
			}, ia
		}, Yi(function(ra, ia, aa) {
			ta.reason || (ta.reason = new CanceledError$1(ra, ia, aa), ea(ta.reason))
		})
	}
	throwIfRequested() {
		if (this.reason) throw this.reason
	}
	subscribe(Yi) {
		if (this.reason) {
			Yi(this.reason);
			return
		}
		this._listeners ? this._listeners.push(Yi) : this._listeners = [Yi]
	}
	unsubscribe(Yi) {
		if (!this._listeners) return;
		const ea = this._listeners.indexOf(Yi);
		ea !== -1 && this._listeners.splice(ea, 1)
	}
	toAbortSignal() {
		const Yi = new AbortController,
			ea = ta => {
				Yi.abort(ta)
			};
		return this.subscribe(ea), Yi.signal.unsubscribe = () => this.unsubscribe(ea), Yi.signal
	}
	static source() {
		let Yi;
		return {
			token: new Js(function(na) {
				Yi = na
			}),
			cancel: Yi
		}
	}
};

function spread$1(ue) {
	return function(ea) {
		return ue.apply(null, ea)
	}
}

function isAxiosError$1(ue) {
	return utils$5.isObject(ue) && ue.isAxiosError === !0
}
const HttpStatusCode$1 = {
	Continue: 100,
	SwitchingProtocols: 101,
	Processing: 102,
	EarlyHints: 103,
	Ok: 200,
	Created: 201,
	Accepted: 202,
	NonAuthoritativeInformation: 203,
	NoContent: 204,
	ResetContent: 205,
	PartialContent: 206,
	MultiStatus: 207,
	AlreadyReported: 208,
	ImUsed: 226,
	MultipleChoices: 300,
	MovedPermanently: 301,
	Found: 302,
	SeeOther: 303,
	NotModified: 304,
	UseProxy: 305,
	Unused: 306,
	TemporaryRedirect: 307,
	PermanentRedirect: 308,
	BadRequest: 400,
	Unauthorized: 401,
	PaymentRequired: 402,
	Forbidden: 403,
	NotFound: 404,
	MethodNotAllowed: 405,
	NotAcceptable: 406,
	ProxyAuthenticationRequired: 407,
	RequestTimeout: 408,
	Conflict: 409,
	Gone: 410,
	LengthRequired: 411,
	PreconditionFailed: 412,
	PayloadTooLarge: 413,
	UriTooLong: 414,
	UnsupportedMediaType: 415,
	RangeNotSatisfiable: 416,
	ExpectationFailed: 417,
	ImATeapot: 418,
	MisdirectedRequest: 421,
	UnprocessableEntity: 422,
	Locked: 423,
	FailedDependency: 424,
	TooEarly: 425,
	UpgradeRequired: 426,
	PreconditionRequired: 428,
	TooManyRequests: 429,
	RequestHeaderFieldsTooLarge: 431,
	UnavailableForLegalReasons: 451,
	InternalServerError: 500,
	NotImplemented: 501,
	BadGateway: 502,
	ServiceUnavailable: 503,
	GatewayTimeout: 504,
	HttpVersionNotSupported: 505,
	VariantAlsoNegotiates: 506,
	InsufficientStorage: 507,
	LoopDetected: 508,
	NotExtended: 510,
	NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode$1).forEach(([ue, Yi]) => {
	HttpStatusCode$1[Yi] = ue
});

function createInstance(ue) {
	const Yi = new Axios$1(ue),
		ea = bind(Axios$1.prototype.request, Yi);
	return utils$5.extend(ea, Axios$1.prototype, Yi, {
		allOwnKeys: !0
	}), utils$5.extend(ea, Yi, null, {
		allOwnKeys: !0
	}), ea.create = function(na) {
		return createInstance(mergeConfig$1(ue, na))
	}, ea
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$3;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = function(Yi) {
	return Promise.all(Yi)
};
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = ue => formDataToJSON(utils$5.isHTMLForm(ue) ? new FormData(ue) : ue);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const {
	Axios,
	AxiosError,
	CanceledError,
	isCancel,
	CancelToken,
	VERSION: VERSION$2,
	all,
	Cancel,
	isAxiosError,
	spread,
	toFormData,
	AxiosHeaders,
	HttpStatusCode,
	formToJSON,
	getAdapter,
	mergeConfig
} = axios;
var dist$1 = {},
	Address$1 = {};
const SymbolInspect = Symbol.for("nodejs.util.inspect.custom");
var symbol_inspect = SymbolInspect,
	crc16$2 = {};
Object.defineProperty(crc16$2, "__esModule", {
	value: !0
});
crc16$2.crc16 = void 0;

function crc16$1(ue) {
	let ea = 0;
	const ta = Buffer.alloc(ue.length + 2);
	ta.set(ue);
	for (let na of ta) {
		let ra = 128;
		for (; ra > 0;) ea <<= 1, na & ra && (ea += 1), ra >>= 1, ea > 65535 && (ea &= 65535, ea ^= 4129)
	}
	return Buffer.from([Math.floor(ea / 256), ea % 256])
}
crc16$2.crc16 = crc16$1;
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(ue) {
		return ue && ue.__esModule ? ue : {
			default: ue
		}
	},
	_a$4;
Object.defineProperty(Address$1, "__esModule", {
	value: !0
});
Address$1.address = Address$1.Address = void 0;
const symbol_inspect_1$2 = __importDefault$7(symbol_inspect),
	crc16_1$1 = crc16$2,
	bounceable_tag = 17,
	non_bounceable_tag = 81,
	test_flag = 128;

function parseFriendlyAddress(ue) {
	if (typeof ue == "string" && !Address.isFriendly(ue)) throw new Error("Unknown address type");
	const Yi = Buffer.isBuffer(ue) ? ue : Buffer.from(ue, "base64");
	if (Yi.length !== 36) throw new Error("Unknown address type: byte length is not equal to 36");
	const ea = Yi.subarray(0, 34),
		ta = Yi.subarray(34, 36),
		na = (0, crc16_1$1.crc16)(ea);
	if (!(na[0] === ta[0] && na[1] === ta[1])) throw new Error("Invalid checksum: " + ue);
	let ra = ea[0],
		ia = !1,
		aa = !1;
	if (ra & test_flag && (ia = !0, ra = ra ^ test_flag), ra !== bounceable_tag && ra !== non_bounceable_tag) throw "Unknown address tag";
	aa = ra === bounceable_tag;
	let oa = null;
	ea[1] === 255 ? oa = -1 : oa = ea[1];
	const la = ea.subarray(2, 34);
	return {
		isTestOnly: ia,
		isBounceable: aa,
		workchain: oa,
		hashPart: la
	}
}
class Address {
	static isAddress(Yi) {
		return Yi instanceof Address
	}
	static isFriendly(Yi) {
		return !(Yi.length !== 48 || !/[A-Za-z0-9+/_-]+/.test(Yi))
	}
	static isRaw(Yi) {
		if (Yi.indexOf(":") === -1) return !1;
		let [ea, ta] = Yi.split(":");
		return !(!Number.isInteger(parseFloat(ea)) || !/[a-f0-9]+/.test(ta.toLowerCase()) || ta.length !== 64)
	}
	static normalize(Yi) {
		return typeof Yi == "string" ? Address.parse(Yi).toString() : Yi.toString()
	}
	static parse(Yi) {
		if (Address.isFriendly(Yi)) return this.parseFriendly(Yi).address;
		if (Address.isRaw(Yi)) return this.parseRaw(Yi);
		throw new Error("Unknown address type: " + Yi)
	}
	static parseRaw(Yi) {
		let ea = parseInt(Yi.split(":")[0]),
			ta = Buffer.from(Yi.split(":")[1], "hex");
		return new Address(ea, ta)
	}
	static parseFriendly(Yi) {
		if (Buffer.isBuffer(Yi)) {
			let ea = parseFriendlyAddress(Yi);
			return {
				isBounceable: ea.isBounceable,
				isTestOnly: ea.isTestOnly,
				address: new Address(ea.workchain, ea.hashPart)
			}
		} else {
			let ea = Yi.replace(/\-/g, "+").replace(/_/g, "/"),
				ta = parseFriendlyAddress(ea);
			return {
				isBounceable: ta.isBounceable,
				isTestOnly: ta.isTestOnly,
				address: new Address(ta.workchain, ta.hashPart)
			}
		}
	}
	constructor(Yi, ea) {
		if (this.toRawString = () => this.workChain + ":" + this.hash.toString("hex"), this.toRaw = () => {
				const ta = Buffer.alloc(36);
				return ta.set(this.hash), ta.set([this.workChain, this.workChain, this.workChain, this.workChain], 32), ta
			}, this.toStringBuffer = ta => {
				let na = ta && ta.testOnly !== void 0 ? ta.testOnly : !1,
					ia = (ta && ta.bounceable !== void 0 ? ta.bounceable : !0) ? bounceable_tag : non_bounceable_tag;
				na && (ia |= test_flag);
				const aa = Buffer.alloc(34);
				aa[0] = ia, aa[1] = this.workChain, aa.set(this.hash, 2);
				const oa = Buffer.alloc(36);
				return oa.set(aa), oa.set((0, crc16_1$1.crc16)(aa), 34), oa
			}, this.toString = ta => {
				let na = ta && ta.urlSafe !== void 0 ? ta.urlSafe : !0,
					ra = this.toStringBuffer(ta);
				return na ? ra.toString("base64").replace(/\+/g, "-").replace(/\//g, "_") : ra.toString("base64")
			}, this[_a$4] = () => this.toString(), ea.length !== 32) throw new Error("Invalid address hash length: " + ea.length);
		this.workChain = Yi, this.hash = ea, Object.freeze(this)
	}
	equals(Yi) {
		return Yi.workChain !== this.workChain ? !1 : Yi.hash.equals(this.hash)
	}
}
Address$1.Address = Address;
_a$4 = symbol_inspect_1$2.default;

function address(ue) {
	return Address.parse(ue)
}
Address$1.address = address;
var ExternalAddress$1 = {},
	__importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(ue) {
		return ue && ue.__esModule ? ue : {
			default: ue
		}
	},
	_a$3;
Object.defineProperty(ExternalAddress$1, "__esModule", {
	value: !0
});
ExternalAddress$1.ExternalAddress = void 0;
const symbol_inspect_1$1 = __importDefault$6(symbol_inspect);
class ExternalAddress {
	static isAddress(Yi) {
		return Yi instanceof ExternalAddress
	}
	constructor(Yi, ea) {
		this[_a$3] = () => this.toString(), this.value = Yi, this.bits = ea
	}
	toString() {
		return `External<${this.bits}:${this.value}>`
	}
}
ExternalAddress$1.ExternalAddress = ExternalAddress;
_a$3 = symbol_inspect_1$1.default;
var ADNLAddress$1 = {},
	base32 = {};
Object.defineProperty(base32, "__esModule", {
	value: !0
});
base32.base32Decode = base32.base32Encode = void 0;
const alphabet = "abcdefghijklmnopqrstuvwxyz234567";

function base32Encode(ue) {
	const Yi = ue.byteLength;
	let ea = 0,
		ta = 0,
		na = "";
	for (let ra = 0; ra < Yi; ra++)
		for (ta = ta << 8 | ue[ra], ea += 8; ea >= 5;) na += alphabet[ta >>> ea - 5 & 31], ea -= 5;
	return ea > 0 && (na += alphabet[ta << 5 - ea & 31]), na
}
base32.base32Encode = base32Encode;

function readChar(ue, Yi) {
	const ea = ue.indexOf(Yi);
	if (ea === -1) throw new Error("Invalid character found: " + Yi);
	return ea
}

function base32Decode(ue) {
	let Yi;
	Yi = ue.toLowerCase();
	const {
		length: ea
	} = Yi;
	let ta = 0,
		na = 0,
		ra = 0;
	const ia = Buffer.alloc(ea * 5 / 8 | 0);
	for (let aa = 0; aa < ea; aa++) na = na << 5 | readChar(alphabet, Yi[aa]), ta += 5, ta >= 8 && (ia[ra++] = na >>> ta - 8 & 255, ta -= 8);
	return ia
}
base32.base32Decode = base32Decode;
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(ue) {
		return ue && ue.__esModule ? ue : {
			default: ue
		}
	},
	_a$2;
Object.defineProperty(ADNLAddress$1, "__esModule", {
	value: !0
});
ADNLAddress$1.ADNLAddress = void 0;
const symbol_inspect_1 = __importDefault$5(symbol_inspect),
	base32_1 = base32,
	crc16_1 = crc16$2;
class ADNLAddress {
	static parseFriendly(Yi) {
		if (Yi.length !== 55) throw Error("Invalid address");
		Yi = "f" + Yi;
		let ea = (0, base32_1.base32Decode)(Yi);
		if (ea[0] !== 45) throw Error("Invalid address");
		let ta = ea.slice(33);
		if (!(0, crc16_1.crc16)(ea.slice(0, 33)).equals(ta)) throw Error("Invalid address");
		return new ADNLAddress(ea.slice(1, 33))
	}
	static parseRaw(Yi) {
		const ea = Buffer.from(Yi, "base64");
		return new ADNLAddress(ea)
	}
	constructor(Yi) {
		if (this.toRaw = () => this.address.toString("hex").toUpperCase(), this.toString = () => {
				let ea = Buffer.concat([Buffer.from([45]), this.address]),
					ta = (0, crc16_1.crc16)(ea);
				return ea = Buffer.concat([ea, ta]), (0, base32_1.base32Encode)(ea).slice(1)
			}, this[_a$2] = () => this.toString(), Yi.length !== 32) throw Error("Invalid address");
		this.address = Yi
	}
	equals(Yi) {
		return this.address.equals(Yi.address)
	}
}
ADNLAddress$1.ADNLAddress = ADNLAddress;
_a$2 = symbol_inspect_1.default;
var contractAddress$1 = {},
	Builder = {},
	BitBuilder = {},
	BitString = {},
	paddedBits = {},
	hasRequiredPaddedBits;

function requirePaddedBits() {
	if (hasRequiredPaddedBits) return paddedBits;
	hasRequiredPaddedBits = 1, Object.defineProperty(paddedBits, "__esModule", {
		value: !0
	}), paddedBits.paddedBufferToBits = paddedBits.bitsToPaddedBuffer = void 0;
	const ue = requireBitBuilder(),
		Yi = requireBitString();

	function ea(na) {
		let ra = new ue.BitBuilder(Math.ceil(na.length / 8) * 8);
		ra.writeBits(na);
		let ia = Math.ceil(na.length / 8) * 8 - na.length;
		for (let aa = 0; aa < ia; aa++) aa === 0 ? ra.writeBit(1) : ra.writeBit(0);
		return ra.buffer()
	}
	paddedBits.bitsToPaddedBuffer = ea;

	function ta(na) {
		let ra = 0;
		for (let ia = na.length - 1; ia >= 0; ia--)
			if (na[ia] !== 0) {
				const aa = na[ia];
				let oa = aa & -aa;
				oa & 1 || (oa = Math.log2(oa) + 1), ia > 0 && (ra = ia << 3), ra += 8 - oa;
				break
			} return new Yi.BitString(na, 0, ra)
	}
	return paddedBits.paddedBufferToBits = ta, paddedBits
}
var hasRequiredBitString;

function requireBitString() {
	if (hasRequiredBitString) return BitString;
	hasRequiredBitString = 1;
	var ue = commonjsGlobal && commonjsGlobal.__importDefault || function(ra) {
			return ra && ra.__esModule ? ra : {
				default: ra
			}
		},
		Yi;
	Object.defineProperty(BitString, "__esModule", {
		value: !0
	}), BitString.BitString = void 0;
	const ea = requirePaddedBits(),
		ta = ue(symbol_inspect);
	let na = class qs {
		static isBitString(ia) {
			return ia instanceof qs
		}
		constructor(ia, aa, oa) {
			if (this[Yi] = () => this.toString(), oa < 0) throw new Error(`Length ${oa} is out of bounds`);
			this._length = oa, this._data = ia, this._offset = aa
		}
		get length() {
			return this._length
		}
		at(ia) {
			if (ia >= this._length) throw new Error(`Index ${ia} > ${this._length} is out of bounds`);
			if (ia < 0) throw new Error(`Index ${ia} < 0 is out of bounds`);
			let aa = this._offset + ia >> 3,
				oa = 7 - (this._offset + ia) % 8;
			return (this._data[aa] & 1 << oa) !== 0
		}
		substring(ia, aa) {
			if (ia > this._length) throw new Error(`Offset(${ia}) > ${this._length} is out of bounds`);
			if (ia < 0) throw new Error(`Offset(${ia}) < 0 is out of bounds`);
			if (aa === 0) return qs.EMPTY;
			if (ia + aa > this._length) throw new Error(`Offset ${ia} + Length ${aa} > ${this._length} is out of bounds`);
			return new qs(this._data, this._offset + ia, aa)
		}
		subbuffer(ia, aa) {
			if (ia > this._length) throw new Error(`Offset ${ia} is out of bounds`);
			if (ia < 0) throw new Error(`Offset ${ia} is out of bounds`);
			if (ia + aa > this._length) throw new Error(`Offset + Lenght = ${ia+aa} is out of bounds`);
			if (aa % 8 !== 0 || (this._offset + ia) % 8 !== 0) return null;
			let oa = this._offset + ia >> 3,
				la = oa + (aa >> 3);
			return this._data.subarray(oa, la)
		}
		equals(ia) {
			if (this._length !== ia._length) return !1;
			for (let aa = 0; aa < this._length; aa++)
				if (this.at(aa) !== ia.at(aa)) return !1;
			return !0
		}
		toString() {
			const ia = (0, ea.bitsToPaddedBuffer)(this);
			if (this._length % 4 === 0) {
				const aa = ia.subarray(0, Math.ceil(this._length / 8)).toString("hex").toUpperCase();
				return this._length % 8 === 0 ? aa : aa.substring(0, aa.length - 1)
			} else {
				const aa = ia.toString("hex").toUpperCase();
				return this._length % 8 <= 4 ? aa.substring(0, aa.length - 1) + "_" : aa + "_"
			}
		}
	};
	return BitString.BitString = na, Yi = ta.default, na.EMPTY = new na(Buffer.alloc(0), 0, 0), BitString
}
var hasRequiredBitBuilder;

function requireBitBuilder() {
	if (hasRequiredBitBuilder) return BitBuilder;
	hasRequiredBitBuilder = 1, Object.defineProperty(BitBuilder, "__esModule", {
		value: !0
	}), BitBuilder.BitBuilder = void 0;
	const ue = Address$1,
		Yi = ExternalAddress$1,
		ea = requireBitString();
	let ta = class {
		constructor(ra = 1023) {
			this._buffer = Buffer.alloc(Math.ceil(ra / 8)), this._length = 0
		}
		get length() {
			return this._length
		}
		writeBit(ra) {
			let ia = this._length;
			if (ia > this._buffer.length * 8) throw new Error("BitBuilder overflow");
			(typeof ra == "boolean" && ra === !0 || typeof ra == "number" && ra > 0) && (this._buffer[ia / 8 | 0] |= 1 << 7 - ia % 8), this._length++
		}
		writeBits(ra) {
			for (let ia = 0; ia < ra.length; ia++) this.writeBit(ra.at(ia))
		}
		writeBuffer(ra) {
			if (this._length % 8 === 0) {
				if (this._length + ra.length * 8 > this._buffer.length * 8) throw new Error("BitBuilder overflow");
				ra.copy(this._buffer, this._length / 8), this._length += ra.length * 8
			} else
				for (let ia = 0; ia < ra.length; ia++) this.writeUint(ra[ia], 8)
		}
		writeUint(ra, ia) {
			if (ia < 0 || !Number.isSafeInteger(ia)) throw Error(`invalid bit length. Got ${ia}`);
			const aa = BigInt(ra);
			if (ia === 0) {
				if (aa !== 0n) throw Error(`value is not zero for ${ia} bits. Got ${ra}`);
				return
			}
			const oa = 1n << BigInt(ia);
			if (aa < 0 || aa >= oa) throw Error(`bitLength is too small for a value ${ra}. Got ${ia}`);
			if (this._length + ia > this._buffer.length * 8) throw new Error("BitBuilder overflow");
			const la = 8 - this._length % 8;
			if (la > 0) {
				const sa = Math.floor(this._length / 8);
				if (ia < la) {
					const ca = Number(aa);
					this._buffer[sa] |= ca << la - ia, this._length += ia
				} else {
					const ca = Number(aa >> BigInt(ia - la));
					this._buffer[sa] |= ca, this._length += la
				}
			}
			for (ia -= la; ia > 0;) ia >= 8 ? (this._buffer[this._length / 8] = Number(aa >> BigInt(ia - 8) & 0xffn), this._length += 8, ia -= 8) : (this._buffer[this._length / 8] = Number(aa << BigInt(8 - ia) & 0xffn), this._length += ia, ia = 0)
		}
		writeInt(ra, ia) {
			let aa = BigInt(ra);
			if (ia < 0 || !Number.isSafeInteger(ia)) throw Error(`invalid bit length. Got ${ia}`);
			if (ia === 0) {
				if (ra !== 0n) throw Error(`value is not zero for ${ia} bits. Got ${ra}`);
				return
			}
			if (ia === 1) {
				if (ra !== -1n && ra !== 0n) throw Error(`value is not zero or -1 for ${ia} bits. Got ${ra}`);
				this.writeBit(ra === -1n);
				return
			}
			let oa = 1n << BigInt(ia) - 1n;
			if (aa < -oa || aa >= oa) throw Error(`value is out of range for ${ia} bits. Got ${ra}`);
			aa < 0 ? (this.writeBit(!0), aa = oa + aa) : this.writeBit(!1), this.writeUint(aa, ia - 1)
		}
		writeVarUint(ra, ia) {
			let aa = BigInt(ra);
			if (ia < 0 || !Number.isSafeInteger(ia)) throw Error(`invalid bit length. Got ${ia}`);
			if (aa < 0) throw Error(`value is negative. Got ${ra}`);
			if (aa === 0n) {
				this.writeUint(0, ia);
				return
			}
			const oa = Math.ceil(aa.toString(2).length / 8),
				la = oa * 8;
			this.writeUint(oa, ia), this.writeUint(aa, la)
		}
		writeVarInt(ra, ia) {
			let aa = BigInt(ra);
			if (ia < 0 || !Number.isSafeInteger(ia)) throw Error(`invalid bit length. Got ${ia}`);
			if (aa === 0n) {
				this.writeUint(0, ia);
				return
			}
			let oa = aa > 0 ? aa : -aa;
			const la = 1 + Math.ceil(oa.toString(2).length / 8),
				sa = la * 8;
			this.writeUint(la, ia), this.writeInt(aa, sa)
		}
		writeCoins(ra) {
			this.writeVarUint(ra, 4)
		}
		writeAddress(ra) {
			if (ra == null) {
				this.writeUint(0, 2);
				return
			}
			if (ue.Address.isAddress(ra)) {
				this.writeUint(2, 2), this.writeUint(0, 1), this.writeInt(ra.workChain, 8), this.writeBuffer(ra.hash);
				return
			}
			if (Yi.ExternalAddress.isAddress(ra)) {
				this.writeUint(1, 2), this.writeUint(ra.bits, 9), this.writeUint(ra.value, ra.bits);
				return
			}
			throw Error(`Invalid address. Got ${ra}`)
		}
		build() {
			return new ea.BitString(this._buffer, 0, this._length)
		}
		buffer() {
			if (this._length % 8 !== 0) throw new Error("BitBuilder buffer is not byte aligned");
			return this._buffer.subarray(0, this._length / 8)
		}
	};
	return BitBuilder.BitBuilder = ta, BitBuilder
}
var Cell = {},
	CellType$1 = {};
Object.defineProperty(CellType$1, "__esModule", {
	value: !0
});
CellType$1.CellType = void 0;
var CellType;
(function(ue) {
	ue[ue.Ordinary = -1] = "Ordinary", ue[ue.PrunedBranch = 1] = "PrunedBranch", ue[ue.Library = 2] = "Library", ue[ue.MerkleProof = 3] = "MerkleProof", ue[ue.MerkleUpdate = 4] = "MerkleUpdate"
})(CellType || (CellType$1.CellType = CellType = {}));
var Slice = {},
	Dictionary = {},
	generateMerkleProof = {},
	readUnaryLength$2 = {};
Object.defineProperty(readUnaryLength$2, "__esModule", {
	value: !0
});
readUnaryLength$2.readUnaryLength = void 0;

function readUnaryLength$1(ue) {
	let Yi = 0;
	for (; ue.loadBit();) Yi++;
	return Yi
}
readUnaryLength$2.readUnaryLength = readUnaryLength$1;
var exoticMerkleProof = {},
	BitReader$1 = {};
Object.defineProperty(BitReader$1, "__esModule", {
	value: !0
});
BitReader$1.BitReader = void 0;
const Address_1$4 = Address$1,
	ExternalAddress_1 = ExternalAddress$1;
class BitReader {
	constructor(Yi, ea = 0) {
		this._checkpoints = [], this._bits = Yi, this._offset = ea
	}
	get offset() {
		return this._offset
	}
	get remaining() {
		return this._bits.length - this._offset
	}
	skip(Yi) {
		if (Yi < 0 || this._offset + Yi > this._bits.length) throw new Error(`Index ${this._offset+Yi} is out of bounds`);
		this._offset += Yi
	}
	reset() {
		this._checkpoints.length > 0 ? this._offset = this._checkpoints.pop() : this._offset = 0
	}
	save() {
		this._checkpoints.push(this._offset)
	}
	loadBit() {
		let Yi = this._bits.at(this._offset);
		return this._offset++, Yi
	}
	preloadBit() {
		return this._bits.at(this._offset)
	}
	loadBits(Yi) {
		let ea = this._bits.substring(this._offset, Yi);
		return this._offset += Yi, ea
	}
	preloadBits(Yi) {
		return this._bits.substring(this._offset, Yi)
	}
	loadBuffer(Yi) {
		let ea = this._preloadBuffer(Yi, this._offset);
		return this._offset += Yi * 8, ea
	}
	preloadBuffer(Yi) {
		return this._preloadBuffer(Yi, this._offset)
	}
	loadUint(Yi) {
		return this._toSafeInteger(this.loadUintBig(Yi), "loadUintBig")
	}
	loadUintBig(Yi) {
		let ea = this.preloadUintBig(Yi);
		return this._offset += Yi, ea
	}
	preloadUint(Yi) {
		return this._toSafeInteger(this._preloadUint(Yi, this._offset), "preloadUintBig")
	}
	preloadUintBig(Yi) {
		return this._preloadUint(Yi, this._offset)
	}
	loadInt(Yi) {
		let ea = this._preloadInt(Yi, this._offset);
		return this._offset += Yi, this._toSafeInteger(ea, "loadUintBig")
	}
	loadIntBig(Yi) {
		let ea = this._preloadInt(Yi, this._offset);
		return this._offset += Yi, ea
	}
	preloadInt(Yi) {
		return this._toSafeInteger(this._preloadInt(Yi, this._offset), "preloadIntBig")
	}
	preloadIntBig(Yi) {
		return this._preloadInt(Yi, this._offset)
	}
	loadVarUint(Yi) {
		let ea = Number(this.loadUint(Yi));
		return this._toSafeInteger(this.loadUintBig(ea * 8), "loadVarUintBig")
	}
	loadVarUintBig(Yi) {
		let ea = Number(this.loadUint(Yi));
		return this.loadUintBig(ea * 8)
	}
	preloadVarUint(Yi) {
		let ea = Number(this._preloadUint(Yi, this._offset));
		return this._toSafeInteger(this._preloadUint(ea * 8, this._offset + Yi), "preloadVarUintBig")
	}
	preloadVarUintBig(Yi) {
		let ea = Number(this._preloadUint(Yi, this._offset));
		return this._preloadUint(ea * 8, this._offset + Yi)
	}
	loadVarInt(Yi) {
		let ea = Number(this.loadUint(Yi));
		return this._toSafeInteger(this.loadIntBig(ea * 8), "loadVarIntBig")
	}
	loadVarIntBig(Yi) {
		let ea = Number(this.loadUint(Yi));
		return this.loadIntBig(ea * 8)
	}
	preloadVarInt(Yi) {
		let ea = Number(this._preloadUint(Yi, this._offset));
		return this._toSafeInteger(this._preloadInt(ea * 8, this._offset + Yi), "preloadVarIntBig")
	}
	preloadVarIntBig(Yi) {
		let ea = Number(this._preloadUint(Yi, this._offset));
		return this._preloadInt(ea * 8, this._offset + Yi)
	}
	loadCoins() {
		return this.loadVarUintBig(4)
	}
	preloadCoins() {
		return this.preloadVarUintBig(4)
	}
	loadAddress() {
		let Yi = Number(this._preloadUint(2, this._offset));
		if (Yi === 2) return this._loadInternalAddress();
		throw new Error("Invalid address: " + Yi)
	}
	loadMaybeAddress() {
		let Yi = Number(this._preloadUint(2, this._offset));
		if (Yi === 0) return this._offset += 2, null;
		if (Yi === 2) return this._loadInternalAddress();
		throw new Error("Invalid address")
	}
	loadExternalAddress() {
		if (Number(this._preloadUint(2, this._offset)) === 1) return this._loadExternalAddress();
		throw new Error("Invalid address")
	}
	loadMaybeExternalAddress() {
		let Yi = Number(this._preloadUint(2, this._offset));
		if (Yi === 0) return this._offset += 2, null;
		if (Yi === 1) return this._loadExternalAddress();
		throw new Error("Invalid address")
	}
	loadAddressAny() {
		let Yi = Number(this._preloadUint(2, this._offset));
		if (Yi === 0) return this._offset += 2, null;
		if (Yi === 2) return this._loadInternalAddress();
		if (Yi === 1) return this._loadExternalAddress();
		throw Error(Yi === 3 ? "Unsupported" : "Unreachable")
	}
	loadPaddedBits(Yi) {
		if (Yi % 8 !== 0) throw new Error("Invalid number of bits");
		let ea = Yi;
		for (;;)
			if (this._bits.at(this._offset + ea - 1)) {
				ea--;
				break
			} else ea--;
		let ta = this._bits.substring(this._offset, ea);
		return this._offset += Yi, ta
	}
	clone() {
		return new BitReader(this._bits, this._offset)
	}
	_preloadInt(Yi, ea) {
		if (Yi == 0) return 0n;
		let ta = this._bits.at(ea),
			na = 0n;
		for (let ra = 0; ra < Yi - 1; ra++) this._bits.at(ea + 1 + ra) && (na += 1n << BigInt(Yi - ra - 1 - 1));
		return ta && (na = na - (1n << BigInt(Yi - 1))), na
	}
	_preloadUint(Yi, ea) {
		if (Yi == 0) return 0n;
		let ta = 0n;
		for (let na = 0; na < Yi; na++) this._bits.at(ea + na) && (ta += 1n << BigInt(Yi - na - 1));
		return ta
	}
	_preloadBuffer(Yi, ea) {
		let ta = this._bits.subbuffer(ea, Yi * 8);
		if (ta) return ta;
		let na = Buffer.alloc(Yi);
		for (let ra = 0; ra < Yi; ra++) na[ra] = Number(this._preloadUint(8, ea + ra * 8));
		return na
	}
	_loadInternalAddress() {
		if (Number(this._preloadUint(2, this._offset)) !== 2 || this._preloadUint(1, this._offset + 2) !== 0n) throw Error("Invalid address");
		let ea = Number(this._preloadInt(8, this._offset + 3)),
			ta = this._preloadBuffer(32, this._offset + 11);
		return this._offset += 267, new Address_1$4.Address(ea, ta)
	}
	_loadExternalAddress() {
		if (Number(this._preloadUint(2, this._offset)) !== 1) throw Error("Invalid address");
		let ea = Number(this._preloadUint(9, this._offset + 2)),
			ta = this._preloadUint(ea, this._offset + 11);
		return this._offset += 11 + ea, new ExternalAddress_1.ExternalAddress(ta, ea)
	}
	_toSafeInteger(Yi, ea) {
		if (BigInt(Number.MAX_SAFE_INTEGER) < Yi || Yi < BigInt(Number.MIN_SAFE_INTEGER)) throw new TypeError(`${Yi} is out of safe integer range. Use ${ea} instead`);
		return Number(Yi)
	}
}
BitReader$1.BitReader = BitReader;
var hasRequiredExoticMerkleProof;

function requireExoticMerkleProof() {
	if (hasRequiredExoticMerkleProof) return exoticMerkleProof;
	hasRequiredExoticMerkleProof = 1, Object.defineProperty(exoticMerkleProof, "__esModule", {
		value: !0
	}), exoticMerkleProof.convertToMerkleProof = exoticMerkleProof.exoticMerkleProof = void 0;
	const ue = BitReader$1,
		Yi = requireBuilder();

	function ea(na, ra) {
		const ia = new ue.BitReader(na);
		if (na.length !== 280) throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${na.length}"`);
		if (ra.length !== 1) throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${ra.length}"`);
		let oa = ia.loadUint(8);
		if (oa !== 3) throw new Error(`Merkle Proof cell must have type 3, got "${oa}"`);
		const la = ia.loadBuffer(32),
			sa = ia.loadUint(16),
			ca = ra[0].hash(0),
			ua = ra[0].depth(0);
		if (sa !== ua) throw new Error(`Merkle Proof cell ref depth must be exactly "${sa}", got "${ua}"`);
		if (!la.equals(ca)) throw new Error(`Merkle Proof cell ref hash must be exactly "${la.toString("hex")}", got "${ca.toString("hex")}"`);
		return {
			proofDepth: sa,
			proofHash: la
		}
	}
	exoticMerkleProof.exoticMerkleProof = ea;

	function ta(na) {
		return (0, Yi.beginCell)().storeUint(3, 8).storeBuffer(na.hash(0)).storeUint(na.depth(0), 16).storeRef(na).endCell({
			exotic: !0
		})
	}
	return exoticMerkleProof.convertToMerkleProof = ta, exoticMerkleProof
}
var hasRequiredGenerateMerkleProof;

function requireGenerateMerkleProof() {
	if (hasRequiredGenerateMerkleProof) return generateMerkleProof;
	hasRequiredGenerateMerkleProof = 1, Object.defineProperty(generateMerkleProof, "__esModule", {
		value: !0
	}), generateMerkleProof.generateMerkleProof = generateMerkleProof.generateMerkleProofDirect = void 0;
	const ue = requireBuilder(),
		Yi = readUnaryLength$2,
		ea = requireExoticMerkleProof();

	function ta(aa) {
		return (0, ue.beginCell)().storeUint(1, 8).storeUint(1, 8).storeBuffer(aa.hash(0)).storeUint(aa.depth(0), 16).endCell({
			exotic: !0
		})
	}

	function na(aa, oa, la, sa) {
		const ca = oa.asCell();
		if (sa.length == 0) return ta(ca);
		let ua = oa.loadBit() ? 1 : 0,
			da = 0,
			ha = aa;
		if (ua === 0) {
			da = (0, Yi.readUnaryLength)(oa);
			for (let pa = 0; pa < da; pa++) ha += oa.loadBit() ? "1" : "0"
		} else if ((oa.loadBit() ? 1 : 0) === 0) {
			da = oa.loadUint(Math.ceil(Math.log2(la + 1)));
			for (let va = 0; va < da; va++) ha += oa.loadBit() ? "1" : "0"
		} else {
			let va = oa.loadBit() ? "1" : "0";
			da = oa.loadUint(Math.ceil(Math.log2(la + 1)));
			for (let ba = 0; ba < da; ba++) ha += va
		}
		if (la - da === 0) return ca;
		{
			let pa = ca.beginParse(),
				va = pa.loadRef(),
				ba = pa.loadRef();
			if (!va.isExotic) {
				const Ea = sa.filter(Sa => ha + "0" === Sa.slice(0, ha.length + 1));
				va = na(ha + "0", va.beginParse(), la - da - 1, Ea)
			}
			if (!ba.isExotic) {
				const Ea = sa.filter(Sa => ha + "1" === Sa.slice(0, ha.length + 1));
				ba = na(ha + "1", ba.beginParse(), la - da - 1, Ea)
			}
			return (0, ue.beginCell)().storeSlice(pa).storeRef(va).storeRef(ba).endCell()
		}
	}

	function ra(aa, oa, la) {
		oa.forEach(ca => {
			if (!aa.has(ca)) throw new Error(`Trying to generate merkle proof for a missing key "${ca}"`)
		});
		const sa = (0, ue.beginCell)().storeDictDirect(aa).asSlice();
		return na("", sa, la.bits, oa.map(ca => la.serialize(ca).toString(2).padStart(la.bits, "0")))
	}
	generateMerkleProof.generateMerkleProofDirect = ra;

	function ia(aa, oa, la) {
		return (0, ea.convertToMerkleProof)(ra(aa, oa, la))
	}
	return generateMerkleProof.generateMerkleProof = ia, generateMerkleProof
}
var generateMerkleUpdate = {},
	hasRequiredGenerateMerkleUpdate;

function requireGenerateMerkleUpdate() {
	if (hasRequiredGenerateMerkleUpdate) return generateMerkleUpdate;
	hasRequiredGenerateMerkleUpdate = 1, Object.defineProperty(generateMerkleUpdate, "__esModule", {
		value: !0
	}), generateMerkleUpdate.generateMerkleUpdate = void 0;
	const ue = requireBuilder(),
		Yi = requireGenerateMerkleProof();

	function ea(na, ra) {
		return (0, ue.beginCell)().storeUint(4, 8).storeBuffer(na.hash(0)).storeBuffer(ra.hash(0)).storeUint(na.depth(0), 16).storeUint(ra.depth(0), 16).storeRef(na).storeRef(ra).endCell({
			exotic: !0
		})
	}

	function ta(na, ra, ia, aa) {
		const oa = (0, Yi.generateMerkleProof)(na, [ra], ia).refs[0];
		na.set(ra, aa);
		const la = (0, Yi.generateMerkleProof)(na, [ra], ia).refs[0];
		return ea(oa, la)
	}
	return generateMerkleUpdate.generateMerkleUpdate = ta, generateMerkleUpdate
}
var parseDict$1 = {};
Object.defineProperty(parseDict$1, "__esModule", {
	value: !0
});
parseDict$1.parseDict = void 0;

function readUnaryLength(ue) {
	let Yi = 0;
	for (; ue.loadBit();) Yi++;
	return Yi
}

function doParse(ue, Yi, ea, ta, na) {
	let ra = Yi.loadBit() ? 1 : 0,
		ia = 0,
		aa = ue;
	if (ra === 0) {
		ia = readUnaryLength(Yi);
		for (let oa = 0; oa < ia; oa++) aa += Yi.loadBit() ? "1" : "0"
	} else if ((Yi.loadBit() ? 1 : 0) === 0) {
		ia = Yi.loadUint(Math.ceil(Math.log2(ea + 1)));
		for (let la = 0; la < ia; la++) aa += Yi.loadBit() ? "1" : "0"
	} else {
		let la = Yi.loadBit() ? "1" : "0";
		ia = Yi.loadUint(Math.ceil(Math.log2(ea + 1)));
		for (let sa = 0; sa < ia; sa++) aa += la
	}
	if (ea - ia === 0) ta.set(BigInt("0b" + aa), na(Yi));
	else {
		let oa = Yi.loadRef(),
			la = Yi.loadRef();
		oa.isExotic || doParse(aa + "0", oa.beginParse(), ea - ia - 1, ta, na), la.isExotic || doParse(aa + "1", la.beginParse(), ea - ia - 1, ta, na)
	}
}

function parseDict(ue, Yi, ea) {
	let ta = new Map;
	return ue && doParse("", ue, Yi, ta, ea), ta
}
parseDict$1.parseDict = parseDict;
var serializeDict = {},
	findCommonPrefix$1 = {};
Object.defineProperty(findCommonPrefix$1, "__esModule", {
	value: !0
});
findCommonPrefix$1.findCommonPrefix = void 0;

function findCommonPrefix(ue, Yi = 0) {
	if (ue.length === 0) return "";
	let ea = ue[0].slice(Yi);
	for (let ta = 1; ta < ue.length; ta++) {
		const na = ue[ta];
		for (; na.indexOf(ea, Yi) !== Yi;)
			if (ea = ea.substring(0, ea.length - 1), ea === "") return ea
	}
	return ea
}
findCommonPrefix$1.findCommonPrefix = findCommonPrefix;
var hasRequiredSerializeDict;

function requireSerializeDict() {
	if (hasRequiredSerializeDict) return serializeDict;
	hasRequiredSerializeDict = 1, Object.defineProperty(serializeDict, "__esModule", {
		value: !0
	}), serializeDict.serializeDict = serializeDict.detectLabelType = serializeDict.writeLabelSame = serializeDict.writeLabelLong = serializeDict.writeLabelShort = serializeDict.buildTree = void 0;
	const ue = requireBuilder(),
		Yi = findCommonPrefix$1;

	function ea(Sa, Ca) {
		for (; Sa.length < Ca;) Sa = "0" + Sa;
		return Sa
	}

	function ta(Sa, Ca) {
		if (Sa.size === 0) throw Error("Internal inconsistency");
		let ka = new Map,
			Pa = new Map;
		for (let [ja, Za] of Sa.entries()) ja[Ca] === "0" ? ka.set(ja, Za) : Pa.set(ja, Za);
		if (ka.size === 0) throw Error("Internal inconsistency. Left emtpy.");
		if (Pa.size === 0) throw Error("Internal inconsistency. Right emtpy.");
		return {
			left: ka,
			right: Pa
		}
	}

	function na(Sa, Ca) {
		if (Sa.size === 0) throw Error("Internal inconsistency");
		if (Sa.size === 1) return {
			type: "leaf",
			value: Array.from(Sa.values())[0]
		};
		let {
			left: ka,
			right: Pa
		} = ta(Sa, Ca);
		return {
			type: "fork",
			left: ra(ka, Ca + 1),
			right: ra(Pa, Ca + 1)
		}
	}

	function ra(Sa, Ca = 0) {
		if (Sa.size === 0) throw Error("Internal inconsistency");
		const ka = (0, Yi.findCommonPrefix)(Array.from(Sa.keys()), Ca);
		return {
			label: ka,
			node: na(Sa, ka.length + Ca)
		}
	}

	function ia(Sa, Ca) {
		let ka = new Map;
		for (let Pa of Array.from(Sa.keys())) {
			const ja = ea(Pa.toString(2), Ca);
			ka.set(ja, Sa.get(Pa))
		}
		return ra(ka)
	}
	serializeDict.buildTree = ia;

	function aa(Sa, Ca) {
		Ca.storeBit(0);
		for (let ka = 0; ka < Sa.length; ka++) Ca.storeBit(1);
		return Ca.storeBit(0), Sa.length > 0 && Ca.storeUint(BigInt("0b" + Sa), Sa.length), Ca
	}
	serializeDict.writeLabelShort = aa;

	function oa(Sa) {
		return 1 + Sa.length + 1 + Sa.length
	}

	function la(Sa, Ca, ka) {
		ka.storeBit(1), ka.storeBit(0);
		let Pa = Math.ceil(Math.log2(Ca + 1));
		return ka.storeUint(Sa.length, Pa), Sa.length > 0 && ka.storeUint(BigInt("0b" + Sa), Sa.length), ka
	}
	serializeDict.writeLabelLong = la;

	function sa(Sa, Ca) {
		return 2 + Math.ceil(Math.log2(Ca + 1)) + Sa.length
	}

	function ca(Sa, Ca, ka, Pa) {
		Pa.storeBit(1), Pa.storeBit(1), Pa.storeBit(Sa);
		let ja = Math.ceil(Math.log2(ka + 1));
		Pa.storeUint(Ca, ja)
	}
	serializeDict.writeLabelSame = ca;

	function ua(Sa) {
		return 3 + Math.ceil(Math.log2(Sa + 1))
	}

	function da(Sa) {
		if (Sa.length === 0 || Sa.length === 1) return !0;
		for (let Ca = 1; Ca < Sa.length; Ca++)
			if (Sa[Ca] !== Sa[0]) return !1;
		return !0
	}

	function ha(Sa, Ca) {
		let ka = "short",
			Pa = oa(Sa),
			ja = sa(Sa, Ca);
		if (ja < Pa && (Pa = ja, ka = "long"), da(Sa)) {
			let Za = ua(Ca);
			Za < Pa && (Pa = Za, ka = "same")
		}
		return ka
	}
	serializeDict.detectLabelType = ha;

	function pa(Sa, Ca, ka) {
		let Pa = ha(Sa, Ca);
		Pa === "short" ? aa(Sa, ka) : Pa === "long" ? la(Sa, Ca, ka) : Pa === "same" && ca(Sa[0] === "1", Sa.length, Ca, ka)
	}

	function va(Sa, Ca, ka, Pa) {
		if (Sa.type === "leaf" && ka(Sa.value, Pa), Sa.type === "fork") {
			const ja = (0, ue.beginCell)(),
				Za = (0, ue.beginCell)();
			ba(Sa.left, Ca - 1, ka, ja), ba(Sa.right, Ca - 1, ka, Za), Pa.storeRef(ja), Pa.storeRef(Za)
		}
	}

	function ba(Sa, Ca, ka, Pa) {
		pa(Sa.label, Ca, Pa), va(Sa.node, Ca - Sa.label.length, ka, Pa)
	}

	function Ea(Sa, Ca, ka, Pa) {
		const ja = ia(Sa, Ca);
		ba(ja, Ca, ka, Pa)
	}
	return serializeDict.serializeDict = Ea, serializeDict
}
var internalKeySerializer = {};
Object.defineProperty(internalKeySerializer, "__esModule", {
	value: !0
});
internalKeySerializer.deserializeInternalKey = internalKeySerializer.serializeInternalKey = void 0;
const Address_1$3 = Address$1,
	BitString_1 = requireBitString(),
	paddedBits_1$1 = requirePaddedBits();

function serializeInternalKey(ue) {
	if (typeof ue == "number") {
		if (!Number.isSafeInteger(ue)) throw Error("Invalid key type: not a safe integer: " + ue);
		return "n:" + ue.toString(10)
	} else {
		if (typeof ue == "bigint") return "b:" + ue.toString(10);
		if (Address_1$3.Address.isAddress(ue)) return "a:" + ue.toString();
		if (Buffer.isBuffer(ue)) return "f:" + ue.toString("hex");
		if (BitString_1.BitString.isBitString(ue)) return "B:" + ue.toString();
		throw Error("Invalid key type")
	}
}
internalKeySerializer.serializeInternalKey = serializeInternalKey;

function deserializeInternalKey(ue) {
	let Yi = ue.slice(0, 2),
		ea = ue.slice(2);
	if (Yi === "n:") return parseInt(ea, 10);
	if (Yi === "b:") return BigInt(ea);
	if (Yi === "a:") return Address_1$3.Address.parse(ea);
	if (Yi === "f:") return Buffer.from(ea, "hex");
	if (Yi === "B:") {
		const ta = ea.slice(-1) == "_";
		if (ta || ea.length % 2 != 0) {
			let ra = ta ? ea.length - 1 : ea.length;
			const ia = ea.substr(0, ra) + "0";
			return !ta && ra & 1 ? new BitString_1.BitString(Buffer.from(ia, "hex"), 0, ra << 2) : (0, paddedBits_1$1.paddedBufferToBits)(Buffer.from(ia, "hex"))
		} else return new BitString_1.BitString(Buffer.from(ea, "hex"), 0, ea.length << 2)
	}
	throw Error("Invalid key type: " + Yi)
}
internalKeySerializer.deserializeInternalKey = deserializeInternalKey;
var hasRequiredDictionary;

function requireDictionary() {
	if (hasRequiredDictionary) return Dictionary;
	hasRequiredDictionary = 1, Object.defineProperty(Dictionary, "__esModule", {
		value: !0
	}), Dictionary.Dictionary = void 0;
	const ue = Address$1,
		Yi = requireBuilder(),
		ea = requireCell(),
		ta = requireBitString(),
		na = requireGenerateMerkleProof(),
		ra = requireGenerateMerkleUpdate(),
		ia = parseDict$1,
		aa = requireSerializeDict(),
		oa = internalKeySerializer;
	let la = class Vs {
		static empty(fa, ga) {
			return fa && ga ? new Vs(new Map, fa, ga) : new Vs(new Map, null, null)
		}
		static load(fa, ga, wa) {
			let Ma;
			if (wa instanceof ea.Cell) {
				if (wa.isExotic) return Vs.empty(fa, ga);
				Ma = wa.beginParse()
			} else Ma = wa;
			let Aa = Ma.loadMaybeRef();
			return Aa && !Aa.isExotic ? Vs.loadDirect(fa, ga, Aa.beginParse()) : Vs.empty(fa, ga)
		}
		static loadDirect(fa, ga, wa) {
			if (!wa) return Vs.empty(fa, ga);
			let Ma;
			wa instanceof ea.Cell ? Ma = wa.beginParse() : Ma = wa;
			let Aa = (0, ia.parseDict)(Ma, fa.bits, ga.parse),
				Ra = new Map;
			for (let [Ta, La] of Aa) Ra.set((0, oa.serializeInternalKey)(fa.parse(Ta)), La);
			return new Vs(Ra, fa, ga)
		}
		constructor(fa, ga, wa) {
			this._key = ga, this._value = wa, this._map = fa
		}
		get size() {
			return this._map.size
		}
		get(fa) {
			return this._map.get((0, oa.serializeInternalKey)(fa))
		}
		has(fa) {
			return this._map.has((0, oa.serializeInternalKey)(fa))
		}
		set(fa, ga) {
			return this._map.set((0, oa.serializeInternalKey)(fa), ga), this
		}
		delete(fa) {
			const ga = (0, oa.serializeInternalKey)(fa);
			return this._map.delete(ga)
		}
		clear() {
			this._map.clear()
		}*[Symbol.iterator]() {
			for (const [fa, ga] of this._map) yield [(0, oa.deserializeInternalKey)(fa), ga]
		}
		keys() {
			return Array.from(this._map.keys()).map(fa => (0, oa.deserializeInternalKey)(fa))
		}
		values() {
			return Array.from(this._map.values())
		}
		store(fa, ga, wa) {
			if (this._map.size === 0) fa.storeBit(0);
			else {
				let Ma = this._key;
				ga != null && (Ma = ga);
				let Aa = this._value;
				if (wa != null && (Aa = wa), !Ma) throw Error("Key serializer is not defined");
				if (!Aa) throw Error("Value serializer is not defined");
				let Ra = new Map;
				for (const [La, ya] of this._map) Ra.set(Ma.serialize((0, oa.deserializeInternalKey)(La)), ya);
				fa.storeBit(1);
				let Ta = (0, Yi.beginCell)();
				(0, aa.serializeDict)(Ra, Ma.bits, Aa.serialize, Ta), fa.storeRef(Ta.endCell())
			}
		}
		storeDirect(fa, ga, wa) {
			if (this._map.size === 0) throw Error("Cannot store empty dictionary directly");
			let Ma = this._key;
			ga != null && (Ma = ga);
			let Aa = this._value;
			if (wa != null && (Aa = wa), !Ma) throw Error("Key serializer is not defined");
			if (!Aa) throw Error("Value serializer is not defined");
			let Ra = new Map;
			for (const [Ta, La] of this._map) Ra.set(Ma.serialize((0, oa.deserializeInternalKey)(Ta)), La);
			(0, aa.serializeDict)(Ra, Ma.bits, Aa.serialize, fa)
		}
		generateMerkleProof(fa) {
			return (0, na.generateMerkleProof)(this, fa, this._key)
		}
		generateMerkleProofDirect(fa) {
			return (0, na.generateMerkleProofDirect)(this, fa, this._key)
		}
		generateMerkleUpdate(fa, ga) {
			return (0, ra.generateMerkleUpdate)(this, fa, this._key, ga)
		}
	};
	Dictionary.Dictionary = la, la.Keys = {
		Address: () => sa(),
		BigInt: ma => ca(ma),
		Int: ma => ua(ma),
		BigUint: ma => da(ma),
		Uint: ma => ha(ma),
		Buffer: ma => pa(ma),
		BitString: ma => va(ma)
	}, la.Values = {
		BigInt: ma => Ea(ma),
		Int: ma => ba(ma),
		BigVarInt: ma => Sa(ma),
		BigUint: ma => Pa(ma),
		Uint: ma => ka(ma),
		BigVarUint: ma => Ca(ma),
		Bool: () => ja(),
		Address: () => Za(),
		Cell: () => Ga(),
		Buffer: ma => Ua(ma),
		BitString: ma => xa(ma),
		Dictionary: (ma, fa) => Ja(ma, fa)
	};

	function sa() {
		return {
			bits: 267,
			serialize: ma => {
				if (!ue.Address.isAddress(ma)) throw Error("Key is not an address");
				return (0, Yi.beginCell)().storeAddress(ma).endCell().beginParse().preloadUintBig(267)
			},
			parse: ma => (0, Yi.beginCell)().storeUint(ma, 267).endCell().beginParse().loadAddress()
		}
	}

	function ca(ma) {
		return {
			bits: ma,
			serialize: fa => {
				if (typeof fa != "bigint") throw Error("Key is not a bigint");
				return (0, Yi.beginCell)().storeInt(fa, ma).endCell().beginParse().loadUintBig(ma)
			},
			parse: fa => (0, Yi.beginCell)().storeUint(fa, ma).endCell().beginParse().loadIntBig(ma)
		}
	}

	function ua(ma) {
		return {
			bits: ma,
			serialize: fa => {
				if (typeof fa != "number") throw Error("Key is not a number");
				if (!Number.isSafeInteger(fa)) throw Error("Key is not a safe integer: " + fa);
				return (0, Yi.beginCell)().storeInt(fa, ma).endCell().beginParse().loadUintBig(ma)
			},
			parse: fa => (0, Yi.beginCell)().storeUint(fa, ma).endCell().beginParse().loadInt(ma)
		}
	}

	function da(ma) {
		return {
			bits: ma,
			serialize: fa => {
				if (typeof fa != "bigint") throw Error("Key is not a bigint");
				if (fa < 0) throw Error("Key is negative: " + fa);
				return (0, Yi.beginCell)().storeUint(fa, ma).endCell().beginParse().loadUintBig(ma)
			},
			parse: fa => (0, Yi.beginCell)().storeUint(fa, ma).endCell().beginParse().loadUintBig(ma)
		}
	}

	function ha(ma) {
		return {
			bits: ma,
			serialize: fa => {
				if (typeof fa != "number") throw Error("Key is not a number");
				if (!Number.isSafeInteger(fa)) throw Error("Key is not a safe integer: " + fa);
				if (fa < 0) throw Error("Key is negative: " + fa);
				return (0, Yi.beginCell)().storeUint(fa, ma).endCell().beginParse().loadUintBig(ma)
			},
			parse: fa => Number((0, Yi.beginCell)().storeUint(fa, ma).endCell().beginParse().loadUint(ma))
		}
	}

	function pa(ma) {
		return {
			bits: ma * 8,
			serialize: fa => {
				if (!Buffer.isBuffer(fa)) throw Error("Key is not a buffer");
				return (0, Yi.beginCell)().storeBuffer(fa).endCell().beginParse().loadUintBig(ma * 8)
			},
			parse: fa => (0, Yi.beginCell)().storeUint(fa, ma * 8).endCell().beginParse().loadBuffer(ma)
		}
	}

	function va(ma) {
		return {
			bits: ma,
			serialize: fa => {
				if (!ta.BitString.isBitString(fa)) throw Error("Key is not a BitString");
				return (0, Yi.beginCell)().storeBits(fa).endCell().beginParse().loadUintBig(ma)
			},
			parse: fa => (0, Yi.beginCell)().storeUint(fa, ma).endCell().beginParse().loadBits(ma)
		}
	}

	function ba(ma) {
		return {
			serialize: (fa, ga) => {
				ga.storeInt(fa, ma)
			},
			parse: fa => fa.loadInt(ma)
		}
	}

	function Ea(ma) {
		return {
			serialize: (fa, ga) => {
				ga.storeInt(fa, ma)
			},
			parse: fa => fa.loadIntBig(ma)
		}
	}

	function Sa(ma) {
		return {
			serialize: (fa, ga) => {
				ga.storeVarInt(fa, ma)
			},
			parse: fa => fa.loadVarIntBig(ma)
		}
	}

	function Ca(ma) {
		return {
			serialize: (fa, ga) => {
				ga.storeVarUint(fa, ma)
			},
			parse: fa => fa.loadVarUintBig(ma)
		}
	}

	function ka(ma) {
		return {
			serialize: (fa, ga) => {
				ga.storeUint(fa, ma)
			},
			parse: fa => fa.loadUint(ma)
		}
	}

	function Pa(ma) {
		return {
			serialize: (fa, ga) => {
				ga.storeUint(fa, ma)
			},
			parse: fa => fa.loadUintBig(ma)
		}
	}

	function ja() {
		return {
			serialize: (ma, fa) => {
				fa.storeBit(ma)
			},
			parse: ma => ma.loadBit()
		}
	}

	function Za() {
		return {
			serialize: (ma, fa) => {
				fa.storeAddress(ma)
			},
			parse: ma => ma.loadAddress()
		}
	}

	function Ga() {
		return {
			serialize: (ma, fa) => {
				fa.storeRef(ma)
			},
			parse: ma => ma.loadRef()
		}
	}

	function Ja(ma, fa) {
		return {
			serialize: (ga, wa) => {
				ga.store(wa)
			},
			parse: ga => la.load(ma, fa, ga)
		}
	}

	function Ua(ma) {
		return {
			serialize: (fa, ga) => {
				if (fa.length !== ma) throw Error("Invalid buffer size");
				ga.storeBuffer(fa)
			},
			parse: fa => fa.loadBuffer(ma)
		}
	}

	function xa(ma) {
		return {
			serialize: (fa, ga) => {
				if (fa.length !== ma) throw Error("Invalid BitString size");
				ga.storeBits(fa)
			},
			parse: fa => fa.loadBits(ma)
		}
	}
	return Dictionary
}
var strings = {},
	hasRequiredStrings;

function requireStrings() {
	if (hasRequiredStrings) return strings;
	hasRequiredStrings = 1, Object.defineProperty(strings, "__esModule", {
		value: !0
	}), strings.writeString = strings.stringToCell = strings.readString = void 0;
	const ue = requireBuilder();

	function Yi(ia) {
		if (ia.remainingBits % 8 !== 0) throw new Error(`Invalid string length: ${ia.remainingBits}`);
		if (ia.remainingRefs !== 0 && ia.remainingRefs !== 1) throw new Error(`invalid number of refs: ${ia.remainingRefs}`);
		let aa;
		return ia.remainingBits === 0 ? aa = Buffer.alloc(0) : aa = ia.loadBuffer(ia.remainingBits / 8), ia.remainingRefs === 1 && (aa = Buffer.concat([aa, Yi(ia.loadRef().beginParse())])), aa
	}

	function ea(ia) {
		return Yi(ia).toString()
	}
	strings.readString = ea;

	function ta(ia, aa) {
		if (ia.length > 0) {
			let oa = Math.floor(aa.availableBits / 8);
			if (ia.length > oa) {
				let la = ia.subarray(0, oa),
					sa = ia.subarray(oa);
				aa = aa.storeBuffer(la);
				let ca = (0, ue.beginCell)();
				ta(sa, ca), aa = aa.storeRef(ca.endCell())
			} else aa = aa.storeBuffer(ia)
		}
	}

	function na(ia) {
		let aa = (0, ue.beginCell)();
		return ta(Buffer.from(ia), aa), aa.endCell()
	}
	strings.stringToCell = na;

	function ra(ia, aa) {
		ta(Buffer.from(ia), aa)
	}
	return strings.writeString = ra, strings
}
var hasRequiredSlice;

function requireSlice() {
	if (hasRequiredSlice) return Slice;
	hasRequiredSlice = 1;
	var ue = commonjsGlobal && commonjsGlobal.__importDefault || function(aa) {
			return aa && aa.__esModule ? aa : {
				default: aa
			}
		},
		Yi;
	Object.defineProperty(Slice, "__esModule", {
		value: !0
	}), Slice.Slice = void 0;
	const ea = ue(symbol_inspect),
		ta = requireDictionary(),
		na = requireBuilder(),
		ra = requireStrings();
	let ia = class js {
		constructor(oa, la) {
			this[Yi] = () => this.toString(), this._reader = oa.clone(), this._refs = [...la], this._refsOffset = 0
		}
		get remainingBits() {
			return this._reader.remaining
		}
		get offsetBits() {
			return this._reader.offset
		}
		get remainingRefs() {
			return this._refs.length - this._refsOffset
		}
		get offsetRefs() {
			return this._refsOffset
		}
		skip(oa) {
			return this._reader.skip(oa), this
		}
		loadBit() {
			return this._reader.loadBit()
		}
		preloadBit() {
			return this._reader.preloadBit()
		}
		loadBoolean() {
			return this.loadBit()
		}
		loadMaybeBoolean() {
			return this.loadBit() ? this.loadBoolean() : null
		}
		loadBits(oa) {
			return this._reader.loadBits(oa)
		}
		preloadBits(oa) {
			return this._reader.preloadBits(oa)
		}
		loadUint(oa) {
			return this._reader.loadUint(oa)
		}
		loadUintBig(oa) {
			return this._reader.loadUintBig(oa)
		}
		preloadUint(oa) {
			return this._reader.preloadUint(oa)
		}
		preloadUintBig(oa) {
			return this._reader.preloadUintBig(oa)
		}
		loadMaybeUint(oa) {
			return this.loadBit() ? this.loadUint(oa) : null
		}
		loadMaybeUintBig(oa) {
			return this.loadBit() ? this.loadUintBig(oa) : null
		}
		loadInt(oa) {
			return this._reader.loadInt(oa)
		}
		loadIntBig(oa) {
			return this._reader.loadIntBig(oa)
		}
		preloadInt(oa) {
			return this._reader.preloadInt(oa)
		}
		preloadIntBig(oa) {
			return this._reader.preloadIntBig(oa)
		}
		loadMaybeInt(oa) {
			return this.loadBit() ? this.loadInt(oa) : null
		}
		loadMaybeIntBig(oa) {
			return this.loadBit() ? this.loadIntBig(oa) : null
		}
		loadVarUint(oa) {
			return this._reader.loadVarUint(oa)
		}
		loadVarUintBig(oa) {
			return this._reader.loadVarUintBig(oa)
		}
		preloadVarUint(oa) {
			return this._reader.preloadVarUint(oa)
		}
		preloadVarUintBig(oa) {
			return this._reader.preloadVarUintBig(oa)
		}
		loadVarInt(oa) {
			return this._reader.loadVarInt(oa)
		}
		loadVarIntBig(oa) {
			return this._reader.loadVarIntBig(oa)
		}
		preloadVarInt(oa) {
			return this._reader.preloadVarInt(oa)
		}
		preloadVarIntBig(oa) {
			return this._reader.preloadVarIntBig(oa)
		}
		loadCoins() {
			return this._reader.loadCoins()
		}
		preloadCoins() {
			return this._reader.preloadCoins()
		}
		loadMaybeCoins() {
			return this._reader.loadBit() ? this._reader.loadCoins() : null
		}
		loadAddress() {
			return this._reader.loadAddress()
		}
		loadMaybeAddress() {
			return this._reader.loadMaybeAddress()
		}
		loadExternalAddress() {
			return this._reader.loadExternalAddress()
		}
		loadMaybeExternalAddress() {
			return this._reader.loadMaybeExternalAddress()
		}
		loadAddressAny() {
			return this._reader.loadAddressAny()
		}
		loadRef() {
			if (this._refsOffset >= this._refs.length) throw new Error("No more references");
			return this._refs[this._refsOffset++]
		}
		preloadRef() {
			if (this._refsOffset >= this._refs.length) throw new Error("No more references");
			return this._refs[this._refsOffset]
		}
		loadMaybeRef() {
			return this.loadBit() ? this.loadRef() : null
		}
		preloadMaybeRef() {
			return this.preloadBit() ? this.preloadRef() : null
		}
		loadBuffer(oa) {
			return this._reader.loadBuffer(oa)
		}
		preloadBuffer(oa) {
			return this._reader.preloadBuffer(oa)
		}
		loadStringTail() {
			return (0, ra.readString)(this)
		}
		loadMaybeStringTail() {
			return this.loadBit() ? (0, ra.readString)(this) : null
		}
		loadStringRefTail() {
			return (0, ra.readString)(this.loadRef().beginParse())
		}
		loadMaybeStringRefTail() {
			const oa = this.loadMaybeRef();
			return oa ? (0, ra.readString)(oa.beginParse()) : null
		}
		loadDict(oa, la) {
			return ta.Dictionary.load(oa, la, this)
		}
		loadDictDirect(oa, la) {
			return ta.Dictionary.loadDirect(oa, la, this)
		}
		endParse() {
			if (this.remainingBits > 0 || this.remainingRefs > 0) throw new Error("Slice is not empty")
		}
		asCell() {
			return (0, na.beginCell)().storeSlice(this).endCell()
		}
		asBuilder() {
			return (0, na.beginCell)().storeSlice(this)
		}
		clone(oa = !1) {
			if (oa) {
				let la = this._reader.clone();
				return la.reset(), new js(la, this._refs)
			} else {
				let la = new js(this._reader, this._refs);
				return la._refsOffset = this._refsOffset, la
			}
		}
		toString() {
			return this.asCell().toString()
		}
	};
	return Slice.Slice = ia, Yi = ea.default, Slice
}
var resolveExotic = {},
	exoticLibrary$1 = {};
Object.defineProperty(exoticLibrary$1, "__esModule", {
	value: !0
});
exoticLibrary$1.exoticLibrary = void 0;
const BitReader_1$2 = BitReader$1;

function exoticLibrary(ue, Yi) {
	const ea = new BitReader_1$2.BitReader(ue);
	if (ue.length !== 264) throw new Error(`Library cell must have exactly (8 + 256) bits, got "${ue.length}"`);
	let na = ea.loadUint(8);
	if (na !== 2) throw new Error(`Library cell must have type 2, got "${na}"`);
	return {}
}
exoticLibrary$1.exoticLibrary = exoticLibrary;
var exoticMerkleUpdate$1 = {};
Object.defineProperty(exoticMerkleUpdate$1, "__esModule", {
	value: !0
});
exoticMerkleUpdate$1.exoticMerkleUpdate = void 0;
const BitReader_1$1 = BitReader$1;

function exoticMerkleUpdate(ue, Yi) {
	const ea = new BitReader_1$1.BitReader(ue),
		ta = 8 + 2 * 272;
	if (ue.length !== ta) throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${ue.length}"`);
	if (Yi.length !== 2) throw new Error(`Merkle Update cell must have exactly 2 refs, got "${Yi.length}"`);
	let na = ea.loadUint(8);
	if (na !== 4) throw new Error(`Merkle Update cell type must be exactly 4, got "${na}"`);
	const ra = ea.loadBuffer(32),
		ia = ea.loadBuffer(32),
		aa = ea.loadUint(16),
		oa = ea.loadUint(16);
	if (aa !== Yi[0].depth(0)) throw new Error(`Merkle Update cell ref depth must be exactly "${aa}", got "${Yi[0].depth(0)}"`);
	if (!ra.equals(Yi[0].hash(0))) throw new Error(`Merkle Update cell ref hash must be exactly "${ra.toString("hex")}", got "${Yi[0].hash(0).toString("hex")}"`);
	if (oa !== Yi[1].depth(0)) throw new Error(`Merkle Update cell ref depth must be exactly "${oa}", got "${Yi[1].depth(0)}"`);
	if (!ia.equals(Yi[1].hash(0))) throw new Error(`Merkle Update cell ref hash must be exactly "${ia.toString("hex")}", got "${Yi[1].hash(0).toString("hex")}"`);
	return {
		proofDepth1: aa,
		proofDepth2: oa,
		proofHash1: ra,
		proofHash2: ia
	}
}
exoticMerkleUpdate$1.exoticMerkleUpdate = exoticMerkleUpdate;
var exoticPruned$1 = {},
	LevelMask$1 = {};
Object.defineProperty(LevelMask$1, "__esModule", {
	value: !0
});
LevelMask$1.LevelMask = void 0;
class LevelMask {
	constructor(Yi = 0) {
		this._mask = 0, this._mask = Yi, this._hashIndex = countSetBits(this._mask), this._hashCount = this._hashIndex + 1
	}
	get value() {
		return this._mask
	}
	get level() {
		return 32 - Math.clz32(this._mask)
	}
	get hashIndex() {
		return this._hashIndex
	}
	get hashCount() {
		return this._hashCount
	}
	apply(Yi) {
		return new LevelMask(this._mask & (1 << Yi) - 1)
	}
	isSignificant(Yi) {
		return Yi === 0 || (this._mask >> Yi - 1) % 2 !== 0
	}
}
LevelMask$1.LevelMask = LevelMask;

function countSetBits(ue) {
	return ue = ue - (ue >> 1 & 1431655765), ue = (ue & 858993459) + (ue >> 2 & 858993459), (ue + (ue >> 4) & 252645135) * 16843009 >> 24
}
Object.defineProperty(exoticPruned$1, "__esModule", {
	value: !0
});
exoticPruned$1.exoticPruned = void 0;
const BitReader_1 = BitReader$1,
	LevelMask_1 = LevelMask$1;

function exoticPruned(ue, Yi) {
	let ea = new BitReader_1.BitReader(ue),
		ta = ea.loadUint(8);
	if (ta !== 1) throw new Error(`Pruned branch cell must have type 1, got "${ta}"`);
	if (Yi.length !== 0) throw new Error(`Pruned Branch cell can't has refs, got "${Yi.length}"`);
	let na;
	if (ue.length === 280) na = new LevelMask_1.LevelMask(1);
	else {
		if (na = new LevelMask_1.LevelMask(ea.loadUint(8)), na.level < 1 || na.level > 3) throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${na.level}/${na.value}"`);
		const oa = 16 + na.apply(na.level - 1).hashCount * 272;
		if (ue.length !== oa) throw new Error(`Pruned branch cell must have exactly ${oa} bits, got "${ue.length}"`)
	}
	let ra = [],
		ia = [],
		aa = [];
	for (let oa = 0; oa < na.level; oa++) ia.push(ea.loadBuffer(32));
	for (let oa = 0; oa < na.level; oa++) aa.push(ea.loadUint(16));
	for (let oa = 0; oa < na.level; oa++) ra.push({
		depth: aa[oa],
		hash: ia[oa]
	});
	return {
		mask: na.value,
		pruned: ra
	}
}
exoticPruned$1.exoticPruned = exoticPruned;
var hasRequiredResolveExotic;

function requireResolveExotic() {
	if (hasRequiredResolveExotic) return resolveExotic;
	hasRequiredResolveExotic = 1, Object.defineProperty(resolveExotic, "__esModule", {
		value: !0
	}), resolveExotic.resolveExotic = void 0;
	const ue = BitReader$1,
		Yi = CellType$1,
		ea = exoticLibrary$1,
		ta = requireExoticMerkleProof(),
		na = exoticMerkleUpdate$1,
		ra = exoticPruned$1,
		ia = LevelMask$1;

	function aa(ua, da) {
		let ha = (0, ra.exoticPruned)(ua, da),
			pa = [],
			va = [],
			ba = new ia.LevelMask(ha.mask);
		for (let Ea = 0; Ea < ha.pruned.length; Ea++) pa.push(ha.pruned[Ea].depth), va.push(ha.pruned[Ea].hash);
		return {
			type: Yi.CellType.PrunedBranch,
			depths: pa,
			hashes: va,
			mask: ba
		}
	}

	function oa(ua, da) {
		(0, ea.exoticLibrary)(ua, da);
		let ha = [],
			pa = [],
			va = new ia.LevelMask;
		return {
			type: Yi.CellType.Library,
			depths: ha,
			hashes: pa,
			mask: va
		}
	}

	function la(ua, da) {
		(0, ta.exoticMerkleProof)(ua, da);
		let ha = [],
			pa = [],
			va = new ia.LevelMask(da[0].level() >> 1);
		return {
			type: Yi.CellType.MerkleProof,
			depths: ha,
			hashes: pa,
			mask: va
		}
	}

	function sa(ua, da) {
		(0, na.exoticMerkleUpdate)(ua, da);
		let ha = [],
			pa = [],
			va = new ia.LevelMask((da[0].level() | da[1].level()) >> 1);
		return {
			type: Yi.CellType.MerkleUpdate,
			depths: ha,
			hashes: pa,
			mask: va
		}
	}

	function ca(ua, da) {
		let pa = new ue.BitReader(ua).preloadUint(8);
		if (pa === 1) return aa(ua, da);
		if (pa === 2) return oa(ua, da);
		if (pa === 3) return la(ua, da);
		if (pa === 4) return sa(ua, da);
		throw Error("Invalid exotic cell type: " + pa)
	}
	return resolveExotic.resolveExotic = ca, resolveExotic
}
var wonderCalculator = {},
	descriptor = {};
Object.defineProperty(descriptor, "__esModule", {
	value: !0
});
descriptor.getRepr = descriptor.getBitsDescriptor = descriptor.getRefsDescriptor = void 0;
const CellType_1 = CellType$1,
	paddedBits_1 = requirePaddedBits();

function getRefsDescriptor(ue, Yi, ea) {
	return ue.length + (ea !== CellType_1.CellType.Ordinary ? 1 : 0) * 8 + Yi * 32
}
descriptor.getRefsDescriptor = getRefsDescriptor;

function getBitsDescriptor(ue) {
	let Yi = ue.length;
	return Math.ceil(Yi / 8) + Math.floor(Yi / 8)
}
descriptor.getBitsDescriptor = getBitsDescriptor;

function getRepr(ue, Yi, ea, ta, na, ra) {
	const ia = Math.ceil(Yi.length / 8),
		aa = Buffer.alloc(2 + ia + 34 * ea.length);
	let oa = 0;
	aa[oa++] = getRefsDescriptor(ea, na, ra), aa[oa++] = getBitsDescriptor(ue), (0, paddedBits_1.bitsToPaddedBuffer)(Yi).copy(aa, oa), oa += ia;
	for (const la of ea) {
		let sa;
		ra == CellType_1.CellType.MerkleProof || ra == CellType_1.CellType.MerkleUpdate ? sa = la.depth(ta + 1) : sa = la.depth(ta), aa[oa++] = Math.floor(sa / 256), aa[oa++] = sa % 256
	}
	for (const la of ea) {
		let sa;
		ra == CellType_1.CellType.MerkleProof || ra == CellType_1.CellType.MerkleUpdate ? sa = la.hash(ta + 1) : sa = la.hash(ta), sa.copy(aa, oa), oa += 32
	}
	return aa
}
descriptor.getRepr = getRepr;
var dist = {},
	sha256$5 = {};
const t$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

function n$1(ue, Yi, ea, ta) {
	let na, ra, ia;
	const aa = Yi || [0],
		oa = (ea = ea || 0) >>> 3,
		la = ta === -1 ? 3 : 0;
	for (na = 0; na < ue.length; na += 1) ia = na + oa, ra = ia >>> 2, aa.length <= ra && aa.push(0), aa[ra] |= ue[na] << 8 * (la + ta * (ia % 4));
	return {
		value: aa,
		binLen: 8 * ue.length + ea
	}
}

function e$2(ue, Yi, ea) {
	switch (Yi) {
		case "UTF8":
		case "UTF16BE":
		case "UTF16LE":
			break;
		default:
			throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE")
	}
	switch (ue) {
		case "HEX":
			return function(ta, na, ra) {
				return function(ia, aa, oa, la) {
					let sa, ca, ua, da;
					if (ia.length % 2 != 0) throw new Error("String of HEX type must be in byte increments");
					const ha = aa || [0],
						pa = (oa = oa || 0) >>> 3,
						va = la === -1 ? 3 : 0;
					for (sa = 0; sa < ia.length; sa += 2) {
						if (ca = parseInt(ia.substr(sa, 2), 16), isNaN(ca)) throw new Error("String of HEX type contains invalid characters");
						for (da = (sa >>> 1) + pa, ua = da >>> 2; ha.length <= ua;) ha.push(0);
						ha[ua] |= ca << 8 * (va + la * (da % 4))
					}
					return {
						value: ha,
						binLen: 4 * ia.length + oa
					}
				}(ta, na, ra, ea)
			};
		case "TEXT":
			return function(ta, na, ra) {
				return function(ia, aa, oa, la, sa) {
					let ca, ua, da, ha, pa, va, ba, Ea, Sa = 0;
					const Ca = oa || [0],
						ka = (la = la || 0) >>> 3;
					if (aa === "UTF8")
						for (ba = sa === -1 ? 3 : 0, da = 0; da < ia.length; da += 1)
							for (ca = ia.charCodeAt(da), ua = [], 128 > ca ? ua.push(ca) : 2048 > ca ? (ua.push(192 | ca >>> 6), ua.push(128 | 63 & ca)) : 55296 > ca || 57344 <= ca ? ua.push(224 | ca >>> 12, 128 | ca >>> 6 & 63, 128 | 63 & ca) : (da += 1, ca = 65536 + ((1023 & ca) << 10 | 1023 & ia.charCodeAt(da)), ua.push(240 | ca >>> 18, 128 | ca >>> 12 & 63, 128 | ca >>> 6 & 63, 128 | 63 & ca)), ha = 0; ha < ua.length; ha += 1) {
								for (va = Sa + ka, pa = va >>> 2; Ca.length <= pa;) Ca.push(0);
								Ca[pa] |= ua[ha] << 8 * (ba + sa * (va % 4)), Sa += 1
							} else
								for (ba = sa === -1 ? 2 : 0, Ea = aa === "UTF16LE" && sa !== 1 || aa !== "UTF16LE" && sa === 1, da = 0; da < ia.length; da += 1) {
									for (ca = ia.charCodeAt(da), Ea === !0 && (ha = 255 & ca, ca = ha << 8 | ca >>> 8), va = Sa + ka, pa = va >>> 2; Ca.length <= pa;) Ca.push(0);
									Ca[pa] |= ca << 8 * (ba + sa * (va % 4)), Sa += 2
								}
					return {
						value: Ca,
						binLen: 8 * Sa + la
					}
				}(ta, Yi, na, ra, ea)
			};
		case "B64":
			return function(ta, na, ra) {
				return function(ia, aa, oa, la) {
					let sa, ca, ua, da, ha, pa, va, ba = 0;
					const Ea = aa || [0],
						Sa = (oa = oa || 0) >>> 3,
						Ca = la === -1 ? 3 : 0,
						ka = ia.indexOf("=");
					if (ia.search(/^[a-zA-Z0-9=+/]+$/) === -1) throw new Error("Invalid character in base-64 string");
					if (ia = ia.replace(/=/g, ""), ka !== -1 && ka < ia.length) throw new Error("Invalid '=' found in base-64 string");
					for (ca = 0; ca < ia.length; ca += 4) {
						for (ha = ia.substr(ca, 4), da = 0, ua = 0; ua < ha.length; ua += 1) sa = t$3.indexOf(ha.charAt(ua)), da |= sa << 18 - 6 * ua;
						for (ua = 0; ua < ha.length - 1; ua += 1) {
							for (va = ba + Sa, pa = va >>> 2; Ea.length <= pa;) Ea.push(0);
							Ea[pa] |= (da >>> 16 - 8 * ua & 255) << 8 * (Ca + la * (va % 4)), ba += 1
						}
					}
					return {
						value: Ea,
						binLen: 8 * ba + oa
					}
				}(ta, na, ra, ea)
			};
		case "BYTES":
			return function(ta, na, ra) {
				return function(ia, aa, oa, la) {
					let sa, ca, ua, da;
					const ha = aa || [0],
						pa = (oa = oa || 0) >>> 3,
						va = la === -1 ? 3 : 0;
					for (ca = 0; ca < ia.length; ca += 1) sa = ia.charCodeAt(ca), da = ca + pa, ua = da >>> 2, ha.length <= ua && ha.push(0), ha[ua] |= sa << 8 * (va + la * (da % 4));
					return {
						value: ha,
						binLen: 8 * ia.length + oa
					}
				}(ta, na, ra, ea)
			};
		case "ARRAYBUFFER":
			try {
				new ArrayBuffer(0)
			} catch {
				throw new Error("ARRAYBUFFER not supported by this environment")
			}
			return function(ta, na, ra) {
				return function(ia, aa, oa, la) {
					return n$1(new Uint8Array(ia), aa, oa, la)
				}(ta, na, ra, ea)
			};
		case "UINT8ARRAY":
			try {
				new Uint8Array(0)
			} catch {
				throw new Error("UINT8ARRAY not supported by this environment")
			}
			return function(ta, na, ra) {
				return n$1(ta, na, ra, ea)
			};
		default:
			throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")
	}
}

function r$3(ue, Yi, ea, ta) {
	switch (ue) {
		case "HEX":
			return function(na) {
				return function(ra, ia, aa, oa) {
					let la, sa, ca = "";
					const ua = ia / 8,
						da = aa === -1 ? 3 : 0;
					for (la = 0; la < ua; la += 1) sa = ra[la >>> 2] >>> 8 * (da + aa * (la % 4)), ca += "0123456789abcdef".charAt(sa >>> 4 & 15) + "0123456789abcdef".charAt(15 & sa);
					return oa.outputUpper ? ca.toUpperCase() : ca
				}(na, Yi, ea, ta)
			};
		case "B64":
			return function(na) {
				return function(ra, ia, aa, oa) {
					let la, sa, ca, ua, da, ha = "";
					const pa = ia / 8,
						va = aa === -1 ? 3 : 0;
					for (la = 0; la < pa; la += 3)
						for (ua = la + 1 < pa ? ra[la + 1 >>> 2] : 0, da = la + 2 < pa ? ra[la + 2 >>> 2] : 0, ca = (ra[la >>> 2] >>> 8 * (va + aa * (la % 4)) & 255) << 16 | (ua >>> 8 * (va + aa * ((la + 1) % 4)) & 255) << 8 | da >>> 8 * (va + aa * ((la + 2) % 4)) & 255, sa = 0; sa < 4; sa += 1) ha += 8 * la + 6 * sa <= ia ? t$3.charAt(ca >>> 6 * (3 - sa) & 63) : oa.b64Pad;
					return ha
				}(na, Yi, ea, ta)
			};
		case "BYTES":
			return function(na) {
				return function(ra, ia, aa) {
					let oa, la, sa = "";
					const ca = ia / 8,
						ua = aa === -1 ? 3 : 0;
					for (oa = 0; oa < ca; oa += 1) la = ra[oa >>> 2] >>> 8 * (ua + aa * (oa % 4)) & 255, sa += String.fromCharCode(la);
					return sa
				}(na, Yi, ea)
			};
		case "ARRAYBUFFER":
			try {
				new ArrayBuffer(0)
			} catch {
				throw new Error("ARRAYBUFFER not supported by this environment")
			}
			return function(na) {
				return function(ra, ia, aa) {
					let oa;
					const la = ia / 8,
						sa = new ArrayBuffer(la),
						ca = new Uint8Array(sa),
						ua = aa === -1 ? 3 : 0;
					for (oa = 0; oa < la; oa += 1) ca[oa] = ra[oa >>> 2] >>> 8 * (ua + aa * (oa % 4)) & 255;
					return sa
				}(na, Yi, ea)
			};
		case "UINT8ARRAY":
			try {
				new Uint8Array(0)
			} catch {
				throw new Error("UINT8ARRAY not supported by this environment")
			}
			return function(na) {
				return function(ra, ia, aa) {
					let oa;
					const la = ia / 8,
						sa = aa === -1 ? 3 : 0,
						ca = new Uint8Array(la);
					for (oa = 0; oa < la; oa += 1) ca[oa] = ra[oa >>> 2] >>> 8 * (sa + aa * (oa % 4)) & 255;
					return ca
				}(na, Yi, ea)
			};
		default:
			throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")
	}
}
const i$2 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298],
	s$1 = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428],
	o$1 = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225],
	h$1 = "Chosen SHA variant is not supported";

function u$1(ue, Yi) {
	let ea, ta;
	const na = ue.binLen >>> 3,
		ra = Yi.binLen >>> 3,
		ia = na << 3,
		aa = 4 - na << 3;
	if (na % 4 != 0) {
		for (ea = 0; ea < ra; ea += 4) ta = na + ea >>> 2, ue.value[ta] |= Yi.value[ea >>> 2] << ia, ue.value.push(0), ue.value[ta + 1] |= Yi.value[ea >>> 2] >>> aa;
		return (ue.value.length << 2) - 4 >= ra + na && ue.value.pop(), {
			value: ue.value,
			binLen: ue.binLen + Yi.binLen
		}
	}
	return {
		value: ue.value.concat(Yi.value),
		binLen: ue.binLen + Yi.binLen
	}
}

function w$1(ue) {
	const Yi = {
			outputUpper: !1,
			b64Pad: "=",
			outputLen: -1
		},
		ea = ue || {},
		ta = "Output length must be a multiple of 8";
	if (Yi.outputUpper = ea.outputUpper || !1, ea.b64Pad && (Yi.b64Pad = ea.b64Pad), ea.outputLen) {
		if (ea.outputLen % 8 != 0) throw new Error(ta);
		Yi.outputLen = ea.outputLen
	} else if (ea.shakeLen) {
		if (ea.shakeLen % 8 != 0) throw new Error(ta);
		Yi.outputLen = ea.shakeLen
	}
	if (typeof Yi.outputUpper != "boolean") throw new Error("Invalid outputUpper formatting option");
	if (typeof Yi.b64Pad != "string") throw new Error("Invalid b64Pad formatting option");
	return Yi
}

function c$1(ue, Yi, ea, ta) {
	const na = ue + " must include a value and format";
	if (!Yi) {
		if (!ta) throw new Error(na);
		return ta
	}
	if (Yi.value === void 0 || !Yi.format) throw new Error(na);
	return e$2(Yi.format, Yi.encoding || "UTF8", ea)(Yi.value)
}
let f$1 = class {
	constructor(Yi, ea, ta) {
		const na = ta || {};
		if (this.t = ea, this.i = na.encoding || "UTF8", this.numRounds = na.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds) throw new Error("numRounds must a integer >= 1");
		this.s = Yi, this.o = [], this.h = 0, this.u = !1, this.l = 0, this.A = !1, this.H = [], this.S = []
	}
	update(Yi) {
		let ea, ta = 0;
		const na = this.p >>> 5,
			ra = this.m(Yi, this.o, this.h),
			ia = ra.binLen,
			aa = ra.value,
			oa = ia >>> 5;
		for (ea = 0; ea < oa; ea += na) ta + this.p <= ia && (this.C = this.R(aa.slice(ea, ea + na), this.C), ta += this.p);
		this.l += ta, this.o = aa.slice(ta >>> 5), this.h = ia % this.p, this.u = !0
	}
	getHash(Yi, ea) {
		let ta, na, ra = this.U;
		const ia = w$1(ea);
		if (this.v) {
			if (ia.outputLen === -1) throw new Error("Output length must be specified in options");
			ra = ia.outputLen
		}
		const aa = r$3(Yi, ra, this.K, ia);
		if (this.A && this.T) return aa(this.T(ia));
		for (na = this.F(this.o.slice(), this.h, this.l, this.g(this.C), ra), ta = 1; ta < this.numRounds; ta += 1) this.v && ra % 32 != 0 && (na[na.length - 1] &= 16777215 >>> 24 - ra % 32), na = this.F(na, ra, 0, this.B(this.s), ra);
		return aa(na)
	}
	setHMACKey(Yi, ea, ta) {
		if (!this.L) throw new Error("Variant does not support HMAC");
		if (this.u) throw new Error("Cannot set MAC key after calling update");
		const na = e$2(ea, (ta || {}).encoding || "UTF8", this.K);
		this.M(na(Yi))
	}
	M(Yi) {
		const ea = this.p >>> 3,
			ta = ea / 4 - 1;
		let na;
		if (this.numRounds !== 1) throw new Error("Cannot set numRounds with MAC");
		if (this.A) throw new Error("MAC key already set");
		for (ea < Yi.binLen / 8 && (Yi.value = this.F(Yi.value, Yi.binLen, 0, this.B(this.s), this.U)); Yi.value.length <= ta;) Yi.value.push(0);
		for (na = 0; na <= ta; na += 1) this.H[na] = 909522486 ^ Yi.value[na], this.S[na] = 1549556828 ^ Yi.value[na];
		this.C = this.R(this.H, this.C), this.l = this.p, this.A = !0
	}
	getHMAC(Yi, ea) {
		const ta = w$1(ea);
		return r$3(Yi, this.U, this.K, ta)(this.k())
	}
	k() {
		let Yi;
		if (!this.A) throw new Error("Cannot call getHMAC without first setting MAC key");
		const ea = this.F(this.o.slice(), this.h, this.l, this.g(this.C), this.U);
		return Yi = this.R(this.S, this.B(this.s)), Yi = this.F(ea, this.U, this.p, Yi, this.U), Yi
	}
};

function a$1(ue, Yi) {
	return ue << Yi | ue >>> 32 - Yi
}

function l$1(ue, Yi) {
	return ue >>> Yi | ue << 32 - Yi
}

function A$1(ue, Yi) {
	return ue >>> Yi
}

function E$1(ue, Yi, ea) {
	return ue ^ Yi ^ ea
}

function H$1(ue, Yi, ea) {
	return ue & Yi ^ ~ue & ea
}

function S$1(ue, Yi, ea) {
	return ue & Yi ^ ue & ea ^ Yi & ea
}

function b$1(ue) {
	return l$1(ue, 2) ^ l$1(ue, 13) ^ l$1(ue, 22)
}

function p$1(ue, Yi) {
	const ea = (65535 & ue) + (65535 & Yi);
	return (65535 & (ue >>> 16) + (Yi >>> 16) + (ea >>> 16)) << 16 | 65535 & ea
}

function d$2(ue, Yi, ea, ta) {
	const na = (65535 & ue) + (65535 & Yi) + (65535 & ea) + (65535 & ta);
	return (65535 & (ue >>> 16) + (Yi >>> 16) + (ea >>> 16) + (ta >>> 16) + (na >>> 16)) << 16 | 65535 & na
}

function m$1(ue, Yi, ea, ta, na) {
	const ra = (65535 & ue) + (65535 & Yi) + (65535 & ea) + (65535 & ta) + (65535 & na);
	return (65535 & (ue >>> 16) + (Yi >>> 16) + (ea >>> 16) + (ta >>> 16) + (na >>> 16) + (ra >>> 16)) << 16 | 65535 & ra
}

function C$1(ue) {
	return l$1(ue, 7) ^ l$1(ue, 18) ^ A$1(ue, 3)
}

function y$1(ue) {
	return l$1(ue, 6) ^ l$1(ue, 11) ^ l$1(ue, 25)
}

function R$1(ue) {
	return [1732584193, 4023233417, 2562383102, 271733878, 3285377520]
}

function U$1(ue, Yi) {
	let ea, ta, na, ra, ia, aa, oa;
	const la = [];
	for (ea = Yi[0], ta = Yi[1], na = Yi[2], ra = Yi[3], ia = Yi[4], oa = 0; oa < 80; oa += 1) la[oa] = oa < 16 ? ue[oa] : a$1(la[oa - 3] ^ la[oa - 8] ^ la[oa - 14] ^ la[oa - 16], 1), aa = oa < 20 ? m$1(a$1(ea, 5), H$1(ta, na, ra), ia, 1518500249, la[oa]) : oa < 40 ? m$1(a$1(ea, 5), E$1(ta, na, ra), ia, 1859775393, la[oa]) : oa < 60 ? m$1(a$1(ea, 5), S$1(ta, na, ra), ia, 2400959708, la[oa]) : m$1(a$1(ea, 5), E$1(ta, na, ra), ia, 3395469782, la[oa]), ia = ra, ra = na, na = a$1(ta, 30), ta = ea, ea = aa;
	return Yi[0] = p$1(ea, Yi[0]), Yi[1] = p$1(ta, Yi[1]), Yi[2] = p$1(na, Yi[2]), Yi[3] = p$1(ra, Yi[3]), Yi[4] = p$1(ia, Yi[4]), Yi
}

function v$1(ue, Yi, ea, ta) {
	let na;
	const ra = 15 + (Yi + 65 >>> 9 << 4),
		ia = Yi + ea;
	for (; ue.length <= ra;) ue.push(0);
	for (ue[Yi >>> 5] |= 128 << 24 - Yi % 32, ue[ra] = 4294967295 & ia, ue[ra - 1] = ia / 4294967296 | 0, na = 0; na < ue.length; na += 16) ta = U$1(ue.slice(na, na + 16), ta);
	return ta
}
let K$1 = class extends f$1 {
	constructor(Yi, ea, ta) {
		if (Yi !== "SHA-1") throw new Error(h$1);
		super(Yi, ea, ta);
		const na = ta || {};
		this.L = !0, this.T = this.k, this.K = -1, this.m = e$2(this.t, this.i, this.K), this.R = U$1, this.g = function(ra) {
			return ra.slice()
		}, this.B = R$1, this.F = v$1, this.C = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.p = 512, this.U = 160, this.v = !1, na.hmacKey && this.M(c$1("hmacKey", na.hmacKey, this.K))
	}
};

function T$1(ue) {
	let Yi;
	return Yi = ue == "SHA-224" ? s$1.slice() : o$1.slice(), Yi
}

function F$1(ue, Yi) {
	let ea, ta, na, ra, ia, aa, oa, la, sa, ca, ua;
	const da = [];
	for (ea = Yi[0], ta = Yi[1], na = Yi[2], ra = Yi[3], ia = Yi[4], aa = Yi[5], oa = Yi[6], la = Yi[7], ua = 0; ua < 64; ua += 1) da[ua] = ua < 16 ? ue[ua] : d$2(l$1(ha = da[ua - 2], 17) ^ l$1(ha, 19) ^ A$1(ha, 10), da[ua - 7], C$1(da[ua - 15]), da[ua - 16]), sa = m$1(la, y$1(ia), H$1(ia, aa, oa), i$2[ua], da[ua]), ca = p$1(b$1(ea), S$1(ea, ta, na)), la = oa, oa = aa, aa = ia, ia = p$1(ra, sa), ra = na, na = ta, ta = ea, ea = p$1(sa, ca);
	var ha;
	return Yi[0] = p$1(ea, Yi[0]), Yi[1] = p$1(ta, Yi[1]), Yi[2] = p$1(na, Yi[2]), Yi[3] = p$1(ra, Yi[3]), Yi[4] = p$1(ia, Yi[4]), Yi[5] = p$1(aa, Yi[5]), Yi[6] = p$1(oa, Yi[6]), Yi[7] = p$1(la, Yi[7]), Yi
}
let g$1 = class extends f$1 {
		constructor(Yi, ea, ta) {
			if (Yi !== "SHA-224" && Yi !== "SHA-256") throw new Error(h$1);
			super(Yi, ea, ta);
			const na = ta || {};
			this.T = this.k, this.L = !0, this.K = -1, this.m = e$2(this.t, this.i, this.K), this.R = F$1, this.g = function(ra) {
				return ra.slice()
			}, this.B = T$1, this.F = function(ra, ia, aa, oa) {
				return function(la, sa, ca, ua, da) {
					let ha, pa;
					const va = 15 + (sa + 65 >>> 9 << 4),
						ba = sa + ca;
					for (; la.length <= va;) la.push(0);
					for (la[sa >>> 5] |= 128 << 24 - sa % 32, la[va] = 4294967295 & ba, la[va - 1] = ba / 4294967296 | 0, ha = 0; ha < la.length; ha += 16) ua = F$1(la.slice(ha, ha + 16), ua);
					return pa = da === "SHA-224" ? [ua[0], ua[1], ua[2], ua[3], ua[4], ua[5], ua[6]] : ua, pa
				}(ra, ia, aa, oa, Yi)
			}, this.C = T$1(Yi), this.p = 512, this.U = Yi === "SHA-224" ? 224 : 256, this.v = !1, na.hmacKey && this.M(c$1("hmacKey", na.hmacKey, this.K))
		}
	},
	B$1 = class {
		constructor(Yi, ea) {
			this.Y = Yi, this.N = ea
		}
	};

function L$1(ue, Yi) {
	let ea;
	return Yi > 32 ? (ea = 64 - Yi, new B$1(ue.N << Yi | ue.Y >>> ea, ue.Y << Yi | ue.N >>> ea)) : Yi !== 0 ? (ea = 32 - Yi, new B$1(ue.Y << Yi | ue.N >>> ea, ue.N << Yi | ue.Y >>> ea)) : ue
}

function M$1(ue, Yi) {
	let ea;
	return Yi < 32 ? (ea = 32 - Yi, new B$1(ue.Y >>> Yi | ue.N << ea, ue.N >>> Yi | ue.Y << ea)) : (ea = 64 - Yi, new B$1(ue.N >>> Yi | ue.Y << ea, ue.Y >>> Yi | ue.N << ea))
}

function k$1(ue, Yi) {
	return new B$1(ue.Y >>> Yi, ue.N >>> Yi | ue.Y << 32 - Yi)
}

function Y$1(ue, Yi, ea) {
	return new B$1(ue.Y & Yi.Y ^ ue.Y & ea.Y ^ Yi.Y & ea.Y, ue.N & Yi.N ^ ue.N & ea.N ^ Yi.N & ea.N)
}

function N$1(ue) {
	const Yi = M$1(ue, 28),
		ea = M$1(ue, 34),
		ta = M$1(ue, 39);
	return new B$1(Yi.Y ^ ea.Y ^ ta.Y, Yi.N ^ ea.N ^ ta.N)
}

function I$1(ue, Yi) {
	let ea, ta;
	ea = (65535 & ue.N) + (65535 & Yi.N), ta = (ue.N >>> 16) + (Yi.N >>> 16) + (ea >>> 16);
	const na = (65535 & ta) << 16 | 65535 & ea;
	return ea = (65535 & ue.Y) + (65535 & Yi.Y) + (ta >>> 16), ta = (ue.Y >>> 16) + (Yi.Y >>> 16) + (ea >>> 16), new B$1((65535 & ta) << 16 | 65535 & ea, na)
}

function X$1(ue, Yi, ea, ta) {
	let na, ra;
	na = (65535 & ue.N) + (65535 & Yi.N) + (65535 & ea.N) + (65535 & ta.N), ra = (ue.N >>> 16) + (Yi.N >>> 16) + (ea.N >>> 16) + (ta.N >>> 16) + (na >>> 16);
	const ia = (65535 & ra) << 16 | 65535 & na;
	return na = (65535 & ue.Y) + (65535 & Yi.Y) + (65535 & ea.Y) + (65535 & ta.Y) + (ra >>> 16), ra = (ue.Y >>> 16) + (Yi.Y >>> 16) + (ea.Y >>> 16) + (ta.Y >>> 16) + (na >>> 16), new B$1((65535 & ra) << 16 | 65535 & na, ia)
}

function z$1(ue, Yi, ea, ta, na) {
	let ra, ia;
	ra = (65535 & ue.N) + (65535 & Yi.N) + (65535 & ea.N) + (65535 & ta.N) + (65535 & na.N), ia = (ue.N >>> 16) + (Yi.N >>> 16) + (ea.N >>> 16) + (ta.N >>> 16) + (na.N >>> 16) + (ra >>> 16);
	const aa = (65535 & ia) << 16 | 65535 & ra;
	return ra = (65535 & ue.Y) + (65535 & Yi.Y) + (65535 & ea.Y) + (65535 & ta.Y) + (65535 & na.Y) + (ia >>> 16), ia = (ue.Y >>> 16) + (Yi.Y >>> 16) + (ea.Y >>> 16) + (ta.Y >>> 16) + (na.Y >>> 16) + (ra >>> 16), new B$1((65535 & ia) << 16 | 65535 & ra, aa)
}

function x$1(ue, Yi) {
	return new B$1(ue.Y ^ Yi.Y, ue.N ^ Yi.N)
}

function _$1(ue) {
	const Yi = M$1(ue, 19),
		ea = M$1(ue, 61),
		ta = k$1(ue, 6);
	return new B$1(Yi.Y ^ ea.Y ^ ta.Y, Yi.N ^ ea.N ^ ta.N)
}

function O$1(ue) {
	const Yi = M$1(ue, 1),
		ea = M$1(ue, 8),
		ta = k$1(ue, 7);
	return new B$1(Yi.Y ^ ea.Y ^ ta.Y, Yi.N ^ ea.N ^ ta.N)
}

function P$2(ue) {
	const Yi = M$1(ue, 14),
		ea = M$1(ue, 18),
		ta = M$1(ue, 41);
	return new B$1(Yi.Y ^ ea.Y ^ ta.Y, Yi.N ^ ea.N ^ ta.N)
}
const V$1 = [new B$1(i$2[0], 3609767458), new B$1(i$2[1], 602891725), new B$1(i$2[2], 3964484399), new B$1(i$2[3], 2173295548), new B$1(i$2[4], 4081628472), new B$1(i$2[5], 3053834265), new B$1(i$2[6], 2937671579), new B$1(i$2[7], 3664609560), new B$1(i$2[8], 2734883394), new B$1(i$2[9], 1164996542), new B$1(i$2[10], 1323610764), new B$1(i$2[11], 3590304994), new B$1(i$2[12], 4068182383), new B$1(i$2[13], 991336113), new B$1(i$2[14], 633803317), new B$1(i$2[15], 3479774868), new B$1(i$2[16], 2666613458), new B$1(i$2[17], 944711139), new B$1(i$2[18], 2341262773), new B$1(i$2[19], 2007800933), new B$1(i$2[20], 1495990901), new B$1(i$2[21], 1856431235), new B$1(i$2[22], 3175218132), new B$1(i$2[23], 2198950837), new B$1(i$2[24], 3999719339), new B$1(i$2[25], 766784016), new B$1(i$2[26], 2566594879), new B$1(i$2[27], 3203337956), new B$1(i$2[28], 1034457026), new B$1(i$2[29], 2466948901), new B$1(i$2[30], 3758326383), new B$1(i$2[31], 168717936), new B$1(i$2[32], 1188179964), new B$1(i$2[33], 1546045734), new B$1(i$2[34], 1522805485), new B$1(i$2[35], 2643833823), new B$1(i$2[36], 2343527390), new B$1(i$2[37], 1014477480), new B$1(i$2[38], 1206759142), new B$1(i$2[39], 344077627), new B$1(i$2[40], 1290863460), new B$1(i$2[41], 3158454273), new B$1(i$2[42], 3505952657), new B$1(i$2[43], 106217008), new B$1(i$2[44], 3606008344), new B$1(i$2[45], 1432725776), new B$1(i$2[46], 1467031594), new B$1(i$2[47], 851169720), new B$1(i$2[48], 3100823752), new B$1(i$2[49], 1363258195), new B$1(i$2[50], 3750685593), new B$1(i$2[51], 3785050280), new B$1(i$2[52], 3318307427), new B$1(i$2[53], 3812723403), new B$1(i$2[54], 2003034995), new B$1(i$2[55], 3602036899), new B$1(i$2[56], 1575990012), new B$1(i$2[57], 1125592928), new B$1(i$2[58], 2716904306), new B$1(i$2[59], 442776044), new B$1(i$2[60], 593698344), new B$1(i$2[61], 3733110249), new B$1(i$2[62], 2999351573), new B$1(i$2[63], 3815920427), new B$1(3391569614, 3928383900), new B$1(3515267271, 566280711), new B$1(3940187606, 3454069534), new B$1(4118630271, 4000239992), new B$1(116418474, 1914138554), new B$1(174292421, 2731055270), new B$1(289380356, 3203993006), new B$1(460393269, 320620315), new B$1(685471733, 587496836), new B$1(852142971, 1086792851), new B$1(1017036298, 365543100), new B$1(1126000580, 2618297676), new B$1(1288033470, 3409855158), new B$1(1501505948, 4234509866), new B$1(1607167915, 987167468), new B$1(1816402316, 1246189591)];

function Z$1(ue) {
	return ue === "SHA-384" ? [new B$1(3418070365, s$1[0]), new B$1(1654270250, s$1[1]), new B$1(2438529370, s$1[2]), new B$1(355462360, s$1[3]), new B$1(1731405415, s$1[4]), new B$1(41048885895, s$1[5]), new B$1(3675008525, s$1[6]), new B$1(1203062813, s$1[7])] : [new B$1(o$1[0], 4089235720), new B$1(o$1[1], 2227873595), new B$1(o$1[2], 4271175723), new B$1(o$1[3], 1595750129), new B$1(o$1[4], 2917565137), new B$1(o$1[5], 725511199), new B$1(o$1[6], 4215389547), new B$1(o$1[7], 327033209)]
}

function j$1(ue, Yi) {
	let ea, ta, na, ra, ia, aa, oa, la, sa, ca, ua, da;
	const ha = [];
	for (ea = Yi[0], ta = Yi[1], na = Yi[2], ra = Yi[3], ia = Yi[4], aa = Yi[5], oa = Yi[6], la = Yi[7], ua = 0; ua < 80; ua += 1) ua < 16 ? (da = 2 * ua, ha[ua] = new B$1(ue[da], ue[da + 1])) : ha[ua] = X$1(_$1(ha[ua - 2]), ha[ua - 7], O$1(ha[ua - 15]), ha[ua - 16]), sa = z$1(la, P$2(ia), (va = aa, ba = oa, new B$1((pa = ia).Y & va.Y ^ ~pa.Y & ba.Y, pa.N & va.N ^ ~pa.N & ba.N)), V$1[ua], ha[ua]), ca = I$1(N$1(ea), Y$1(ea, ta, na)), la = oa, oa = aa, aa = ia, ia = I$1(ra, sa), ra = na, na = ta, ta = ea, ea = I$1(sa, ca);
	var pa, va, ba;
	return Yi[0] = I$1(ea, Yi[0]), Yi[1] = I$1(ta, Yi[1]), Yi[2] = I$1(na, Yi[2]), Yi[3] = I$1(ra, Yi[3]), Yi[4] = I$1(ia, Yi[4]), Yi[5] = I$1(aa, Yi[5]), Yi[6] = I$1(oa, Yi[6]), Yi[7] = I$1(la, Yi[7]), Yi
}
let q$1 = class extends f$1 {
	constructor(Yi, ea, ta) {
		if (Yi !== "SHA-384" && Yi !== "SHA-512") throw new Error(h$1);
		super(Yi, ea, ta);
		const na = ta || {};
		this.T = this.k, this.L = !0, this.K = -1, this.m = e$2(this.t, this.i, this.K), this.R = j$1, this.g = function(ra) {
			return ra.slice()
		}, this.B = Z$1, this.F = function(ra, ia, aa, oa) {
			return function(la, sa, ca, ua, da) {
				let ha, pa;
				const va = 31 + (sa + 129 >>> 10 << 5),
					ba = sa + ca;
				for (; la.length <= va;) la.push(0);
				for (la[sa >>> 5] |= 128 << 24 - sa % 32, la[va] = 4294967295 & ba, la[va - 1] = ba / 4294967296 | 0, ha = 0; ha < la.length; ha += 32) ua = j$1(la.slice(ha, ha + 32), ua);
				return pa = da === "SHA-384" ? [(ua = ua)[0].Y, ua[0].N, ua[1].Y, ua[1].N, ua[2].Y, ua[2].N, ua[3].Y, ua[3].N, ua[4].Y, ua[4].N, ua[5].Y, ua[5].N] : [ua[0].Y, ua[0].N, ua[1].Y, ua[1].N, ua[2].Y, ua[2].N, ua[3].Y, ua[3].N, ua[4].Y, ua[4].N, ua[5].Y, ua[5].N, ua[6].Y, ua[6].N, ua[7].Y, ua[7].N], pa
			}(ra, ia, aa, oa, Yi)
		}, this.C = Z$1(Yi), this.p = 1024, this.U = Yi === "SHA-384" ? 384 : 512, this.v = !1, na.hmacKey && this.M(c$1("hmacKey", na.hmacKey, this.K))
	}
};
const D$1 = [new B$1(0, 1), new B$1(0, 32898), new B$1(2147483648, 32906), new B$1(2147483648, 2147516416), new B$1(0, 32907), new B$1(0, 2147483649), new B$1(2147483648, 2147516545), new B$1(2147483648, 32777), new B$1(0, 138), new B$1(0, 136), new B$1(0, 2147516425), new B$1(0, 2147483658), new B$1(0, 2147516555), new B$1(2147483648, 139), new B$1(2147483648, 32905), new B$1(2147483648, 32771), new B$1(2147483648, 32770), new B$1(2147483648, 128), new B$1(0, 32778), new B$1(2147483648, 2147483658), new B$1(2147483648, 2147516545), new B$1(2147483648, 32896), new B$1(0, 2147483649), new B$1(2147483648, 2147516424)],
	G$1 = [
		[0, 36, 3, 41, 18],
		[1, 44, 10, 45, 2],
		[62, 6, 43, 15, 61],
		[28, 55, 25, 21, 56],
		[27, 20, 39, 8, 14]
	];

function J$1(ue) {
	let Yi;
	const ea = [];
	for (Yi = 0; Yi < 5; Yi += 1) ea[Yi] = [new B$1(0, 0), new B$1(0, 0), new B$1(0, 0), new B$1(0, 0), new B$1(0, 0)];
	return ea
}

function Q$1(ue) {
	let Yi;
	const ea = [];
	for (Yi = 0; Yi < 5; Yi += 1) ea[Yi] = ue[Yi].slice();
	return ea
}

function W$1(ue, Yi) {
	let ea, ta, na, ra;
	const ia = [],
		aa = [];
	if (ue !== null)
		for (ta = 0; ta < ue.length; ta += 2) Yi[(ta >>> 1) % 5][(ta >>> 1) / 5 | 0] = x$1(Yi[(ta >>> 1) % 5][(ta >>> 1) / 5 | 0], new B$1(ue[ta + 1], ue[ta]));
	for (ea = 0; ea < 24; ea += 1) {
		for (ra = J$1(), ta = 0; ta < 5; ta += 1) ia[ta] = (oa = Yi[ta][0], la = Yi[ta][1], sa = Yi[ta][2], ca = Yi[ta][3], ua = Yi[ta][4], new B$1(oa.Y ^ la.Y ^ sa.Y ^ ca.Y ^ ua.Y, oa.N ^ la.N ^ sa.N ^ ca.N ^ ua.N));
		for (ta = 0; ta < 5; ta += 1) aa[ta] = x$1(ia[(ta + 4) % 5], L$1(ia[(ta + 1) % 5], 1));
		for (ta = 0; ta < 5; ta += 1)
			for (na = 0; na < 5; na += 1) Yi[ta][na] = x$1(Yi[ta][na], aa[ta]);
		for (ta = 0; ta < 5; ta += 1)
			for (na = 0; na < 5; na += 1) ra[na][(2 * ta + 3 * na) % 5] = L$1(Yi[ta][na], G$1[ta][na]);
		for (ta = 0; ta < 5; ta += 1)
			for (na = 0; na < 5; na += 1) Yi[ta][na] = x$1(ra[ta][na], new B$1(~ra[(ta + 1) % 5][na].Y & ra[(ta + 2) % 5][na].Y, ~ra[(ta + 1) % 5][na].N & ra[(ta + 2) % 5][na].N));
		Yi[0][0] = x$1(Yi[0][0], D$1[ea])
	}
	var oa, la, sa, ca, ua;
	return Yi
}

function $$1(ue) {
	let Yi, ea, ta = 0;
	const na = [0, 0],
		ra = [4294967295 & ue, ue / 4294967296 & 2097151];
	for (Yi = 6; Yi >= 0; Yi--) ea = ra[Yi >> 2] >>> 8 * Yi & 255, ea === 0 && ta === 0 || (na[ta + 1 >> 2] |= ea << 8 * (ta + 1), ta += 1);
	return ta = ta !== 0 ? ta : 1, na[0] |= ta, {
		value: ta + 1 > 4 ? na : [na[0]],
		binLen: 8 + 8 * ta
	}
}

function tt$1(ue) {
	return u$1($$1(ue.binLen), ue)
}

function nt$1(ue, Yi) {
	let ea, ta = $$1(Yi);
	ta = u$1(ta, ue);
	const na = Yi >>> 2,
		ra = (na - ta.value.length % na) % na;
	for (ea = 0; ea < ra; ea++) ta.value.push(0);
	return ta.value
}
let et$1 = class extends f$1 {
	constructor(Yi, ea, ta) {
		let na = 6,
			ra = 0;
		super(Yi, ea, ta);
		const ia = ta || {};
		if (this.numRounds !== 1) {
			if (ia.kmacKey || ia.hmacKey) throw new Error("Cannot set numRounds with MAC");
			if (this.s === "CSHAKE128" || this.s === "CSHAKE256") throw new Error("Cannot set numRounds for CSHAKE variants")
		}
		switch (this.K = 1, this.m = e$2(this.t, this.i, this.K), this.R = W$1, this.g = Q$1, this.B = J$1, this.C = J$1(), this.v = !1, Yi) {
			case "SHA3-224":
				this.p = ra = 1152, this.U = 224, this.L = !0, this.T = this.k;
				break;
			case "SHA3-256":
				this.p = ra = 1088, this.U = 256, this.L = !0, this.T = this.k;
				break;
			case "SHA3-384":
				this.p = ra = 832, this.U = 384, this.L = !0, this.T = this.k;
				break;
			case "SHA3-512":
				this.p = ra = 576, this.U = 512, this.L = !0, this.T = this.k;
				break;
			case "SHAKE128":
				na = 31, this.p = ra = 1344, this.U = -1, this.v = !0, this.L = !1, this.T = null;
				break;
			case "SHAKE256":
				na = 31, this.p = ra = 1088, this.U = -1, this.v = !0, this.L = !1, this.T = null;
				break;
			case "KMAC128":
				na = 4, this.p = ra = 1344, this.I(ta), this.U = -1, this.v = !0, this.L = !1, this.T = this.X;
				break;
			case "KMAC256":
				na = 4, this.p = ra = 1088, this.I(ta), this.U = -1, this.v = !0, this.L = !1, this.T = this.X;
				break;
			case "CSHAKE128":
				this.p = ra = 1344, na = this._(ta), this.U = -1, this.v = !0, this.L = !1, this.T = null;
				break;
			case "CSHAKE256":
				this.p = ra = 1088, na = this._(ta), this.U = -1, this.v = !0, this.L = !1, this.T = null;
				break;
			default:
				throw new Error(h$1)
		}
		this.F = function(aa, oa, la, sa, ca) {
			return function(ua, da, ha, pa, va, ba, Ea) {
				let Sa, Ca, ka = 0;
				const Pa = [],
					ja = va >>> 5,
					Za = da >>> 5;
				for (Sa = 0; Sa < Za && da >= va; Sa += ja) pa = W$1(ua.slice(Sa, Sa + ja), pa), da -= va;
				for (ua = ua.slice(Sa), da %= va; ua.length < ja;) ua.push(0);
				for (Sa = da >>> 3, ua[Sa >> 2] ^= ba << Sa % 4 * 8, ua[ja - 1] ^= 2147483648, pa = W$1(ua, pa); 32 * Pa.length < Ea && (Ca = pa[ka % 5][ka / 5 | 0], Pa.push(Ca.N), !(32 * Pa.length >= Ea));) Pa.push(Ca.Y), ka += 1, 64 * ka % va == 0 && (W$1(null, pa), ka = 0);
				return Pa
			}(aa, oa, 0, sa, ra, na, ca)
		}, ia.hmacKey && this.M(c$1("hmacKey", ia.hmacKey, this.K))
	}
	_(Yi, ea) {
		const ta = function(ra) {
			const ia = ra || {};
			return {
				funcName: c$1("funcName", ia.funcName, 1, {
					value: [],
					binLen: 0
				}),
				customization: c$1("Customization", ia.customization, 1, {
					value: [],
					binLen: 0
				})
			}
		}(Yi || {});
		ea && (ta.funcName = ea);
		const na = u$1(tt$1(ta.funcName), tt$1(ta.customization));
		if (ta.customization.binLen !== 0 || ta.funcName.binLen !== 0) {
			const ra = nt$1(na, this.p >>> 3);
			for (let ia = 0; ia < ra.length; ia += this.p >>> 5) this.C = this.R(ra.slice(ia, ia + (this.p >>> 5)), this.C), this.l += this.p;
			return 4
		}
		return 31
	}
	I(Yi) {
		const ea = function(na) {
			const ra = na || {};
			return {
				kmacKey: c$1("kmacKey", ra.kmacKey, 1),
				funcName: {
					value: [1128353099],
					binLen: 32
				},
				customization: c$1("Customization", ra.customization, 1, {
					value: [],
					binLen: 0
				})
			}
		}(Yi || {});
		this._(Yi, ea.funcName);
		const ta = nt$1(tt$1(ea.kmacKey), this.p >>> 3);
		for (let na = 0; na < ta.length; na += this.p >>> 5) this.C = this.R(ta.slice(na, na + (this.p >>> 5)), this.C), this.l += this.p;
		this.A = !0
	}
	X(Yi) {
		const ea = u$1({
			value: this.o.slice(),
			binLen: this.h
		}, function(ta) {
			let na, ra, ia = 0;
			const aa = [0, 0],
				oa = [4294967295 & ta, ta / 4294967296 & 2097151];
			for (na = 6; na >= 0; na--) ra = oa[na >> 2] >>> 8 * na & 255, ra === 0 && ia === 0 || (aa[ia >> 2] |= ra << 8 * ia, ia += 1);
			return ia = ia !== 0 ? ia : 1, aa[ia >> 2] |= ia << 8 * ia, {
				value: ia + 1 > 4 ? aa : [aa[0]],
				binLen: 8 + 8 * ia
			}
		}(Yi.outputLen));
		return this.F(ea.value, ea.binLen, this.l, this.g(this.C), Yi.outputLen)
	}
};
class sha$2 {
	constructor(Yi, ea, ta) {
		if (Yi == "SHA-1") this.O = new K$1(Yi, ea, ta);
		else if (Yi == "SHA-224" || Yi == "SHA-256") this.O = new g$1(Yi, ea, ta);
		else if (Yi == "SHA-384" || Yi == "SHA-512") this.O = new q$1(Yi, ea, ta);
		else {
			if (Yi != "SHA3-224" && Yi != "SHA3-256" && Yi != "SHA3-384" && Yi != "SHA3-512" && Yi != "SHAKE128" && Yi != "SHAKE256" && Yi != "CSHAKE128" && Yi != "CSHAKE256" && Yi != "KMAC128" && Yi != "KMAC256") throw new Error(h$1);
			this.O = new et$1(Yi, ea, ta)
		}
	}
	update(Yi) {
		this.O.update(Yi)
	}
	getHash(Yi, ea) {
		return this.O.getHash(Yi, ea)
	}
	setHMACKey(Yi, ea, ta) {
		this.O.setHMACKey(Yi, ea, ta)
	}
	getHMAC(Yi, ea) {
		return this.O.getHMAC(Yi, ea)
	}
}
const sha$3 = Object.freeze(Object.defineProperty({
		__proto__: null,
		default: sha$2
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	require$$0$1 = getAugmentedNamespace(sha$3);
var browser$c = {},
	getSecureRandom$1 = {};
Object.defineProperty(getSecureRandom$1, "__esModule", {
	value: !0
});
getSecureRandom$1.getSecureRandomWords = getSecureRandom$1.getSecureRandomBytes = void 0;

function getSecureRandomBytes$1(ue) {
	return Buffer.from(window.crypto.getRandomValues(new Uint8Array(ue)))
}
getSecureRandom$1.getSecureRandomBytes = getSecureRandomBytes$1;

function getSecureRandomWords$1(ue) {
	return window.crypto.getRandomValues(new Uint16Array(ue))
}
getSecureRandom$1.getSecureRandomWords = getSecureRandomWords$1;
var hmac_sha512$3 = {};
Object.defineProperty(hmac_sha512$3, "__esModule", {
	value: !0
});
hmac_sha512$3.hmac_sha512 = void 0;
async function hmac_sha512$2(ue, Yi) {
	let ea = typeof ue == "string" ? Buffer.from(ue, "utf-8") : ue,
		ta = typeof Yi == "string" ? Buffer.from(Yi, "utf-8") : Yi;
	const na = {
			name: "HMAC",
			hash: "SHA-512"
		},
		ra = await window.crypto.subtle.importKey("raw", ea, na, !1, ["sign"]);
	return Buffer.from(await crypto.subtle.sign(na, ra, ta))
}
hmac_sha512$3.hmac_sha512 = hmac_sha512$2;
var pbkdf2_sha512$3 = {};
Object.defineProperty(pbkdf2_sha512$3, "__esModule", {
	value: !0
});
pbkdf2_sha512$3.pbkdf2_sha512 = void 0;
async function pbkdf2_sha512$2(ue, Yi, ea, ta) {
	const na = typeof ue == "string" ? Buffer.from(ue, "utf-8") : ue,
		ra = typeof Yi == "string" ? Buffer.from(Yi, "utf-8") : Yi,
		ia = await window.crypto.subtle.importKey("raw", na, {
			name: "PBKDF2"
		}, !1, ["deriveBits"]),
		aa = await window.crypto.subtle.deriveBits({
			name: "PBKDF2",
			hash: "SHA-512",
			salt: ra,
			iterations: ea
		}, ia, ta * 8);
	return Buffer.from(aa)
}
pbkdf2_sha512$3.pbkdf2_sha512 = pbkdf2_sha512$2;
var sha256$4 = {};
Object.defineProperty(sha256$4, "__esModule", {
	value: !0
});
sha256$4.sha256 = void 0;
async function sha256$3(ue) {
	return typeof ue == "string" ? Buffer.from(await crypto.subtle.digest("SHA-256", Buffer.from(ue, "utf-8"))) : Buffer.from(await crypto.subtle.digest("SHA-256", ue))
}
sha256$4.sha256 = sha256$3;
var sha512$5 = {};
Object.defineProperty(sha512$5, "__esModule", {
	value: !0
});
sha512$5.sha512 = void 0;
async function sha512$4(ue) {
	return typeof ue == "string" ? Buffer.from(await crypto.subtle.digest("SHA-512", Buffer.from(ue, "utf-8"))) : Buffer.from(await crypto.subtle.digest("SHA-512", ue))
}
sha512$5.sha512 = sha512$4;
(function(ue) {
	Object.defineProperty(ue, "__esModule", {
		value: !0
	}), ue.sha512 = ue.sha256 = ue.pbkdf2_sha512 = ue.hmac_sha512 = ue.getSecureRandomWords = ue.getSecureRandomBytes = void 0;
	var Yi = getSecureRandom$1;
	Object.defineProperty(ue, "getSecureRandomBytes", {
		enumerable: !0,
		get: function() {
			return Yi.getSecureRandomBytes
		}
	}), Object.defineProperty(ue, "getSecureRandomWords", {
		enumerable: !0,
		get: function() {
			return Yi.getSecureRandomWords
		}
	});
	var ea = hmac_sha512$3;
	Object.defineProperty(ue, "hmac_sha512", {
		enumerable: !0,
		get: function() {
			return ea.hmac_sha512
		}
	});
	var ta = pbkdf2_sha512$3;
	Object.defineProperty(ue, "pbkdf2_sha512", {
		enumerable: !0,
		get: function() {
			return ta.pbkdf2_sha512
		}
	});
	var na = sha256$4;
	Object.defineProperty(ue, "sha256", {
		enumerable: !0,
		get: function() {
			return na.sha256
		}
	});
	var ra = sha512$5;
	Object.defineProperty(ue, "sha512", {
		enumerable: !0,
		get: function() {
			return ra.sha512
		}
	})
})(browser$c);
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(ue) {
	return ue && ue.__esModule ? ue : {
		default: ue
	}
};
Object.defineProperty(sha256$5, "__esModule", {
	value: !0
});
sha256$5.sha256 = sha256$5.sha256_fallback = sha256$5.sha256_sync = void 0;
const jssha_1$2 = __importDefault$4(require$$0$1),
	crypto_primitives_1$4 = browser$c;

function sha256_sync(ue) {
	let Yi;
	typeof ue == "string" ? Yi = Buffer.from(ue, "utf-8").toString("hex") : Yi = ue.toString("hex");
	let ea = new jssha_1$2.default("SHA-256", "HEX");
	ea.update(Yi);
	let ta = ea.getHash("HEX");
	return Buffer.from(ta, "hex")
}
sha256$5.sha256_sync = sha256_sync;
async function sha256_fallback(ue) {
	return sha256_sync(ue)
}
sha256$5.sha256_fallback = sha256_fallback;

function sha256$2(ue) {
	return (0, crypto_primitives_1$4.sha256)(ue)
}
sha256$5.sha256 = sha256$2;
var sha512$3 = {},
	__importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(ue) {
		return ue && ue.__esModule ? ue : {
			default: ue
		}
	};
Object.defineProperty(sha512$3, "__esModule", {
	value: !0
});
sha512$3.sha512 = sha512$3.sha512_fallback = sha512$3.sha512_sync = void 0;
const jssha_1$1 = __importDefault$3(require$$0$1),
	crypto_primitives_1$3 = browser$c;

function sha512_sync(ue) {
	let Yi;
	typeof ue == "string" ? Yi = Buffer.from(ue, "utf-8").toString("hex") : Yi = ue.toString("hex");
	let ea = new jssha_1$1.default("SHA-512", "HEX");
	ea.update(Yi);
	let ta = ea.getHash("HEX");
	return Buffer.from(ta, "hex")
}
sha512$3.sha512_sync = sha512_sync;
async function sha512_fallback(ue) {
	return sha512_sync(ue)
}
sha512$3.sha512_fallback = sha512_fallback;
async function sha512$2(ue) {
	return (0, crypto_primitives_1$3.sha512)(ue)
}
sha512$3.sha512 = sha512$2;
var pbkdf2_sha512$1 = {};
Object.defineProperty(pbkdf2_sha512$1, "__esModule", {
	value: !0
});
pbkdf2_sha512$1.pbkdf2_sha512 = void 0;
const crypto_primitives_1$2 = browser$c;

function pbkdf2_sha512(ue, Yi, ea, ta) {
	return (0, crypto_primitives_1$2.pbkdf2_sha512)(ue, Yi, ea, ta)
}
pbkdf2_sha512$1.pbkdf2_sha512 = pbkdf2_sha512;
var hmac_sha512$1 = {},
	__importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(ue) {
		return ue && ue.__esModule ? ue : {
			default: ue
		}
	};
Object.defineProperty(hmac_sha512$1, "__esModule", {
	value: !0
});
hmac_sha512$1.hmac_sha512 = hmac_sha512$1.hmac_sha512_fallback = void 0;
const jssha_1 = __importDefault$2(require$$0$1),
	crypto_primitives_1$1 = browser$c;
async function hmac_sha512_fallback(ue, Yi) {
	let ea = typeof ue == "string" ? Buffer.from(ue, "utf-8") : ue,
		ta = typeof Yi == "string" ? Buffer.from(Yi, "utf-8") : Yi;
	const na = new jssha_1.default("SHA-512", "HEX", {
		hmacKey: {
			value: ea.toString("hex"),
			format: "HEX"
		}
	});
	na.update(ta.toString("hex"));
	const ra = na.getHash("HEX");
	return Buffer.from(ra, "hex")
}
hmac_sha512$1.hmac_sha512_fallback = hmac_sha512_fallback;

function hmac_sha512(ue, Yi) {
	return (0, crypto_primitives_1$1.hmac_sha512)(ue, Yi)
}
hmac_sha512$1.hmac_sha512 = hmac_sha512;
var getSecureRandom = {};
Object.defineProperty(getSecureRandom, "__esModule", {
	value: !0
});
getSecureRandom.getSecureRandomNumber = getSecureRandom.getSecureRandomWords = getSecureRandom.getSecureRandomBytes = void 0;
const crypto_primitives_1 = browser$c;
async function getSecureRandomBytes(ue) {
	return (0, crypto_primitives_1.getSecureRandomBytes)(ue)
}
getSecureRandom.getSecureRandomBytes = getSecureRandomBytes;
async function getSecureRandomWords(ue) {
	return getSecureRandomWords()
}
getSecureRandom.getSecureRandomWords = getSecureRandomWords;
async function getSecureRandomNumber(ue, Yi) {
	let ea = Yi - ue;
	var ta = Math.ceil(Math.log2(ea));
	if (ta > 53) throw new Error("Range is too large");
	for (var na = Math.ceil(ta / 8), ra = Math.pow(2, ta) - 1;;) {
		let aa = await getSecureRandomBytes(ta),
			oa = (na - 1) * 8,
			la = 0;
		for (var ia = 0; ia < na; ia++) la += aa[ia] * Math.pow(2, oa), oa -= 8;
		if (la = la & ra, !(la >= ea)) return ue + la
	}
}
getSecureRandom.getSecureRandomNumber = getSecureRandomNumber;
var newSecureWords$1 = {},
	wordlist$1 = {};
Object.defineProperty(wordlist$1, "__esModule", {
	value: !0
});
wordlist$1.wordlist = void 0;
wordlist$1.wordlist = ["abacus", "abdomen", "abdominal", "abide", "abiding", "ability", "ablaze", "able", "abnormal", "abrasion", "abrasive", "abreast", "abridge", "abroad", "abruptly", "absence", "absentee", "absently", "absinthe", "absolute", "absolve", "abstain", "abstract", "absurd", "accent", "acclaim", "acclimate", "accompany", "account", "accuracy", "accurate", "accustom", "acetone", "achiness", "aching", "acid", "acorn", "acquaint", "acquire", "acre", "acrobat", "acronym", "acting", "action", "activate", "activator", "active", "activism", "activist", "activity", "actress", "acts", "acutely", "acuteness", "aeration", "aerobics", "aerosol", "aerospace", "afar", "affair", "affected", "affecting", "affection", "affidavit", "affiliate", "affirm", "affix", "afflicted", "affluent", "afford", "affront", "aflame", "afloat", "aflutter", "afoot", "afraid", "afterglow", "afterlife", "aftermath", "aftermost", "afternoon", "aged", "ageless", "agency", "agenda", "agent", "aggregate", "aghast", "agile", "agility", "aging", "agnostic", "agonize", "agonizing", "agony", "agreeable", "agreeably", "agreed", "agreeing", "agreement", "aground", "ahead", "ahoy", "aide", "aids", "aim", "ajar", "alabaster", "alarm", "albatross", "album", "alfalfa", "algebra", "algorithm", "alias", "alibi", "alienable", "alienate", "aliens", "alike", "alive", "alkaline", "alkalize", "almanac", "almighty", "almost", "aloe", "aloft", "aloha", "alone", "alongside", "aloof", "alphabet", "alright", "although", "altitude", "alto", "aluminum", "alumni", "always", "amaretto", "amaze", "amazingly", "amber", "ambiance", "ambiguity", "ambiguous", "ambition", "ambitious", "ambulance", "ambush", "amendable", "amendment", "amends", "amenity", "amiable", "amicably", "amid", "amigo", "amino", "amiss", "ammonia", "ammonium", "amnesty", "amniotic", "among", "amount", "amperage", "ample", "amplifier", "amplify", "amply", "amuck", "amulet", "amusable", "amused", "amusement", "amuser", "amusing", "anaconda", "anaerobic", "anagram", "anatomist", "anatomy", "anchor", "anchovy", "ancient", "android", "anemia", "anemic", "aneurism", "anew", "angelfish", "angelic", "anger", "angled", "angler", "angles", "angling", "angrily", "angriness", "anguished", "angular", "animal", "animate", "animating", "animation", "animator", "anime", "animosity", "ankle", "annex", "annotate", "announcer", "annoying", "annually", "annuity", "anointer", "another", "answering", "antacid", "antarctic", "anteater", "antelope", "antennae", "anthem", "anthill", "anthology", "antibody", "antics", "antidote", "antihero", "antiquely", "antiques", "antiquity", "antirust", "antitoxic", "antitrust", "antiviral", "antivirus", "antler", "antonym", "antsy", "anvil", "anybody", "anyhow", "anymore", "anyone", "anyplace", "anything", "anytime", "anyway", "anywhere", "aorta", "apache", "apostle", "appealing", "appear", "appease", "appeasing", "appendage", "appendix", "appetite", "appetizer", "applaud", "applause", "apple", "appliance", "applicant", "applied", "apply", "appointee", "appraisal", "appraiser", "apprehend", "approach", "approval", "approve", "apricot", "april", "apron", "aptitude", "aptly", "aqua", "aqueduct", "arbitrary", "arbitrate", "ardently", "area", "arena", "arguable", "arguably", "argue", "arise", "armadillo", "armband", "armchair", "armed", "armful", "armhole", "arming", "armless", "armoire", "armored", "armory", "armrest", "army", "aroma", "arose", "around", "arousal", "arrange", "array", "arrest", "arrival", "arrive", "arrogance", "arrogant", "arson", "art", "ascend", "ascension", "ascent", "ascertain", "ashamed", "ashen", "ashes", "ashy", "aside", "askew", "asleep", "asparagus", "aspect", "aspirate", "aspire", "aspirin", "astonish", "astound", "astride", "astrology", "astronaut", "astronomy", "astute", "atlantic", "atlas", "atom", "atonable", "atop", "atrium", "atrocious", "atrophy", "attach", "attain", "attempt", "attendant", "attendee", "attention", "attentive", "attest", "attic", "attire", "attitude", "attractor", "attribute", "atypical", "auction", "audacious", "audacity", "audible", "audibly", "audience", "audio", "audition", "augmented", "august", "authentic", "author", "autism", "autistic", "autograph", "automaker", "automated", "automatic", "autopilot", "available", "avalanche", "avatar", "avenge", "avenging", "avenue", "average", "aversion", "avert", "aviation", "aviator", "avid", "avoid", "await", "awaken", "award", "aware", "awhile", "awkward", "awning", "awoke", "awry", "axis", "babble", "babbling", "babied", "baboon", "backache", "backboard", "backboned", "backdrop", "backed", "backer", "backfield", "backfire", "backhand", "backing", "backlands", "backlash", "backless", "backlight", "backlit", "backlog", "backpack", "backpedal", "backrest", "backroom", "backshift", "backside", "backslid", "backspace", "backspin", "backstab", "backstage", "backtalk", "backtrack", "backup", "backward", "backwash", "backwater", "backyard", "bacon", "bacteria", "bacterium", "badass", "badge", "badland", "badly", "badness", "baffle", "baffling", "bagel", "bagful", "baggage", "bagged", "baggie", "bagginess", "bagging", "baggy", "bagpipe", "baguette", "baked", "bakery", "bakeshop", "baking", "balance", "balancing", "balcony", "balmy", "balsamic", "bamboo", "banana", "banish", "banister", "banjo", "bankable", "bankbook", "banked", "banker", "banking", "banknote", "bankroll", "banner", "bannister", "banshee", "banter", "barbecue", "barbed", "barbell", "barber", "barcode", "barge", "bargraph", "barista", "baritone", "barley", "barmaid", "barman", "barn", "barometer", "barrack", "barracuda", "barrel", "barrette", "barricade", "barrier", "barstool", "bartender", "barterer", "bash", "basically", "basics", "basil", "basin", "basis", "basket", "batboy", "batch", "bath", "baton", "bats", "battalion", "battered", "battering", "battery", "batting", "battle", "bauble", "bazooka", "blabber", "bladder", "blade", "blah", "blame", "blaming", "blanching", "blandness", "blank", "blaspheme", "blasphemy", "blast", "blatancy", "blatantly", "blazer", "blazing", "bleach", "bleak", "bleep", "blemish", "blend", "bless", "blighted", "blimp", "bling", "blinked", "blinker", "blinking", "blinks", "blip", "blissful", "blitz", "blizzard", "bloated", "bloating", "blob", "blog", "bloomers", "blooming", "blooper", "blot", "blouse", "blubber", "bluff", "bluish", "blunderer", "blunt", "blurb", "blurred", "blurry", "blurt", "blush", "blustery", "boaster", "boastful", "boasting", "boat", "bobbed", "bobbing", "bobble", "bobcat", "bobsled", "bobtail", "bodacious", "body", "bogged", "boggle", "bogus", "boil", "bok", "bolster", "bolt", "bonanza", "bonded", "bonding", "bondless", "boned", "bonehead", "boneless", "bonelike", "boney", "bonfire", "bonnet", "bonsai", "bonus", "bony", "boogeyman", "boogieman", "book", "boondocks", "booted", "booth", "bootie", "booting", "bootlace", "bootleg", "boots", "boozy", "borax", "boring", "borough", "borrower", "borrowing", "boss", "botanical", "botanist", "botany", "botch", "both", "bottle", "bottling", "bottom", "bounce", "bouncing", "bouncy", "bounding", "boundless", "bountiful", "bovine", "boxcar", "boxer", "boxing", "boxlike", "boxy", "breach", "breath", "breeches", "breeching", "breeder", "breeding", "breeze", "breezy", "brethren", "brewery", "brewing", "briar", "bribe", "brick", "bride", "bridged", "brigade", "bright", "brilliant", "brim", "bring", "brink", "brisket", "briskly", "briskness", "bristle", "brittle", "broadband", "broadcast", "broaden", "broadly", "broadness", "broadside", "broadways", "broiler", "broiling", "broken", "broker", "bronchial", "bronco", "bronze", "bronzing", "brook", "broom", "brought", "browbeat", "brownnose", "browse", "browsing", "bruising", "brunch", "brunette", "brunt", "brush", "brussels", "brute", "brutishly", "bubble", "bubbling", "bubbly", "buccaneer", "bucked", "bucket", "buckle", "buckshot", "buckskin", "bucktooth", "buckwheat", "buddhism", "buddhist", "budding", "buddy", "budget", "buffalo", "buffed", "buffer", "buffing", "buffoon", "buggy", "bulb", "bulge", "bulginess", "bulgur", "bulk", "bulldog", "bulldozer", "bullfight", "bullfrog", "bullhorn", "bullion", "bullish", "bullpen", "bullring", "bullseye", "bullwhip", "bully", "bunch", "bundle", "bungee", "bunion", "bunkbed", "bunkhouse", "bunkmate", "bunny", "bunt", "busboy", "bush", "busily", "busload", "bust", "busybody", "buzz", "cabana", "cabbage", "cabbie", "cabdriver", "cable", "caboose", "cache", "cackle", "cacti", "cactus", "caddie", "caddy", "cadet", "cadillac", "cadmium", "cage", "cahoots", "cake", "calamari", "calamity", "calcium", "calculate", "calculus", "caliber", "calibrate", "calm", "caloric", "calorie", "calzone", "camcorder", "cameo", "camera", "camisole", "camper", "campfire", "camping", "campsite", "campus", "canal", "canary", "cancel", "candied", "candle", "candy", "cane", "canine", "canister", "cannabis", "canned", "canning", "cannon", "cannot", "canola", "canon", "canopener", "canopy", "canteen", "canyon", "capable", "capably", "capacity", "cape", "capillary", "capital", "capitol", "capped", "capricorn", "capsize", "capsule", "caption", "captivate", "captive", "captivity", "capture", "caramel", "carat", "caravan", "carbon", "cardboard", "carded", "cardiac", "cardigan", "cardinal", "cardstock", "carefully", "caregiver", "careless", "caress", "caretaker", "cargo", "caring", "carless", "carload", "carmaker", "carnage", "carnation", "carnival", "carnivore", "carol", "carpenter", "carpentry", "carpool", "carport", "carried", "carrot", "carrousel", "carry", "cartel", "cartload", "carton", "cartoon", "cartridge", "cartwheel", "carve", "carving", "carwash", "cascade", "case", "cash", "casing", "casino", "casket", "cassette", "casually", "casualty", "catacomb", "catalog", "catalyst", "catalyze", "catapult", "cataract", "catatonic", "catcall", "catchable", "catcher", "catching", "catchy", "caterer", "catering", "catfight", "catfish", "cathedral", "cathouse", "catlike", "catnap", "catnip", "catsup", "cattail", "cattishly", "cattle", "catty", "catwalk", "caucasian", "caucus", "causal", "causation", "cause", "causing", "cauterize", "caution", "cautious", "cavalier", "cavalry", "caviar", "cavity", "cedar", "celery", "celestial", "celibacy", "celibate", "celtic", "cement", "census", "ceramics", "ceremony", "certainly", "certainty", "certified", "certify", "cesarean", "cesspool", "chafe", "chaffing", "chain", "chair", "chalice", "challenge", "chamber", "chamomile", "champion", "chance", "change", "channel", "chant", "chaos", "chaperone", "chaplain", "chapped", "chaps", "chapter", "character", "charbroil", "charcoal", "charger", "charging", "chariot", "charity", "charm", "charred", "charter", "charting", "chase", "chasing", "chaste", "chastise", "chastity", "chatroom", "chatter", "chatting", "chatty", "cheating", "cheddar", "cheek", "cheer", "cheese", "cheesy", "chef", "chemicals", "chemist", "chemo", "cherisher", "cherub", "chess", "chest", "chevron", "chevy", "chewable", "chewer", "chewing", "chewy", "chief", "chihuahua", "childcare", "childhood", "childish", "childless", "childlike", "chili", "chill", "chimp", "chip", "chirping", "chirpy", "chitchat", "chivalry", "chive", "chloride", "chlorine", "choice", "chokehold", "choking", "chomp", "chooser", "choosing", "choosy", "chop", "chosen", "chowder", "chowtime", "chrome", "chubby", "chuck", "chug", "chummy", "chump", "chunk", "churn", "chute", "cider", "cilantro", "cinch", "cinema", "cinnamon", "circle", "circling", "circular", "circulate", "circus", "citable", "citadel", "citation", "citizen", "citric", "citrus", "city", "civic", "civil", "clad", "claim", "clambake", "clammy", "clamor", "clamp", "clamshell", "clang", "clanking", "clapped", "clapper", "clapping", "clarify", "clarinet", "clarity", "clash", "clasp", "class", "clatter", "clause", "clavicle", "claw", "clay", "clean", "clear", "cleat", "cleaver", "cleft", "clench", "clergyman", "clerical", "clerk", "clever", "clicker", "client", "climate", "climatic", "cling", "clinic", "clinking", "clip", "clique", "cloak", "clobber", "clock", "clone", "cloning", "closable", "closure", "clothes", "clothing", "cloud", "clover", "clubbed", "clubbing", "clubhouse", "clump", "clumsily", "clumsy", "clunky", "clustered", "clutch", "clutter", "coach", "coagulant", "coastal", "coaster", "coasting", "coastland", "coastline", "coat", "coauthor", "cobalt", "cobbler", "cobweb", "cocoa", "coconut", "cod", "coeditor", "coerce", "coexist", "coffee", "cofounder", "cognition", "cognitive", "cogwheel", "coherence", "coherent", "cohesive", "coil", "coke", "cola", "cold", "coleslaw", "coliseum", "collage", "collapse", "collar", "collected", "collector", "collide", "collie", "collision", "colonial", "colonist", "colonize", "colony", "colossal", "colt", "coma", "come", "comfort", "comfy", "comic", "coming", "comma", "commence", "commend", "comment", "commerce", "commode", "commodity", "commodore", "common", "commotion", "commute", "commuting", "compacted", "compacter", "compactly", "compactor", "companion", "company", "compare", "compel", "compile", "comply", "component", "composed", "composer", "composite", "compost", "composure", "compound", "compress", "comprised", "computer", "computing", "comrade", "concave", "conceal", "conceded", "concept", "concerned", "concert", "conch", "concierge", "concise", "conclude", "concrete", "concur", "condense", "condiment", "condition", "condone", "conducive", "conductor", "conduit", "cone", "confess", "confetti", "confidant", "confident", "confider", "confiding", "configure", "confined", "confining", "confirm", "conflict", "conform", "confound", "confront", "confused", "confusing", "confusion", "congenial", "congested", "congrats", "congress", "conical", "conjoined", "conjure", "conjuror", "connected", "connector", "consensus", "consent", "console", "consoling", "consonant", "constable", "constant", "constrain", "constrict", "construct", "consult", "consumer", "consuming", "contact", "container", "contempt", "contend", "contented", "contently", "contents", "contest", "context", "contort", "contour", "contrite", "control", "contusion", "convene", "convent", "copartner", "cope", "copied", "copier", "copilot", "coping", "copious", "copper", "copy", "coral", "cork", "cornball", "cornbread", "corncob", "cornea", "corned", "corner", "cornfield", "cornflake", "cornhusk", "cornmeal", "cornstalk", "corny", "coronary", "coroner", "corporal", "corporate", "corral", "correct", "corridor", "corrode", "corroding", "corrosive", "corsage", "corset", "cortex", "cosigner", "cosmetics", "cosmic", "cosmos", "cosponsor", "cost", "cottage", "cotton", "couch", "cough", "could", "countable", "countdown", "counting", "countless", "country", "county", "courier", "covenant", "cover", "coveted", "coveting", "coyness", "cozily", "coziness", "cozy", "crabbing", "crabgrass", "crablike", "crabmeat", "cradle", "cradling", "crafter", "craftily", "craftsman", "craftwork", "crafty", "cramp", "cranberry", "crane", "cranial", "cranium", "crank", "crate", "crave", "craving", "crawfish", "crawlers", "crawling", "crayfish", "crayon", "crazed", "crazily", "craziness", "crazy", "creamed", "creamer", "creamlike", "crease", "creasing", "creatable", "create", "creation", "creative", "creature", "credible", "credibly", "credit", "creed", "creme", "creole", "crepe", "crept", "crescent", "crested", "cresting", "crestless", "crevice", "crewless", "crewman", "crewmate", "crib", "cricket", "cried", "crier", "crimp", "crimson", "cringe", "cringing", "crinkle", "crinkly", "crisped", "crisping", "crisply", "crispness", "crispy", "criteria", "critter", "croak", "crock", "crook", "croon", "crop", "cross", "crouch", "crouton", "crowbar", "crowd", "crown", "crucial", "crudely", "crudeness", "cruelly", "cruelness", "cruelty", "crumb", "crummiest", "crummy", "crumpet", "crumpled", "cruncher", "crunching", "crunchy", "crusader", "crushable", "crushed", "crusher", "crushing", "crust", "crux", "crying", "cryptic", "crystal", "cubbyhole", "cube", "cubical", "cubicle", "cucumber", "cuddle", "cuddly", "cufflink", "culinary", "culminate", "culpable", "culprit", "cultivate", "cultural", "culture", "cupbearer", "cupcake", "cupid", "cupped", "cupping", "curable", "curator", "curdle", "cure", "curfew", "curing", "curled", "curler", "curliness", "curling", "curly", "curry", "curse", "cursive", "cursor", "curtain", "curtly", "curtsy", "curvature", "curve", "curvy", "cushy", "cusp", "cussed", "custard", "custodian", "custody", "customary", "customer", "customize", "customs", "cut", "cycle", "cyclic", "cycling", "cyclist", "cylinder", "cymbal", "cytoplasm", "cytoplast", "dab", "dad", "daffodil", "dagger", "daily", "daintily", "dainty", "dairy", "daisy", "dallying", "dance", "dancing", "dandelion", "dander", "dandruff", "dandy", "danger", "dangle", "dangling", "daredevil", "dares", "daringly", "darkened", "darkening", "darkish", "darkness", "darkroom", "darling", "darn", "dart", "darwinism", "dash", "dastardly", "data", "datebook", "dating", "daughter", "daunting", "dawdler", "dawn", "daybed", "daybreak", "daycare", "daydream", "daylight", "daylong", "dayroom", "daytime", "dazzler", "dazzling", "deacon", "deafening", "deafness", "dealer", "dealing", "dealmaker", "dealt", "dean", "debatable", "debate", "debating", "debit", "debrief", "debtless", "debtor", "debug", "debunk", "decade", "decaf", "decal", "decathlon", "decay", "deceased", "deceit", "deceiver", "deceiving", "december", "decency", "decent", "deception", "deceptive", "decibel", "decidable", "decimal", "decimeter", "decipher", "deck", "declared", "decline", "decode", "decompose", "decorated", "decorator", "decoy", "decrease", "decree", "dedicate", "dedicator", "deduce", "deduct", "deed", "deem", "deepen", "deeply", "deepness", "deface", "defacing", "defame", "default", "defeat", "defection", "defective", "defendant", "defender", "defense", "defensive", "deferral", "deferred", "defiance", "defiant", "defile", "defiling", "define", "definite", "deflate", "deflation", "deflator", "deflected", "deflector", "defog", "deforest", "defraud", "defrost", "deftly", "defuse", "defy", "degraded", "degrading", "degrease", "degree", "dehydrate", "deity", "dejected", "delay", "delegate", "delegator", "delete", "deletion", "delicacy", "delicate", "delicious", "delighted", "delirious", "delirium", "deliverer", "delivery", "delouse", "delta", "deluge", "delusion", "deluxe", "demanding", "demeaning", "demeanor", "demise", "democracy", "democrat", "demote", "demotion", "demystify", "denatured", "deniable", "denial", "denim", "denote", "dense", "density", "dental", "dentist", "denture", "deny", "deodorant", "deodorize", "departed", "departure", "depict", "deplete", "depletion", "deplored", "deploy", "deport", "depose", "depraved", "depravity", "deprecate", "depress", "deprive", "depth", "deputize", "deputy", "derail", "deranged", "derby", "derived", "desecrate", "deserve", "deserving", "designate", "designed", "designer", "designing", "deskbound", "desktop", "deskwork", "desolate", "despair", "despise", "despite", "destiny", "destitute", "destruct", "detached", "detail", "detection", "detective", "detector", "detention", "detergent", "detest", "detonate", "detonator", "detoxify", "detract", "deuce", "devalue", "deviancy", "deviant", "deviate", "deviation", "deviator", "device", "devious", "devotedly", "devotee", "devotion", "devourer", "devouring", "devoutly", "dexterity", "dexterous", "diabetes", "diabetic", "diabolic", "diagnoses", "diagnosis", "diagram", "dial", "diameter", "diaper", "diaphragm", "diary", "dice", "dicing", "dictate", "dictation", "dictator", "difficult", "diffused", "diffuser", "diffusion", "diffusive", "dig", "dilation", "diligence", "diligent", "dill", "dilute", "dime", "diminish", "dimly", "dimmed", "dimmer", "dimness", "dimple", "diner", "dingbat", "dinghy", "dinginess", "dingo", "dingy", "dining", "dinner", "diocese", "dioxide", "diploma", "dipped", "dipper", "dipping", "directed", "direction", "directive", "directly", "directory", "direness", "dirtiness", "disabled", "disagree", "disallow", "disarm", "disarray", "disaster", "disband", "disbelief", "disburse", "discard", "discern", "discharge", "disclose", "discolor", "discount", "discourse", "discover", "discuss", "disdain", "disengage", "disfigure", "disgrace", "dish", "disinfect", "disjoin", "disk", "dislike", "disliking", "dislocate", "dislodge", "disloyal", "dismantle", "dismay", "dismiss", "dismount", "disobey", "disorder", "disown", "disparate", "disparity", "dispatch", "dispense", "dispersal", "dispersed", "disperser", "displace", "display", "displease", "disposal", "dispose", "disprove", "dispute", "disregard", "disrupt", "dissuade", "distance", "distant", "distaste", "distill", "distinct", "distort", "distract", "distress", "district", "distrust", "ditch", "ditto", "ditzy", "dividable", "divided", "dividend", "dividers", "dividing", "divinely", "diving", "divinity", "divisible", "divisibly", "division", "divisive", "divorcee", "dizziness", "dizzy", "doable", "docile", "dock", "doctrine", "document", "dodge", "dodgy", "doily", "doing", "dole", "dollar", "dollhouse", "dollop", "dolly", "dolphin", "domain", "domelike", "domestic", "dominion", "dominoes", "donated", "donation", "donator", "donor", "donut", "doodle", "doorbell", "doorframe", "doorknob", "doorman", "doormat", "doornail", "doorpost", "doorstep", "doorstop", "doorway", "doozy", "dork", "dormitory", "dorsal", "dosage", "dose", "dotted", "doubling", "douche", "dove", "down", "dowry", "doze", "drab", "dragging", "dragonfly", "dragonish", "dragster", "drainable", "drainage", "drained", "drainer", "drainpipe", "dramatic", "dramatize", "drank", "drapery", "drastic", "draw", "dreaded", "dreadful", "dreadlock", "dreamboat", "dreamily", "dreamland", "dreamless", "dreamlike", "dreamt", "dreamy", "drearily", "dreary", "drench", "dress", "drew", "dribble", "dried", "drier", "drift", "driller", "drilling", "drinkable", "drinking", "dripping", "drippy", "drivable", "driven", "driver", "driveway", "driving", "drizzle", "drizzly", "drone", "drool", "droop", "drop-down", "dropbox", "dropkick", "droplet", "dropout", "dropper", "drove", "drown", "drowsily", "drudge", "drum", "dry", "dubbed", "dubiously", "duchess", "duckbill", "ducking", "duckling", "ducktail", "ducky", "duct", "dude", "duffel", "dugout", "duh", "duke", "duller", "dullness", "duly", "dumping", "dumpling", "dumpster", "duo", "dupe", "duplex", "duplicate", "duplicity", "durable", "durably", "duration", "duress", "during", "dusk", "dust", "dutiful", "duty", "duvet", "dwarf", "dweeb", "dwelled", "dweller", "dwelling", "dwindle", "dwindling", "dynamic", "dynamite", "dynasty", "dyslexia", "dyslexic", "each", "eagle", "earache", "eardrum", "earflap", "earful", "earlobe", "early", "earmark", "earmuff", "earphone", "earpiece", "earplugs", "earring", "earshot", "earthen", "earthlike", "earthling", "earthly", "earthworm", "earthy", "earwig", "easeful", "easel", "easiest", "easily", "easiness", "easing", "eastbound", "eastcoast", "easter", "eastward", "eatable", "eaten", "eatery", "eating", "eats", "ebay", "ebony", "ebook", "ecard", "eccentric", "echo", "eclair", "eclipse", "ecologist", "ecology", "economic", "economist", "economy", "ecosphere", "ecosystem", "edge", "edginess", "edging", "edgy", "edition", "editor", "educated", "education", "educator", "eel", "effective", "effects", "efficient", "effort", "eggbeater", "egging", "eggnog", "eggplant", "eggshell", "egomaniac", "egotism", "egotistic", "either", "eject", "elaborate", "elastic", "elated", "elbow", "eldercare", "elderly", "eldest", "electable", "election", "elective", "elephant", "elevate", "elevating", "elevation", "elevator", "eleven", "elf", "eligible", "eligibly", "eliminate", "elite", "elitism", "elixir", "elk", "ellipse", "elliptic", "elm", "elongated", "elope", "eloquence", "eloquent", "elsewhere", "elude", "elusive", "elves", "email", "embargo", "embark", "embassy", "embattled", "embellish", "ember", "embezzle", "emblaze", "emblem", "embody", "embolism", "emboss", "embroider", "emcee", "emerald", "emergency", "emission", "emit", "emote", "emoticon", "emotion", "empathic", "empathy", "emperor", "emphases", "emphasis", "emphasize", "emphatic", "empirical", "employed", "employee", "employer", "emporium", "empower", "emptier", "emptiness", "empty", "emu", "enable", "enactment", "enamel", "enchanted", "enchilada", "encircle", "enclose", "enclosure", "encode", "encore", "encounter", "encourage", "encroach", "encrust", "encrypt", "endanger", "endeared", "endearing", "ended", "ending", "endless", "endnote", "endocrine", "endorphin", "endorse", "endowment", "endpoint", "endurable", "endurance", "enduring", "energetic", "energize", "energy", "enforced", "enforcer", "engaged", "engaging", "engine", "engorge", "engraved", "engraver", "engraving", "engross", "engulf", "enhance", "enigmatic", "enjoyable", "enjoyably", "enjoyer", "enjoying", "enjoyment", "enlarged", "enlarging", "enlighten", "enlisted", "enquirer", "enrage", "enrich", "enroll", "enslave", "ensnare", "ensure", "entail", "entangled", "entering", "entertain", "enticing", "entire", "entitle", "entity", "entomb", "entourage", "entrap", "entree", "entrench", "entrust", "entryway", "entwine", "enunciate", "envelope", "enviable", "enviably", "envious", "envision", "envoy", "envy", "enzyme", "epic", "epidemic", "epidermal", "epidermis", "epidural", "epilepsy", "epileptic", "epilogue", "epiphany", "episode", "equal", "equate", "equation", "equator", "equinox", "equipment", "equity", "equivocal", "eradicate", "erasable", "erased", "eraser", "erasure", "ergonomic", "errand", "errant", "erratic", "error", "erupt", "escalate", "escalator", "escapable", "escapade", "escapist", "escargot", "eskimo", "esophagus", "espionage", "espresso", "esquire", "essay", "essence", "essential", "establish", "estate", "esteemed", "estimate", "estimator", "estranged", "estrogen", "etching", "eternal", "eternity", "ethanol", "ether", "ethically", "ethics", "euphemism", "evacuate", "evacuee", "evade", "evaluate", "evaluator", "evaporate", "evasion", "evasive", "even", "everglade", "evergreen", "everybody", "everyday", "everyone", "evict", "evidence", "evident", "evil", "evoke", "evolution", "evolve", "exact", "exalted", "example", "excavate", "excavator", "exceeding", "exception", "excess", "exchange", "excitable", "exciting", "exclaim", "exclude", "excluding", "exclusion", "exclusive", "excretion", "excretory", "excursion", "excusable", "excusably", "excuse", "exemplary", "exemplify", "exemption", "exerciser", "exert", "exes", "exfoliate", "exhale", "exhaust", "exhume", "exile", "existing", "exit", "exodus", "exonerate", "exorcism", "exorcist", "expand", "expanse", "expansion", "expansive", "expectant", "expedited", "expediter", "expel", "expend", "expenses", "expensive", "expert", "expire", "expiring", "explain", "expletive", "explicit", "explode", "exploit", "explore", "exploring", "exponent", "exporter", "exposable", "expose", "exposure", "express", "expulsion", "exquisite", "extended", "extending", "extent", "extenuate", "exterior", "external", "extinct", "extortion", "extradite", "extras", "extrovert", "extrude", "extruding", "exuberant", "fable", "fabric", "fabulous", "facebook", "facecloth", "facedown", "faceless", "facelift", "faceplate", "faceted", "facial", "facility", "facing", "facsimile", "faction", "factoid", "factor", "factsheet", "factual", "faculty", "fade", "fading", "failing", "falcon", "fall", "false", "falsify", "fame", "familiar", "family", "famine", "famished", "fanatic", "fancied", "fanciness", "fancy", "fanfare", "fang", "fanning", "fantasize", "fantastic", "fantasy", "fascism", "fastball", "faster", "fasting", "fastness", "faucet", "favorable", "favorably", "favored", "favoring", "favorite", "fax", "feast", "federal", "fedora", "feeble", "feed", "feel", "feisty", "feline", "felt-tip", "feminine", "feminism", "feminist", "feminize", "femur", "fence", "fencing", "fender", "ferment", "fernlike", "ferocious", "ferocity", "ferret", "ferris", "ferry", "fervor", "fester", "festival", "festive", "festivity", "fetal", "fetch", "fever", "fiber", "fiction", "fiddle", "fiddling", "fidelity", "fidgeting", "fidgety", "fifteen", "fifth", "fiftieth", "fifty", "figment", "figure", "figurine", "filing", "filled", "filler", "filling", "film", "filter", "filth", "filtrate", "finale", "finalist", "finalize", "finally", "finance", "financial", "finch", "fineness", "finer", "finicky", "finished", "finisher", "finishing", "finite", "finless", "finlike", "fiscally", "fit", "five", "flaccid", "flagman", "flagpole", "flagship", "flagstick", "flagstone", "flail", "flakily", "flaky", "flame", "flammable", "flanked", "flanking", "flannels", "flap", "flaring", "flashback", "flashbulb", "flashcard", "flashily", "flashing", "flashy", "flask", "flatbed", "flatfoot", "flatly", "flatness", "flatten", "flattered", "flatterer", "flattery", "flattop", "flatware", "flatworm", "flavored", "flavorful", "flavoring", "flaxseed", "fled", "fleshed", "fleshy", "flick", "flier", "flight", "flinch", "fling", "flint", "flip", "flirt", "float", "flock", "flogging", "flop", "floral", "florist", "floss", "flounder", "flyable", "flyaway", "flyer", "flying", "flyover", "flypaper", "foam", "foe", "fog", "foil", "folic", "folk", "follicle", "follow", "fondling", "fondly", "fondness", "fondue", "font", "food", "fool", "footage", "football", "footbath", "footboard", "footer", "footgear", "foothill", "foothold", "footing", "footless", "footman", "footnote", "footpad", "footpath", "footprint", "footrest", "footsie", "footsore", "footwear", "footwork", "fossil", "foster", "founder", "founding", "fountain", "fox", "foyer", "fraction", "fracture", "fragile", "fragility", "fragment", "fragrance", "fragrant", "frail", "frame", "framing", "frantic", "fraternal", "frayed", "fraying", "frays", "freckled", "freckles", "freebase", "freebee", "freebie", "freedom", "freefall", "freehand", "freeing", "freeload", "freely", "freemason", "freeness", "freestyle", "freeware", "freeway", "freewill", "freezable", "freezing", "freight", "french", "frenzied", "frenzy", "frequency", "frequent", "fresh", "fretful", "fretted", "friction", "friday", "fridge", "fried", "friend", "frighten", "frightful", "frigidity", "frigidly", "frill", "fringe", "frisbee", "frisk", "fritter", "frivolous", "frolic", "from", "front", "frostbite", "frosted", "frostily", "frosting", "frostlike", "frosty", "froth", "frown", "frozen", "fructose", "frugality", "frugally", "fruit", "frustrate", "frying", "gab", "gaffe", "gag", "gainfully", "gaining", "gains", "gala", "gallantly", "galleria", "gallery", "galley", "gallon", "gallows", "gallstone", "galore", "galvanize", "gambling", "game", "gaming", "gamma", "gander", "gangly", "gangrene", "gangway", "gap", "garage", "garbage", "garden", "gargle", "garland", "garlic", "garment", "garnet", "garnish", "garter", "gas", "gatherer", "gathering", "gating", "gauging", "gauntlet", "gauze", "gave", "gawk", "gazing", "gear", "gecko", "geek", "geiger", "gem", "gender", "generic", "generous", "genetics", "genre", "gentile", "gentleman", "gently", "gents", "geography", "geologic", "geologist", "geology", "geometric", "geometry", "geranium", "gerbil", "geriatric", "germicide", "germinate", "germless", "germproof", "gestate", "gestation", "gesture", "getaway", "getting", "getup", "giant", "gibberish", "giblet", "giddily", "giddiness", "giddy", "gift", "gigabyte", "gigahertz", "gigantic", "giggle", "giggling", "giggly", "gigolo", "gilled", "gills", "gimmick", "girdle", "giveaway", "given", "giver", "giving", "gizmo", "gizzard", "glacial", "glacier", "glade", "gladiator", "gladly", "glamorous", "glamour", "glance", "glancing", "glandular", "glare", "glaring", "glass", "glaucoma", "glazing", "gleaming", "gleeful", "glider", "gliding", "glimmer", "glimpse", "glisten", "glitch", "glitter", "glitzy", "gloater", "gloating", "gloomily", "gloomy", "glorified", "glorifier", "glorify", "glorious", "glory", "gloss", "glove", "glowing", "glowworm", "glucose", "glue", "gluten", "glutinous", "glutton", "gnarly", "gnat", "goal", "goatskin", "goes", "goggles", "going", "goldfish", "goldmine", "goldsmith", "golf", "goliath", "gonad", "gondola", "gone", "gong", "good", "gooey", "goofball", "goofiness", "goofy", "google", "goon", "gopher", "gore", "gorged", "gorgeous", "gory", "gosling", "gossip", "gothic", "gotten", "gout", "gown", "grab", "graceful", "graceless", "gracious", "gradation", "graded", "grader", "gradient", "grading", "gradually", "graduate", "graffiti", "grafted", "grafting", "grain", "granddad", "grandkid", "grandly", "grandma", "grandpa", "grandson", "granite", "granny", "granola", "grant", "granular", "grape", "graph", "grapple", "grappling", "grasp", "grass", "gratified", "gratify", "grating", "gratitude", "gratuity", "gravel", "graveness", "graves", "graveyard", "gravitate", "gravity", "gravy", "gray", "grazing", "greasily", "greedily", "greedless", "greedy", "green", "greeter", "greeting", "grew", "greyhound", "grid", "grief", "grievance", "grieving", "grievous", "grill", "grimace", "grimacing", "grime", "griminess", "grimy", "grinch", "grinning", "grip", "gristle", "grit", "groggily", "groggy", "groin", "groom", "groove", "grooving", "groovy", "grope", "ground", "grouped", "grout", "grove", "grower", "growing", "growl", "grub", "grudge", "grudging", "grueling", "gruffly", "grumble", "grumbling", "grumbly", "grumpily", "grunge", "grunt", "guacamole", "guidable", "guidance", "guide", "guiding", "guileless", "guise", "gulf", "gullible", "gully", "gulp", "gumball", "gumdrop", "gumminess", "gumming", "gummy", "gurgle", "gurgling", "guru", "gush", "gusto", "gusty", "gutless", "guts", "gutter", "guy", "guzzler", "gyration", "habitable", "habitant", "habitat", "habitual", "hacked", "hacker", "hacking", "hacksaw", "had", "haggler", "haiku", "half", "halogen", "halt", "halved", "halves", "hamburger", "hamlet", "hammock", "hamper", "hamster", "hamstring", "handbag", "handball", "handbook", "handbrake", "handcart", "handclap", "handclasp", "handcraft", "handcuff", "handed", "handful", "handgrip", "handgun", "handheld", "handiness", "handiwork", "handlebar", "handled", "handler", "handling", "handmade", "handoff", "handpick", "handprint", "handrail", "handsaw", "handset", "handsfree", "handshake", "handstand", "handwash", "handwork", "handwoven", "handwrite", "handyman", "hangnail", "hangout", "hangover", "hangup", "hankering", "hankie", "hanky", "haphazard", "happening", "happier", "happiest", "happily", "happiness", "happy", "harbor", "hardcopy", "hardcore", "hardcover", "harddisk", "hardened", "hardener", "hardening", "hardhat", "hardhead", "hardiness", "hardly", "hardness", "hardship", "hardware", "hardwired", "hardwood", "hardy", "harmful", "harmless", "harmonica", "harmonics", "harmonize", "harmony", "harness", "harpist", "harsh", "harvest", "hash", "hassle", "haste", "hastily", "hastiness", "hasty", "hatbox", "hatchback", "hatchery", "hatchet", "hatching", "hatchling", "hate", "hatless", "hatred", "haunt", "haven", "hazard", "hazelnut", "hazily", "haziness", "hazing", "hazy", "headache", "headband", "headboard", "headcount", "headdress", "headed", "header", "headfirst", "headgear", "heading", "headlamp", "headless", "headlock", "headphone", "headpiece", "headrest", "headroom", "headscarf", "headset", "headsman", "headstand", "headstone", "headway", "headwear", "heap", "heat", "heave", "heavily", "heaviness", "heaving", "hedge", "hedging", "heftiness", "hefty", "helium", "helmet", "helper", "helpful", "helping", "helpless", "helpline", "hemlock", "hemstitch", "hence", "henchman", "henna", "herald", "herbal", "herbicide", "herbs", "heritage", "hermit", "heroics", "heroism", "herring", "herself", "hertz", "hesitancy", "hesitant", "hesitate", "hexagon", "hexagram", "hubcap", "huddle", "huddling", "huff", "hug", "hula", "hulk", "hull", "human", "humble", "humbling", "humbly", "humid", "humiliate", "humility", "humming", "hummus", "humongous", "humorist", "humorless", "humorous", "humpback", "humped", "humvee", "hunchback", "hundredth", "hunger", "hungrily", "hungry", "hunk", "hunter", "hunting", "huntress", "huntsman", "hurdle", "hurled", "hurler", "hurling", "hurray", "hurricane", "hurried", "hurry", "hurt", "husband", "hush", "husked", "huskiness", "hut", "hybrid", "hydrant", "hydrated", "hydration", "hydrogen", "hydroxide", "hyperlink", "hypertext", "hyphen", "hypnoses", "hypnosis", "hypnotic", "hypnotism", "hypnotist", "hypnotize", "hypocrisy", "hypocrite", "ibuprofen", "ice", "iciness", "icing", "icky", "icon", "icy", "idealism", "idealist", "idealize", "ideally", "idealness", "identical", "identify", "identity", "ideology", "idiocy", "idiom", "idly", "igloo", "ignition", "ignore", "iguana", "illicitly", "illusion", "illusive", "image", "imaginary", "imagines", "imaging", "imbecile", "imitate", "imitation", "immature", "immerse", "immersion", "imminent", "immobile", "immodest", "immorally", "immortal", "immovable", "immovably", "immunity", "immunize", "impaired", "impale", "impart", "impatient", "impeach", "impeding", "impending", "imperfect", "imperial", "impish", "implant", "implement", "implicate", "implicit", "implode", "implosion", "implosive", "imply", "impolite", "important", "importer", "impose", "imposing", "impotence", "impotency", "impotent", "impound", "imprecise", "imprint", "imprison", "impromptu", "improper", "improve", "improving", "improvise", "imprudent", "impulse", "impulsive", "impure", "impurity", "iodine", "iodize", "ion", "ipad", "iphone", "ipod", "irate", "irk", "iron", "irregular", "irrigate", "irritable", "irritably", "irritant", "irritate", "islamic", "islamist", "isolated", "isolating", "isolation", "isotope", "issue", "issuing", "italicize", "italics", "item", "itinerary", "itunes", "ivory", "ivy", "jab", "jackal", "jacket", "jackknife", "jackpot", "jailbird", "jailbreak", "jailer", "jailhouse", "jalapeno", "jam", "janitor", "january", "jargon", "jarring", "jasmine", "jaundice", "jaunt", "java", "jawed", "jawless", "jawline", "jaws", "jaybird", "jaywalker", "jazz", "jeep", "jeeringly", "jellied", "jelly", "jersey", "jester", "jet", "jiffy", "jigsaw", "jimmy", "jingle", "jingling", "jinx", "jitters", "jittery", "job", "jockey", "jockstrap", "jogger", "jogging", "john", "joining", "jokester", "jokingly", "jolliness", "jolly", "jolt", "jot", "jovial", "joyfully", "joylessly", "joyous", "joyride", "joystick", "jubilance", "jubilant", "judge", "judgingly", "judicial", "judiciary", "judo", "juggle", "juggling", "jugular", "juice", "juiciness", "juicy", "jujitsu", "jukebox", "july", "jumble", "jumbo", "jump", "junction", "juncture", "june", "junior", "juniper", "junkie", "junkman", "junkyard", "jurist", "juror", "jury", "justice", "justifier", "justify", "justly", "justness", "juvenile", "kabob", "kangaroo", "karaoke", "karate", "karma", "kebab", "keenly", "keenness", "keep", "keg", "kelp", "kennel", "kept", "kerchief", "kerosene", "kettle", "kick", "kiln", "kilobyte", "kilogram", "kilometer", "kilowatt", "kilt", "kimono", "kindle", "kindling", "kindly", "kindness", "kindred", "kinetic", "kinfolk", "king", "kinship", "kinsman", "kinswoman", "kissable", "kisser", "kissing", "kitchen", "kite", "kitten", "kitty", "kiwi", "kleenex", "knapsack", "knee", "knelt", "knickers", "knoll", "koala", "kooky", "kosher", "krypton", "kudos", "kung", "labored", "laborer", "laboring", "laborious", "labrador", "ladder", "ladies", "ladle", "ladybug", "ladylike", "lagged", "lagging", "lagoon", "lair", "lake", "lance", "landed", "landfall", "landfill", "landing", "landlady", "landless", "landline", "landlord", "landmark", "landmass", "landmine", "landowner", "landscape", "landside", "landslide", "language", "lankiness", "lanky", "lantern", "lapdog", "lapel", "lapped", "lapping", "laptop", "lard", "large", "lark", "lash", "lasso", "last", "latch", "late", "lather", "latitude", "latrine", "latter", "latticed", "launch", "launder", "laundry", "laurel", "lavender", "lavish", "laxative", "lazily", "laziness", "lazy", "lecturer", "left", "legacy", "legal", "legend", "legged", "leggings", "legible", "legibly", "legislate", "lego", "legroom", "legume", "legwarmer", "legwork", "lemon", "lend", "length", "lens", "lent", "leotard", "lesser", "letdown", "lethargic", "lethargy", "letter", "lettuce", "level", "leverage", "levers", "levitate", "levitator", "liability", "liable", "liberty", "librarian", "library", "licking", "licorice", "lid", "life", "lifter", "lifting", "liftoff", "ligament", "likely", "likeness", "likewise", "liking", "lilac", "lilly", "lily", "limb", "limeade", "limelight", "limes", "limit", "limping", "limpness", "line", "lingo", "linguini", "linguist", "lining", "linked", "linoleum", "linseed", "lint", "lion", "lip", "liquefy", "liqueur", "liquid", "lisp", "list", "litigate", "litigator", "litmus", "litter", "little", "livable", "lived", "lively", "liver", "livestock", "lividly", "living", "lizard", "lubricant", "lubricate", "lucid", "luckily", "luckiness", "luckless", "lucrative", "ludicrous", "lugged", "lukewarm", "lullaby", "lumber", "luminance", "luminous", "lumpiness", "lumping", "lumpish", "lunacy", "lunar", "lunchbox", "luncheon", "lunchroom", "lunchtime", "lung", "lurch", "lure", "luridness", "lurk", "lushly", "lushness", "luster", "lustfully", "lustily", "lustiness", "lustrous", "lusty", "luxurious", "luxury", "lying", "lyrically", "lyricism", "lyricist", "lyrics", "macarena", "macaroni", "macaw", "mace", "machine", "machinist", "magazine", "magenta", "maggot", "magical", "magician", "magma", "magnesium", "magnetic", "magnetism", "magnetize", "magnifier", "magnify", "magnitude", "magnolia", "mahogany", "maimed", "majestic", "majesty", "majorette", "majority", "makeover", "maker", "makeshift", "making", "malformed", "malt", "mama", "mammal", "mammary", "mammogram", "manager", "managing", "manatee", "mandarin", "mandate", "mandatory", "mandolin", "manger", "mangle", "mango", "mangy", "manhandle", "manhole", "manhood", "manhunt", "manicotti", "manicure", "manifesto", "manila", "mankind", "manlike", "manliness", "manly", "manmade", "manned", "mannish", "manor", "manpower", "mantis", "mantra", "manual", "many", "map", "marathon", "marauding", "marbled", "marbles", "marbling", "march", "mardi", "margarine", "margarita", "margin", "marigold", "marina", "marine", "marital", "maritime", "marlin", "marmalade", "maroon", "married", "marrow", "marry", "marshland", "marshy", "marsupial", "marvelous", "marxism", "mascot", "masculine", "mashed", "mashing", "massager", "masses", "massive", "mastiff", "matador", "matchbook", "matchbox", "matcher", "matching", "matchless", "material", "maternal", "maternity", "math", "mating", "matriarch", "matrimony", "matrix", "matron", "matted", "matter", "maturely", "maturing", "maturity", "mauve", "maverick", "maximize", "maximum", "maybe", "mayday", "mayflower", "moaner", "moaning", "mobile", "mobility", "mobilize", "mobster", "mocha", "mocker", "mockup", "modified", "modify", "modular", "modulator", "module", "moisten", "moistness", "moisture", "molar", "molasses", "mold", "molecular", "molecule", "molehill", "mollusk", "mom", "monastery", "monday", "monetary", "monetize", "moneybags", "moneyless", "moneywise", "mongoose", "mongrel", "monitor", "monkhood", "monogamy", "monogram", "monologue", "monopoly", "monorail", "monotone", "monotype", "monoxide", "monsieur", "monsoon", "monstrous", "monthly", "monument", "moocher", "moodiness", "moody", "mooing", "moonbeam", "mooned", "moonlight", "moonlike", "moonlit", "moonrise", "moonscape", "moonshine", "moonstone", "moonwalk", "mop", "morale", "morality", "morally", "morbidity", "morbidly", "morphine", "morphing", "morse", "mortality", "mortally", "mortician", "mortified", "mortify", "mortuary", "mosaic", "mossy", "most", "mothball", "mothproof", "motion", "motivate", "motivator", "motive", "motocross", "motor", "motto", "mountable", "mountain", "mounted", "mounting", "mourner", "mournful", "mouse", "mousiness", "moustache", "mousy", "mouth", "movable", "move", "movie", "moving", "mower", "mowing", "much", "muck", "mud", "mug", "mulberry", "mulch", "mule", "mulled", "mullets", "multiple", "multiply", "multitask", "multitude", "mumble", "mumbling", "mumbo", "mummified", "mummify", "mummy", "mumps", "munchkin", "mundane", "municipal", "muppet", "mural", "murkiness", "murky", "murmuring", "muscular", "museum", "mushily", "mushiness", "mushroom", "mushy", "music", "musket", "muskiness", "musky", "mustang", "mustard", "muster", "mustiness", "musty", "mutable", "mutate", "mutation", "mute", "mutilated", "mutilator", "mutiny", "mutt", "mutual", "muzzle", "myself", "myspace", "mystified", "mystify", "myth", "nacho", "nag", "nail", "name", "naming", "nanny", "nanometer", "nape", "napkin", "napped", "napping", "nappy", "narrow", "nastily", "nastiness", "national", "native", "nativity", "natural", "nature", "naturist", "nautical", "navigate", "navigator", "navy", "nearby", "nearest", "nearly", "nearness", "neatly", "neatness", "nebula", "nebulizer", "nectar", "negate", "negation", "negative", "neglector", "negligee", "negligent", "negotiate", "nemeses", "nemesis", "neon", "nephew", "nerd", "nervous", "nervy", "nest", "net", "neurology", "neuron", "neurosis", "neurotic", "neuter", "neutron", "never", "next", "nibble", "nickname", "nicotine", "niece", "nifty", "nimble", "nimbly", "nineteen", "ninetieth", "ninja", "nintendo", "ninth", "nuclear", "nuclei", "nucleus", "nugget", "nullify", "number", "numbing", "numbly", "numbness", "numeral", "numerate", "numerator", "numeric", "numerous", "nuptials", "nursery", "nursing", "nurture", "nutcase", "nutlike", "nutmeg", "nutrient", "nutshell", "nuttiness", "nutty", "nuzzle", "nylon", "oaf", "oak", "oasis", "oat", "obedience", "obedient", "obituary", "object", "obligate", "obliged", "oblivion", "oblivious", "oblong", "obnoxious", "oboe", "obscure", "obscurity", "observant", "observer", "observing", "obsessed", "obsession", "obsessive", "obsolete", "obstacle", "obstinate", "obstruct", "obtain", "obtrusive", "obtuse", "obvious", "occultist", "occupancy", "occupant", "occupier", "occupy", "ocean", "ocelot", "octagon", "octane", "october", "octopus", "ogle", "oil", "oink", "ointment", "okay", "old", "olive", "olympics", "omega", "omen", "ominous", "omission", "omit", "omnivore", "onboard", "oncoming", "ongoing", "onion", "online", "onlooker", "only", "onscreen", "onset", "onshore", "onslaught", "onstage", "onto", "onward", "onyx", "oops", "ooze", "oozy", "opacity", "opal", "open", "operable", "operate", "operating", "operation", "operative", "operator", "opium", "opossum", "opponent", "oppose", "opposing", "opposite", "oppressed", "oppressor", "opt", "opulently", "osmosis", "other", "otter", "ouch", "ought", "ounce", "outage", "outback", "outbid", "outboard", "outbound", "outbreak", "outburst", "outcast", "outclass", "outcome", "outdated", "outdoors", "outer", "outfield", "outfit", "outflank", "outgoing", "outgrow", "outhouse", "outing", "outlast", "outlet", "outline", "outlook", "outlying", "outmatch", "outmost", "outnumber", "outplayed", "outpost", "outpour", "output", "outrage", "outrank", "outreach", "outright", "outscore", "outsell", "outshine", "outshoot", "outsider", "outskirts", "outsmart", "outsource", "outspoken", "outtakes", "outthink", "outward", "outweigh", "outwit", "oval", "ovary", "oven", "overact", "overall", "overarch", "overbid", "overbill", "overbite", "overblown", "overboard", "overbook", "overbuilt", "overcast", "overcoat", "overcome", "overcook", "overcrowd", "overdraft", "overdrawn", "overdress", "overdrive", "overdue", "overeager", "overeater", "overexert", "overfed", "overfeed", "overfill", "overflow", "overfull", "overgrown", "overhand", "overhang", "overhaul", "overhead", "overhear", "overheat", "overhung", "overjoyed", "overkill", "overlabor", "overlaid", "overlap", "overlay", "overload", "overlook", "overlord", "overlying", "overnight", "overpass", "overpay", "overplant", "overplay", "overpower", "overprice", "overrate", "overreach", "overreact", "override", "overripe", "overrule", "overrun", "overshoot", "overshot", "oversight", "oversized", "oversleep", "oversold", "overspend", "overstate", "overstay", "overstep", "overstock", "overstuff", "oversweet", "overtake", "overthrow", "overtime", "overtly", "overtone", "overture", "overturn", "overuse", "overvalue", "overview", "overwrite", "owl", "oxford", "oxidant", "oxidation", "oxidize", "oxidizing", "oxygen", "oxymoron", "oyster", "ozone", "paced", "pacemaker", "pacific", "pacifier", "pacifism", "pacifist", "pacify", "padded", "padding", "paddle", "paddling", "padlock", "pagan", "pager", "paging", "pajamas", "palace", "palatable", "palm", "palpable", "palpitate", "paltry", "pampered", "pamperer", "pampers", "pamphlet", "panama", "pancake", "pancreas", "panda", "pandemic", "pang", "panhandle", "panic", "panning", "panorama", "panoramic", "panther", "pantomime", "pantry", "pants", "pantyhose", "paparazzi", "papaya", "paper", "paprika", "papyrus", "parabola", "parachute", "parade", "paradox", "paragraph", "parakeet", "paralegal", "paralyses", "paralysis", "paralyze", "paramedic", "parameter", "paramount", "parasail", "parasite", "parasitic", "parcel", "parched", "parchment", "pardon", "parish", "parka", "parking", "parkway", "parlor", "parmesan", "parole", "parrot", "parsley", "parsnip", "partake", "parted", "parting", "partition", "partly", "partner", "partridge", "party", "passable", "passably", "passage", "passcode", "passenger", "passerby", "passing", "passion", "passive", "passivism", "passover", "passport", "password", "pasta", "pasted", "pastel", "pastime", "pastor", "pastrami", "pasture", "pasty", "patchwork", "patchy", "paternal", "paternity", "path", "patience", "patient", "patio", "patriarch", "patriot", "patrol", "patronage", "patronize", "pauper", "pavement", "paver", "pavestone", "pavilion", "paving", "pawing", "payable", "payback", "paycheck", "payday", "payee", "payer", "paying", "payment", "payphone", "payroll", "pebble", "pebbly", "pecan", "pectin", "peculiar", "peddling", "pediatric", "pedicure", "pedigree", "pedometer", "pegboard", "pelican", "pellet", "pelt", "pelvis", "penalize", "penalty", "pencil", "pendant", "pending", "penholder", "penknife", "pennant", "penniless", "penny", "penpal", "pension", "pentagon", "pentagram", "pep", "perceive", "percent", "perch", "percolate", "perennial", "perfected", "perfectly", "perfume", "periscope", "perish", "perjurer", "perjury", "perkiness", "perky", "perm", "peroxide", "perpetual", "perplexed", "persecute", "persevere", "persuaded", "persuader", "pesky", "peso", "pessimism", "pessimist", "pester", "pesticide", "petal", "petite", "petition", "petri", "petroleum", "petted", "petticoat", "pettiness", "petty", "petunia", "phantom", "phobia", "phoenix", "phonebook", "phoney", "phonics", "phoniness", "phony", "phosphate", "photo", "phrase", "phrasing", "placard", "placate", "placidly", "plank", "planner", "plant", "plasma", "plaster", "plastic", "plated", "platform", "plating", "platinum", "platonic", "platter", "platypus", "plausible", "plausibly", "playable", "playback", "player", "playful", "playgroup", "playhouse", "playing", "playlist", "playmaker", "playmate", "playoff", "playpen", "playroom", "playset", "plaything", "playtime", "plaza", "pleading", "pleat", "pledge", "plentiful", "plenty", "plethora", "plexiglas", "pliable", "plod", "plop", "plot", "plow", "ploy", "pluck", "plug", "plunder", "plunging", "plural", "plus", "plutonium", "plywood", "poach", "pod", "poem", "poet", "pogo", "pointed", "pointer", "pointing", "pointless", "pointy", "poise", "poison", "poker", "poking", "polar", "police", "policy", "polio", "polish", "politely", "polka", "polo", "polyester", "polygon", "polygraph", "polymer", "poncho", "pond", "pony", "popcorn", "pope", "poplar", "popper", "poppy", "popsicle", "populace", "popular", "populate", "porcupine", "pork", "porous", "porridge", "portable", "portal", "portfolio", "porthole", "portion", "portly", "portside", "poser", "posh", "posing", "possible", "possibly", "possum", "postage", "postal", "postbox", "postcard", "posted", "poster", "posting", "postnasal", "posture", "postwar", "pouch", "pounce", "pouncing", "pound", "pouring", "pout", "powdered", "powdering", "powdery", "power", "powwow", "pox", "praising", "prance", "prancing", "pranker", "prankish", "prankster", "prayer", "praying", "preacher", "preaching", "preachy", "preamble", "precinct", "precise", "precision", "precook", "precut", "predator", "predefine", "predict", "preface", "prefix", "preflight", "preformed", "pregame", "pregnancy", "pregnant", "preheated", "prelaunch", "prelaw", "prelude", "premiere", "premises", "premium", "prenatal", "preoccupy", "preorder", "prepaid", "prepay", "preplan", "preppy", "preschool", "prescribe", "preseason", "preset", "preshow", "president", "presoak", "press", "presume", "presuming", "preteen", "pretended", "pretender", "pretense", "pretext", "pretty", "pretzel", "prevail", "prevalent", "prevent", "preview", "previous", "prewar", "prewashed", "prideful", "pried", "primal", "primarily", "primary", "primate", "primer", "primp", "princess", "print", "prior", "prism", "prison", "prissy", "pristine", "privacy", "private", "privatize", "prize", "proactive", "probable", "probably", "probation", "probe", "probing", "probiotic", "problem", "procedure", "process", "proclaim", "procreate", "procurer", "prodigal", "prodigy", "produce", "product", "profane", "profanity", "professed", "professor", "profile", "profound", "profusely", "progeny", "prognosis", "program", "progress", "projector", "prologue", "prolonged", "promenade", "prominent", "promoter", "promotion", "prompter", "promptly", "prone", "prong", "pronounce", "pronto", "proofing", "proofread", "proofs", "propeller", "properly", "property", "proponent", "proposal", "propose", "props", "prorate", "protector", "protegee", "proton", "prototype", "protozoan", "protract", "protrude", "proud", "provable", "proved", "proven", "provided", "provider", "providing", "province", "proving", "provoke", "provoking", "provolone", "prowess", "prowler", "prowling", "proximity", "proxy", "prozac", "prude", "prudishly", "prune", "pruning", "pry", "psychic", "public", "publisher", "pucker", "pueblo", "pug", "pull", "pulmonary", "pulp", "pulsate", "pulse", "pulverize", "puma", "pumice", "pummel", "punch", "punctual", "punctuate", "punctured", "pungent", "punisher", "punk", "pupil", "puppet", "puppy", "purchase", "pureblood", "purebred", "purely", "pureness", "purgatory", "purge", "purging", "purifier", "purify", "purist", "puritan", "purity", "purple", "purplish", "purposely", "purr", "purse", "pursuable", "pursuant", "pursuit", "purveyor", "pushcart", "pushchair", "pusher", "pushiness", "pushing", "pushover", "pushpin", "pushup", "pushy", "putdown", "putt", "puzzle", "puzzling", "pyramid", "pyromania", "python", "quack", "quadrant", "quail", "quaintly", "quake", "quaking", "qualified", "qualifier", "qualify", "quality", "qualm", "quantum", "quarrel", "quarry", "quartered", "quarterly", "quarters", "quartet", "quench", "query", "quicken", "quickly", "quickness", "quicksand", "quickstep", "quiet", "quill", "quilt", "quintet", "quintuple", "quirk", "quit", "quiver", "quizzical", "quotable", "quotation", "quote", "rabid", "race", "racing", "racism", "rack", "racoon", "radar", "radial", "radiance", "radiantly", "radiated", "radiation", "radiator", "radio", "radish", "raffle", "raft", "rage", "ragged", "raging", "ragweed", "raider", "railcar", "railing", "railroad", "railway", "raisin", "rake", "raking", "rally", "ramble", "rambling", "ramp", "ramrod", "ranch", "rancidity", "random", "ranged", "ranger", "ranging", "ranked", "ranking", "ransack", "ranting", "rants", "rare", "rarity", "rascal", "rash", "rasping", "ravage", "raven", "ravine", "raving", "ravioli", "ravishing", "reabsorb", "reach", "reacquire", "reaction", "reactive", "reactor", "reaffirm", "ream", "reanalyze", "reappear", "reapply", "reappoint", "reapprove", "rearrange", "rearview", "reason", "reassign", "reassure", "reattach", "reawake", "rebalance", "rebate", "rebel", "rebirth", "reboot", "reborn", "rebound", "rebuff", "rebuild", "rebuilt", "reburial", "rebuttal", "recall", "recant", "recapture", "recast", "recede", "recent", "recess", "recharger", "recipient", "recital", "recite", "reckless", "reclaim", "recliner", "reclining", "recluse", "reclusive", "recognize", "recoil", "recollect", "recolor", "reconcile", "reconfirm", "reconvene", "recopy", "record", "recount", "recoup", "recovery", "recreate", "rectal", "rectangle", "rectified", "rectify", "recycled", "recycler", "recycling", "reemerge", "reenact", "reenter", "reentry", "reexamine", "referable", "referee", "reference", "refill", "refinance", "refined", "refinery", "refining", "refinish", "reflected", "reflector", "reflex", "reflux", "refocus", "refold", "reforest", "reformat", "reformed", "reformer", "reformist", "refract", "refrain", "refreeze", "refresh", "refried", "refueling", "refund", "refurbish", "refurnish", "refusal", "refuse", "refusing", "refutable", "refute", "regain", "regalia", "regally", "reggae", "regime", "region", "register", "registrar", "registry", "regress", "regretful", "regroup", "regular", "regulate", "regulator", "rehab", "reheat", "rehire", "rehydrate", "reimburse", "reissue", "reiterate", "rejoice", "rejoicing", "rejoin", "rekindle", "relapse", "relapsing", "relatable", "related", "relation", "relative", "relax", "relay", "relearn", "release", "relenting", "reliable", "reliably", "reliance", "reliant", "relic", "relieve", "relieving", "relight", "relish", "relive", "reload", "relocate", "relock", "reluctant", "rely", "remake", "remark", "remarry", "rematch", "remedial", "remedy", "remember", "reminder", "remindful", "remission", "remix", "remnant", "remodeler", "remold", "remorse", "remote", "removable", "removal", "removed", "remover", "removing", "rename", "renderer", "rendering", "rendition", "renegade", "renewable", "renewably", "renewal", "renewed", "renounce", "renovate", "renovator", "rentable", "rental", "rented", "renter", "reoccupy", "reoccur", "reopen", "reorder", "repackage", "repacking", "repaint", "repair", "repave", "repaying", "repayment", "repeal", "repeated", "repeater", "repent", "rephrase", "replace", "replay", "replica", "reply", "reporter", "repose", "repossess", "repost", "repressed", "reprimand", "reprint", "reprise", "reproach", "reprocess", "reproduce", "reprogram", "reps", "reptile", "reptilian", "repugnant", "repulsion", "repulsive", "repurpose", "reputable", "reputably", "request", "require", "requisite", "reroute", "rerun", "resale", "resample", "rescuer", "reseal", "research", "reselect", "reseller", "resemble", "resend", "resent", "reset", "reshape", "reshoot", "reshuffle", "residence", "residency", "resident", "residual", "residue", "resigned", "resilient", "resistant", "resisting", "resize", "resolute", "resolved", "resonant", "resonate", "resort", "resource", "respect", "resubmit", "result", "resume", "resupply", "resurface", "resurrect", "retail", "retainer", "retaining", "retake", "retaliate", "retention", "rethink", "retinal", "retired", "retiree", "retiring", "retold", "retool", "retorted", "retouch", "retrace", "retract", "retrain", "retread", "retreat", "retrial", "retrieval", "retriever", "retry", "return", "retying", "retype", "reunion", "reunite", "reusable", "reuse", "reveal", "reveler", "revenge", "revenue", "reverb", "revered", "reverence", "reverend", "reversal", "reverse", "reversing", "reversion", "revert", "revisable", "revise", "revision", "revisit", "revivable", "revival", "reviver", "reviving", "revocable", "revoke", "revolt", "revolver", "revolving", "reward", "rewash", "rewind", "rewire", "reword", "rework", "rewrap", "rewrite", "rhyme", "ribbon", "ribcage", "rice", "riches", "richly", "richness", "rickety", "ricotta", "riddance", "ridden", "ride", "riding", "rifling", "rift", "rigging", "rigid", "rigor", "rimless", "rimmed", "rind", "rink", "rinse", "rinsing", "riot", "ripcord", "ripeness", "ripening", "ripping", "ripple", "rippling", "riptide", "rise", "rising", "risk", "risotto", "ritalin", "ritzy", "rival", "riverbank", "riverbed", "riverboat", "riverside", "riveter", "riveting", "roamer", "roaming", "roast", "robbing", "robe", "robin", "robotics", "robust", "rockband", "rocker", "rocket", "rockfish", "rockiness", "rocking", "rocklike", "rockslide", "rockstar", "rocky", "rogue", "roman", "romp", "rope", "roping", "roster", "rosy", "rotten", "rotting", "rotunda", "roulette", "rounding", "roundish", "roundness", "roundup", "roundworm", "routine", "routing", "rover", "roving", "royal", "rubbed", "rubber", "rubbing", "rubble", "rubdown", "ruby", "ruckus", "rudder", "rug", "ruined", "rule", "rumble", "rumbling", "rummage", "rumor", "runaround", "rundown", "runner", "running", "runny", "runt", "runway", "rupture", "rural", "ruse", "rush", "rust", "rut", "sabbath", "sabotage", "sacrament", "sacred", "sacrifice", "sadden", "saddlebag", "saddled", "saddling", "sadly", "sadness", "safari", "safeguard", "safehouse", "safely", "safeness", "saffron", "saga", "sage", "sagging", "saggy", "said", "saint", "sake", "salad", "salami", "salaried", "salary", "saline", "salon", "saloon", "salsa", "salt", "salutary", "salute", "salvage", "salvaging", "salvation", "same", "sample", "sampling", "sanction", "sanctity", "sanctuary", "sandal", "sandbag", "sandbank", "sandbar", "sandblast", "sandbox", "sanded", "sandfish", "sanding", "sandlot", "sandpaper", "sandpit", "sandstone", "sandstorm", "sandworm", "sandy", "sanitary", "sanitizer", "sank", "santa", "sapling", "sappiness", "sappy", "sarcasm", "sarcastic", "sardine", "sash", "sasquatch", "sassy", "satchel", "satiable", "satin", "satirical", "satisfied", "satisfy", "saturate", "saturday", "sauciness", "saucy", "sauna", "savage", "savanna", "saved", "savings", "savior", "savor", "saxophone", "say", "scabbed", "scabby", "scalded", "scalding", "scale", "scaling", "scallion", "scallop", "scalping", "scam", "scandal", "scanner", "scanning", "scant", "scapegoat", "scarce", "scarcity", "scarecrow", "scared", "scarf", "scarily", "scariness", "scarring", "scary", "scavenger", "scenic", "schedule", "schematic", "scheme", "scheming", "schilling", "schnapps", "scholar", "science", "scientist", "scion", "scoff", "scolding", "scone", "scoop", "scooter", "scope", "scorch", "scorebook", "scorecard", "scored", "scoreless", "scorer", "scoring", "scorn", "scorpion", "scotch", "scoundrel", "scoured", "scouring", "scouting", "scouts", "scowling", "scrabble", "scraggly", "scrambled", "scrambler", "scrap", "scratch", "scrawny", "screen", "scribble", "scribe", "scribing", "scrimmage", "script", "scroll", "scrooge", "scrounger", "scrubbed", "scrubber", "scruffy", "scrunch", "scrutiny", "scuba", "scuff", "sculptor", "sculpture", "scurvy", "scuttle", "secluded", "secluding", "seclusion", "second", "secrecy", "secret", "sectional", "sector", "secular", "securely", "security", "sedan", "sedate", "sedation", "sedative", "sediment", "seduce", "seducing", "segment", "seismic", "seizing", "seldom", "selected", "selection", "selective", "selector", "self", "seltzer", "semantic", "semester", "semicolon", "semifinal", "seminar", "semisoft", "semisweet", "senate", "senator", "send", "senior", "senorita", "sensation", "sensitive", "sensitize", "sensually", "sensuous", "sepia", "september", "septic", "septum", "sequel", "sequence", "sequester", "series", "sermon", "serotonin", "serpent", "serrated", "serve", "service", "serving", "sesame", "sessions", "setback", "setting", "settle", "settling", "setup", "sevenfold", "seventeen", "seventh", "seventy", "severity", "shabby", "shack", "shaded", "shadily", "shadiness", "shading", "shadow", "shady", "shaft", "shakable", "shakily", "shakiness", "shaking", "shaky", "shale", "shallot", "shallow", "shame", "shampoo", "shamrock", "shank", "shanty", "shape", "shaping", "share", "sharpener", "sharper", "sharpie", "sharply", "sharpness", "shawl", "sheath", "shed", "sheep", "sheet", "shelf", "shell", "shelter", "shelve", "shelving", "sherry", "shield", "shifter", "shifting", "shiftless", "shifty", "shimmer", "shimmy", "shindig", "shine", "shingle", "shininess", "shining", "shiny", "ship", "shirt", "shivering", "shock", "shone", "shoplift", "shopper", "shopping", "shoptalk", "shore", "shortage", "shortcake", "shortcut", "shorten", "shorter", "shorthand", "shortlist", "shortly", "shortness", "shorts", "shortwave", "shorty", "shout", "shove", "showbiz", "showcase", "showdown", "shower", "showgirl", "showing", "showman", "shown", "showoff", "showpiece", "showplace", "showroom", "showy", "shrank", "shrapnel", "shredder", "shredding", "shrewdly", "shriek", "shrill", "shrimp", "shrine", "shrink", "shrivel", "shrouded", "shrubbery", "shrubs", "shrug", "shrunk", "shucking", "shudder", "shuffle", "shuffling", "shun", "shush", "shut", "shy", "siamese", "siberian", "sibling", "siding", "sierra", "siesta", "sift", "sighing", "silenced", "silencer", "silent", "silica", "silicon", "silk", "silliness", "silly", "silo", "silt", "silver", "similarly", "simile", "simmering", "simple", "simplify", "simply", "sincere", "sincerity", "singer", "singing", "single", "singular", "sinister", "sinless", "sinner", "sinuous", "sip", "siren", "sister", "sitcom", "sitter", "sitting", "situated", "situation", "sixfold", "sixteen", "sixth", "sixties", "sixtieth", "sixtyfold", "sizable", "sizably", "size", "sizing", "sizzle", "sizzling", "skater", "skating", "skedaddle", "skeletal", "skeleton", "skeptic", "sketch", "skewed", "skewer", "skid", "skied", "skier", "skies", "skiing", "skilled", "skillet", "skillful", "skimmed", "skimmer", "skimming", "skimpily", "skincare", "skinhead", "skinless", "skinning", "skinny", "skintight", "skipper", "skipping", "skirmish", "skirt", "skittle", "skydiver", "skylight", "skyline", "skype", "skyrocket", "skyward", "slab", "slacked", "slacker", "slacking", "slackness", "slacks", "slain", "slam", "slander", "slang", "slapping", "slapstick", "slashed", "slashing", "slate", "slather", "slaw", "sled", "sleek", "sleep", "sleet", "sleeve", "slept", "sliceable", "sliced", "slicer", "slicing", "slick", "slider", "slideshow", "sliding", "slighted", "slighting", "slightly", "slimness", "slimy", "slinging", "slingshot", "slinky", "slip", "slit", "sliver", "slobbery", "slogan", "sloped", "sloping", "sloppily", "sloppy", "slot", "slouching", "slouchy", "sludge", "slug", "slum", "slurp", "slush", "sly", "small", "smartly", "smartness", "smasher", "smashing", "smashup", "smell", "smelting", "smile", "smilingly", "smirk", "smite", "smith", "smitten", "smock", "smog", "smoked", "smokeless", "smokiness", "smoking", "smoky", "smolder", "smooth", "smother", "smudge", "smudgy", "smuggler", "smuggling", "smugly", "smugness", "snack", "snagged", "snaking", "snap", "snare", "snarl", "snazzy", "sneak", "sneer", "sneeze", "sneezing", "snide", "sniff", "snippet", "snipping", "snitch", "snooper", "snooze", "snore", "snoring", "snorkel", "snort", "snout", "snowbird", "snowboard", "snowbound", "snowcap", "snowdrift", "snowdrop", "snowfall", "snowfield", "snowflake", "snowiness", "snowless", "snowman", "snowplow", "snowshoe", "snowstorm", "snowsuit", "snowy", "snub", "snuff", "snuggle", "snugly", "snugness", "speak", "spearfish", "spearhead", "spearman", "spearmint", "species", "specimen", "specked", "speckled", "specks", "spectacle", "spectator", "spectrum", "speculate", "speech", "speed", "spellbind", "speller", "spelling", "spendable", "spender", "spending", "spent", "spew", "sphere", "spherical", "sphinx", "spider", "spied", "spiffy", "spill", "spilt", "spinach", "spinal", "spindle", "spinner", "spinning", "spinout", "spinster", "spiny", "spiral", "spirited", "spiritism", "spirits", "spiritual", "splashed", "splashing", "splashy", "splatter", "spleen", "splendid", "splendor", "splice", "splicing", "splinter", "splotchy", "splurge", "spoilage", "spoiled", "spoiler", "spoiling", "spoils", "spoken", "spokesman", "sponge", "spongy", "sponsor", "spoof", "spookily", "spooky", "spool", "spoon", "spore", "sporting", "sports", "sporty", "spotless", "spotlight", "spotted", "spotter", "spotting", "spotty", "spousal", "spouse", "spout", "sprain", "sprang", "sprawl", "spray", "spree", "sprig", "spring", "sprinkled", "sprinkler", "sprint", "sprite", "sprout", "spruce", "sprung", "spry", "spud", "spur", "sputter", "spyglass", "squabble", "squad", "squall", "squander", "squash", "squatted", "squatter", "squatting", "squeak", "squealer", "squealing", "squeamish", "squeegee", "squeeze", "squeezing", "squid", "squiggle", "squiggly", "squint", "squire", "squirt", "squishier", "squishy", "stability", "stabilize", "stable", "stack", "stadium", "staff", "stage", "staging", "stagnant", "stagnate", "stainable", "stained", "staining", "stainless", "stalemate", "staleness", "stalling", "stallion", "stamina", "stammer", "stamp", "stand", "stank", "staple", "stapling", "starboard", "starch", "stardom", "stardust", "starfish", "stargazer", "staring", "stark", "starless", "starlet", "starlight", "starlit", "starring", "starry", "starship", "starter", "starting", "startle", "startling", "startup", "starved", "starving", "stash", "state", "static", "statistic", "statue", "stature", "status", "statute", "statutory", "staunch", "stays", "steadfast", "steadier", "steadily", "steadying", "steam", "steed", "steep", "steerable", "steering", "steersman", "stegosaur", "stellar", "stem", "stench", "stencil", "step", "stereo", "sterile", "sterility", "sterilize", "sterling", "sternness", "sternum", "stew", "stick", "stiffen", "stiffly", "stiffness", "stifle", "stifling", "stillness", "stilt", "stimulant", "stimulate", "stimuli", "stimulus", "stinger", "stingily", "stinging", "stingray", "stingy", "stinking", "stinky", "stipend", "stipulate", "stir", "stitch", "stock", "stoic", "stoke", "stole", "stomp", "stonewall", "stoneware", "stonework", "stoning", "stony", "stood", "stooge", "stool", "stoop", "stoplight", "stoppable", "stoppage", "stopped", "stopper", "stopping", "stopwatch", "storable", "storage", "storeroom", "storewide", "storm", "stout", "stove", "stowaway", "stowing", "straddle", "straggler", "strained", "strainer", "straining", "strangely", "stranger", "strangle", "strategic", "strategy", "stratus", "straw", "stray", "streak", "stream", "street", "strength", "strenuous", "strep", "stress", "stretch", "strewn", "stricken", "strict", "stride", "strife", "strike", "striking", "strive", "striving", "strobe", "strode", "stroller", "strongbox", "strongly", "strongman", "struck", "structure", "strudel", "struggle", "strum", "strung", "strut", "stubbed", "stubble", "stubbly", "stubborn", "stucco", "stuck", "student", "studied", "studio", "study", "stuffed", "stuffing", "stuffy", "stumble", "stumbling", "stump", "stung", "stunned", "stunner", "stunning", "stunt", "stupor", "sturdily", "sturdy", "styling", "stylishly", "stylist", "stylized", "stylus", "suave", "subarctic", "subatomic", "subdivide", "subdued", "subduing", "subfloor", "subgroup", "subheader", "subject", "sublease", "sublet", "sublevel", "sublime", "submarine", "submerge", "submersed", "submitter", "subpanel", "subpar", "subplot", "subprime", "subscribe", "subscript", "subsector", "subside", "subsiding", "subsidize", "subsidy", "subsoil", "subsonic", "substance", "subsystem", "subtext", "subtitle", "subtly", "subtotal", "subtract", "subtype", "suburb", "subway", "subwoofer", "subzero", "succulent", "such", "suction", "sudden", "sudoku", "suds", "sufferer", "suffering", "suffice", "suffix", "suffocate", "suffrage", "sugar", "suggest", "suing", "suitable", "suitably", "suitcase", "suitor", "sulfate", "sulfide", "sulfite", "sulfur", "sulk", "sullen", "sulphate", "sulphuric", "sultry", "superbowl", "superglue", "superhero", "superior", "superjet", "superman", "supermom", "supernova", "supervise", "supper", "supplier", "supply", "support", "supremacy", "supreme", "surcharge", "surely", "sureness", "surface", "surfacing", "surfboard", "surfer", "surgery", "surgical", "surging", "surname", "surpass", "surplus", "surprise", "surreal", "surrender", "surrogate", "surround", "survey", "survival", "survive", "surviving", "survivor", "sushi", "suspect", "suspend", "suspense", "sustained", "sustainer", "swab", "swaddling", "swagger", "swampland", "swan", "swapping", "swarm", "sway", "swear", "sweat", "sweep", "swell", "swept", "swerve", "swifter", "swiftly", "swiftness", "swimmable", "swimmer", "swimming", "swimsuit", "swimwear", "swinger", "swinging", "swipe", "swirl", "switch", "swivel", "swizzle", "swooned", "swoop", "swoosh", "swore", "sworn", "swung", "sycamore", "sympathy", "symphonic", "symphony", "symptom", "synapse", "syndrome", "synergy", "synopses", "synopsis", "synthesis", "synthetic", "syrup", "system", "t-shirt", "tabasco", "tabby", "tableful", "tables", "tablet", "tableware", "tabloid", "tackiness", "tacking", "tackle", "tackling", "tacky", "taco", "tactful", "tactical", "tactics", "tactile", "tactless", "tadpole", "taekwondo", "tag", "tainted", "take", "taking", "talcum", "talisman", "tall", "talon", "tamale", "tameness", "tamer", "tamper", "tank", "tanned", "tannery", "tanning", "tantrum", "tapeless", "tapered", "tapering", "tapestry", "tapioca", "tapping", "taps", "tarantula", "target", "tarmac", "tarnish", "tarot", "tartar", "tartly", "tartness", "task", "tassel", "taste", "tastiness", "tasting", "tasty", "tattered", "tattle", "tattling", "tattoo", "taunt", "tavern", "thank", "that", "thaw", "theater", "theatrics", "thee", "theft", "theme", "theology", "theorize", "thermal", "thermos", "thesaurus", "these", "thesis", "thespian", "thicken", "thicket", "thickness", "thieving", "thievish", "thigh", "thimble", "thing", "think", "thinly", "thinner", "thinness", "thinning", "thirstily", "thirsting", "thirsty", "thirteen", "thirty", "thong", "thorn", "those", "thousand", "thrash", "thread", "threaten", "threefold", "thrift", "thrill", "thrive", "thriving", "throat", "throbbing", "throng", "throttle", "throwaway", "throwback", "thrower", "throwing", "thud", "thumb", "thumping", "thursday", "thus", "thwarting", "thyself", "tiara", "tibia", "tidal", "tidbit", "tidiness", "tidings", "tidy", "tiger", "tighten", "tightly", "tightness", "tightrope", "tightwad", "tigress", "tile", "tiling", "till", "tilt", "timid", "timing", "timothy", "tinderbox", "tinfoil", "tingle", "tingling", "tingly", "tinker", "tinkling", "tinsel", "tinsmith", "tint", "tinwork", "tiny", "tipoff", "tipped", "tipper", "tipping", "tiptoeing", "tiptop", "tiring", "tissue", "trace", "tracing", "track", "traction", "tractor", "trade", "trading", "tradition", "traffic", "tragedy", "trailing", "trailside", "train", "traitor", "trance", "tranquil", "transfer", "transform", "translate", "transpire", "transport", "transpose", "trapdoor", "trapeze", "trapezoid", "trapped", "trapper", "trapping", "traps", "trash", "travel", "traverse", "travesty", "tray", "treachery", "treading", "treadmill", "treason", "treat", "treble", "tree", "trekker", "tremble", "trembling", "tremor", "trench", "trend", "trespass", "triage", "trial", "triangle", "tribesman", "tribunal", "tribune", "tributary", "tribute", "triceps", "trickery", "trickily", "tricking", "trickle", "trickster", "tricky", "tricolor", "tricycle", "trident", "tried", "trifle", "trifocals", "trillion", "trilogy", "trimester", "trimmer", "trimming", "trimness", "trinity", "trio", "tripod", "tripping", "triumph", "trivial", "trodden", "trolling", "trombone", "trophy", "tropical", "tropics", "trouble", "troubling", "trough", "trousers", "trout", "trowel", "truce", "truck", "truffle", "trump", "trunks", "trustable", "trustee", "trustful", "trusting", "trustless", "truth", "try", "tubby", "tubeless", "tubular", "tucking", "tuesday", "tug", "tuition", "tulip", "tumble", "tumbling", "tummy", "turban", "turbine", "turbofan", "turbojet", "turbulent", "turf", "turkey", "turmoil", "turret", "turtle", "tusk", "tutor", "tutu", "tux", "tweak", "tweed", "tweet", "tweezers", "twelve", "twentieth", "twenty", "twerp", "twice", "twiddle", "twiddling", "twig", "twilight", "twine", "twins", "twirl", "twistable", "twisted", "twister", "twisting", "twisty", "twitch", "twitter", "tycoon", "tying", "tyke", "udder", "ultimate", "ultimatum", "ultra", "umbilical", "umbrella", "umpire", "unabashed", "unable", "unadorned", "unadvised", "unafraid", "unaired", "unaligned", "unaltered", "unarmored", "unashamed", "unaudited", "unawake", "unaware", "unbaked", "unbalance", "unbeaten", "unbend", "unbent", "unbiased", "unbitten", "unblended", "unblessed", "unblock", "unbolted", "unbounded", "unboxed", "unbraided", "unbridle", "unbroken", "unbuckled", "unbundle", "unburned", "unbutton", "uncanny", "uncapped", "uncaring", "uncertain", "unchain", "unchanged", "uncharted", "uncheck", "uncivil", "unclad", "unclaimed", "unclamped", "unclasp", "uncle", "unclip", "uncloak", "unclog", "unclothed", "uncoated", "uncoiled", "uncolored", "uncombed", "uncommon", "uncooked", "uncork", "uncorrupt", "uncounted", "uncouple", "uncouth", "uncover", "uncross", "uncrown", "uncrushed", "uncured", "uncurious", "uncurled", "uncut", "undamaged", "undated", "undaunted", "undead", "undecided", "undefined", "underage", "underarm", "undercoat", "undercook", "undercut", "underdog", "underdone", "underfed", "underfeed", "underfoot", "undergo", "undergrad", "underhand", "underline", "underling", "undermine", "undermost", "underpaid", "underpass", "underpay", "underrate", "undertake", "undertone", "undertook", "undertow", "underuse", "underwear", "underwent", "underwire", "undesired", "undiluted", "undivided", "undocked", "undoing", "undone", "undrafted", "undress", "undrilled", "undusted", "undying", "unearned", "unearth", "unease", "uneasily", "uneasy", "uneatable", "uneaten", "unedited", "unelected", "unending", "unengaged", "unenvied", "unequal", "unethical", "uneven", "unexpired", "unexposed", "unfailing", "unfair", "unfasten", "unfazed", "unfeeling", "unfiled", "unfilled", "unfitted", "unfitting", "unfixable", "unfixed", "unflawed", "unfocused", "unfold", "unfounded", "unframed", "unfreeze", "unfrosted", "unfrozen", "unfunded", "unglazed", "ungloved", "unglue", "ungodly", "ungraded", "ungreased", "unguarded", "unguided", "unhappily", "unhappy", "unharmed", "unhealthy", "unheard", "unhearing", "unheated", "unhelpful", "unhidden", "unhinge", "unhitched", "unholy", "unhook", "unicorn", "unicycle", "unified", "unifier", "uniformed", "uniformly", "unify", "unimpeded", "uninjured", "uninstall", "uninsured", "uninvited", "union", "uniquely", "unisexual", "unison", "unissued", "unit", "universal", "universe", "unjustly", "unkempt", "unkind", "unknotted", "unknowing", "unknown", "unlaced", "unlatch", "unlawful", "unleaded", "unlearned", "unleash", "unless", "unleveled", "unlighted", "unlikable", "unlimited", "unlined", "unlinked", "unlisted", "unlit", "unlivable", "unloaded", "unloader", "unlocked", "unlocking", "unlovable", "unloved", "unlovely", "unloving", "unluckily", "unlucky", "unmade", "unmanaged", "unmanned", "unmapped", "unmarked", "unmasked", "unmasking", "unmatched", "unmindful", "unmixable", "unmixed", "unmolded", "unmoral", "unmovable", "unmoved", "unmoving", "unnamable", "unnamed", "unnatural", "unneeded", "unnerve", "unnerving", "unnoticed", "unopened", "unopposed", "unpack", "unpadded", "unpaid", "unpainted", "unpaired", "unpaved", "unpeeled", "unpicked", "unpiloted", "unpinned", "unplanned", "unplanted", "unpleased", "unpledged", "unplowed", "unplug", "unpopular", "unproven", "unquote", "unranked", "unrated", "unraveled", "unreached", "unread", "unreal", "unreeling", "unrefined", "unrelated", "unrented", "unrest", "unretired", "unrevised", "unrigged", "unripe", "unrivaled", "unroasted", "unrobed", "unroll", "unruffled", "unruly", "unrushed", "unsaddle", "unsafe", "unsaid", "unsalted", "unsaved", "unsavory", "unscathed", "unscented", "unscrew", "unsealed", "unseated", "unsecured", "unseeing", "unseemly", "unseen", "unselect", "unselfish", "unsent", "unsettled", "unshackle", "unshaken", "unshaved", "unshaven", "unsheathe", "unshipped", "unsightly", "unsigned", "unskilled", "unsliced", "unsmooth", "unsnap", "unsocial", "unsoiled", "unsold", "unsolved", "unsorted", "unspoiled", "unspoken", "unstable", "unstaffed", "unstamped", "unsteady", "unsterile", "unstirred", "unstitch", "unstopped", "unstuck", "unstuffed", "unstylish", "unsubtle", "unsubtly", "unsuited", "unsure", "unsworn", "untagged", "untainted", "untaken", "untamed", "untangled", "untapped", "untaxed", "unthawed", "unthread", "untidy", "untie", "until", "untimed", "untimely", "untitled", "untoasted", "untold", "untouched", "untracked", "untrained", "untreated", "untried", "untrimmed", "untrue", "untruth", "unturned", "untwist", "untying", "unusable", "unused", "unusual", "unvalued", "unvaried", "unvarying", "unveiled", "unveiling", "unvented", "unviable", "unvisited", "unvocal", "unwanted", "unwarlike", "unwary", "unwashed", "unwatched", "unweave", "unwed", "unwelcome", "unwell", "unwieldy", "unwilling", "unwind", "unwired", "unwitting", "unwomanly", "unworldly", "unworn", "unworried", "unworthy", "unwound", "unwoven", "unwrapped", "unwritten", "unzip", "upbeat", "upchuck", "upcoming", "upcountry", "update", "upfront", "upgrade", "upheaval", "upheld", "uphill", "uphold", "uplifted", "uplifting", "upload", "upon", "upper", "upright", "uprising", "upriver", "uproar", "uproot", "upscale", "upside", "upstage", "upstairs", "upstart", "upstate", "upstream", "upstroke", "upswing", "uptake", "uptight", "uptown", "upturned", "upward", "upwind", "uranium", "urban", "urchin", "urethane", "urgency", "urgent", "urging", "urologist", "urology", "usable", "usage", "useable", "used", "uselessly", "user", "usher", "usual", "utensil", "utility", "utilize", "utmost", "utopia", "utter", "vacancy", "vacant", "vacate", "vacation", "vagabond", "vagrancy", "vagrantly", "vaguely", "vagueness", "valiant", "valid", "valium", "valley", "valuables", "value", "vanilla", "vanish", "vanity", "vanquish", "vantage", "vaporizer", "variable", "variably", "varied", "variety", "various", "varmint", "varnish", "varsity", "varying", "vascular", "vaseline", "vastly", "vastness", "veal", "vegan", "veggie", "vehicular", "velcro", "velocity", "velvet", "vendetta", "vending", "vendor", "veneering", "vengeful", "venomous", "ventricle", "venture", "venue", "venus", "verbalize", "verbally", "verbose", "verdict", "verify", "verse", "version", "versus", "vertebrae", "vertical", "vertigo", "very", "vessel", "vest", "veteran", "veto", "vexingly", "viability", "viable", "vibes", "vice", "vicinity", "victory", "video", "viewable", "viewer", "viewing", "viewless", "viewpoint", "vigorous", "village", "villain", "vindicate", "vineyard", "vintage", "violate", "violation", "violator", "violet", "violin", "viper", "viral", "virtual", "virtuous", "virus", "visa", "viscosity", "viscous", "viselike", "visible", "visibly", "vision", "visiting", "visitor", "visor", "vista", "vitality", "vitalize", "vitally", "vitamins", "vivacious", "vividly", "vividness", "vixen", "vocalist", "vocalize", "vocally", "vocation", "voice", "voicing", "void", "volatile", "volley", "voltage", "volumes", "voter", "voting", "voucher", "vowed", "vowel", "voyage", "wackiness", "wad", "wafer", "waffle", "waged", "wager", "wages", "waggle", "wagon", "wake", "waking", "walk", "walmart", "walnut", "walrus", "waltz", "wand", "wannabe", "wanted", "wanting", "wasabi", "washable", "washbasin", "washboard", "washbowl", "washcloth", "washday", "washed", "washer", "washhouse", "washing", "washout", "washroom", "washstand", "washtub", "wasp", "wasting", "watch", "water", "waviness", "waving", "wavy", "whacking", "whacky", "wham", "wharf", "wheat", "whenever", "whiff", "whimsical", "whinny", "whiny", "whisking", "whoever", "whole", "whomever", "whoopee", "whooping", "whoops", "why", "wick", "widely", "widen", "widget", "widow", "width", "wieldable", "wielder", "wife", "wifi", "wikipedia", "wildcard", "wildcat", "wilder", "wildfire", "wildfowl", "wildland", "wildlife", "wildly", "wildness", "willed", "willfully", "willing", "willow", "willpower", "wilt", "wimp", "wince", "wincing", "wind", "wing", "winking", "winner", "winnings", "winter", "wipe", "wired", "wireless", "wiring", "wiry", "wisdom", "wise", "wish", "wisplike", "wispy", "wistful", "wizard", "wobble", "wobbling", "wobbly", "wok", "wolf", "wolverine", "womanhood", "womankind", "womanless", "womanlike", "womanly", "womb", "woof", "wooing", "wool", "woozy", "word", "work", "worried", "worrier", "worrisome", "worry", "worsening", "worshiper", "worst", "wound", "woven", "wow", "wrangle", "wrath", "wreath", "wreckage", "wrecker", "wrecking", "wrench", "wriggle", "wriggly", "wrinkle", "wrinkly", "wrist", "writing", "written", "wrongdoer", "wronged", "wrongful", "wrongly", "wrongness", "wrought", "xbox", "xerox", "yahoo", "yam", "yanking", "yapping", "yard", "yarn", "yeah", "yearbook", "yearling", "yearly", "yearning", "yeast", "yelling", "yelp", "yen", "yesterday", "yiddish", "yield", "yin", "yippee", "yo-yo", "yodel", "yoga", "yogurt", "yonder", "yoyo", "yummy", "zap", "zealous", "zebra", "zen", "zeppelin", "zero", "zestfully", "zesty", "zigzagged", "zipfile", "zipping", "zippy", "zips", "zit", "zodiac", "zombie", "zone", "zoning", "zookeeper", "zoologist", "zoology", "zoom"];
Object.defineProperty(newSecureWords$1, "__esModule", {
	value: !0
});
newSecureWords$1.newSecureWords = void 0;
const getSecureRandom_1$1 = getSecureRandom,
	wordlist_1$1 = wordlist$1;
async function newSecureWords(ue = 6) {
	let Yi = [];
	for (let ea = 0; ea < ue; ea++) Yi.push(wordlist_1$1.wordlist[await (0, getSecureRandom_1$1.getSecureRandomNumber)(0, wordlist_1$1.wordlist.length)]);
	return Yi
}
newSecureWords$1.newSecureWords = newSecureWords;
var newSecurePassphrase = {},
	hasRequiredNewSecurePassphrase;

function requireNewSecurePassphrase() {
	if (hasRequiredNewSecurePassphrase) return newSecurePassphrase;
	hasRequiredNewSecurePassphrase = 1, Object.defineProperty(newSecurePassphrase, "__esModule", {
		value: !0
	}), newSecurePassphrase.newSecurePassphrase = void 0;
	const ue = requireDist();
	async function Yi(ea = 6) {
		return (await (0, ue.newSecureWords)(ea)).join("-")
	}
	return newSecurePassphrase.newSecurePassphrase = Yi, newSecurePassphrase
}
var mnemonic = {};

function commonjsRequire(ue) {
	throw new Error('Could not dynamically require "' + ue + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
var naclFast = {
		exports: {}
	},
	cryptoBrowserify = {},
	browser$b = {
		exports: {}
	},
	safeBuffer$1 = {
		exports: {}
	};
const require$$1$2 = getAugmentedNamespace(dist$2); /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$1;

function requireSafeBuffer$1() {
	return hasRequiredSafeBuffer$1 || (hasRequiredSafeBuffer$1 = 1, function(ue, Yi) {
		var ea = require$$1$2,
			ta = ea.Buffer;

		function na(ia, aa) {
			for (var oa in ia) aa[oa] = ia[oa]
		}
		ta.from && ta.alloc && ta.allocUnsafe && ta.allocUnsafeSlow ? ue.exports = ea : (na(ea, Yi), Yi.Buffer = ra);

		function ra(ia, aa, oa) {
			return ta(ia, aa, oa)
		}
		ra.prototype = Object.create(ta.prototype), na(ta, ra), ra.from = function(ia, aa, oa) {
			if (typeof ia == "number") throw new TypeError("Argument must not be a number");
			return ta(ia, aa, oa)
		}, ra.alloc = function(ia, aa, oa) {
			if (typeof ia != "number") throw new TypeError("Argument must be a number");
			var la = ta(ia);
			return aa !== void 0 ? typeof oa == "string" ? la.fill(aa, oa) : la.fill(aa) : la.fill(0), la
		}, ra.allocUnsafe = function(ia) {
			if (typeof ia != "number") throw new TypeError("Argument must be a number");
			return ta(ia)
		}, ra.allocUnsafeSlow = function(ia) {
			if (typeof ia != "number") throw new TypeError("Argument must be a number");
			return ea.SlowBuffer(ia)
		}
	}(safeBuffer$1, safeBuffer$1.exports)), safeBuffer$1.exports
}
var hasRequiredBrowser$b;

function requireBrowser$b() {
	if (hasRequiredBrowser$b) return browser$b.exports;
	hasRequiredBrowser$b = 1;
	var ue = 65536,
		Yi = 4294967295;

	function ea() {
		throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`)
	}
	var ta = requireSafeBuffer$1().Buffer,
		na = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
	na && na.getRandomValues ? browser$b.exports = ra : browser$b.exports = ea;

	function ra(ia, aa) {
		if (ia > Yi) throw new RangeError("requested too many random bytes");
		var oa = ta.allocUnsafe(ia);
		if (ia > 0)
			if (ia > ue)
				for (var la = 0; la < ia; la += ue) na.getRandomValues(oa.slice(la, la + ue));
			else na.getRandomValues(oa);
		return typeof aa == "function" ? process$1.nextTick(function() {
			aa(null, oa)
		}) : oa
	}
	return browser$b.exports
}
var inherits_browser = {
		exports: {}
	},
	hasRequiredInherits_browser;

function requireInherits_browser() {
	return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(Yi, ea) {
		ea && (Yi.super_ = ea, Yi.prototype = Object.create(ea.prototype, {
			constructor: {
				value: Yi,
				enumerable: !1,
				writable: !0,
				configurable: !0
			}
		}))
	} : inherits_browser.exports = function(Yi, ea) {
		if (ea) {
			Yi.super_ = ea;
			var ta = function() {};
			ta.prototype = ea.prototype, Yi.prototype = new ta, Yi.prototype.constructor = Yi
		}
	}), inherits_browser.exports
}
var readableBrowser$1 = {
		exports: {}
	},
	events = {
		exports: {}
	},
	hasRequiredEvents;

function requireEvents() {
	if (hasRequiredEvents) return events.exports;
	hasRequiredEvents = 1;
	var ue = typeof Reflect == "object" ? Reflect : null,
		Yi = ue && typeof ue.apply == "function" ? ue.apply : function(ka, Pa, ja) {
			return Function.prototype.apply.call(ka, Pa, ja)
		},
		ea;
	ue && typeof ue.ownKeys == "function" ? ea = ue.ownKeys : Object.getOwnPropertySymbols ? ea = function(ka) {
		return Object.getOwnPropertyNames(ka).concat(Object.getOwnPropertySymbols(ka))
	} : ea = function(ka) {
		return Object.getOwnPropertyNames(ka)
	};

	function ta(Ca) {
		console && console.warn && console.warn(Ca)
	}
	var na = Number.isNaN || function(ka) {
		return ka !== ka
	};

	function ra() {
		ra.init.call(this)
	}
	events.exports = ra, events.exports.once = ba, ra.EventEmitter = ra, ra.prototype._events = void 0, ra.prototype._eventsCount = 0, ra.prototype._maxListeners = void 0;
	var ia = 10;

	function aa(Ca) {
		if (typeof Ca != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof Ca)
	}
	Object.defineProperty(ra, "defaultMaxListeners", {
		enumerable: !0,
		get: function() {
			return ia
		},
		set: function(Ca) {
			if (typeof Ca != "number" || Ca < 0 || na(Ca)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + Ca + ".");
			ia = Ca
		}
	}), ra.init = function() {
		(this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
	}, ra.prototype.setMaxListeners = function(ka) {
		if (typeof ka != "number" || ka < 0 || na(ka)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + ka + ".");
		return this._maxListeners = ka, this
	};

	function oa(Ca) {
		return Ca._maxListeners === void 0 ? ra.defaultMaxListeners : Ca._maxListeners
	}
	ra.prototype.getMaxListeners = function() {
		return oa(this)
	}, ra.prototype.emit = function(ka) {
		for (var Pa = [], ja = 1; ja < arguments.length; ja++) Pa.push(arguments[ja]);
		var Za = ka === "error",
			Ga = this._events;
		if (Ga !== void 0) Za = Za && Ga.error === void 0;
		else if (!Za) return !1;
		if (Za) {
			var Ja;
			if (Pa.length > 0 && (Ja = Pa[0]), Ja instanceof Error) throw Ja;
			var Ua = new Error("Unhandled error." + (Ja ? " (" + Ja.message + ")" : ""));
			throw Ua.context = Ja, Ua
		}
		var xa = Ga[ka];
		if (xa === void 0) return !1;
		if (typeof xa == "function") Yi(xa, this, Pa);
		else
			for (var ma = xa.length, fa = ha(xa, ma), ja = 0; ja < ma; ++ja) Yi(fa[ja], this, Pa);
		return !0
	};

	function la(Ca, ka, Pa, ja) {
		var Za, Ga, Ja;
		if (aa(Pa), Ga = Ca._events, Ga === void 0 ? (Ga = Ca._events = Object.create(null), Ca._eventsCount = 0) : (Ga.newListener !== void 0 && (Ca.emit("newListener", ka, Pa.listener ? Pa.listener : Pa), Ga = Ca._events), Ja = Ga[ka]), Ja === void 0) Ja = Ga[ka] = Pa, ++Ca._eventsCount;
		else if (typeof Ja == "function" ? Ja = Ga[ka] = ja ? [Pa, Ja] : [Ja, Pa] : ja ? Ja.unshift(Pa) : Ja.push(Pa), Za = oa(Ca), Za > 0 && Ja.length > Za && !Ja.warned) {
			Ja.warned = !0;
			var Ua = new Error("Possible EventEmitter memory leak detected. " + Ja.length + " " + String(ka) + " listeners added. Use emitter.setMaxListeners() to increase limit");
			Ua.name = "MaxListenersExceededWarning", Ua.emitter = Ca, Ua.type = ka, Ua.count = Ja.length, ta(Ua)
		}
		return Ca
	}
	ra.prototype.addListener = function(ka, Pa) {
		return la(this, ka, Pa, !1)
	}, ra.prototype.on = ra.prototype.addListener, ra.prototype.prependListener = function(ka, Pa) {
		return la(this, ka, Pa, !0)
	};

	function sa() {
		if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
	}

	function ca(Ca, ka, Pa) {
		var ja = {
				fired: !1,
				wrapFn: void 0,
				target: Ca,
				type: ka,
				listener: Pa
			},
			Za = sa.bind(ja);
		return Za.listener = Pa, ja.wrapFn = Za, Za
	}
	ra.prototype.once = function(ka, Pa) {
		return aa(Pa), this.on(ka, ca(this, ka, Pa)), this
	}, ra.prototype.prependOnceListener = function(ka, Pa) {
		return aa(Pa), this.prependListener(ka, ca(this, ka, Pa)), this
	}, ra.prototype.removeListener = function(ka, Pa) {
		var ja, Za, Ga, Ja, Ua;
		if (aa(Pa), Za = this._events, Za === void 0) return this;
		if (ja = Za[ka], ja === void 0) return this;
		if (ja === Pa || ja.listener === Pa) --this._eventsCount === 0 ? this._events = Object.create(null) : (delete Za[ka], Za.removeListener && this.emit("removeListener", ka, ja.listener || Pa));
		else if (typeof ja != "function") {
			for (Ga = -1, Ja = ja.length - 1; Ja >= 0; Ja--)
				if (ja[Ja] === Pa || ja[Ja].listener === Pa) {
					Ua = ja[Ja].listener, Ga = Ja;
					break
				} if (Ga < 0) return this;
			Ga === 0 ? ja.shift() : pa(ja, Ga), ja.length === 1 && (Za[ka] = ja[0]), Za.removeListener !== void 0 && this.emit("removeListener", ka, Ua || Pa)
		}
		return this
	}, ra.prototype.off = ra.prototype.removeListener, ra.prototype.removeAllListeners = function(ka) {
		var Pa, ja, Za;
		if (ja = this._events, ja === void 0) return this;
		if (ja.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : ja[ka] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete ja[ka]), this;
		if (arguments.length === 0) {
			var Ga = Object.keys(ja),
				Ja;
			for (Za = 0; Za < Ga.length; ++Za) Ja = Ga[Za], Ja !== "removeListener" && this.removeAllListeners(Ja);
			return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
		}
		if (Pa = ja[ka], typeof Pa == "function") this.removeListener(ka, Pa);
		else if (Pa !== void 0)
			for (Za = Pa.length - 1; Za >= 0; Za--) this.removeListener(ka, Pa[Za]);
		return this
	};

	function ua(Ca, ka, Pa) {
		var ja = Ca._events;
		if (ja === void 0) return [];
		var Za = ja[ka];
		return Za === void 0 ? [] : typeof Za == "function" ? Pa ? [Za.listener || Za] : [Za] : Pa ? va(Za) : ha(Za, Za.length)
	}
	ra.prototype.listeners = function(ka) {
		return ua(this, ka, !0)
	}, ra.prototype.rawListeners = function(ka) {
		return ua(this, ka, !1)
	}, ra.listenerCount = function(Ca, ka) {
		return typeof Ca.listenerCount == "function" ? Ca.listenerCount(ka) : da.call(Ca, ka)
	}, ra.prototype.listenerCount = da;

	function da(Ca) {
		var ka = this._events;
		if (ka !== void 0) {
			var Pa = ka[Ca];
			if (typeof Pa == "function") return 1;
			if (Pa !== void 0) return Pa.length
		}
		return 0
	}
	ra.prototype.eventNames = function() {
		return this._eventsCount > 0 ? ea(this._events) : []
	};

	function ha(Ca, ka) {
		for (var Pa = new Array(ka), ja = 0; ja < ka; ++ja) Pa[ja] = Ca[ja];
		return Pa
	}

	function pa(Ca, ka) {
		for (; ka + 1 < Ca.length; ka++) Ca[ka] = Ca[ka + 1];
		Ca.pop()
	}

	function va(Ca) {
		for (var ka = new Array(Ca.length), Pa = 0; Pa < ka.length; ++Pa) ka[Pa] = Ca[Pa].listener || Ca[Pa];
		return ka
	}

	function ba(Ca, ka) {
		return new Promise(function(Pa, ja) {
			function Za(Ja) {
				Ca.removeListener(ka, Ga), ja(Ja)
			}

			function Ga() {
				typeof Ca.removeListener == "function" && Ca.removeListener("error", Za), Pa([].slice.call(arguments))
			}
			Sa(Ca, ka, Ga, {
				once: !0
			}), ka !== "error" && Ea(Ca, Za, {
				once: !0
			})
		})
	}

	function Ea(Ca, ka, Pa) {
		typeof Ca.on == "function" && Sa(Ca, "error", ka, Pa)
	}

	function Sa(Ca, ka, Pa, ja) {
		if (typeof Ca.on == "function") ja.once ? Ca.once(ka, Pa) : Ca.on(ka, Pa);
		else if (typeof Ca.addEventListener == "function") Ca.addEventListener(ka, function Za(Ga) {
			ja.once && Ca.removeEventListener(ka, Za), Pa(Ga)
		});
		else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof Ca)
	}
	return events.exports
}
var streamBrowser$1, hasRequiredStreamBrowser$1;

function requireStreamBrowser$1() {
	return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = requireEvents().EventEmitter), streamBrowser$1
}
var util$1 = {},
	types = {},
	shams$1, hasRequiredShams$1;

function requireShams$1() {
	return hasRequiredShams$1 || (hasRequiredShams$1 = 1, shams$1 = function() {
		if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
		if (typeof Symbol.iterator == "symbol") return !0;
		var Yi = {},
			ea = Symbol("test"),
			ta = Object(ea);
		if (typeof ea == "string" || Object.prototype.toString.call(ea) !== "[object Symbol]" || Object.prototype.toString.call(ta) !== "[object Symbol]") return !1;
		var na = 42;
		Yi[ea] = na;
		for (ea in Yi) return !1;
		if (typeof Object.keys == "function" && Object.keys(Yi).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(Yi).length !== 0) return !1;
		var ra = Object.getOwnPropertySymbols(Yi);
		if (ra.length !== 1 || ra[0] !== ea || !Object.prototype.propertyIsEnumerable.call(Yi, ea)) return !1;
		if (typeof Object.getOwnPropertyDescriptor == "function") {
			var ia = Object.getOwnPropertyDescriptor(Yi, ea);
			if (ia.value !== na || ia.enumerable !== !0) return !1
		}
		return !0
	}), shams$1
}
var shams, hasRequiredShams;

function requireShams() {
	if (hasRequiredShams) return shams;
	hasRequiredShams = 1;
	var ue = requireShams$1();
	return shams = function() {
		return ue() && !!Symbol.toStringTag
	}, shams
}
var esErrors, hasRequiredEsErrors;

function requireEsErrors() {
	return hasRequiredEsErrors || (hasRequiredEsErrors = 1, esErrors = Error), esErrors
}
var _eval, hasRequired_eval;

function require_eval() {
	return hasRequired_eval || (hasRequired_eval = 1, _eval = EvalError), _eval
}
var range, hasRequiredRange;

function requireRange() {
	return hasRequiredRange || (hasRequiredRange = 1, range = RangeError), range
}
var ref, hasRequiredRef;

function requireRef() {
	return hasRequiredRef || (hasRequiredRef = 1, ref = ReferenceError), ref
}
var syntax, hasRequiredSyntax;

function requireSyntax() {
	return hasRequiredSyntax || (hasRequiredSyntax = 1, syntax = SyntaxError), syntax
}
var type, hasRequiredType;

function requireType() {
	return hasRequiredType || (hasRequiredType = 1, type = TypeError), type
}
var uri, hasRequiredUri;

function requireUri() {
	return hasRequiredUri || (hasRequiredUri = 1, uri = URIError), uri
}
var hasSymbols, hasRequiredHasSymbols;

function requireHasSymbols() {
	if (hasRequiredHasSymbols) return hasSymbols;
	hasRequiredHasSymbols = 1;
	var ue = typeof Symbol < "u" && Symbol,
		Yi = requireShams$1();
	return hasSymbols = function() {
		return typeof ue != "function" || typeof Symbol != "function" || typeof ue("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : Yi()
	}, hasSymbols
}
var hasProto, hasRequiredHasProto;

function requireHasProto() {
	if (hasRequiredHasProto) return hasProto;
	hasRequiredHasProto = 1;
	var ue = {
			__proto__: null,
			foo: {}
		},
		Yi = Object;
	return hasProto = function() {
		return {
			__proto__: ue
		}.foo === ue.foo && !(ue instanceof Yi)
	}, hasProto
}
var implementation, hasRequiredImplementation;

function requireImplementation() {
	if (hasRequiredImplementation) return implementation;
	hasRequiredImplementation = 1;
	var ue = "Function.prototype.bind called on incompatible ",
		Yi = Object.prototype.toString,
		ea = Math.max,
		ta = "[object Function]",
		na = function(oa, la) {
			for (var sa = [], ca = 0; ca < oa.length; ca += 1) sa[ca] = oa[ca];
			for (var ua = 0; ua < la.length; ua += 1) sa[ua + oa.length] = la[ua];
			return sa
		},
		ra = function(oa, la) {
			for (var sa = [], ca = la, ua = 0; ca < oa.length; ca += 1, ua += 1) sa[ua] = oa[ca];
			return sa
		},
		ia = function(aa, oa) {
			for (var la = "", sa = 0; sa < aa.length; sa += 1) la += aa[sa], sa + 1 < aa.length && (la += oa);
			return la
		};
	return implementation = function(oa) {
		var la = this;
		if (typeof la != "function" || Yi.apply(la) !== ta) throw new TypeError(ue + la);
		for (var sa = ra(arguments, 1), ca, ua = function() {
				if (this instanceof ca) {
					var ba = la.apply(this, na(sa, arguments));
					return Object(ba) === ba ? ba : this
				}
				return la.apply(oa, na(sa, arguments))
			}, da = ea(0, la.length - sa.length), ha = [], pa = 0; pa < da; pa++) ha[pa] = "$" + pa;
		if (ca = Function("binder", "return function (" + ia(ha, ",") + "){ return binder.apply(this,arguments); }")(ua), la.prototype) {
			var va = function() {};
			va.prototype = la.prototype, ca.prototype = new va, va.prototype = null
		}
		return ca
	}, implementation
}
var functionBind, hasRequiredFunctionBind;

function requireFunctionBind() {
	if (hasRequiredFunctionBind) return functionBind;
	hasRequiredFunctionBind = 1;
	var ue = requireImplementation();
	return functionBind = Function.prototype.bind || ue, functionBind
}
var hasown, hasRequiredHasown;

function requireHasown() {
	if (hasRequiredHasown) return hasown;
	hasRequiredHasown = 1;
	var ue = Function.prototype.call,
		Yi = Object.prototype.hasOwnProperty,
		ea = requireFunctionBind();
	return hasown = ea.call(ue, Yi), hasown
}
var getIntrinsic, hasRequiredGetIntrinsic;

function requireGetIntrinsic() {
	if (hasRequiredGetIntrinsic) return getIntrinsic;
	hasRequiredGetIntrinsic = 1;
	var ue, Yi = requireEsErrors(),
		ea = require_eval(),
		ta = requireRange(),
		na = requireRef(),
		ra = requireSyntax(),
		ia = requireType(),
		aa = requireUri(),
		oa = Function,
		la = function(Ma) {
			try {
				return oa('"use strict"; return (' + Ma + ").constructor;")()
			} catch {}
		},
		sa = Object.getOwnPropertyDescriptor;
	if (sa) try {
		sa({}, "")
	} catch {
		sa = null
	}
	var ca = function() {
			throw new ia
		},
		ua = sa ? function() {
			try {
				return arguments.callee, ca
			} catch {
				try {
					return sa(arguments, "callee").get
				} catch {
					return ca
				}
			}
		}() : ca,
		da = requireHasSymbols()(),
		ha = requireHasProto()(),
		pa = Object.getPrototypeOf || (ha ? function(Ma) {
			return Ma.__proto__
		} : null),
		va = {},
		ba = typeof Uint8Array > "u" || !pa ? ue : pa(Uint8Array),
		Ea = {
			__proto__: null,
			"%AggregateError%": typeof AggregateError > "u" ? ue : AggregateError,
			"%Array%": Array,
			"%ArrayBuffer%": typeof ArrayBuffer > "u" ? ue : ArrayBuffer,
			"%ArrayIteratorPrototype%": da && pa ? pa([][Symbol.iterator]()) : ue,
			"%AsyncFromSyncIteratorPrototype%": ue,
			"%AsyncFunction%": va,
			"%AsyncGenerator%": va,
			"%AsyncGeneratorFunction%": va,
			"%AsyncIteratorPrototype%": va,
			"%Atomics%": typeof Atomics > "u" ? ue : Atomics,
			"%BigInt%": typeof BigInt > "u" ? ue : BigInt,
			"%BigInt64Array%": typeof BigInt64Array > "u" ? ue : BigInt64Array,
			"%BigUint64Array%": typeof BigUint64Array > "u" ? ue : BigUint64Array,
			"%Boolean%": Boolean,
			"%DataView%": typeof DataView > "u" ? ue : DataView,
			"%Date%": Date,
			"%decodeURI%": decodeURI,
			"%decodeURIComponent%": decodeURIComponent,
			"%encodeURI%": encodeURI,
			"%encodeURIComponent%": encodeURIComponent,
			"%Error%": Yi,
			"%eval%": eval,
			"%EvalError%": ea,
			"%Float32Array%": typeof Float32Array > "u" ? ue : Float32Array,
			"%Float64Array%": typeof Float64Array > "u" ? ue : Float64Array,
			"%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? ue : FinalizationRegistry,
			"%Function%": oa,
			"%GeneratorFunction%": va,
			"%Int8Array%": typeof Int8Array > "u" ? ue : Int8Array,
			"%Int16Array%": typeof Int16Array > "u" ? ue : Int16Array,
			"%Int32Array%": typeof Int32Array > "u" ? ue : Int32Array,
			"%isFinite%": isFinite,
			"%isNaN%": isNaN,
			"%IteratorPrototype%": da && pa ? pa(pa([][Symbol.iterator]())) : ue,
			"%JSON%": typeof JSON == "object" ? JSON : ue,
			"%Map%": typeof Map > "u" ? ue : Map,
			"%MapIteratorPrototype%": typeof Map > "u" || !da || !pa ? ue : pa(new Map()[Symbol.iterator]()),
			"%Math%": Math,
			"%Number%": Number,
			"%Object%": Object,
			"%parseFloat%": parseFloat,
			"%parseInt%": parseInt,
			"%Promise%": typeof Promise > "u" ? ue : Promise,
			"%Proxy%": typeof Proxy > "u" ? ue : Proxy,
			"%RangeError%": ta,
			"%ReferenceError%": na,
			"%Reflect%": typeof Reflect > "u" ? ue : Reflect,
			"%RegExp%": RegExp,
			"%Set%": typeof Set > "u" ? ue : Set,
			"%SetIteratorPrototype%": typeof Set > "u" || !da || !pa ? ue : pa(new Set()[Symbol.iterator]()),
			"%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? ue : SharedArrayBuffer,
			"%String%": String,
			"%StringIteratorPrototype%": da && pa ? pa("" [Symbol.iterator]()) : ue,
			"%Symbol%": da ? Symbol : ue,
			"%SyntaxError%": ra,
			"%ThrowTypeError%": ua,
			"%TypedArray%": ba,
			"%TypeError%": ia,
			"%Uint8Array%": typeof Uint8Array > "u" ? ue : Uint8Array,
			"%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? ue : Uint8ClampedArray,
			"%Uint16Array%": typeof Uint16Array > "u" ? ue : Uint16Array,
			"%Uint32Array%": typeof Uint32Array > "u" ? ue : Uint32Array,
			"%URIError%": aa,
			"%WeakMap%": typeof WeakMap > "u" ? ue : WeakMap,
			"%WeakRef%": typeof WeakRef > "u" ? ue : WeakRef,
			"%WeakSet%": typeof WeakSet > "u" ? ue : WeakSet
		};
	if (pa) try {
		null.error
	} catch (Ma) {
		var Sa = pa(pa(Ma));
		Ea["%Error.prototype%"] = Sa
	}
	var Ca = function Ma(Aa) {
			var Ra;
			if (Aa === "%AsyncFunction%") Ra = la("async function () {}");
			else if (Aa === "%GeneratorFunction%") Ra = la("function* () {}");
			else if (Aa === "%AsyncGeneratorFunction%") Ra = la("async function* () {}");
			else if (Aa === "%AsyncGenerator%") {
				var Ta = Ma("%AsyncGeneratorFunction%");
				Ta && (Ra = Ta.prototype)
			} else if (Aa === "%AsyncIteratorPrototype%") {
				var La = Ma("%AsyncGenerator%");
				La && pa && (Ra = pa(La.prototype))
			}
			return Ea[Aa] = Ra, Ra
		},
		ka = {
			__proto__: null,
			"%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
			"%ArrayPrototype%": ["Array", "prototype"],
			"%ArrayProto_entries%": ["Array", "prototype", "entries"],
			"%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
			"%ArrayProto_keys%": ["Array", "prototype", "keys"],
			"%ArrayProto_values%": ["Array", "prototype", "values"],
			"%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
			"%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
			"%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
			"%BooleanPrototype%": ["Boolean", "prototype"],
			"%DataViewPrototype%": ["DataView", "prototype"],
			"%DatePrototype%": ["Date", "prototype"],
			"%ErrorPrototype%": ["Error", "prototype"],
			"%EvalErrorPrototype%": ["EvalError", "prototype"],
			"%Float32ArrayPrototype%": ["Float32Array", "prototype"],
			"%Float64ArrayPrototype%": ["Float64Array", "prototype"],
			"%FunctionPrototype%": ["Function", "prototype"],
			"%Generator%": ["GeneratorFunction", "prototype"],
			"%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
			"%Int8ArrayPrototype%": ["Int8Array", "prototype"],
			"%Int16ArrayPrototype%": ["Int16Array", "prototype"],
			"%Int32ArrayPrototype%": ["Int32Array", "prototype"],
			"%JSONParse%": ["JSON", "parse"],
			"%JSONStringify%": ["JSON", "stringify"],
			"%MapPrototype%": ["Map", "prototype"],
			"%NumberPrototype%": ["Number", "prototype"],
			"%ObjectPrototype%": ["Object", "prototype"],
			"%ObjProto_toString%": ["Object", "prototype", "toString"],
			"%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
			"%PromisePrototype%": ["Promise", "prototype"],
			"%PromiseProto_then%": ["Promise", "prototype", "then"],
			"%Promise_all%": ["Promise", "all"],
			"%Promise_reject%": ["Promise", "reject"],
			"%Promise_resolve%": ["Promise", "resolve"],
			"%RangeErrorPrototype%": ["RangeError", "prototype"],
			"%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
			"%RegExpPrototype%": ["RegExp", "prototype"],
			"%SetPrototype%": ["Set", "prototype"],
			"%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
			"%StringPrototype%": ["String", "prototype"],
			"%SymbolPrototype%": ["Symbol", "prototype"],
			"%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
			"%TypedArrayPrototype%": ["TypedArray", "prototype"],
			"%TypeErrorPrototype%": ["TypeError", "prototype"],
			"%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
			"%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
			"%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
			"%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
			"%URIErrorPrototype%": ["URIError", "prototype"],
			"%WeakMapPrototype%": ["WeakMap", "prototype"],
			"%WeakSetPrototype%": ["WeakSet", "prototype"]
		},
		Pa = requireFunctionBind(),
		ja = requireHasown(),
		Za = Pa.call(Function.call, Array.prototype.concat),
		Ga = Pa.call(Function.apply, Array.prototype.splice),
		Ja = Pa.call(Function.call, String.prototype.replace),
		Ua = Pa.call(Function.call, String.prototype.slice),
		xa = Pa.call(Function.call, RegExp.prototype.exec),
		ma = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
		fa = /\\(\\)?/g,
		ga = function(Aa) {
			var Ra = Ua(Aa, 0, 1),
				Ta = Ua(Aa, -1);
			if (Ra === "%" && Ta !== "%") throw new ra("invalid intrinsic syntax, expected closing `%`");
			if (Ta === "%" && Ra !== "%") throw new ra("invalid intrinsic syntax, expected opening `%`");
			var La = [];
			return Ja(Aa, ma, function(ya, Ba, io, oo) {
				La[La.length] = io ? Ja(oo, fa, "$1") : Ba || ya
			}), La
		},
		wa = function(Aa, Ra) {
			var Ta = Aa,
				La;
			if (ja(ka, Ta) && (La = ka[Ta], Ta = "%" + La[0] + "%"), ja(Ea, Ta)) {
				var ya = Ea[Ta];
				if (ya === va && (ya = Ca(Ta)), typeof ya > "u" && !Ra) throw new ia("intrinsic " + Aa + " exists, but is not available. Please file an issue!");
				return {
					alias: La,
					name: Ta,
					value: ya
				}
			}
			throw new ra("intrinsic " + Aa + " does not exist!")
		};
	return getIntrinsic = function(Aa, Ra) {
		if (typeof Aa != "string" || Aa.length === 0) throw new ia("intrinsic name must be a non-empty string");
		if (arguments.length > 1 && typeof Ra != "boolean") throw new ia('"allowMissing" argument must be a boolean');
		if (xa(/^%?[^%]*%?$/, Aa) === null) throw new ra("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
		var Ta = ga(Aa),
			La = Ta.length > 0 ? Ta[0] : "",
			ya = wa("%" + La + "%", Ra),
			Ba = ya.name,
			io = ya.value,
			oo = !1,
			ao = ya.alias;
		ao && (La = ao[0], Ga(Ta, Za([0, 1], ao)));
		for (var Ia = 1, Na = !0; Ia < Ta.length; Ia += 1) {
			var za = Ta[Ia],
				ro = Ua(za, 0, 1),
				Va = Ua(za, -1);
			if ((ro === '"' || ro === "'" || ro === "`" || Va === '"' || Va === "'" || Va === "`") && ro !== Va) throw new ra("property names with quotes must have matching quotes");
			if ((za === "constructor" || !Na) && (oo = !0), La += "." + za, Ba = "%" + La + "%", ja(Ea, Ba)) io = Ea[Ba];
			else if (io != null) {
				if (!(za in io)) {
					if (!Ra) throw new ia("base intrinsic for " + Aa + " exists, but the property is not available.");
					return
				}
				if (sa && Ia + 1 >= Ta.length) {
					var Wa = sa(io, za);
					Na = !!Wa, Na && "get" in Wa && !("originalValue" in Wa.get) ? io = Wa.get : io = io[za]
				} else Na = ja(io, za), io = io[za];
				Na && !oo && (Ea[Ba] = io)
			}
		}
		return io
	}, getIntrinsic
}
var callBind = {
		exports: {}
	},
	esDefineProperty, hasRequiredEsDefineProperty;

function requireEsDefineProperty() {
	if (hasRequiredEsDefineProperty) return esDefineProperty;
	hasRequiredEsDefineProperty = 1;
	var ue = requireGetIntrinsic(),
		Yi = ue("%Object.defineProperty%", !0) || !1;
	if (Yi) try {
		Yi({}, "a", {
			value: 1
		})
	} catch {
		Yi = !1
	}
	return esDefineProperty = Yi, esDefineProperty
}
var gopd, hasRequiredGopd;

function requireGopd() {
	if (hasRequiredGopd) return gopd;
	hasRequiredGopd = 1;
	var ue = requireGetIntrinsic(),
		Yi = ue("%Object.getOwnPropertyDescriptor%", !0);
	if (Yi) try {
		Yi([], "length")
	} catch {
		Yi = null
	}
	return gopd = Yi, gopd
}
var defineDataProperty, hasRequiredDefineDataProperty;

function requireDefineDataProperty() {
	if (hasRequiredDefineDataProperty) return defineDataProperty;
	hasRequiredDefineDataProperty = 1;
	var ue = requireEsDefineProperty(),
		Yi = requireSyntax(),
		ea = requireType(),
		ta = requireGopd();
	return defineDataProperty = function(ra, ia, aa) {
		if (!ra || typeof ra != "object" && typeof ra != "function") throw new ea("`obj` must be an object or a function`");
		if (typeof ia != "string" && typeof ia != "symbol") throw new ea("`property` must be a string or a symbol`");
		if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null) throw new ea("`nonEnumerable`, if provided, must be a boolean or null");
		if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null) throw new ea("`nonWritable`, if provided, must be a boolean or null");
		if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null) throw new ea("`nonConfigurable`, if provided, must be a boolean or null");
		if (arguments.length > 6 && typeof arguments[6] != "boolean") throw new ea("`loose`, if provided, must be a boolean");
		var oa = arguments.length > 3 ? arguments[3] : null,
			la = arguments.length > 4 ? arguments[4] : null,
			sa = arguments.length > 5 ? arguments[5] : null,
			ca = arguments.length > 6 ? arguments[6] : !1,
			ua = !!ta && ta(ra, ia);
		if (ue) ue(ra, ia, {
			configurable: sa === null && ua ? ua.configurable : !sa,
			enumerable: oa === null && ua ? ua.enumerable : !oa,
			value: aa,
			writable: la === null && ua ? ua.writable : !la
		});
		else if (ca || !oa && !la && !sa) ra[ia] = aa;
		else throw new Yi("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")
	}, defineDataProperty
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors;

function requireHasPropertyDescriptors() {
	if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
	hasRequiredHasPropertyDescriptors = 1;
	var ue = requireEsDefineProperty(),
		Yi = function() {
			return !!ue
		};
	return Yi.hasArrayLengthDefineBug = function() {
		if (!ue) return null;
		try {
			return ue([], "length", {
				value: 1
			}).length !== 1
		} catch {
			return !0
		}
	}, hasPropertyDescriptors_1 = Yi, hasPropertyDescriptors_1
}
var setFunctionLength, hasRequiredSetFunctionLength;

function requireSetFunctionLength() {
	if (hasRequiredSetFunctionLength) return setFunctionLength;
	hasRequiredSetFunctionLength = 1;
	var ue = requireGetIntrinsic(),
		Yi = requireDefineDataProperty(),
		ea = requireHasPropertyDescriptors()(),
		ta = requireGopd(),
		na = requireType(),
		ra = ue("%Math.floor%");
	return setFunctionLength = function(aa, oa) {
		if (typeof aa != "function") throw new na("`fn` is not a function");
		if (typeof oa != "number" || oa < 0 || oa > 4294967295 || ra(oa) !== oa) throw new na("`length` must be a positive 32-bit integer");
		var la = arguments.length > 2 && !!arguments[2],
			sa = !0,
			ca = !0;
		if ("length" in aa && ta) {
			var ua = ta(aa, "length");
			ua && !ua.configurable && (sa = !1), ua && !ua.writable && (ca = !1)
		}
		return (sa || ca || !la) && (ea ? Yi(aa, "length", oa, !0, !0) : Yi(aa, "length", oa)), aa
	}, setFunctionLength
}
var hasRequiredCallBind;

function requireCallBind() {
	return hasRequiredCallBind || (hasRequiredCallBind = 1, function(ue) {
		var Yi = requireFunctionBind(),
			ea = requireGetIntrinsic(),
			ta = requireSetFunctionLength(),
			na = requireType(),
			ra = ea("%Function.prototype.apply%"),
			ia = ea("%Function.prototype.call%"),
			aa = ea("%Reflect.apply%", !0) || Yi.call(ia, ra),
			oa = requireEsDefineProperty(),
			la = ea("%Math.max%");
		ue.exports = function(ua) {
			if (typeof ua != "function") throw new na("a function is required");
			var da = aa(Yi, ia, arguments);
			return ta(da, 1 + la(0, ua.length - (arguments.length - 1)), !0)
		};
		var sa = function() {
			return aa(Yi, ra, arguments)
		};
		oa ? oa(ue.exports, "apply", {
			value: sa
		}) : ue.exports.apply = sa
	}(callBind)), callBind.exports
}
var callBound, hasRequiredCallBound;

function requireCallBound() {
	if (hasRequiredCallBound) return callBound;
	hasRequiredCallBound = 1;
	var ue = requireGetIntrinsic(),
		Yi = requireCallBind(),
		ea = Yi(ue("String.prototype.indexOf"));
	return callBound = function(na, ra) {
		var ia = ue(na, !!ra);
		return typeof ia == "function" && ea(na, ".prototype.") > -1 ? Yi(ia) : ia
	}, callBound
}
var isArguments, hasRequiredIsArguments;

function requireIsArguments() {
	if (hasRequiredIsArguments) return isArguments;
	hasRequiredIsArguments = 1;
	var ue = requireShams()(),
		Yi = requireCallBound(),
		ea = Yi("Object.prototype.toString"),
		ta = function(aa) {
			return ue && aa && typeof aa == "object" && Symbol.toStringTag in aa ? !1 : ea(aa) === "[object Arguments]"
		},
		na = function(aa) {
			return ta(aa) ? !0 : aa !== null && typeof aa == "object" && typeof aa.length == "number" && aa.length >= 0 && ea(aa) !== "[object Array]" && ea(aa.callee) === "[object Function]"
		},
		ra = function() {
			return ta(arguments)
		}();
	return ta.isLegacyArguments = na, isArguments = ra ? ta : na, isArguments
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;

function requireIsGeneratorFunction() {
	if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
	hasRequiredIsGeneratorFunction = 1;
	var ue = Object.prototype.toString,
		Yi = Function.prototype.toString,
		ea = /^\s*(?:function)?\*/,
		ta = requireShams()(),
		na = Object.getPrototypeOf,
		ra = function() {
			if (!ta) return !1;
			try {
				return Function("return function*() {}")()
			} catch {}
		},
		ia;
	return isGeneratorFunction = function(oa) {
		if (typeof oa != "function") return !1;
		if (ea.test(Yi.call(oa))) return !0;
		if (!ta) {
			var la = ue.call(oa);
			return la === "[object GeneratorFunction]"
		}
		if (!na) return !1;
		if (typeof ia > "u") {
			var sa = ra();
			ia = sa ? na(sa) : !1
		}
		return na(oa) === ia
	}, isGeneratorFunction
}
var isCallable, hasRequiredIsCallable;

function requireIsCallable() {
	if (hasRequiredIsCallable) return isCallable;
	hasRequiredIsCallable = 1;
	var ue = Function.prototype.toString,
		Yi = typeof Reflect == "object" && Reflect !== null && Reflect.apply,
		ea, ta;
	if (typeof Yi == "function" && typeof Object.defineProperty == "function") try {
		ea = Object.defineProperty({}, "length", {
			get: function() {
				throw ta
			}
		}), ta = {}, Yi(function() {
			throw 42
		}, null, ea)
	} catch (Ea) {
		Ea !== ta && (Yi = null)
	} else Yi = null;
	var na = /^\s*class\b/,
		ra = function(Sa) {
			try {
				var Ca = ue.call(Sa);
				return na.test(Ca)
			} catch {
				return !1
			}
		},
		ia = function(Sa) {
			try {
				return ra(Sa) ? !1 : (ue.call(Sa), !0)
			} catch {
				return !1
			}
		},
		aa = Object.prototype.toString,
		oa = "[object Object]",
		la = "[object Function]",
		sa = "[object GeneratorFunction]",
		ca = "[object HTMLAllCollection]",
		ua = "[object HTML document.all class]",
		da = "[object HTMLCollection]",
		ha = typeof Symbol == "function" && !!Symbol.toStringTag,
		pa = !(0 in [, ]),
		va = function() {
			return !1
		};
	if (typeof document == "object") {
		var ba = document.all;
		aa.call(ba) === aa.call(document.all) && (va = function(Sa) {
			if ((pa || !Sa) && (typeof Sa > "u" || typeof Sa == "object")) try {
				var Ca = aa.call(Sa);
				return (Ca === ca || Ca === ua || Ca === da || Ca === oa) && Sa("") == null
			} catch {}
			return !1
		})
	}
	return isCallable = Yi ? function(Sa) {
		if (va(Sa)) return !0;
		if (!Sa || typeof Sa != "function" && typeof Sa != "object") return !1;
		try {
			Yi(Sa, null, ea)
		} catch (Ca) {
			if (Ca !== ta) return !1
		}
		return !ra(Sa) && ia(Sa)
	} : function(Sa) {
		if (va(Sa)) return !0;
		if (!Sa || typeof Sa != "function" && typeof Sa != "object") return !1;
		if (ha) return ia(Sa);
		if (ra(Sa)) return !1;
		var Ca = aa.call(Sa);
		return Ca !== la && Ca !== sa && !/^\[object HTML/.test(Ca) ? !1 : ia(Sa)
	}, isCallable
}
var forEach_1, hasRequiredForEach;

function requireForEach() {
	if (hasRequiredForEach) return forEach_1;
	hasRequiredForEach = 1;
	var ue = requireIsCallable(),
		Yi = Object.prototype.toString,
		ea = Object.prototype.hasOwnProperty,
		ta = function(oa, la, sa) {
			for (var ca = 0, ua = oa.length; ca < ua; ca++) ea.call(oa, ca) && (sa == null ? la(oa[ca], ca, oa) : la.call(sa, oa[ca], ca, oa))
		},
		na = function(oa, la, sa) {
			for (var ca = 0, ua = oa.length; ca < ua; ca++) sa == null ? la(oa.charAt(ca), ca, oa) : la.call(sa, oa.charAt(ca), ca, oa)
		},
		ra = function(oa, la, sa) {
			for (var ca in oa) ea.call(oa, ca) && (sa == null ? la(oa[ca], ca, oa) : la.call(sa, oa[ca], ca, oa))
		},
		ia = function(oa, la, sa) {
			if (!ue(la)) throw new TypeError("iterator must be a function");
			var ca;
			arguments.length >= 3 && (ca = sa), Yi.call(oa) === "[object Array]" ? ta(oa, la, ca) : typeof oa == "string" ? na(oa, la, ca) : ra(oa, la, ca)
		};
	return forEach_1 = ia, forEach_1
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;

function requirePossibleTypedArrayNames() {
	return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1, possibleTypedArrayNames = ["Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"]), possibleTypedArrayNames
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;

function requireAvailableTypedArrays() {
	if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
	hasRequiredAvailableTypedArrays = 1;
	var ue = requirePossibleTypedArrayNames(),
		Yi = typeof globalThis > "u" ? commonjsGlobal : globalThis;
	return availableTypedArrays = function() {
		for (var ta = [], na = 0; na < ue.length; na++) typeof Yi[ue[na]] == "function" && (ta[ta.length] = ue[na]);
		return ta
	}, availableTypedArrays
}
var whichTypedArray, hasRequiredWhichTypedArray;

function requireWhichTypedArray() {
	if (hasRequiredWhichTypedArray) return whichTypedArray;
	hasRequiredWhichTypedArray = 1;
	var ue = requireForEach(),
		Yi = requireAvailableTypedArrays(),
		ea = requireCallBind(),
		ta = requireCallBound(),
		na = requireGopd(),
		ra = ta("Object.prototype.toString"),
		ia = requireShams()(),
		aa = typeof globalThis > "u" ? commonjsGlobal : globalThis,
		oa = Yi(),
		la = ta("String.prototype.slice"),
		sa = Object.getPrototypeOf,
		ca = ta("Array.prototype.indexOf", !0) || function(va, ba) {
			for (var Ea = 0; Ea < va.length; Ea += 1)
				if (va[Ea] === ba) return Ea;
			return -1
		},
		ua = {
			__proto__: null
		};
	ia && na && sa ? ue(oa, function(pa) {
		var va = new aa[pa];
		if (Symbol.toStringTag in va) {
			var ba = sa(va),
				Ea = na(ba, Symbol.toStringTag);
			if (!Ea) {
				var Sa = sa(ba);
				Ea = na(Sa, Symbol.toStringTag)
			}
			ua["$" + pa] = ea(Ea.get)
		}
	}) : ue(oa, function(pa) {
		var va = new aa[pa],
			ba = va.slice || va.set;
		ba && (ua["$" + pa] = ea(ba))
	});
	var da = function(va) {
			var ba = !1;
			return ue(ua, function(Ea, Sa) {
				if (!ba) try {
					"$" + Ea(va) === Sa && (ba = la(Sa, 1))
				} catch {}
			}), ba
		},
		ha = function(va) {
			var ba = !1;
			return ue(ua, function(Ea, Sa) {
				if (!ba) try {
					Ea(va), ba = la(Sa, 1)
				} catch {}
			}), ba
		};
	return whichTypedArray = function(va) {
		if (!va || typeof va != "object") return !1;
		if (!ia) {
			var ba = la(ra(va), 8, -1);
			return ca(oa, ba) > -1 ? ba : ba !== "Object" ? !1 : ha(va)
		}
		return na ? da(va) : null
	}, whichTypedArray
}
var isTypedArray, hasRequiredIsTypedArray;

function requireIsTypedArray() {
	if (hasRequiredIsTypedArray) return isTypedArray;
	hasRequiredIsTypedArray = 1;
	var ue = requireWhichTypedArray();
	return isTypedArray = function(ea) {
		return !!ue(ea)
	}, isTypedArray
}
var hasRequiredTypes;

function requireTypes() {
	return hasRequiredTypes || (hasRequiredTypes = 1, function(ue) {
		var Yi = requireIsArguments(),
			ea = requireIsGeneratorFunction(),
			ta = requireWhichTypedArray(),
			na = requireIsTypedArray();

		function ra(so) {
			return so.call.bind(so)
		}
		var ia = typeof BigInt < "u",
			aa = typeof Symbol < "u",
			oa = ra(Object.prototype.toString),
			la = ra(Number.prototype.valueOf),
			sa = ra(String.prototype.valueOf),
			ca = ra(Boolean.prototype.valueOf);
		if (ia) var ua = ra(BigInt.prototype.valueOf);
		if (aa) var da = ra(Symbol.prototype.valueOf);

		function ha(so, Xa) {
			if (typeof so != "object") return !1;
			try {
				return Xa(so), !0
			} catch {
				return !1
			}
		}
		ue.isArgumentsObject = Yi, ue.isGeneratorFunction = ea, ue.isTypedArray = na;

		function pa(so) {
			return typeof Promise < "u" && so instanceof Promise || so !== null && typeof so == "object" && typeof so.then == "function" && typeof so.catch == "function"
		}
		ue.isPromise = pa;

		function va(so) {
			return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(so) : na(so) || Ba(so)
		}
		ue.isArrayBufferView = va;

		function ba(so) {
			return ta(so) === "Uint8Array"
		}
		ue.isUint8Array = ba;

		function Ea(so) {
			return ta(so) === "Uint8ClampedArray"
		}
		ue.isUint8ClampedArray = Ea;

		function Sa(so) {
			return ta(so) === "Uint16Array"
		}
		ue.isUint16Array = Sa;

		function Ca(so) {
			return ta(so) === "Uint32Array"
		}
		ue.isUint32Array = Ca;

		function ka(so) {
			return ta(so) === "Int8Array"
		}
		ue.isInt8Array = ka;

		function Pa(so) {
			return ta(so) === "Int16Array"
		}
		ue.isInt16Array = Pa;

		function ja(so) {
			return ta(so) === "Int32Array"
		}
		ue.isInt32Array = ja;

		function Za(so) {
			return ta(so) === "Float32Array"
		}
		ue.isFloat32Array = Za;

		function Ga(so) {
			return ta(so) === "Float64Array"
		}
		ue.isFloat64Array = Ga;

		function Ja(so) {
			return ta(so) === "BigInt64Array"
		}
		ue.isBigInt64Array = Ja;

		function Ua(so) {
			return ta(so) === "BigUint64Array"
		}
		ue.isBigUint64Array = Ua;

		function xa(so) {
			return oa(so) === "[object Map]"
		}
		xa.working = typeof Map < "u" && xa(new Map);

		function ma(so) {
			return typeof Map > "u" ? !1 : xa.working ? xa(so) : so instanceof Map
		}
		ue.isMap = ma;

		function fa(so) {
			return oa(so) === "[object Set]"
		}
		fa.working = typeof Set < "u" && fa(new Set);

		function ga(so) {
			return typeof Set > "u" ? !1 : fa.working ? fa(so) : so instanceof Set
		}
		ue.isSet = ga;

		function wa(so) {
			return oa(so) === "[object WeakMap]"
		}
		wa.working = typeof WeakMap < "u" && wa(new WeakMap);

		function Ma(so) {
			return typeof WeakMap > "u" ? !1 : wa.working ? wa(so) : so instanceof WeakMap
		}
		ue.isWeakMap = Ma;

		function Aa(so) {
			return oa(so) === "[object WeakSet]"
		}
		Aa.working = typeof WeakSet < "u" && Aa(new WeakSet);

		function Ra(so) {
			return Aa(so)
		}
		ue.isWeakSet = Ra;

		function Ta(so) {
			return oa(so) === "[object ArrayBuffer]"
		}
		Ta.working = typeof ArrayBuffer < "u" && Ta(new ArrayBuffer);

		function La(so) {
			return typeof ArrayBuffer > "u" ? !1 : Ta.working ? Ta(so) : so instanceof ArrayBuffer
		}
		ue.isArrayBuffer = La;

		function ya(so) {
			return oa(so) === "[object DataView]"
		}
		ya.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ya(new DataView(new ArrayBuffer(1), 0, 1));

		function Ba(so) {
			return typeof DataView > "u" ? !1 : ya.working ? ya(so) : so instanceof DataView
		}
		ue.isDataView = Ba;
		var io = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;

		function oo(so) {
			return oa(so) === "[object SharedArrayBuffer]"
		}

		function ao(so) {
			return typeof io > "u" ? !1 : (typeof oo.working > "u" && (oo.working = oo(new io)), oo.working ? oo(so) : so instanceof io)
		}
		ue.isSharedArrayBuffer = ao;

		function Ia(so) {
			return oa(so) === "[object AsyncFunction]"
		}
		ue.isAsyncFunction = Ia;

		function Na(so) {
			return oa(so) === "[object Map Iterator]"
		}
		ue.isMapIterator = Na;

		function za(so) {
			return oa(so) === "[object Set Iterator]"
		}
		ue.isSetIterator = za;

		function ro(so) {
			return oa(so) === "[object Generator]"
		}
		ue.isGeneratorObject = ro;

		function Va(so) {
			return oa(so) === "[object WebAssembly.Module]"
		}
		ue.isWebAssemblyCompiledModule = Va;

		function Wa(so) {
			return ha(so, la)
		}
		ue.isNumberObject = Wa;

		function qa(so) {
			return ha(so, sa)
		}
		ue.isStringObject = qa;

		function Ka(so) {
			return ha(so, ca)
		}
		ue.isBooleanObject = Ka;

		function lo(so) {
			return ia && ha(so, ua)
		}
		ue.isBigIntObject = lo;

		function yo(so) {
			return aa && ha(so, da)
		}
		ue.isSymbolObject = yo;

		function fo(so) {
			return Wa(so) || qa(so) || Ka(so) || lo(so) || yo(so)
		}
		ue.isBoxedPrimitive = fo;

		function vo(so) {
			return typeof Uint8Array < "u" && (La(so) || ao(so))
		}
		ue.isAnyArrayBuffer = vo, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(so) {
			Object.defineProperty(ue, so, {
				enumerable: !1,
				value: function() {
					throw new Error(so + " is not supported in userland")
				}
			})
		})
	}(types)), types
}
var isBufferBrowser, hasRequiredIsBufferBrowser;

function requireIsBufferBrowser() {
	return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(Yi) {
		return Yi && typeof Yi == "object" && typeof Yi.copy == "function" && typeof Yi.fill == "function" && typeof Yi.readUInt8 == "function"
	}), isBufferBrowser
}
var hasRequiredUtil$1;

function requireUtil$1() {
	return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(ue) {
		var Yi = {},
			ea = Object.getOwnPropertyDescriptors || function(io) {
				for (var oo = Object.keys(io), ao = {}, Ia = 0; Ia < oo.length; Ia++) ao[oo[Ia]] = Object.getOwnPropertyDescriptor(io, oo[Ia]);
				return ao
			},
			ta = /%[sdj%]/g;
		ue.format = function(Ba) {
			if (!Pa(Ba)) {
				for (var io = [], oo = 0; oo < arguments.length; oo++) io.push(aa(arguments[oo]));
				return io.join(" ")
			}
			for (var oo = 1, ao = arguments, Ia = ao.length, Na = String(Ba).replace(ta, function(ro) {
					if (ro === "%%") return "%";
					if (oo >= Ia) return ro;
					switch (ro) {
						case "%s":
							return String(ao[oo++]);
						case "%d":
							return Number(ao[oo++]);
						case "%j":
							try {
								return JSON.stringify(ao[oo++])
							} catch {
								return "[Circular]"
							}
						default:
							return ro
					}
				}), za = ao[oo]; oo < Ia; za = ao[++oo]) Sa(za) || !Ja(za) ? Na += " " + za : Na += " " + aa(za);
			return Na
		}, ue.deprecate = function(Ba, io) {
			if (typeof process$1 < "u" && process$1.noDeprecation === !0) return Ba;
			if (typeof process$1 > "u") return function() {
				return ue.deprecate(Ba, io).apply(this, arguments)
			};
			var oo = !1;

			function ao() {
				if (!oo) {
					if (process$1.throwDeprecation) throw new Error(io);
					process$1.traceDeprecation ? console.trace(io) : console.error(io), oo = !0
				}
				return Ba.apply(this, arguments)
			}
			return ao
		};
		var na = {},
			ra = /^$/;
		if (Yi.NODE_DEBUG) {
			var ia = Yi.NODE_DEBUG;
			ia = ia.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ra = new RegExp("^" + ia + "$", "i")
		}
		ue.debuglog = function(Ba) {
			if (Ba = Ba.toUpperCase(), !na[Ba])
				if (ra.test(Ba)) {
					var io = process$1.pid;
					na[Ba] = function() {
						var oo = ue.format.apply(ue, arguments);
						console.error("%s %d: %s", Ba, io, oo)
					}
				} else na[Ba] = function() {};
			return na[Ba]
		};

		function aa(Ba, io) {
			var oo = {
				seen: [],
				stylize: la
			};
			return arguments.length >= 3 && (oo.depth = arguments[2]), arguments.length >= 4 && (oo.colors = arguments[3]), Ea(io) ? oo.showHidden = io : io && ue._extend(oo, io), Za(oo.showHidden) && (oo.showHidden = !1), Za(oo.depth) && (oo.depth = 2), Za(oo.colors) && (oo.colors = !1), Za(oo.customInspect) && (oo.customInspect = !0), oo.colors && (oo.stylize = oa), ca(oo, Ba, oo.depth)
		}
		ue.inspect = aa, aa.colors = {
			bold: [1, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			white: [37, 39],
			grey: [90, 39],
			black: [30, 39],
			blue: [34, 39],
			cyan: [36, 39],
			green: [32, 39],
			magenta: [35, 39],
			red: [31, 39],
			yellow: [33, 39]
		}, aa.styles = {
			special: "cyan",
			number: "yellow",
			boolean: "yellow",
			undefined: "grey",
			null: "bold",
			string: "green",
			date: "magenta",
			regexp: "red"
		};

		function oa(Ba, io) {
			var oo = aa.styles[io];
			return oo ? "\x1B[" + aa.colors[oo][0] + "m" + Ba + "\x1B[" + aa.colors[oo][1] + "m" : Ba
		}

		function la(Ba, io) {
			return Ba
		}

		function sa(Ba) {
			var io = {};
			return Ba.forEach(function(oo, ao) {
				io[oo] = !0
			}), io
		}

		function ca(Ba, io, oo) {
			if (Ba.customInspect && io && ma(io.inspect) && io.inspect !== ue.inspect && !(io.constructor && io.constructor.prototype === io)) {
				var ao = io.inspect(oo, Ba);
				return Pa(ao) || (ao = ca(Ba, ao, oo)), ao
			}
			var Ia = ua(Ba, io);
			if (Ia) return Ia;
			var Na = Object.keys(io),
				za = sa(Na);
			if (Ba.showHidden && (Na = Object.getOwnPropertyNames(io)), xa(io) && (Na.indexOf("message") >= 0 || Na.indexOf("description") >= 0)) return da(io);
			if (Na.length === 0) {
				if (ma(io)) {
					var ro = io.name ? ": " + io.name : "";
					return Ba.stylize("[Function" + ro + "]", "special")
				}
				if (Ga(io)) return Ba.stylize(RegExp.prototype.toString.call(io), "regexp");
				if (Ua(io)) return Ba.stylize(Date.prototype.toString.call(io), "date");
				if (xa(io)) return da(io)
			}
			var Va = "",
				Wa = !1,
				qa = ["{", "}"];
			if (ba(io) && (Wa = !0, qa = ["[", "]"]), ma(io)) {
				var Ka = io.name ? ": " + io.name : "";
				Va = " [Function" + Ka + "]"
			}
			if (Ga(io) && (Va = " " + RegExp.prototype.toString.call(io)), Ua(io) && (Va = " " + Date.prototype.toUTCString.call(io)), xa(io) && (Va = " " + da(io)), Na.length === 0 && (!Wa || io.length == 0)) return qa[0] + Va + qa[1];
			if (oo < 0) return Ga(io) ? Ba.stylize(RegExp.prototype.toString.call(io), "regexp") : Ba.stylize("[Object]", "special");
			Ba.seen.push(io);
			var lo;
			return Wa ? lo = ha(Ba, io, oo, za, Na) : lo = Na.map(function(yo) {
				return pa(Ba, io, oo, za, yo, Wa)
			}), Ba.seen.pop(), va(lo, Va, qa)
		}

		function ua(Ba, io) {
			if (Za(io)) return Ba.stylize("undefined", "undefined");
			if (Pa(io)) {
				var oo = "'" + JSON.stringify(io).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
				return Ba.stylize(oo, "string")
			}
			if (ka(io)) return Ba.stylize("" + io, "number");
			if (Ea(io)) return Ba.stylize("" + io, "boolean");
			if (Sa(io)) return Ba.stylize("null", "null")
		}

		function da(Ba) {
			return "[" + Error.prototype.toString.call(Ba) + "]"
		}

		function ha(Ba, io, oo, ao, Ia) {
			for (var Na = [], za = 0, ro = io.length; za < ro; ++za) Ra(io, String(za)) ? Na.push(pa(Ba, io, oo, ao, String(za), !0)) : Na.push("");
			return Ia.forEach(function(Va) {
				Va.match(/^\d+$/) || Na.push(pa(Ba, io, oo, ao, Va, !0))
			}), Na
		}

		function pa(Ba, io, oo, ao, Ia, Na) {
			var za, ro, Va;
			if (Va = Object.getOwnPropertyDescriptor(io, Ia) || {
					value: io[Ia]
				}, Va.get ? Va.set ? ro = Ba.stylize("[Getter/Setter]", "special") : ro = Ba.stylize("[Getter]", "special") : Va.set && (ro = Ba.stylize("[Setter]", "special")), Ra(ao, Ia) || (za = "[" + Ia + "]"), ro || (Ba.seen.indexOf(Va.value) < 0 ? (Sa(oo) ? ro = ca(Ba, Va.value, null) : ro = ca(Ba, Va.value, oo - 1), ro.indexOf(`
`) > -1 && (Na ? ro = ro.split(`
`).map(function(Wa) {
					return "  " + Wa
				}).join(`
`).slice(2) : ro = `
` + ro.split(`
`).map(function(Wa) {
					return "   " + Wa
				}).join(`
`))) : ro = Ba.stylize("[Circular]", "special")), Za(za)) {
				if (Na && Ia.match(/^\d+$/)) return ro;
				za = JSON.stringify("" + Ia), za.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (za = za.slice(1, -1), za = Ba.stylize(za, "name")) : (za = za.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), za = Ba.stylize(za, "string"))
			}
			return za + ": " + ro
		}

		function va(Ba, io, oo) {
			var ao = Ba.reduce(function(Ia, Na) {
				return Na.indexOf(`
`) >= 0, Ia + Na.replace(/\u001b\[\d\d?m/g, "").length + 1
			}, 0);
			return ao > 60 ? oo[0] + (io === "" ? "" : io + `
 `) + " " + Ba.join(`,
  `) + " " + oo[1] : oo[0] + io + " " + Ba.join(", ") + " " + oo[1]
		}
		ue.types = requireTypes();

		function ba(Ba) {
			return Array.isArray(Ba)
		}
		ue.isArray = ba;

		function Ea(Ba) {
			return typeof Ba == "boolean"
		}
		ue.isBoolean = Ea;

		function Sa(Ba) {
			return Ba === null
		}
		ue.isNull = Sa;

		function Ca(Ba) {
			return Ba == null
		}
		ue.isNullOrUndefined = Ca;

		function ka(Ba) {
			return typeof Ba == "number"
		}
		ue.isNumber = ka;

		function Pa(Ba) {
			return typeof Ba == "string"
		}
		ue.isString = Pa;

		function ja(Ba) {
			return typeof Ba == "symbol"
		}
		ue.isSymbol = ja;

		function Za(Ba) {
			return Ba === void 0
		}
		ue.isUndefined = Za;

		function Ga(Ba) {
			return Ja(Ba) && ga(Ba) === "[object RegExp]"
		}
		ue.isRegExp = Ga, ue.types.isRegExp = Ga;

		function Ja(Ba) {
			return typeof Ba == "object" && Ba !== null
		}
		ue.isObject = Ja;

		function Ua(Ba) {
			return Ja(Ba) && ga(Ba) === "[object Date]"
		}
		ue.isDate = Ua, ue.types.isDate = Ua;

		function xa(Ba) {
			return Ja(Ba) && (ga(Ba) === "[object Error]" || Ba instanceof Error)
		}
		ue.isError = xa, ue.types.isNativeError = xa;

		function ma(Ba) {
			return typeof Ba == "function"
		}
		ue.isFunction = ma;

		function fa(Ba) {
			return Ba === null || typeof Ba == "boolean" || typeof Ba == "number" || typeof Ba == "string" || typeof Ba == "symbol" || typeof Ba > "u"
		}
		ue.isPrimitive = fa, ue.isBuffer = requireIsBufferBrowser();

		function ga(Ba) {
			return Object.prototype.toString.call(Ba)
		}

		function wa(Ba) {
			return Ba < 10 ? "0" + Ba.toString(10) : Ba.toString(10)
		}
		var Ma = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

		function Aa() {
			var Ba = new Date,
				io = [wa(Ba.getHours()), wa(Ba.getMinutes()), wa(Ba.getSeconds())].join(":");
			return [Ba.getDate(), Ma[Ba.getMonth()], io].join(" ")
		}
		ue.log = function() {
			console.log("%s - %s", Aa(), ue.format.apply(ue, arguments))
		}, ue.inherits = requireInherits_browser(), ue._extend = function(Ba, io) {
			if (!io || !Ja(io)) return Ba;
			for (var oo = Object.keys(io), ao = oo.length; ao--;) Ba[oo[ao]] = io[oo[ao]];
			return Ba
		};

		function Ra(Ba, io) {
			return Object.prototype.hasOwnProperty.call(Ba, io)
		}
		var Ta = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
		ue.promisify = function(io) {
			if (typeof io != "function") throw new TypeError('The "original" argument must be of type Function');
			if (Ta && io[Ta]) {
				var oo = io[Ta];
				if (typeof oo != "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function');
				return Object.defineProperty(oo, Ta, {
					value: oo,
					enumerable: !1,
					writable: !1,
					configurable: !0
				}), oo
			}

			function oo() {
				for (var ao, Ia, Na = new Promise(function(Va, Wa) {
						ao = Va, Ia = Wa
					}), za = [], ro = 0; ro < arguments.length; ro++) za.push(arguments[ro]);
				za.push(function(Va, Wa) {
					Va ? Ia(Va) : ao(Wa)
				});
				try {
					io.apply(this, za)
				} catch (Va) {
					Ia(Va)
				}
				return Na
			}
			return Object.setPrototypeOf(oo, Object.getPrototypeOf(io)), Ta && Object.defineProperty(oo, Ta, {
				value: oo,
				enumerable: !1,
				writable: !1,
				configurable: !0
			}), Object.defineProperties(oo, ea(io))
		}, ue.promisify.custom = Ta;

		function La(Ba, io) {
			if (!Ba) {
				var oo = new Error("Promise was rejected with a falsy value");
				oo.reason = Ba, Ba = oo
			}
			return io(Ba)
		}

		function ya(Ba) {
			if (typeof Ba != "function") throw new TypeError('The "original" argument must be of type Function');

			function io() {
				for (var oo = [], ao = 0; ao < arguments.length; ao++) oo.push(arguments[ao]);
				var Ia = oo.pop();
				if (typeof Ia != "function") throw new TypeError("The last argument must be of type Function");
				var Na = this,
					za = function() {
						return Ia.apply(Na, arguments)
					};
				Ba.apply(this, oo).then(function(ro) {
					process$1.nextTick(za.bind(null, null, ro))
				}, function(ro) {
					process$1.nextTick(La.bind(null, ro, za))
				})
			}
			return Object.setPrototypeOf(io, Object.getPrototypeOf(Ba)), Object.defineProperties(io, ea(Ba)), io
		}
		ue.callbackify = ya
	}(util$1)), util$1
}
var buffer_list, hasRequiredBuffer_list;

function requireBuffer_list() {
	if (hasRequiredBuffer_list) return buffer_list;
	hasRequiredBuffer_list = 1;

	function ue(ha, pa) {
		var va = Object.keys(ha);
		if (Object.getOwnPropertySymbols) {
			var ba = Object.getOwnPropertySymbols(ha);
			pa && (ba = ba.filter(function(Ea) {
				return Object.getOwnPropertyDescriptor(ha, Ea).enumerable
			})), va.push.apply(va, ba)
		}
		return va
	}

	function Yi(ha) {
		for (var pa = 1; pa < arguments.length; pa++) {
			var va = arguments[pa] != null ? arguments[pa] : {};
			pa % 2 ? ue(Object(va), !0).forEach(function(ba) {
				ea(ha, ba, va[ba])
			}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ha, Object.getOwnPropertyDescriptors(va)) : ue(Object(va)).forEach(function(ba) {
				Object.defineProperty(ha, ba, Object.getOwnPropertyDescriptor(va, ba))
			})
		}
		return ha
	}

	function ea(ha, pa, va) {
		return pa = ia(pa), pa in ha ? Object.defineProperty(ha, pa, {
			value: va,
			enumerable: !0,
			configurable: !0,
			writable: !0
		}) : ha[pa] = va, ha
	}

	function ta(ha, pa) {
		if (!(ha instanceof pa)) throw new TypeError("Cannot call a class as a function")
	}

	function na(ha, pa) {
		for (var va = 0; va < pa.length; va++) {
			var ba = pa[va];
			ba.enumerable = ba.enumerable || !1, ba.configurable = !0, "value" in ba && (ba.writable = !0), Object.defineProperty(ha, ia(ba.key), ba)
		}
	}

	function ra(ha, pa, va) {
		return pa && na(ha.prototype, pa), Object.defineProperty(ha, "prototype", {
			writable: !1
		}), ha
	}

	function ia(ha) {
		var pa = aa(ha, "string");
		return typeof pa == "symbol" ? pa : String(pa)
	}

	function aa(ha, pa) {
		if (typeof ha != "object" || ha === null) return ha;
		var va = ha[Symbol.toPrimitive];
		if (va !== void 0) {
			var ba = va.call(ha, pa || "default");
			if (typeof ba != "object") return ba;
			throw new TypeError("@@toPrimitive must return a primitive value.")
		}
		return (pa === "string" ? String : Number)(ha)
	}
	var oa = require$$1$2,
		la = oa.Buffer,
		sa = requireUtil$1(),
		ca = sa.inspect,
		ua = ca && ca.custom || "inspect";

	function da(ha, pa, va) {
		la.prototype.copy.call(ha, pa, va)
	}
	return buffer_list = function() {
		function ha() {
			ta(this, ha), this.head = null, this.tail = null, this.length = 0
		}
		return ra(ha, [{
			key: "push",
			value: function(va) {
				var ba = {
					data: va,
					next: null
				};
				this.length > 0 ? this.tail.next = ba : this.head = ba, this.tail = ba, ++this.length
			}
		}, {
			key: "unshift",
			value: function(va) {
				var ba = {
					data: va,
					next: this.head
				};
				this.length === 0 && (this.tail = ba), this.head = ba, ++this.length
			}
		}, {
			key: "shift",
			value: function() {
				if (this.length !== 0) {
					var va = this.head.data;
					return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, va
				}
			}
		}, {
			key: "clear",
			value: function() {
				this.head = this.tail = null, this.length = 0
			}
		}, {
			key: "join",
			value: function(va) {
				if (this.length === 0) return "";
				for (var ba = this.head, Ea = "" + ba.data; ba = ba.next;) Ea += va + ba.data;
				return Ea
			}
		}, {
			key: "concat",
			value: function(va) {
				if (this.length === 0) return la.alloc(0);
				for (var ba = la.allocUnsafe(va >>> 0), Ea = this.head, Sa = 0; Ea;) da(Ea.data, ba, Sa), Sa += Ea.data.length, Ea = Ea.next;
				return ba
			}
		}, {
			key: "consume",
			value: function(va, ba) {
				var Ea;
				return va < this.head.data.length ? (Ea = this.head.data.slice(0, va), this.head.data = this.head.data.slice(va)) : va === this.head.data.length ? Ea = this.shift() : Ea = ba ? this._getString(va) : this._getBuffer(va), Ea
			}
		}, {
			key: "first",
			value: function() {
				return this.head.data
			}
		}, {
			key: "_getString",
			value: function(va) {
				var ba = this.head,
					Ea = 1,
					Sa = ba.data;
				for (va -= Sa.length; ba = ba.next;) {
					var Ca = ba.data,
						ka = va > Ca.length ? Ca.length : va;
					if (ka === Ca.length ? Sa += Ca : Sa += Ca.slice(0, va), va -= ka, va === 0) {
						ka === Ca.length ? (++Ea, ba.next ? this.head = ba.next : this.head = this.tail = null) : (this.head = ba, ba.data = Ca.slice(ka));
						break
					}++Ea
				}
				return this.length -= Ea, Sa
			}
		}, {
			key: "_getBuffer",
			value: function(va) {
				var ba = la.allocUnsafe(va),
					Ea = this.head,
					Sa = 1;
				for (Ea.data.copy(ba), va -= Ea.data.length; Ea = Ea.next;) {
					var Ca = Ea.data,
						ka = va > Ca.length ? Ca.length : va;
					if (Ca.copy(ba, ba.length - va, 0, ka), va -= ka, va === 0) {
						ka === Ca.length ? (++Sa, Ea.next ? this.head = Ea.next : this.head = this.tail = null) : (this.head = Ea, Ea.data = Ca.slice(ka));
						break
					}++Sa
				}
				return this.length -= Sa, ba
			}
		}, {
			key: ua,
			value: function(va, ba) {
				return ca(this, Yi(Yi({}, ba), {}, {
					depth: 0,
					customInspect: !1
				}))
			}
		}]), ha
	}(), buffer_list
}
var destroy_1$1, hasRequiredDestroy$1;

function requireDestroy$1() {
	if (hasRequiredDestroy$1) return destroy_1$1;
	hasRequiredDestroy$1 = 1;

	function ue(ia, aa) {
		var oa = this,
			la = this._readableState && this._readableState.destroyed,
			sa = this._writableState && this._writableState.destroyed;
		return la || sa ? (aa ? aa(ia) : ia && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(na, this, ia)) : process$1.nextTick(na, this, ia)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(ia || null, function(ca) {
			!aa && ca ? oa._writableState ? oa._writableState.errorEmitted ? process$1.nextTick(ea, oa) : (oa._writableState.errorEmitted = !0, process$1.nextTick(Yi, oa, ca)) : process$1.nextTick(Yi, oa, ca) : aa ? (process$1.nextTick(ea, oa), aa(ca)) : process$1.nextTick(ea, oa)
		}), this)
	}

	function Yi(ia, aa) {
		na(ia, aa), ea(ia)
	}

	function ea(ia) {
		ia._writableState && !ia._writableState.emitClose || ia._readableState && !ia._readableState.emitClose || ia.emit("close")
	}

	function ta() {
		this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1)
	}

	function na(ia, aa) {
		ia.emit("error", aa)
	}

	function ra(ia, aa) {
		var oa = ia._readableState,
			la = ia._writableState;
		oa && oa.autoDestroy || la && la.autoDestroy ? ia.destroy(aa) : ia.emit("error", aa)
	}
	return destroy_1$1 = {
		destroy: ue,
		undestroy: ta,
		errorOrDestroy: ra
	}, destroy_1$1
}
var errorsBrowser = {},
	hasRequiredErrorsBrowser;

function requireErrorsBrowser() {
	if (hasRequiredErrorsBrowser) return errorsBrowser;
	hasRequiredErrorsBrowser = 1;

	function ue(aa, oa) {
		aa.prototype = Object.create(oa.prototype), aa.prototype.constructor = aa, aa.__proto__ = oa
	}
	var Yi = {};

	function ea(aa, oa, la) {
		la || (la = Error);

		function sa(ua, da, ha) {
			return typeof oa == "string" ? oa : oa(ua, da, ha)
		}
		var ca = function(ua) {
			ue(da, ua);

			function da(ha, pa, va) {
				return ua.call(this, sa(ha, pa, va)) || this
			}
			return da
		}(la);
		ca.prototype.name = la.name, ca.prototype.code = aa, Yi[aa] = ca
	}

	function ta(aa, oa) {
		if (Array.isArray(aa)) {
			var la = aa.length;
			return aa = aa.map(function(sa) {
				return String(sa)
			}), la > 2 ? "one of ".concat(oa, " ").concat(aa.slice(0, la - 1).join(", "), ", or ") + aa[la - 1] : la === 2 ? "one of ".concat(oa, " ").concat(aa[0], " or ").concat(aa[1]) : "of ".concat(oa, " ").concat(aa[0])
		} else return "of ".concat(oa, " ").concat(String(aa))
	}

	function na(aa, oa, la) {
		return aa.substr(0, oa.length) === oa
	}

	function ra(aa, oa, la) {
		return (la === void 0 || la > aa.length) && (la = aa.length), aa.substring(la - oa.length, la) === oa
	}

	function ia(aa, oa, la) {
		return typeof la != "number" && (la = 0), la + oa.length > aa.length ? !1 : aa.indexOf(oa, la) !== -1
	}
	return ea("ERR_INVALID_OPT_VALUE", function(aa, oa) {
		return 'The value "' + oa + '" is invalid for option "' + aa + '"'
	}, TypeError), ea("ERR_INVALID_ARG_TYPE", function(aa, oa, la) {
		var sa;
		typeof oa == "string" && na(oa, "not ") ? (sa = "must not be", oa = oa.replace(/^not /, "")) : sa = "must be";
		var ca;
		if (ra(aa, " argument")) ca = "The ".concat(aa, " ").concat(sa, " ").concat(ta(oa, "type"));
		else {
			var ua = ia(aa, ".") ? "property" : "argument";
			ca = 'The "'.concat(aa, '" ').concat(ua, " ").concat(sa, " ").concat(ta(oa, "type"))
		}
		return ca += ". Received type ".concat(typeof la), ca
	}, TypeError), ea("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), ea("ERR_METHOD_NOT_IMPLEMENTED", function(aa) {
		return "The " + aa + " method is not implemented"
	}), ea("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), ea("ERR_STREAM_DESTROYED", function(aa) {
		return "Cannot call " + aa + " after a stream was destroyed"
	}), ea("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), ea("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), ea("ERR_STREAM_WRITE_AFTER_END", "write after end"), ea("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), ea("ERR_UNKNOWN_ENCODING", function(aa) {
		return "Unknown encoding: " + aa
	}, TypeError), ea("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = Yi, errorsBrowser
}
var state, hasRequiredState;

function requireState() {
	if (hasRequiredState) return state;
	hasRequiredState = 1;
	var ue = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;

	function Yi(ta, na, ra) {
		return ta.highWaterMark != null ? ta.highWaterMark : na ? ta[ra] : null
	}

	function ea(ta, na, ra, ia) {
		var aa = Yi(na, ia, ra);
		if (aa != null) {
			if (!(isFinite(aa) && Math.floor(aa) === aa) || aa < 0) {
				var oa = ia ? ra : "highWaterMark";
				throw new ue(oa, aa)
			}
			return Math.floor(aa)
		}
		return ta.objectMode ? 16 : 16 * 1024
	}
	return state = {
		getHighWaterMark: ea
	}, state
}
var browser$a, hasRequiredBrowser$a;

function requireBrowser$a() {
	if (hasRequiredBrowser$a) return browser$a;
	hasRequiredBrowser$a = 1, browser$a = ue;

	function ue(ea, ta) {
		if (Yi("noDeprecation")) return ea;
		var na = !1;

		function ra() {
			if (!na) {
				if (Yi("throwDeprecation")) throw new Error(ta);
				Yi("traceDeprecation") ? console.trace(ta) : console.warn(ta), na = !0
			}
			return ea.apply(this, arguments)
		}
		return ra
	}

	function Yi(ea) {
		try {
			if (!commonjsGlobal.localStorage) return !1
		} catch {
			return !1
		}
		var ta = commonjsGlobal.localStorage[ea];
		return ta == null ? !1 : String(ta).toLowerCase() === "true"
	}
	return browser$a
}
var _stream_writable$1, hasRequired_stream_writable$1;

function require_stream_writable$1() {
	if (hasRequired_stream_writable$1) return _stream_writable$1;
	hasRequired_stream_writable$1 = 1, _stream_writable$1 = Za;

	function ue(ao) {
		var Ia = this;
		this.next = null, this.entry = null, this.finish = function() {
			oo(Ia, ao)
		}
	}
	var Yi;
	Za.WritableState = Pa;
	var ea = {
			deprecate: requireBrowser$a()
		},
		ta = requireStreamBrowser$1(),
		na = require$$1$2.Buffer,
		ra = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};

	function ia(ao) {
		return na.from(ao)
	}

	function aa(ao) {
		return na.isBuffer(ao) || ao instanceof ra
	}
	var oa = requireDestroy$1(),
		la = requireState(),
		sa = la.getHighWaterMark,
		ca = requireErrorsBrowser().codes,
		ua = ca.ERR_INVALID_ARG_TYPE,
		da = ca.ERR_METHOD_NOT_IMPLEMENTED,
		ha = ca.ERR_MULTIPLE_CALLBACK,
		pa = ca.ERR_STREAM_CANNOT_PIPE,
		va = ca.ERR_STREAM_DESTROYED,
		ba = ca.ERR_STREAM_NULL_VALUES,
		Ea = ca.ERR_STREAM_WRITE_AFTER_END,
		Sa = ca.ERR_UNKNOWN_ENCODING,
		Ca = oa.errorOrDestroy;
	requireInherits_browser()(Za, ta);

	function ka() {}

	function Pa(ao, Ia, Na) {
		Yi = Yi || require_stream_duplex$1(), ao = ao || {}, typeof Na != "boolean" && (Na = Ia instanceof Yi), this.objectMode = !!ao.objectMode, Na && (this.objectMode = this.objectMode || !!ao.writableObjectMode), this.highWaterMark = sa(this, ao, "writableHighWaterMark", Na), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
		var za = ao.decodeStrings === !1;
		this.decodeStrings = !za, this.defaultEncoding = ao.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ro) {
			wa(Ia, ro)
		}, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ao.emitClose !== !1, this.autoDestroy = !!ao.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new ue(this)
	}
	Pa.prototype.getBuffer = function() {
			for (var Ia = this.bufferedRequest, Na = []; Ia;) Na.push(Ia), Ia = Ia.next;
			return Na
		},
		function() {
			try {
				Object.defineProperty(Pa.prototype, "buffer", {
					get: ea.deprecate(function() {
						return this.getBuffer()
					}, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
				})
			} catch {}
		}();
	var ja;
	typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ja = Function.prototype[Symbol.hasInstance], Object.defineProperty(Za, Symbol.hasInstance, {
		value: function(Ia) {
			return ja.call(this, Ia) ? !0 : this !== Za ? !1 : Ia && Ia._writableState instanceof Pa
		}
	})) : ja = function(Ia) {
		return Ia instanceof this
	};

	function Za(ao) {
		Yi = Yi || require_stream_duplex$1();
		var Ia = this instanceof Yi;
		if (!Ia && !ja.call(Za, this)) return new Za(ao);
		this._writableState = new Pa(ao, this, Ia), this.writable = !0, ao && (typeof ao.write == "function" && (this._write = ao.write), typeof ao.writev == "function" && (this._writev = ao.writev), typeof ao.destroy == "function" && (this._destroy = ao.destroy), typeof ao.final == "function" && (this._final = ao.final)), ta.call(this)
	}
	Za.prototype.pipe = function() {
		Ca(this, new pa)
	};

	function Ga(ao, Ia) {
		var Na = new Ea;
		Ca(ao, Na), process$1.nextTick(Ia, Na)
	}

	function Ja(ao, Ia, Na, za) {
		var ro;
		return Na === null ? ro = new ba : typeof Na != "string" && !Ia.objectMode && (ro = new ua("chunk", ["string", "Buffer"], Na)), ro ? (Ca(ao, ro), process$1.nextTick(za, ro), !1) : !0
	}
	Za.prototype.write = function(ao, Ia, Na) {
		var za = this._writableState,
			ro = !1,
			Va = !za.objectMode && aa(ao);
		return Va && !na.isBuffer(ao) && (ao = ia(ao)), typeof Ia == "function" && (Na = Ia, Ia = null), Va ? Ia = "buffer" : Ia || (Ia = za.defaultEncoding), typeof Na != "function" && (Na = ka), za.ending ? Ga(this, Na) : (Va || Ja(this, za, ao, Na)) && (za.pendingcb++, ro = xa(this, za, Va, ao, Ia, Na)), ro
	}, Za.prototype.cork = function() {
		this._writableState.corked++
	}, Za.prototype.uncork = function() {
		var ao = this._writableState;
		ao.corked && (ao.corked--, !ao.writing && !ao.corked && !ao.bufferProcessing && ao.bufferedRequest && Ra(this, ao))
	}, Za.prototype.setDefaultEncoding = function(Ia) {
		if (typeof Ia == "string" && (Ia = Ia.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Ia + "").toLowerCase()) > -1)) throw new Sa(Ia);
		return this._writableState.defaultEncoding = Ia, this
	}, Object.defineProperty(Za.prototype, "writableBuffer", {
		enumerable: !1,
		get: function() {
			return this._writableState && this._writableState.getBuffer()
		}
	});

	function Ua(ao, Ia, Na) {
		return !ao.objectMode && ao.decodeStrings !== !1 && typeof Ia == "string" && (Ia = na.from(Ia, Na)), Ia
	}
	Object.defineProperty(Za.prototype, "writableHighWaterMark", {
		enumerable: !1,
		get: function() {
			return this._writableState.highWaterMark
		}
	});

	function xa(ao, Ia, Na, za, ro, Va) {
		if (!Na) {
			var Wa = Ua(Ia, za, ro);
			za !== Wa && (Na = !0, ro = "buffer", za = Wa)
		}
		var qa = Ia.objectMode ? 1 : za.length;
		Ia.length += qa;
		var Ka = Ia.length < Ia.highWaterMark;
		if (Ka || (Ia.needDrain = !0), Ia.writing || Ia.corked) {
			var lo = Ia.lastBufferedRequest;
			Ia.lastBufferedRequest = {
				chunk: za,
				encoding: ro,
				isBuf: Na,
				callback: Va,
				next: null
			}, lo ? lo.next = Ia.lastBufferedRequest : Ia.bufferedRequest = Ia.lastBufferedRequest, Ia.bufferedRequestCount += 1
		} else ma(ao, Ia, !1, qa, za, ro, Va);
		return Ka
	}

	function ma(ao, Ia, Na, za, ro, Va, Wa) {
		Ia.writelen = za, Ia.writecb = Wa, Ia.writing = !0, Ia.sync = !0, Ia.destroyed ? Ia.onwrite(new va("write")) : Na ? ao._writev(ro, Ia.onwrite) : ao._write(ro, Va, Ia.onwrite), Ia.sync = !1
	}

	function fa(ao, Ia, Na, za, ro) {
		--Ia.pendingcb, Na ? (process$1.nextTick(ro, za), process$1.nextTick(Ba, ao, Ia), ao._writableState.errorEmitted = !0, Ca(ao, za)) : (ro(za), ao._writableState.errorEmitted = !0, Ca(ao, za), Ba(ao, Ia))
	}

	function ga(ao) {
		ao.writing = !1, ao.writecb = null, ao.length -= ao.writelen, ao.writelen = 0
	}

	function wa(ao, Ia) {
		var Na = ao._writableState,
			za = Na.sync,
			ro = Na.writecb;
		if (typeof ro != "function") throw new ha;
		if (ga(Na), Ia) fa(ao, Na, za, Ia, ro);
		else {
			var Va = Ta(Na) || ao.destroyed;
			!Va && !Na.corked && !Na.bufferProcessing && Na.bufferedRequest && Ra(ao, Na), za ? process$1.nextTick(Ma, ao, Na, Va, ro) : Ma(ao, Na, Va, ro)
		}
	}

	function Ma(ao, Ia, Na, za) {
		Na || Aa(ao, Ia), Ia.pendingcb--, za(), Ba(ao, Ia)
	}

	function Aa(ao, Ia) {
		Ia.length === 0 && Ia.needDrain && (Ia.needDrain = !1, ao.emit("drain"))
	}

	function Ra(ao, Ia) {
		Ia.bufferProcessing = !0;
		var Na = Ia.bufferedRequest;
		if (ao._writev && Na && Na.next) {
			var za = Ia.bufferedRequestCount,
				ro = new Array(za),
				Va = Ia.corkedRequestsFree;
			Va.entry = Na;
			for (var Wa = 0, qa = !0; Na;) ro[Wa] = Na, Na.isBuf || (qa = !1), Na = Na.next, Wa += 1;
			ro.allBuffers = qa, ma(ao, Ia, !0, Ia.length, ro, "", Va.finish), Ia.pendingcb++, Ia.lastBufferedRequest = null, Va.next ? (Ia.corkedRequestsFree = Va.next, Va.next = null) : Ia.corkedRequestsFree = new ue(Ia), Ia.bufferedRequestCount = 0
		} else {
			for (; Na;) {
				var Ka = Na.chunk,
					lo = Na.encoding,
					yo = Na.callback,
					fo = Ia.objectMode ? 1 : Ka.length;
				if (ma(ao, Ia, !1, fo, Ka, lo, yo), Na = Na.next, Ia.bufferedRequestCount--, Ia.writing) break
			}
			Na === null && (Ia.lastBufferedRequest = null)
		}
		Ia.bufferedRequest = Na, Ia.bufferProcessing = !1
	}
	Za.prototype._write = function(ao, Ia, Na) {
		Na(new da("_write()"))
	}, Za.prototype._writev = null, Za.prototype.end = function(ao, Ia, Na) {
		var za = this._writableState;
		return typeof ao == "function" ? (Na = ao, ao = null, Ia = null) : typeof Ia == "function" && (Na = Ia, Ia = null), ao != null && this.write(ao, Ia), za.corked && (za.corked = 1, this.uncork()), za.ending || io(this, za, Na), this
	}, Object.defineProperty(Za.prototype, "writableLength", {
		enumerable: !1,
		get: function() {
			return this._writableState.length
		}
	});

	function Ta(ao) {
		return ao.ending && ao.length === 0 && ao.bufferedRequest === null && !ao.finished && !ao.writing
	}

	function La(ao, Ia) {
		ao._final(function(Na) {
			Ia.pendingcb--, Na && Ca(ao, Na), Ia.prefinished = !0, ao.emit("prefinish"), Ba(ao, Ia)
		})
	}

	function ya(ao, Ia) {
		!Ia.prefinished && !Ia.finalCalled && (typeof ao._final == "function" && !Ia.destroyed ? (Ia.pendingcb++, Ia.finalCalled = !0, process$1.nextTick(La, ao, Ia)) : (Ia.prefinished = !0, ao.emit("prefinish")))
	}

	function Ba(ao, Ia) {
		var Na = Ta(Ia);
		if (Na && (ya(ao, Ia), Ia.pendingcb === 0 && (Ia.finished = !0, ao.emit("finish"), Ia.autoDestroy))) {
			var za = ao._readableState;
			(!za || za.autoDestroy && za.endEmitted) && ao.destroy()
		}
		return Na
	}

	function io(ao, Ia, Na) {
		Ia.ending = !0, Ba(ao, Ia), Na && (Ia.finished ? process$1.nextTick(Na) : ao.once("finish", Na)), Ia.ended = !0, ao.writable = !1
	}

	function oo(ao, Ia, Na) {
		var za = ao.entry;
		for (ao.entry = null; za;) {
			var ro = za.callback;
			Ia.pendingcb--, ro(Na), za = za.next
		}
		Ia.corkedRequestsFree.next = ao
	}
	return Object.defineProperty(Za.prototype, "destroyed", {
		enumerable: !1,
		get: function() {
			return this._writableState === void 0 ? !1 : this._writableState.destroyed
		},
		set: function(Ia) {
			this._writableState && (this._writableState.destroyed = Ia)
		}
	}), Za.prototype.destroy = oa.destroy, Za.prototype._undestroy = oa.undestroy, Za.prototype._destroy = function(ao, Ia) {
		Ia(ao)
	}, _stream_writable$1
}
var _stream_duplex$1, hasRequired_stream_duplex$1;

function require_stream_duplex$1() {
	if (hasRequired_stream_duplex$1) return _stream_duplex$1;
	hasRequired_stream_duplex$1 = 1;
	var ue = Object.keys || function(la) {
		var sa = [];
		for (var ca in la) sa.push(ca);
		return sa
	};
	_stream_duplex$1 = ia;
	var Yi = require_stream_readable$1(),
		ea = require_stream_writable$1();
	requireInherits_browser()(ia, Yi);
	for (var ta = ue(ea.prototype), na = 0; na < ta.length; na++) {
		var ra = ta[na];
		ia.prototype[ra] || (ia.prototype[ra] = ea.prototype[ra])
	}

	function ia(la) {
		if (!(this instanceof ia)) return new ia(la);
		Yi.call(this, la), ea.call(this, la), this.allowHalfOpen = !0, la && (la.readable === !1 && (this.readable = !1), la.writable === !1 && (this.writable = !1), la.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", aa)))
	}
	Object.defineProperty(ia.prototype, "writableHighWaterMark", {
		enumerable: !1,
		get: function() {
			return this._writableState.highWaterMark
		}
	}), Object.defineProperty(ia.prototype, "writableBuffer", {
		enumerable: !1,
		get: function() {
			return this._writableState && this._writableState.getBuffer()
		}
	}), Object.defineProperty(ia.prototype, "writableLength", {
		enumerable: !1,
		get: function() {
			return this._writableState.length
		}
	});

	function aa() {
		this._writableState.ended || process$1.nextTick(oa, this)
	}

	function oa(la) {
		la.end()
	}
	return Object.defineProperty(ia.prototype, "destroyed", {
		enumerable: !1,
		get: function() {
			return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed
		},
		set: function(sa) {
			this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = sa, this._writableState.destroyed = sa)
		}
	}), _stream_duplex$1
}
var string_decoder = {},
	hasRequiredString_decoder;

function requireString_decoder() {
	if (hasRequiredString_decoder) return string_decoder;
	hasRequiredString_decoder = 1;
	var ue = requireSafeBuffer$1().Buffer,
		Yi = ue.isEncoding || function(ba) {
			switch (ba = "" + ba, ba && ba.toLowerCase()) {
				case "hex":
				case "utf8":
				case "utf-8":
				case "ascii":
				case "binary":
				case "base64":
				case "ucs2":
				case "ucs-2":
				case "utf16le":
				case "utf-16le":
				case "raw":
					return !0;
				default:
					return !1
			}
		};

	function ea(ba) {
		if (!ba) return "utf8";
		for (var Ea;;) switch (ba) {
			case "utf8":
			case "utf-8":
				return "utf8";
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le":
				return "utf16le";
			case "latin1":
			case "binary":
				return "latin1";
			case "base64":
			case "ascii":
			case "hex":
				return ba;
			default:
				if (Ea) return;
				ba = ("" + ba).toLowerCase(), Ea = !0
		}
	}

	function ta(ba) {
		var Ea = ea(ba);
		if (typeof Ea != "string" && (ue.isEncoding === Yi || !Yi(ba))) throw new Error("Unknown encoding: " + ba);
		return Ea || ba
	}
	string_decoder.StringDecoder = na;

	function na(ba) {
		this.encoding = ta(ba);
		var Ea;
		switch (this.encoding) {
			case "utf16le":
				this.text = ca, this.end = ua, Ea = 4;
				break;
			case "utf8":
				this.fillLast = oa, Ea = 4;
				break;
			case "base64":
				this.text = da, this.end = ha, Ea = 3;
				break;
			default:
				this.write = pa, this.end = va;
				return
		}
		this.lastNeed = 0, this.lastTotal = 0, this.lastChar = ue.allocUnsafe(Ea)
	}
	na.prototype.write = function(ba) {
		if (ba.length === 0) return "";
		var Ea, Sa;
		if (this.lastNeed) {
			if (Ea = this.fillLast(ba), Ea === void 0) return "";
			Sa = this.lastNeed, this.lastNeed = 0
		} else Sa = 0;
		return Sa < ba.length ? Ea ? Ea + this.text(ba, Sa) : this.text(ba, Sa) : Ea || ""
	}, na.prototype.end = sa, na.prototype.text = la, na.prototype.fillLast = function(ba) {
		if (this.lastNeed <= ba.length) return ba.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
		ba.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, ba.length), this.lastNeed -= ba.length
	};

	function ra(ba) {
		return ba <= 127 ? 0 : ba >> 5 === 6 ? 2 : ba >> 4 === 14 ? 3 : ba >> 3 === 30 ? 4 : ba >> 6 === 2 ? -1 : -2
	}

	function ia(ba, Ea, Sa) {
		var Ca = Ea.length - 1;
		if (Ca < Sa) return 0;
		var ka = ra(Ea[Ca]);
		return ka >= 0 ? (ka > 0 && (ba.lastNeed = ka - 1), ka) : --Ca < Sa || ka === -2 ? 0 : (ka = ra(Ea[Ca]), ka >= 0 ? (ka > 0 && (ba.lastNeed = ka - 2), ka) : --Ca < Sa || ka === -2 ? 0 : (ka = ra(Ea[Ca]), ka >= 0 ? (ka > 0 && (ka === 2 ? ka = 0 : ba.lastNeed = ka - 3), ka) : 0))
	}

	function aa(ba, Ea, Sa) {
		if ((Ea[0] & 192) !== 128) return ba.lastNeed = 0, "�";
		if (ba.lastNeed > 1 && Ea.length > 1) {
			if ((Ea[1] & 192) !== 128) return ba.lastNeed = 1, "�";
			if (ba.lastNeed > 2 && Ea.length > 2 && (Ea[2] & 192) !== 128) return ba.lastNeed = 2, "�"
		}
	}

	function oa(ba) {
		var Ea = this.lastTotal - this.lastNeed,
			Sa = aa(this, ba);
		if (Sa !== void 0) return Sa;
		if (this.lastNeed <= ba.length) return ba.copy(this.lastChar, Ea, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
		ba.copy(this.lastChar, Ea, 0, ba.length), this.lastNeed -= ba.length
	}

	function la(ba, Ea) {
		var Sa = ia(this, ba, Ea);
		if (!this.lastNeed) return ba.toString("utf8", Ea);
		this.lastTotal = Sa;
		var Ca = ba.length - (Sa - this.lastNeed);
		return ba.copy(this.lastChar, 0, Ca), ba.toString("utf8", Ea, Ca)
	}

	function sa(ba) {
		var Ea = ba && ba.length ? this.write(ba) : "";
		return this.lastNeed ? Ea + "�" : Ea
	}

	function ca(ba, Ea) {
		if ((ba.length - Ea) % 2 === 0) {
			var Sa = ba.toString("utf16le", Ea);
			if (Sa) {
				var Ca = Sa.charCodeAt(Sa.length - 1);
				if (Ca >= 55296 && Ca <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = ba[ba.length - 2], this.lastChar[1] = ba[ba.length - 1], Sa.slice(0, -1)
			}
			return Sa
		}
		return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = ba[ba.length - 1], ba.toString("utf16le", Ea, ba.length - 1)
	}

	function ua(ba) {
		var Ea = ba && ba.length ? this.write(ba) : "";
		if (this.lastNeed) {
			var Sa = this.lastTotal - this.lastNeed;
			return Ea + this.lastChar.toString("utf16le", 0, Sa)
		}
		return Ea
	}

	function da(ba, Ea) {
		var Sa = (ba.length - Ea) % 3;
		return Sa === 0 ? ba.toString("base64", Ea) : (this.lastNeed = 3 - Sa, this.lastTotal = 3, Sa === 1 ? this.lastChar[0] = ba[ba.length - 1] : (this.lastChar[0] = ba[ba.length - 2], this.lastChar[1] = ba[ba.length - 1]), ba.toString("base64", Ea, ba.length - Sa))
	}

	function ha(ba) {
		var Ea = ba && ba.length ? this.write(ba) : "";
		return this.lastNeed ? Ea + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : Ea
	}

	function pa(ba) {
		return ba.toString(this.encoding)
	}

	function va(ba) {
		return ba && ba.length ? this.write(ba) : ""
	}
	return string_decoder
}
var endOfStream, hasRequiredEndOfStream;

function requireEndOfStream() {
	if (hasRequiredEndOfStream) return endOfStream;
	hasRequiredEndOfStream = 1;
	var ue = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;

	function Yi(ra) {
		var ia = !1;
		return function() {
			if (!ia) {
				ia = !0;
				for (var aa = arguments.length, oa = new Array(aa), la = 0; la < aa; la++) oa[la] = arguments[la];
				ra.apply(this, oa)
			}
		}
	}

	function ea() {}

	function ta(ra) {
		return ra.setHeader && typeof ra.abort == "function"
	}

	function na(ra, ia, aa) {
		if (typeof ia == "function") return na(ra, null, ia);
		ia || (ia = {}), aa = Yi(aa || ea);
		var oa = ia.readable || ia.readable !== !1 && ra.readable,
			la = ia.writable || ia.writable !== !1 && ra.writable,
			sa = function() {
				ra.writable || ua()
			},
			ca = ra._writableState && ra._writableState.finished,
			ua = function() {
				la = !1, ca = !0, oa || aa.call(ra)
			},
			da = ra._readableState && ra._readableState.endEmitted,
			ha = function() {
				oa = !1, da = !0, la || aa.call(ra)
			},
			pa = function(Sa) {
				aa.call(ra, Sa)
			},
			va = function() {
				var Sa;
				if (oa && !da) return (!ra._readableState || !ra._readableState.ended) && (Sa = new ue), aa.call(ra, Sa);
				if (la && !ca) return (!ra._writableState || !ra._writableState.ended) && (Sa = new ue), aa.call(ra, Sa)
			},
			ba = function() {
				ra.req.on("finish", ua)
			};
		return ta(ra) ? (ra.on("complete", ua), ra.on("abort", va), ra.req ? ba() : ra.on("request", ba)) : la && !ra._writableState && (ra.on("end", sa), ra.on("close", sa)), ra.on("end", ha), ra.on("finish", ua), ia.error !== !1 && ra.on("error", pa), ra.on("close", va),
			function() {
				ra.removeListener("complete", ua), ra.removeListener("abort", va), ra.removeListener("request", ba), ra.req && ra.req.removeListener("finish", ua), ra.removeListener("end", sa), ra.removeListener("close", sa), ra.removeListener("finish", ua), ra.removeListener("end", ha), ra.removeListener("error", pa), ra.removeListener("close", va)
			}
	}
	return endOfStream = na, endOfStream
}
var async_iterator, hasRequiredAsync_iterator;

function requireAsync_iterator() {
	if (hasRequiredAsync_iterator) return async_iterator;
	hasRequiredAsync_iterator = 1;
	var ue;

	function Yi(Sa, Ca, ka) {
		return Ca = ea(Ca), Ca in Sa ? Object.defineProperty(Sa, Ca, {
			value: ka,
			enumerable: !0,
			configurable: !0,
			writable: !0
		}) : Sa[Ca] = ka, Sa
	}

	function ea(Sa) {
		var Ca = ta(Sa, "string");
		return typeof Ca == "symbol" ? Ca : String(Ca)
	}

	function ta(Sa, Ca) {
		if (typeof Sa != "object" || Sa === null) return Sa;
		var ka = Sa[Symbol.toPrimitive];
		if (ka !== void 0) {
			var Pa = ka.call(Sa, Ca || "default");
			if (typeof Pa != "object") return Pa;
			throw new TypeError("@@toPrimitive must return a primitive value.")
		}
		return (Ca === "string" ? String : Number)(Sa)
	}
	var na = requireEndOfStream(),
		ra = Symbol("lastResolve"),
		ia = Symbol("lastReject"),
		aa = Symbol("error"),
		oa = Symbol("ended"),
		la = Symbol("lastPromise"),
		sa = Symbol("handlePromise"),
		ca = Symbol("stream");

	function ua(Sa, Ca) {
		return {
			value: Sa,
			done: Ca
		}
	}

	function da(Sa) {
		var Ca = Sa[ra];
		if (Ca !== null) {
			var ka = Sa[ca].read();
			ka !== null && (Sa[la] = null, Sa[ra] = null, Sa[ia] = null, Ca(ua(ka, !1)))
		}
	}

	function ha(Sa) {
		process$1.nextTick(da, Sa)
	}

	function pa(Sa, Ca) {
		return function(ka, Pa) {
			Sa.then(function() {
				if (Ca[oa]) {
					ka(ua(void 0, !0));
					return
				}
				Ca[sa](ka, Pa)
			}, Pa)
		}
	}
	var va = Object.getPrototypeOf(function() {}),
		ba = Object.setPrototypeOf((ue = {
			get stream() {
				return this[ca]
			},
			next: function() {
				var Ca = this,
					ka = this[aa];
				if (ka !== null) return Promise.reject(ka);
				if (this[oa]) return Promise.resolve(ua(void 0, !0));
				if (this[ca].destroyed) return new Promise(function(Ga, Ja) {
					process$1.nextTick(function() {
						Ca[aa] ? Ja(Ca[aa]) : Ga(ua(void 0, !0))
					})
				});
				var Pa = this[la],
					ja;
				if (Pa) ja = new Promise(pa(Pa, this));
				else {
					var Za = this[ca].read();
					if (Za !== null) return Promise.resolve(ua(Za, !1));
					ja = new Promise(this[sa])
				}
				return this[la] = ja, ja
			}
		}, Yi(ue, Symbol.asyncIterator, function() {
			return this
		}), Yi(ue, "return", function() {
			var Ca = this;
			return new Promise(function(ka, Pa) {
				Ca[ca].destroy(null, function(ja) {
					if (ja) {
						Pa(ja);
						return
					}
					ka(ua(void 0, !0))
				})
			})
		}), ue), va),
		Ea = function(Ca) {
			var ka, Pa = Object.create(ba, (ka = {}, Yi(ka, ca, {
				value: Ca,
				writable: !0
			}), Yi(ka, ra, {
				value: null,
				writable: !0
			}), Yi(ka, ia, {
				value: null,
				writable: !0
			}), Yi(ka, aa, {
				value: null,
				writable: !0
			}), Yi(ka, oa, {
				value: Ca._readableState.endEmitted,
				writable: !0
			}), Yi(ka, sa, {
				value: function(Za, Ga) {
					var Ja = Pa[ca].read();
					Ja ? (Pa[la] = null, Pa[ra] = null, Pa[ia] = null, Za(ua(Ja, !1))) : (Pa[ra] = Za, Pa[ia] = Ga)
				},
				writable: !0
			}), ka));
			return Pa[la] = null, na(Ca, function(ja) {
				if (ja && ja.code !== "ERR_STREAM_PREMATURE_CLOSE") {
					var Za = Pa[ia];
					Za !== null && (Pa[la] = null, Pa[ra] = null, Pa[ia] = null, Za(ja)), Pa[aa] = ja;
					return
				}
				var Ga = Pa[ra];
				Ga !== null && (Pa[la] = null, Pa[ra] = null, Pa[ia] = null, Ga(ua(void 0, !0))), Pa[oa] = !0
			}), Ca.on("readable", ha.bind(null, Pa)), Pa
		};
	return async_iterator = Ea, async_iterator
}
var fromBrowser, hasRequiredFromBrowser;

function requireFromBrowser() {
	return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
		throw new Error("Readable.from is not available in the browser")
	}), fromBrowser
}
var _stream_readable$1, hasRequired_stream_readable$1;

function require_stream_readable$1() {
	if (hasRequired_stream_readable$1) return _stream_readable$1;
	hasRequired_stream_readable$1 = 1, _stream_readable$1 = Ga;
	var ue;
	Ga.ReadableState = Za, requireEvents().EventEmitter;
	var Yi = function(Wa, qa) {
			return Wa.listeners(qa).length
		},
		ea = requireStreamBrowser$1(),
		ta = require$$1$2.Buffer,
		na = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};

	function ra(Va) {
		return ta.from(Va)
	}

	function ia(Va) {
		return ta.isBuffer(Va) || Va instanceof na
	}
	var aa = requireUtil$1(),
		oa;
	aa && aa.debuglog ? oa = aa.debuglog("stream") : oa = function() {};
	var la = requireBuffer_list(),
		sa = requireDestroy$1(),
		ca = requireState(),
		ua = ca.getHighWaterMark,
		da = requireErrorsBrowser().codes,
		ha = da.ERR_INVALID_ARG_TYPE,
		pa = da.ERR_STREAM_PUSH_AFTER_EOF,
		va = da.ERR_METHOD_NOT_IMPLEMENTED,
		ba = da.ERR_STREAM_UNSHIFT_AFTER_END_EVENT,
		Ea, Sa, Ca;
	requireInherits_browser()(Ga, ea);
	var ka = sa.errorOrDestroy,
		Pa = ["error", "close", "destroy", "pause", "resume"];

	function ja(Va, Wa, qa) {
		if (typeof Va.prependListener == "function") return Va.prependListener(Wa, qa);
		!Va._events || !Va._events[Wa] ? Va.on(Wa, qa) : Array.isArray(Va._events[Wa]) ? Va._events[Wa].unshift(qa) : Va._events[Wa] = [qa, Va._events[Wa]]
	}

	function Za(Va, Wa, qa) {
		ue = ue || require_stream_duplex$1(), Va = Va || {}, typeof qa != "boolean" && (qa = Wa instanceof ue), this.objectMode = !!Va.objectMode, qa && (this.objectMode = this.objectMode || !!Va.readableObjectMode), this.highWaterMark = ua(this, Va, "readableHighWaterMark", qa), this.buffer = new la, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Va.emitClose !== !1, this.autoDestroy = !!Va.autoDestroy, this.destroyed = !1, this.defaultEncoding = Va.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Va.encoding && (Ea || (Ea = requireString_decoder().StringDecoder), this.decoder = new Ea(Va.encoding), this.encoding = Va.encoding)
	}

	function Ga(Va) {
		if (ue = ue || require_stream_duplex$1(), !(this instanceof Ga)) return new Ga(Va);
		var Wa = this instanceof ue;
		this._readableState = new Za(Va, this, Wa), this.readable = !0, Va && (typeof Va.read == "function" && (this._read = Va.read), typeof Va.destroy == "function" && (this._destroy = Va.destroy)), ea.call(this)
	}
	Object.defineProperty(Ga.prototype, "destroyed", {
		enumerable: !1,
		get: function() {
			return this._readableState === void 0 ? !1 : this._readableState.destroyed
		},
		set: function(Wa) {
			this._readableState && (this._readableState.destroyed = Wa)
		}
	}), Ga.prototype.destroy = sa.destroy, Ga.prototype._undestroy = sa.undestroy, Ga.prototype._destroy = function(Va, Wa) {
		Wa(Va)
	}, Ga.prototype.push = function(Va, Wa) {
		var qa = this._readableState,
			Ka;
		return qa.objectMode ? Ka = !0 : typeof Va == "string" && (Wa = Wa || qa.defaultEncoding, Wa !== qa.encoding && (Va = ta.from(Va, Wa), Wa = ""), Ka = !0), Ja(this, Va, Wa, !1, Ka)
	}, Ga.prototype.unshift = function(Va) {
		return Ja(this, Va, null, !0, !1)
	};

	function Ja(Va, Wa, qa, Ka, lo) {
		oa("readableAddChunk", Wa);
		var yo = Va._readableState;
		if (Wa === null) yo.reading = !1, wa(Va, yo);
		else {
			var fo;
			if (lo || (fo = xa(yo, Wa)), fo) ka(Va, fo);
			else if (yo.objectMode || Wa && Wa.length > 0)
				if (typeof Wa != "string" && !yo.objectMode && Object.getPrototypeOf(Wa) !== ta.prototype && (Wa = ra(Wa)), Ka) yo.endEmitted ? ka(Va, new ba) : Ua(Va, yo, Wa, !0);
				else if (yo.ended) ka(Va, new pa);
			else {
				if (yo.destroyed) return !1;
				yo.reading = !1, yo.decoder && !qa ? (Wa = yo.decoder.write(Wa), yo.objectMode || Wa.length !== 0 ? Ua(Va, yo, Wa, !1) : Ra(Va, yo)) : Ua(Va, yo, Wa, !1)
			} else Ka || (yo.reading = !1, Ra(Va, yo))
		}
		return !yo.ended && (yo.length < yo.highWaterMark || yo.length === 0)
	}

	function Ua(Va, Wa, qa, Ka) {
		Wa.flowing && Wa.length === 0 && !Wa.sync ? (Wa.awaitDrain = 0, Va.emit("data", qa)) : (Wa.length += Wa.objectMode ? 1 : qa.length, Ka ? Wa.buffer.unshift(qa) : Wa.buffer.push(qa), Wa.needReadable && Ma(Va)), Ra(Va, Wa)
	}

	function xa(Va, Wa) {
		var qa;
		return !ia(Wa) && typeof Wa != "string" && Wa !== void 0 && !Va.objectMode && (qa = new ha("chunk", ["string", "Buffer", "Uint8Array"], Wa)), qa
	}
	Ga.prototype.isPaused = function() {
		return this._readableState.flowing === !1
	}, Ga.prototype.setEncoding = function(Va) {
		Ea || (Ea = requireString_decoder().StringDecoder);
		var Wa = new Ea(Va);
		this._readableState.decoder = Wa, this._readableState.encoding = this._readableState.decoder.encoding;
		for (var qa = this._readableState.buffer.head, Ka = ""; qa !== null;) Ka += Wa.write(qa.data), qa = qa.next;
		return this._readableState.buffer.clear(), Ka !== "" && this._readableState.buffer.push(Ka), this._readableState.length = Ka.length, this
	};
	var ma = 1073741824;

	function fa(Va) {
		return Va >= ma ? Va = ma : (Va--, Va |= Va >>> 1, Va |= Va >>> 2, Va |= Va >>> 4, Va |= Va >>> 8, Va |= Va >>> 16, Va++), Va
	}

	function ga(Va, Wa) {
		return Va <= 0 || Wa.length === 0 && Wa.ended ? 0 : Wa.objectMode ? 1 : Va !== Va ? Wa.flowing && Wa.length ? Wa.buffer.head.data.length : Wa.length : (Va > Wa.highWaterMark && (Wa.highWaterMark = fa(Va)), Va <= Wa.length ? Va : Wa.ended ? Wa.length : (Wa.needReadable = !0, 0))
	}
	Ga.prototype.read = function(Va) {
		oa("read", Va), Va = parseInt(Va, 10);
		var Wa = this._readableState,
			qa = Va;
		if (Va !== 0 && (Wa.emittedReadable = !1), Va === 0 && Wa.needReadable && ((Wa.highWaterMark !== 0 ? Wa.length >= Wa.highWaterMark : Wa.length > 0) || Wa.ended)) return oa("read: emitReadable", Wa.length, Wa.ended), Wa.length === 0 && Wa.ended ? Na(this) : Ma(this), null;
		if (Va = ga(Va, Wa), Va === 0 && Wa.ended) return Wa.length === 0 && Na(this), null;
		var Ka = Wa.needReadable;
		oa("need readable", Ka), (Wa.length === 0 || Wa.length - Va < Wa.highWaterMark) && (Ka = !0, oa("length less than watermark", Ka)), Wa.ended || Wa.reading ? (Ka = !1, oa("reading or ended", Ka)) : Ka && (oa("do read"), Wa.reading = !0, Wa.sync = !0, Wa.length === 0 && (Wa.needReadable = !0), this._read(Wa.highWaterMark), Wa.sync = !1, Wa.reading || (Va = ga(qa, Wa)));
		var lo;
		return Va > 0 ? lo = Ia(Va, Wa) : lo = null, lo === null ? (Wa.needReadable = Wa.length <= Wa.highWaterMark, Va = 0) : (Wa.length -= Va, Wa.awaitDrain = 0), Wa.length === 0 && (Wa.ended || (Wa.needReadable = !0), qa !== Va && Wa.ended && Na(this)), lo !== null && this.emit("data", lo), lo
	};

	function wa(Va, Wa) {
		if (oa("onEofChunk"), !Wa.ended) {
			if (Wa.decoder) {
				var qa = Wa.decoder.end();
				qa && qa.length && (Wa.buffer.push(qa), Wa.length += Wa.objectMode ? 1 : qa.length)
			}
			Wa.ended = !0, Wa.sync ? Ma(Va) : (Wa.needReadable = !1, Wa.emittedReadable || (Wa.emittedReadable = !0, Aa(Va)))
		}
	}

	function Ma(Va) {
		var Wa = Va._readableState;
		oa("emitReadable", Wa.needReadable, Wa.emittedReadable), Wa.needReadable = !1, Wa.emittedReadable || (oa("emitReadable", Wa.flowing), Wa.emittedReadable = !0, process$1.nextTick(Aa, Va))
	}

	function Aa(Va) {
		var Wa = Va._readableState;
		oa("emitReadable_", Wa.destroyed, Wa.length, Wa.ended), !Wa.destroyed && (Wa.length || Wa.ended) && (Va.emit("readable"), Wa.emittedReadable = !1), Wa.needReadable = !Wa.flowing && !Wa.ended && Wa.length <= Wa.highWaterMark, ao(Va)
	}

	function Ra(Va, Wa) {
		Wa.readingMore || (Wa.readingMore = !0, process$1.nextTick(Ta, Va, Wa))
	}

	function Ta(Va, Wa) {
		for (; !Wa.reading && !Wa.ended && (Wa.length < Wa.highWaterMark || Wa.flowing && Wa.length === 0);) {
			var qa = Wa.length;
			if (oa("maybeReadMore read 0"), Va.read(0), qa === Wa.length) break
		}
		Wa.readingMore = !1
	}
	Ga.prototype._read = function(Va) {
		ka(this, new va("_read()"))
	}, Ga.prototype.pipe = function(Va, Wa) {
		var qa = this,
			Ka = this._readableState;
		switch (Ka.pipesCount) {
			case 0:
				Ka.pipes = Va;
				break;
			case 1:
				Ka.pipes = [Ka.pipes, Va];
				break;
			default:
				Ka.pipes.push(Va);
				break
		}
		Ka.pipesCount += 1, oa("pipe count=%d opts=%j", Ka.pipesCount, Wa);
		var lo = (!Wa || Wa.end !== !1) && Va !== process$1.stdout && Va !== process$1.stderr,
			yo = lo ? vo : _o;
		Ka.endEmitted ? process$1.nextTick(yo) : qa.once("end", yo), Va.on("unpipe", fo);

		function fo(Lo, Fo) {
			oa("onunpipe"), Lo === qa && Fo && Fo.hasUnpiped === !1 && (Fo.hasUnpiped = !0, to())
		}

		function vo() {
			oa("onend"), Va.end()
		}
		var so = La(qa);
		Va.on("drain", so);
		var Xa = !1;

		function to() {
			oa("cleanup"), Va.removeListener("close", wo), Va.removeListener("finish", Ao), Va.removeListener("drain", so), Va.removeListener("error", Eo), Va.removeListener("unpipe", fo), qa.removeListener("end", vo), qa.removeListener("end", _o), qa.removeListener("data", ho), Xa = !0, Ka.awaitDrain && (!Va._writableState || Va._writableState.needDrain) && so()
		}
		qa.on("data", ho);

		function ho(Lo) {
			oa("ondata");
			var Fo = Va.write(Lo);
			oa("dest.write", Fo), Fo === !1 && ((Ka.pipesCount === 1 && Ka.pipes === Va || Ka.pipesCount > 1 && ro(Ka.pipes, Va) !== -1) && !Xa && (oa("false write response, pause", Ka.awaitDrain), Ka.awaitDrain++), qa.pause())
		}

		function Eo(Lo) {
			oa("onerror", Lo), _o(), Va.removeListener("error", Eo), Yi(Va, "error") === 0 && ka(Va, Lo)
		}
		ja(Va, "error", Eo);

		function wo() {
			Va.removeListener("finish", Ao), _o()
		}
		Va.once("close", wo);

		function Ao() {
			oa("onfinish"), Va.removeListener("close", wo), _o()
		}
		Va.once("finish", Ao);

		function _o() {
			oa("unpipe"), qa.unpipe(Va)
		}
		return Va.emit("pipe", qa), Ka.flowing || (oa("pipe resume"), qa.resume()), Va
	};

	function La(Va) {
		return function() {
			var qa = Va._readableState;
			oa("pipeOnDrain", qa.awaitDrain), qa.awaitDrain && qa.awaitDrain--, qa.awaitDrain === 0 && Yi(Va, "data") && (qa.flowing = !0, ao(Va))
		}
	}
	Ga.prototype.unpipe = function(Va) {
		var Wa = this._readableState,
			qa = {
				hasUnpiped: !1
			};
		if (Wa.pipesCount === 0) return this;
		if (Wa.pipesCount === 1) return Va && Va !== Wa.pipes ? this : (Va || (Va = Wa.pipes), Wa.pipes = null, Wa.pipesCount = 0, Wa.flowing = !1, Va && Va.emit("unpipe", this, qa), this);
		if (!Va) {
			var Ka = Wa.pipes,
				lo = Wa.pipesCount;
			Wa.pipes = null, Wa.pipesCount = 0, Wa.flowing = !1;
			for (var yo = 0; yo < lo; yo++) Ka[yo].emit("unpipe", this, {
				hasUnpiped: !1
			});
			return this
		}
		var fo = ro(Wa.pipes, Va);
		return fo === -1 ? this : (Wa.pipes.splice(fo, 1), Wa.pipesCount -= 1, Wa.pipesCount === 1 && (Wa.pipes = Wa.pipes[0]), Va.emit("unpipe", this, qa), this)
	}, Ga.prototype.on = function(Va, Wa) {
		var qa = ea.prototype.on.call(this, Va, Wa),
			Ka = this._readableState;
		return Va === "data" ? (Ka.readableListening = this.listenerCount("readable") > 0, Ka.flowing !== !1 && this.resume()) : Va === "readable" && !Ka.endEmitted && !Ka.readableListening && (Ka.readableListening = Ka.needReadable = !0, Ka.flowing = !1, Ka.emittedReadable = !1, oa("on readable", Ka.length, Ka.reading), Ka.length ? Ma(this) : Ka.reading || process$1.nextTick(Ba, this)), qa
	}, Ga.prototype.addListener = Ga.prototype.on, Ga.prototype.removeListener = function(Va, Wa) {
		var qa = ea.prototype.removeListener.call(this, Va, Wa);
		return Va === "readable" && process$1.nextTick(ya, this), qa
	}, Ga.prototype.removeAllListeners = function(Va) {
		var Wa = ea.prototype.removeAllListeners.apply(this, arguments);
		return (Va === "readable" || Va === void 0) && process$1.nextTick(ya, this), Wa
	};

	function ya(Va) {
		var Wa = Va._readableState;
		Wa.readableListening = Va.listenerCount("readable") > 0, Wa.resumeScheduled && !Wa.paused ? Wa.flowing = !0 : Va.listenerCount("data") > 0 && Va.resume()
	}

	function Ba(Va) {
		oa("readable nexttick read 0"), Va.read(0)
	}
	Ga.prototype.resume = function() {
		var Va = this._readableState;
		return Va.flowing || (oa("resume"), Va.flowing = !Va.readableListening, io(this, Va)), Va.paused = !1, this
	};

	function io(Va, Wa) {
		Wa.resumeScheduled || (Wa.resumeScheduled = !0, process$1.nextTick(oo, Va, Wa))
	}

	function oo(Va, Wa) {
		oa("resume", Wa.reading), Wa.reading || Va.read(0), Wa.resumeScheduled = !1, Va.emit("resume"), ao(Va), Wa.flowing && !Wa.reading && Va.read(0)
	}
	Ga.prototype.pause = function() {
		return oa("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (oa("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this
	};

	function ao(Va) {
		var Wa = Va._readableState;
		for (oa("flow", Wa.flowing); Wa.flowing && Va.read() !== null;);
	}
	Ga.prototype.wrap = function(Va) {
		var Wa = this,
			qa = this._readableState,
			Ka = !1;
		Va.on("end", function() {
			if (oa("wrapped end"), qa.decoder && !qa.ended) {
				var fo = qa.decoder.end();
				fo && fo.length && Wa.push(fo)
			}
			Wa.push(null)
		}), Va.on("data", function(fo) {
			if (oa("wrapped data"), qa.decoder && (fo = qa.decoder.write(fo)), !(qa.objectMode && fo == null) && !(!qa.objectMode && (!fo || !fo.length))) {
				var vo = Wa.push(fo);
				vo || (Ka = !0, Va.pause())
			}
		});
		for (var lo in Va) this[lo] === void 0 && typeof Va[lo] == "function" && (this[lo] = function(vo) {
			return function() {
				return Va[vo].apply(Va, arguments)
			}
		}(lo));
		for (var yo = 0; yo < Pa.length; yo++) Va.on(Pa[yo], this.emit.bind(this, Pa[yo]));
		return this._read = function(fo) {
			oa("wrapped _read", fo), Ka && (Ka = !1, Va.resume())
		}, this
	}, typeof Symbol == "function" && (Ga.prototype[Symbol.asyncIterator] = function() {
		return Sa === void 0 && (Sa = requireAsync_iterator()), Sa(this)
	}), Object.defineProperty(Ga.prototype, "readableHighWaterMark", {
		enumerable: !1,
		get: function() {
			return this._readableState.highWaterMark
		}
	}), Object.defineProperty(Ga.prototype, "readableBuffer", {
		enumerable: !1,
		get: function() {
			return this._readableState && this._readableState.buffer
		}
	}), Object.defineProperty(Ga.prototype, "readableFlowing", {
		enumerable: !1,
		get: function() {
			return this._readableState.flowing
		},
		set: function(Wa) {
			this._readableState && (this._readableState.flowing = Wa)
		}
	}), Ga._fromList = Ia, Object.defineProperty(Ga.prototype, "readableLength", {
		enumerable: !1,
		get: function() {
			return this._readableState.length
		}
	});

	function Ia(Va, Wa) {
		if (Wa.length === 0) return null;
		var qa;
		return Wa.objectMode ? qa = Wa.buffer.shift() : !Va || Va >= Wa.length ? (Wa.decoder ? qa = Wa.buffer.join("") : Wa.buffer.length === 1 ? qa = Wa.buffer.first() : qa = Wa.buffer.concat(Wa.length), Wa.buffer.clear()) : qa = Wa.buffer.consume(Va, Wa.decoder), qa
	}

	function Na(Va) {
		var Wa = Va._readableState;
		oa("endReadable", Wa.endEmitted), Wa.endEmitted || (Wa.ended = !0, process$1.nextTick(za, Wa, Va))
	}

	function za(Va, Wa) {
		if (oa("endReadableNT", Va.endEmitted, Va.length), !Va.endEmitted && Va.length === 0 && (Va.endEmitted = !0, Wa.readable = !1, Wa.emit("end"), Va.autoDestroy)) {
			var qa = Wa._writableState;
			(!qa || qa.autoDestroy && qa.finished) && Wa.destroy()
		}
	}
	typeof Symbol == "function" && (Ga.from = function(Va, Wa) {
		return Ca === void 0 && (Ca = requireFromBrowser()), Ca(Ga, Va, Wa)
	});

	function ro(Va, Wa) {
		for (var qa = 0, Ka = Va.length; qa < Ka; qa++)
			if (Va[qa] === Wa) return qa;
		return -1
	}
	return _stream_readable$1
}
var _stream_transform$1, hasRequired_stream_transform$1;

function require_stream_transform$1() {
	if (hasRequired_stream_transform$1) return _stream_transform$1;
	hasRequired_stream_transform$1 = 1, _stream_transform$1 = aa;
	var ue = requireErrorsBrowser().codes,
		Yi = ue.ERR_METHOD_NOT_IMPLEMENTED,
		ea = ue.ERR_MULTIPLE_CALLBACK,
		ta = ue.ERR_TRANSFORM_ALREADY_TRANSFORMING,
		na = ue.ERR_TRANSFORM_WITH_LENGTH_0,
		ra = require_stream_duplex$1();
	requireInherits_browser()(aa, ra);

	function ia(sa, ca) {
		var ua = this._transformState;
		ua.transforming = !1;
		var da = ua.writecb;
		if (da === null) return this.emit("error", new ea);
		ua.writechunk = null, ua.writecb = null, ca != null && this.push(ca), da(sa);
		var ha = this._readableState;
		ha.reading = !1, (ha.needReadable || ha.length < ha.highWaterMark) && this._read(ha.highWaterMark)
	}

	function aa(sa) {
		if (!(this instanceof aa)) return new aa(sa);
		ra.call(this, sa), this._transformState = {
			afterTransform: ia.bind(this),
			needTransform: !1,
			transforming: !1,
			writecb: null,
			writechunk: null,
			writeencoding: null
		}, this._readableState.needReadable = !0, this._readableState.sync = !1, sa && (typeof sa.transform == "function" && (this._transform = sa.transform), typeof sa.flush == "function" && (this._flush = sa.flush)), this.on("prefinish", oa)
	}

	function oa() {
		var sa = this;
		typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(ca, ua) {
			la(sa, ca, ua)
		}) : la(this, null, null)
	}
	aa.prototype.push = function(sa, ca) {
		return this._transformState.needTransform = !1, ra.prototype.push.call(this, sa, ca)
	}, aa.prototype._transform = function(sa, ca, ua) {
		ua(new Yi("_transform()"))
	}, aa.prototype._write = function(sa, ca, ua) {
		var da = this._transformState;
		if (da.writecb = ua, da.writechunk = sa, da.writeencoding = ca, !da.transforming) {
			var ha = this._readableState;
			(da.needTransform || ha.needReadable || ha.length < ha.highWaterMark) && this._read(ha.highWaterMark)
		}
	}, aa.prototype._read = function(sa) {
		var ca = this._transformState;
		ca.writechunk !== null && !ca.transforming ? (ca.transforming = !0, this._transform(ca.writechunk, ca.writeencoding, ca.afterTransform)) : ca.needTransform = !0
	}, aa.prototype._destroy = function(sa, ca) {
		ra.prototype._destroy.call(this, sa, function(ua) {
			ca(ua)
		})
	};

	function la(sa, ca, ua) {
		if (ca) return sa.emit("error", ca);
		if (ua != null && sa.push(ua), sa._writableState.length) throw new na;
		if (sa._transformState.transforming) throw new ta;
		return sa.push(null)
	}
	return _stream_transform$1
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;

function require_stream_passthrough$1() {
	if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
	hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = Yi;
	var ue = require_stream_transform$1();
	requireInherits_browser()(Yi, ue);

	function Yi(ea) {
		if (!(this instanceof Yi)) return new Yi(ea);
		ue.call(this, ea)
	}
	return Yi.prototype._transform = function(ea, ta, na) {
		na(null, ea)
	}, _stream_passthrough$1
}
var pipeline_1, hasRequiredPipeline;

function requirePipeline() {
	if (hasRequiredPipeline) return pipeline_1;
	hasRequiredPipeline = 1;
	var ue;

	function Yi(ua) {
		var da = !1;
		return function() {
			da || (da = !0, ua.apply(void 0, arguments))
		}
	}
	var ea = requireErrorsBrowser().codes,
		ta = ea.ERR_MISSING_ARGS,
		na = ea.ERR_STREAM_DESTROYED;

	function ra(ua) {
		if (ua) throw ua
	}

	function ia(ua) {
		return ua.setHeader && typeof ua.abort == "function"
	}

	function aa(ua, da, ha, pa) {
		pa = Yi(pa);
		var va = !1;
		ua.on("close", function() {
			va = !0
		}), ue === void 0 && (ue = requireEndOfStream()), ue(ua, {
			readable: da,
			writable: ha
		}, function(Ea) {
			if (Ea) return pa(Ea);
			va = !0, pa()
		});
		var ba = !1;
		return function(Ea) {
			if (!va && !ba) {
				if (ba = !0, ia(ua)) return ua.abort();
				if (typeof ua.destroy == "function") return ua.destroy();
				pa(Ea || new na("pipe"))
			}
		}
	}

	function oa(ua) {
		ua()
	}

	function la(ua, da) {
		return ua.pipe(da)
	}

	function sa(ua) {
		return !ua.length || typeof ua[ua.length - 1] != "function" ? ra : ua.pop()
	}

	function ca() {
		for (var ua = arguments.length, da = new Array(ua), ha = 0; ha < ua; ha++) da[ha] = arguments[ha];
		var pa = sa(da);
		if (Array.isArray(da[0]) && (da = da[0]), da.length < 2) throw new ta("streams");
		var va, ba = da.map(function(Ea, Sa) {
			var Ca = Sa < da.length - 1,
				ka = Sa > 0;
			return aa(Ea, Ca, ka, function(Pa) {
				va || (va = Pa), Pa && ba.forEach(oa), !Ca && (ba.forEach(oa), pa(va))
			})
		});
		return da.reduce(la)
	}
	return pipeline_1 = ca, pipeline_1
}
var hasRequiredReadableBrowser$1;

function requireReadableBrowser$1() {
	return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1, function(ue, Yi) {
		Yi = ue.exports = require_stream_readable$1(), Yi.Stream = Yi, Yi.Readable = Yi, Yi.Writable = require_stream_writable$1(), Yi.Duplex = require_stream_duplex$1(), Yi.Transform = require_stream_transform$1(), Yi.PassThrough = require_stream_passthrough$1(), Yi.finished = requireEndOfStream(), Yi.pipeline = requirePipeline()
	}(readableBrowser$1, readableBrowser$1.exports)), readableBrowser$1.exports
}
var hashBase$1, hasRequiredHashBase$1;

function requireHashBase$1() {
	if (hasRequiredHashBase$1) return hashBase$1;
	hasRequiredHashBase$1 = 1;
	var ue = requireSafeBuffer$1().Buffer,
		Yi = requireReadableBrowser$1().Transform,
		ea = requireInherits_browser();

	function ta(ra, ia) {
		if (!ue.isBuffer(ra) && typeof ra != "string") throw new TypeError(ia + " must be a string or a buffer")
	}

	function na(ra) {
		Yi.call(this), this._block = ue.allocUnsafe(ra), this._blockSize = ra, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1
	}
	return ea(na, Yi), na.prototype._transform = function(ra, ia, aa) {
		var oa = null;
		try {
			this.update(ra, ia)
		} catch (la) {
			oa = la
		}
		aa(oa)
	}, na.prototype._flush = function(ra) {
		var ia = null;
		try {
			this.push(this.digest())
		} catch (aa) {
			ia = aa
		}
		ra(ia)
	}, na.prototype.update = function(ra, ia) {
		if (ta(ra, "Data"), this._finalized) throw new Error("Digest already called");
		ue.isBuffer(ra) || (ra = ue.from(ra, ia));
		for (var aa = this._block, oa = 0; this._blockOffset + ra.length - oa >= this._blockSize;) {
			for (var la = this._blockOffset; la < this._blockSize;) aa[la++] = ra[oa++];
			this._update(), this._blockOffset = 0
		}
		for (; oa < ra.length;) aa[this._blockOffset++] = ra[oa++];
		for (var sa = 0, ca = ra.length * 8; ca > 0; ++sa) this._length[sa] += ca, ca = this._length[sa] / 4294967296 | 0, ca > 0 && (this._length[sa] -= 4294967296 * ca);
		return this
	}, na.prototype._update = function() {
		throw new Error("_update is not implemented")
	}, na.prototype.digest = function(ra) {
		if (this._finalized) throw new Error("Digest already called");
		this._finalized = !0;
		var ia = this._digest();
		ra !== void 0 && (ia = ia.toString(ra)), this._block.fill(0), this._blockOffset = 0;
		for (var aa = 0; aa < 4; ++aa) this._length[aa] = 0;
		return ia
	}, na.prototype._digest = function() {
		throw new Error("_digest is not implemented")
	}, hashBase$1 = na, hashBase$1
}
var md5_js, hasRequiredMd5_js;

function requireMd5_js() {
	if (hasRequiredMd5_js) return md5_js;
	hasRequiredMd5_js = 1;
	var ue = requireInherits_browser(),
		Yi = requireHashBase$1(),
		ea = requireSafeBuffer$1().Buffer,
		ta = new Array(16);

	function na() {
		Yi.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878
	}
	ue(na, Yi), na.prototype._update = function() {
		for (var sa = ta, ca = 0; ca < 16; ++ca) sa[ca] = this._block.readInt32LE(ca * 4);
		var ua = this._a,
			da = this._b,
			ha = this._c,
			pa = this._d;
		ua = ia(ua, da, ha, pa, sa[0], 3614090360, 7), pa = ia(pa, ua, da, ha, sa[1], 3905402710, 12), ha = ia(ha, pa, ua, da, sa[2], 606105819, 17), da = ia(da, ha, pa, ua, sa[3], 3250441966, 22), ua = ia(ua, da, ha, pa, sa[4], 4118548399, 7), pa = ia(pa, ua, da, ha, sa[5], 1200080426, 12), ha = ia(ha, pa, ua, da, sa[6], 2821735955, 17), da = ia(da, ha, pa, ua, sa[7], 4249261313, 22), ua = ia(ua, da, ha, pa, sa[8], 1770035416, 7), pa = ia(pa, ua, da, ha, sa[9], 2336552879, 12), ha = ia(ha, pa, ua, da, sa[10], 4294925233, 17), da = ia(da, ha, pa, ua, sa[11], 2304563134, 22), ua = ia(ua, da, ha, pa, sa[12], 1804603682, 7), pa = ia(pa, ua, da, ha, sa[13], 4254626195, 12), ha = ia(ha, pa, ua, da, sa[14], 2792965006, 17), da = ia(da, ha, pa, ua, sa[15], 1236535329, 22), ua = aa(ua, da, ha, pa, sa[1], 4129170786, 5), pa = aa(pa, ua, da, ha, sa[6], 3225465664, 9), ha = aa(ha, pa, ua, da, sa[11], 643717713, 14), da = aa(da, ha, pa, ua, sa[0], 3921069994, 20), ua = aa(ua, da, ha, pa, sa[5], 3593408605, 5), pa = aa(pa, ua, da, ha, sa[10], 38016083, 9), ha = aa(ha, pa, ua, da, sa[15], 3634488961, 14), da = aa(da, ha, pa, ua, sa[4], 3889429448, 20), ua = aa(ua, da, ha, pa, sa[9], 568446438, 5), pa = aa(pa, ua, da, ha, sa[14], 3275163606, 9), ha = aa(ha, pa, ua, da, sa[3], 4107603335, 14), da = aa(da, ha, pa, ua, sa[8], 1163531501, 20), ua = aa(ua, da, ha, pa, sa[13], 2850285829, 5), pa = aa(pa, ua, da, ha, sa[2], 4243563512, 9), ha = aa(ha, pa, ua, da, sa[7], 1735328473, 14), da = aa(da, ha, pa, ua, sa[12], 2368359562, 20), ua = oa(ua, da, ha, pa, sa[5], 4294588738, 4), pa = oa(pa, ua, da, ha, sa[8], 2272392833, 11), ha = oa(ha, pa, ua, da, sa[11], 1839030562, 16), da = oa(da, ha, pa, ua, sa[14], 4259657740, 23), ua = oa(ua, da, ha, pa, sa[1], 2763975236, 4), pa = oa(pa, ua, da, ha, sa[4], 1272893353, 11), ha = oa(ha, pa, ua, da, sa[7], 4139469664, 16), da = oa(da, ha, pa, ua, sa[10], 3200236656, 23), ua = oa(ua, da, ha, pa, sa[13], 681279174, 4), pa = oa(pa, ua, da, ha, sa[0], 3936430074, 11), ha = oa(ha, pa, ua, da, sa[3], 3572445317, 16), da = oa(da, ha, pa, ua, sa[6], 76029189, 23), ua = oa(ua, da, ha, pa, sa[9], 3654602809, 4), pa = oa(pa, ua, da, ha, sa[12], 3873151461, 11), ha = oa(ha, pa, ua, da, sa[15], 530742520, 16), da = oa(da, ha, pa, ua, sa[2], 3299628645, 23), ua = la(ua, da, ha, pa, sa[0], 4096336452, 6), pa = la(pa, ua, da, ha, sa[7], 1126891415, 10), ha = la(ha, pa, ua, da, sa[14], 2878612391, 15), da = la(da, ha, pa, ua, sa[5], 4237533241, 21), ua = la(ua, da, ha, pa, sa[12], 1700485571, 6), pa = la(pa, ua, da, ha, sa[3], 2399980690, 10), ha = la(ha, pa, ua, da, sa[10], 4293915773, 15), da = la(da, ha, pa, ua, sa[1], 2240044497, 21), ua = la(ua, da, ha, pa, sa[8], 1873313359, 6), pa = la(pa, ua, da, ha, sa[15], 4264355552, 10), ha = la(ha, pa, ua, da, sa[6], 2734768916, 15), da = la(da, ha, pa, ua, sa[13], 1309151649, 21), ua = la(ua, da, ha, pa, sa[4], 4149444226, 6), pa = la(pa, ua, da, ha, sa[11], 3174756917, 10), ha = la(ha, pa, ua, da, sa[2], 718787259, 15), da = la(da, ha, pa, ua, sa[9], 3951481745, 21), this._a = this._a + ua | 0, this._b = this._b + da | 0, this._c = this._c + ha | 0, this._d = this._d + pa | 0
	}, na.prototype._digest = function() {
		this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
		var sa = ea.allocUnsafe(16);
		return sa.writeInt32LE(this._a, 0), sa.writeInt32LE(this._b, 4), sa.writeInt32LE(this._c, 8), sa.writeInt32LE(this._d, 12), sa
	};

	function ra(sa, ca) {
		return sa << ca | sa >>> 32 - ca
	}

	function ia(sa, ca, ua, da, ha, pa, va) {
		return ra(sa + (ca & ua | ~ca & da) + ha + pa | 0, va) + ca | 0
	}

	function aa(sa, ca, ua, da, ha, pa, va) {
		return ra(sa + (ca & da | ua & ~da) + ha + pa | 0, va) + ca | 0
	}

	function oa(sa, ca, ua, da, ha, pa, va) {
		return ra(sa + (ca ^ ua ^ da) + ha + pa | 0, va) + ca | 0
	}

	function la(sa, ca, ua, da, ha, pa, va) {
		return ra(sa + (ua ^ (ca | ~da)) + ha + pa | 0, va) + ca | 0
	}
	return md5_js = na, md5_js
}
var hashBase, hasRequiredHashBase;

function requireHashBase() {
	if (hasRequiredHashBase) return hashBase;
	hasRequiredHashBase = 1;
	var ue = requireSafeBuffer$1().Buffer,
		Yi = requireReadableBrowser$1().Transform,
		ea = requireInherits_browser();

	function ta(ra, ia) {
		if (!ue.isBuffer(ra) && typeof ra != "string") throw new TypeError(ia + " must be a string or a buffer")
	}

	function na(ra) {
		Yi.call(this), this._block = ue.allocUnsafe(ra), this._blockSize = ra, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1
	}
	return ea(na, Yi), na.prototype._transform = function(ra, ia, aa) {
		var oa = null;
		try {
			this.update(ra, ia)
		} catch (la) {
			oa = la
		}
		aa(oa)
	}, na.prototype._flush = function(ra) {
		var ia = null;
		try {
			this.push(this.digest())
		} catch (aa) {
			ia = aa
		}
		ra(ia)
	}, na.prototype.update = function(ra, ia) {
		if (ta(ra, "Data"), this._finalized) throw new Error("Digest already called");
		ue.isBuffer(ra) || (ra = ue.from(ra, ia));
		for (var aa = this._block, oa = 0; this._blockOffset + ra.length - oa >= this._blockSize;) {
			for (var la = this._blockOffset; la < this._blockSize;) aa[la++] = ra[oa++];
			this._update(), this._blockOffset = 0
		}
		for (; oa < ra.length;) aa[this._blockOffset++] = ra[oa++];
		for (var sa = 0, ca = ra.length * 8; ca > 0; ++sa) this._length[sa] += ca, ca = this._length[sa] / 4294967296 | 0, ca > 0 && (this._length[sa] -= 4294967296 * ca);
		return this
	}, na.prototype._update = function() {
		throw new Error("_update is not implemented")
	}, na.prototype.digest = function(ra) {
		if (this._finalized) throw new Error("Digest already called");
		this._finalized = !0;
		var ia = this._digest();
		ra !== void 0 && (ia = ia.toString(ra)), this._block.fill(0), this._blockOffset = 0;
		for (var aa = 0; aa < 4; ++aa) this._length[aa] = 0;
		return ia
	}, na.prototype._digest = function() {
		throw new Error("_digest is not implemented")
	}, hashBase = na, hashBase
}
var ripemd160, hasRequiredRipemd160;

function requireRipemd160() {
	if (hasRequiredRipemd160) return ripemd160;
	hasRequiredRipemd160 = 1;
	var ue = require$$1$2.Buffer,
		Yi = requireInherits_browser(),
		ea = requireHashBase(),
		ta = new Array(16),
		na = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
		ra = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
		ia = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
		aa = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11],
		oa = [0, 1518500249, 1859775393, 2400959708, 2840853838],
		la = [1352829926, 1548603684, 1836072691, 2053994217, 0];

	function sa() {
		ea.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520
	}
	Yi(sa, ea), sa.prototype._update = function() {
		for (var ba = ta, Ea = 0; Ea < 16; ++Ea) ba[Ea] = this._block.readInt32LE(Ea * 4);
		for (var Sa = this._a | 0, Ca = this._b | 0, ka = this._c | 0, Pa = this._d | 0, ja = this._e | 0, Za = this._a | 0, Ga = this._b | 0, Ja = this._c | 0, Ua = this._d | 0, xa = this._e | 0, ma = 0; ma < 80; ma += 1) {
			var fa, ga;
			ma < 16 ? (fa = ua(Sa, Ca, ka, Pa, ja, ba[na[ma]], oa[0], ia[ma]), ga = va(Za, Ga, Ja, Ua, xa, ba[ra[ma]], la[0], aa[ma])) : ma < 32 ? (fa = da(Sa, Ca, ka, Pa, ja, ba[na[ma]], oa[1], ia[ma]), ga = pa(Za, Ga, Ja, Ua, xa, ba[ra[ma]], la[1], aa[ma])) : ma < 48 ? (fa = ha(Sa, Ca, ka, Pa, ja, ba[na[ma]], oa[2], ia[ma]), ga = ha(Za, Ga, Ja, Ua, xa, ba[ra[ma]], la[2], aa[ma])) : ma < 64 ? (fa = pa(Sa, Ca, ka, Pa, ja, ba[na[ma]], oa[3], ia[ma]), ga = da(Za, Ga, Ja, Ua, xa, ba[ra[ma]], la[3], aa[ma])) : (fa = va(Sa, Ca, ka, Pa, ja, ba[na[ma]], oa[4], ia[ma]), ga = ua(Za, Ga, Ja, Ua, xa, ba[ra[ma]], la[4], aa[ma])), Sa = ja, ja = Pa, Pa = ca(ka, 10), ka = Ca, Ca = fa, Za = xa, xa = Ua, Ua = ca(Ja, 10), Ja = Ga, Ga = ga
		}
		var wa = this._b + ka + Ua | 0;
		this._b = this._c + Pa + xa | 0, this._c = this._d + ja + Za | 0, this._d = this._e + Sa + Ga | 0, this._e = this._a + Ca + Ja | 0, this._a = wa
	}, sa.prototype._digest = function() {
		this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
		var ba = ue.alloc ? ue.alloc(20) : new ue(20);
		return ba.writeInt32LE(this._a, 0), ba.writeInt32LE(this._b, 4), ba.writeInt32LE(this._c, 8), ba.writeInt32LE(this._d, 12), ba.writeInt32LE(this._e, 16), ba
	};

	function ca(ba, Ea) {
		return ba << Ea | ba >>> 32 - Ea
	}

	function ua(ba, Ea, Sa, Ca, ka, Pa, ja, Za) {
		return ca(ba + (Ea ^ Sa ^ Ca) + Pa + ja | 0, Za) + ka | 0
	}

	function da(ba, Ea, Sa, Ca, ka, Pa, ja, Za) {
		return ca(ba + (Ea & Sa | ~Ea & Ca) + Pa + ja | 0, Za) + ka | 0
	}

	function ha(ba, Ea, Sa, Ca, ka, Pa, ja, Za) {
		return ca(ba + ((Ea | ~Sa) ^ Ca) + Pa + ja | 0, Za) + ka | 0
	}

	function pa(ba, Ea, Sa, Ca, ka, Pa, ja, Za) {
		return ca(ba + (Ea & Ca | Sa & ~Ca) + Pa + ja | 0, Za) + ka | 0
	}

	function va(ba, Ea, Sa, Ca, ka, Pa, ja, Za) {
		return ca(ba + (Ea ^ (Sa | ~Ca)) + Pa + ja | 0, Za) + ka | 0
	}
	return ripemd160 = sa, ripemd160
}
var sha_js = {
		exports: {}
	},
	hash$1, hasRequiredHash$1;

function requireHash$1() {
	if (hasRequiredHash$1) return hash$1;
	hasRequiredHash$1 = 1;
	var ue = requireSafeBuffer$1().Buffer;

	function Yi(ea, ta) {
		this._block = ue.alloc(ea), this._finalSize = ta, this._blockSize = ea, this._len = 0
	}
	return Yi.prototype.update = function(ea, ta) {
		typeof ea == "string" && (ta = ta || "utf8", ea = ue.from(ea, ta));
		for (var na = this._block, ra = this._blockSize, ia = ea.length, aa = this._len, oa = 0; oa < ia;) {
			for (var la = aa % ra, sa = Math.min(ia - oa, ra - la), ca = 0; ca < sa; ca++) na[la + ca] = ea[oa + ca];
			aa += sa, oa += sa, aa % ra === 0 && this._update(na)
		}
		return this._len += ia, this
	}, Yi.prototype.digest = function(ea) {
		var ta = this._len % this._blockSize;
		this._block[ta] = 128, this._block.fill(0, ta + 1), ta >= this._finalSize && (this._update(this._block), this._block.fill(0));
		var na = this._len * 8;
		if (na <= 4294967295) this._block.writeUInt32BE(na, this._blockSize - 4);
		else {
			var ra = (na & 4294967295) >>> 0,
				ia = (na - ra) / 4294967296;
			this._block.writeUInt32BE(ia, this._blockSize - 8), this._block.writeUInt32BE(ra, this._blockSize - 4)
		}
		this._update(this._block);
		var aa = this._hash();
		return ea ? aa.toString(ea) : aa
	}, Yi.prototype._update = function() {
		throw new Error("_update must be implemented by subclass")
	}, hash$1 = Yi, hash$1
}
var sha$1, hasRequiredSha$1;

function requireSha$1() {
	if (hasRequiredSha$1) return sha$1;
	hasRequiredSha$1 = 1;
	var ue = requireInherits_browser(),
		Yi = requireHash$1(),
		ea = requireSafeBuffer$1().Buffer,
		ta = [1518500249, 1859775393, -1894007588, -899497514],
		na = new Array(80);

	function ra() {
		this.init(), this._w = na, Yi.call(this, 64, 56)
	}
	ue(ra, Yi), ra.prototype.init = function() {
		return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this
	};

	function ia(la) {
		return la << 5 | la >>> 27
	}

	function aa(la) {
		return la << 30 | la >>> 2
	}

	function oa(la, sa, ca, ua) {
		return la === 0 ? sa & ca | ~sa & ua : la === 2 ? sa & ca | sa & ua | ca & ua : sa ^ ca ^ ua
	}
	return ra.prototype._update = function(la) {
		for (var sa = this._w, ca = this._a | 0, ua = this._b | 0, da = this._c | 0, ha = this._d | 0, pa = this._e | 0, va = 0; va < 16; ++va) sa[va] = la.readInt32BE(va * 4);
		for (; va < 80; ++va) sa[va] = sa[va - 3] ^ sa[va - 8] ^ sa[va - 14] ^ sa[va - 16];
		for (var ba = 0; ba < 80; ++ba) {
			var Ea = ~~(ba / 20),
				Sa = ia(ca) + oa(Ea, ua, da, ha) + pa + sa[ba] + ta[Ea] | 0;
			pa = ha, ha = da, da = aa(ua), ua = ca, ca = Sa
		}
		this._a = ca + this._a | 0, this._b = ua + this._b | 0, this._c = da + this._c | 0, this._d = ha + this._d | 0, this._e = pa + this._e | 0
	}, ra.prototype._hash = function() {
		var la = ea.allocUnsafe(20);
		return la.writeInt32BE(this._a | 0, 0), la.writeInt32BE(this._b | 0, 4), la.writeInt32BE(this._c | 0, 8), la.writeInt32BE(this._d | 0, 12), la.writeInt32BE(this._e | 0, 16), la
	}, sha$1 = ra, sha$1
}
var sha1, hasRequiredSha1;

function requireSha1() {
	if (hasRequiredSha1) return sha1;
	hasRequiredSha1 = 1;
	var ue = requireInherits_browser(),
		Yi = requireHash$1(),
		ea = requireSafeBuffer$1().Buffer,
		ta = [1518500249, 1859775393, -1894007588, -899497514],
		na = new Array(80);

	function ra() {
		this.init(), this._w = na, Yi.call(this, 64, 56)
	}
	ue(ra, Yi), ra.prototype.init = function() {
		return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this
	};

	function ia(sa) {
		return sa << 1 | sa >>> 31
	}

	function aa(sa) {
		return sa << 5 | sa >>> 27
	}

	function oa(sa) {
		return sa << 30 | sa >>> 2
	}

	function la(sa, ca, ua, da) {
		return sa === 0 ? ca & ua | ~ca & da : sa === 2 ? ca & ua | ca & da | ua & da : ca ^ ua ^ da
	}
	return ra.prototype._update = function(sa) {
		for (var ca = this._w, ua = this._a | 0, da = this._b | 0, ha = this._c | 0, pa = this._d | 0, va = this._e | 0, ba = 0; ba < 16; ++ba) ca[ba] = sa.readInt32BE(ba * 4);
		for (; ba < 80; ++ba) ca[ba] = ia(ca[ba - 3] ^ ca[ba - 8] ^ ca[ba - 14] ^ ca[ba - 16]);
		for (var Ea = 0; Ea < 80; ++Ea) {
			var Sa = ~~(Ea / 20),
				Ca = aa(ua) + la(Sa, da, ha, pa) + va + ca[Ea] + ta[Sa] | 0;
			va = pa, pa = ha, ha = oa(da), da = ua, ua = Ca
		}
		this._a = ua + this._a | 0, this._b = da + this._b | 0, this._c = ha + this._c | 0, this._d = pa + this._d | 0, this._e = va + this._e | 0
	}, ra.prototype._hash = function() {
		var sa = ea.allocUnsafe(20);
		return sa.writeInt32BE(this._a | 0, 0), sa.writeInt32BE(this._b | 0, 4), sa.writeInt32BE(this._c | 0, 8), sa.writeInt32BE(this._d | 0, 12), sa.writeInt32BE(this._e | 0, 16), sa
	}, sha1 = ra, sha1
}
var sha256$1, hasRequiredSha256;

function requireSha256() {
	if (hasRequiredSha256) return sha256$1;
	hasRequiredSha256 = 1;
	var ue = requireInherits_browser(),
		Yi = requireHash$1(),
		ea = requireSafeBuffer$1().Buffer,
		ta = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298],
		na = new Array(64);

	function ra() {
		this.init(), this._w = na, Yi.call(this, 64, 56)
	}
	ue(ra, Yi), ra.prototype.init = function() {
		return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this
	};

	function ia(ua, da, ha) {
		return ha ^ ua & (da ^ ha)
	}

	function aa(ua, da, ha) {
		return ua & da | ha & (ua | da)
	}

	function oa(ua) {
		return (ua >>> 2 | ua << 30) ^ (ua >>> 13 | ua << 19) ^ (ua >>> 22 | ua << 10)
	}

	function la(ua) {
		return (ua >>> 6 | ua << 26) ^ (ua >>> 11 | ua << 21) ^ (ua >>> 25 | ua << 7)
	}

	function sa(ua) {
		return (ua >>> 7 | ua << 25) ^ (ua >>> 18 | ua << 14) ^ ua >>> 3
	}

	function ca(ua) {
		return (ua >>> 17 | ua << 15) ^ (ua >>> 19 | ua << 13) ^ ua >>> 10
	}
	return ra.prototype._update = function(ua) {
		for (var da = this._w, ha = this._a | 0, pa = this._b | 0, va = this._c | 0, ba = this._d | 0, Ea = this._e | 0, Sa = this._f | 0, Ca = this._g | 0, ka = this._h | 0, Pa = 0; Pa < 16; ++Pa) da[Pa] = ua.readInt32BE(Pa * 4);
		for (; Pa < 64; ++Pa) da[Pa] = ca(da[Pa - 2]) + da[Pa - 7] + sa(da[Pa - 15]) + da[Pa - 16] | 0;
		for (var ja = 0; ja < 64; ++ja) {
			var Za = ka + la(Ea) + ia(Ea, Sa, Ca) + ta[ja] + da[ja] | 0,
				Ga = oa(ha) + aa(ha, pa, va) | 0;
			ka = Ca, Ca = Sa, Sa = Ea, Ea = ba + Za | 0, ba = va, va = pa, pa = ha, ha = Za + Ga | 0
		}
		this._a = ha + this._a | 0, this._b = pa + this._b | 0, this._c = va + this._c | 0, this._d = ba + this._d | 0, this._e = Ea + this._e | 0, this._f = Sa + this._f | 0, this._g = Ca + this._g | 0, this._h = ka + this._h | 0
	}, ra.prototype._hash = function() {
		var ua = ea.allocUnsafe(32);
		return ua.writeInt32BE(this._a, 0), ua.writeInt32BE(this._b, 4), ua.writeInt32BE(this._c, 8), ua.writeInt32BE(this._d, 12), ua.writeInt32BE(this._e, 16), ua.writeInt32BE(this._f, 20), ua.writeInt32BE(this._g, 24), ua.writeInt32BE(this._h, 28), ua
	}, sha256$1 = ra, sha256$1
}
var sha224$1, hasRequiredSha224;

function requireSha224() {
	if (hasRequiredSha224) return sha224$1;
	hasRequiredSha224 = 1;
	var ue = requireInherits_browser(),
		Yi = requireSha256(),
		ea = requireHash$1(),
		ta = requireSafeBuffer$1().Buffer,
		na = new Array(64);

	function ra() {
		this.init(), this._w = na, ea.call(this, 64, 56)
	}
	return ue(ra, Yi), ra.prototype.init = function() {
		return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this
	}, ra.prototype._hash = function() {
		var ia = ta.allocUnsafe(28);
		return ia.writeInt32BE(this._a, 0), ia.writeInt32BE(this._b, 4), ia.writeInt32BE(this._c, 8), ia.writeInt32BE(this._d, 12), ia.writeInt32BE(this._e, 16), ia.writeInt32BE(this._f, 20), ia.writeInt32BE(this._g, 24), ia
	}, sha224$1 = ra, sha224$1
}
var sha512$1, hasRequiredSha512;

function requireSha512() {
	if (hasRequiredSha512) return sha512$1;
	hasRequiredSha512 = 1;
	var ue = requireInherits_browser(),
		Yi = requireHash$1(),
		ea = requireSafeBuffer$1().Buffer,
		ta = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591],
		na = new Array(160);

	function ra() {
		this.init(), this._w = na, Yi.call(this, 128, 112)
	}
	ue(ra, Yi), ra.prototype.init = function() {
		return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this
	};

	function ia(pa, va, ba) {
		return ba ^ pa & (va ^ ba)
	}

	function aa(pa, va, ba) {
		return pa & va | ba & (pa | va)
	}

	function oa(pa, va) {
		return (pa >>> 28 | va << 4) ^ (va >>> 2 | pa << 30) ^ (va >>> 7 | pa << 25)
	}

	function la(pa, va) {
		return (pa >>> 14 | va << 18) ^ (pa >>> 18 | va << 14) ^ (va >>> 9 | pa << 23)
	}

	function sa(pa, va) {
		return (pa >>> 1 | va << 31) ^ (pa >>> 8 | va << 24) ^ pa >>> 7
	}

	function ca(pa, va) {
		return (pa >>> 1 | va << 31) ^ (pa >>> 8 | va << 24) ^ (pa >>> 7 | va << 25)
	}

	function ua(pa, va) {
		return (pa >>> 19 | va << 13) ^ (va >>> 29 | pa << 3) ^ pa >>> 6
	}

	function da(pa, va) {
		return (pa >>> 19 | va << 13) ^ (va >>> 29 | pa << 3) ^ (pa >>> 6 | va << 26)
	}

	function ha(pa, va) {
		return pa >>> 0 < va >>> 0 ? 1 : 0
	}
	return ra.prototype._update = function(pa) {
		for (var va = this._w, ba = this._ah | 0, Ea = this._bh | 0, Sa = this._ch | 0, Ca = this._dh | 0, ka = this._eh | 0, Pa = this._fh | 0, ja = this._gh | 0, Za = this._hh | 0, Ga = this._al | 0, Ja = this._bl | 0, Ua = this._cl | 0, xa = this._dl | 0, ma = this._el | 0, fa = this._fl | 0, ga = this._gl | 0, wa = this._hl | 0, Ma = 0; Ma < 32; Ma += 2) va[Ma] = pa.readInt32BE(Ma * 4), va[Ma + 1] = pa.readInt32BE(Ma * 4 + 4);
		for (; Ma < 160; Ma += 2) {
			var Aa = va[Ma - 30],
				Ra = va[Ma - 15 * 2 + 1],
				Ta = sa(Aa, Ra),
				La = ca(Ra, Aa);
			Aa = va[Ma - 2 * 2], Ra = va[Ma - 2 * 2 + 1];
			var ya = ua(Aa, Ra),
				Ba = da(Ra, Aa),
				io = va[Ma - 7 * 2],
				oo = va[Ma - 7 * 2 + 1],
				ao = va[Ma - 16 * 2],
				Ia = va[Ma - 16 * 2 + 1],
				Na = La + oo | 0,
				za = Ta + io + ha(Na, La) | 0;
			Na = Na + Ba | 0, za = za + ya + ha(Na, Ba) | 0, Na = Na + Ia | 0, za = za + ao + ha(Na, Ia) | 0, va[Ma] = za, va[Ma + 1] = Na
		}
		for (var ro = 0; ro < 160; ro += 2) {
			za = va[ro], Na = va[ro + 1];
			var Va = aa(ba, Ea, Sa),
				Wa = aa(Ga, Ja, Ua),
				qa = oa(ba, Ga),
				Ka = oa(Ga, ba),
				lo = la(ka, ma),
				yo = la(ma, ka),
				fo = ta[ro],
				vo = ta[ro + 1],
				so = ia(ka, Pa, ja),
				Xa = ia(ma, fa, ga),
				to = wa + yo | 0,
				ho = Za + lo + ha(to, wa) | 0;
			to = to + Xa | 0, ho = ho + so + ha(to, Xa) | 0, to = to + vo | 0, ho = ho + fo + ha(to, vo) | 0, to = to + Na | 0, ho = ho + za + ha(to, Na) | 0;
			var Eo = Ka + Wa | 0,
				wo = qa + Va + ha(Eo, Ka) | 0;
			Za = ja, wa = ga, ja = Pa, ga = fa, Pa = ka, fa = ma, ma = xa + to | 0, ka = Ca + ho + ha(ma, xa) | 0, Ca = Sa, xa = Ua, Sa = Ea, Ua = Ja, Ea = ba, Ja = Ga, Ga = to + Eo | 0, ba = ho + wo + ha(Ga, to) | 0
		}
		this._al = this._al + Ga | 0, this._bl = this._bl + Ja | 0, this._cl = this._cl + Ua | 0, this._dl = this._dl + xa | 0, this._el = this._el + ma | 0, this._fl = this._fl + fa | 0, this._gl = this._gl + ga | 0, this._hl = this._hl + wa | 0, this._ah = this._ah + ba + ha(this._al, Ga) | 0, this._bh = this._bh + Ea + ha(this._bl, Ja) | 0, this._ch = this._ch + Sa + ha(this._cl, Ua) | 0, this._dh = this._dh + Ca + ha(this._dl, xa) | 0, this._eh = this._eh + ka + ha(this._el, ma) | 0, this._fh = this._fh + Pa + ha(this._fl, fa) | 0, this._gh = this._gh + ja + ha(this._gl, ga) | 0, this._hh = this._hh + Za + ha(this._hl, wa) | 0
	}, ra.prototype._hash = function() {
		var pa = ea.allocUnsafe(64);

		function va(ba, Ea, Sa) {
			pa.writeInt32BE(ba, Sa), pa.writeInt32BE(Ea, Sa + 4)
		}
		return va(this._ah, this._al, 0), va(this._bh, this._bl, 8), va(this._ch, this._cl, 16), va(this._dh, this._dl, 24), va(this._eh, this._el, 32), va(this._fh, this._fl, 40), va(this._gh, this._gl, 48), va(this._hh, this._hl, 56), pa
	}, sha512$1 = ra, sha512$1
}
var sha384$1, hasRequiredSha384;

function requireSha384() {
	if (hasRequiredSha384) return sha384$1;
	hasRequiredSha384 = 1;
	var ue = requireInherits_browser(),
		Yi = requireSha512(),
		ea = requireHash$1(),
		ta = requireSafeBuffer$1().Buffer,
		na = new Array(160);

	function ra() {
		this.init(), this._w = na, ea.call(this, 128, 112)
	}
	return ue(ra, Yi), ra.prototype.init = function() {
		return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this
	}, ra.prototype._hash = function() {
		var ia = ta.allocUnsafe(48);

		function aa(oa, la, sa) {
			ia.writeInt32BE(oa, sa), ia.writeInt32BE(la, sa + 4)
		}
		return aa(this._ah, this._al, 0), aa(this._bh, this._bl, 8), aa(this._ch, this._cl, 16), aa(this._dh, this._dl, 24), aa(this._eh, this._el, 32), aa(this._fh, this._fl, 40), ia
	}, sha384$1 = ra, sha384$1
}
var hasRequiredSha_js;

function requireSha_js() {
	if (hasRequiredSha_js) return sha_js.exports;
	hasRequiredSha_js = 1;
	var ue = sha_js.exports = function(ea) {
		ea = ea.toLowerCase();
		var ta = ue[ea];
		if (!ta) throw new Error(ea + " is not supported (we accept pull requests)");
		return new ta
	};
	return ue.sha = requireSha$1(), ue.sha1 = requireSha1(), ue.sha224 = requireSha224(), ue.sha256 = requireSha256(), ue.sha384 = requireSha384(), ue.sha512 = requireSha512(), sha_js.exports
}
var streamBrowserify, hasRequiredStreamBrowserify;

function requireStreamBrowserify() {
	if (hasRequiredStreamBrowserify) return streamBrowserify;
	hasRequiredStreamBrowserify = 1, streamBrowserify = ea;
	var ue = requireEvents().EventEmitter,
		Yi = requireInherits_browser();
	Yi(ea, ue), ea.Readable = require_stream_readable$1(), ea.Writable = require_stream_writable$1(), ea.Duplex = require_stream_duplex$1(), ea.Transform = require_stream_transform$1(), ea.PassThrough = require_stream_passthrough$1(), ea.finished = requireEndOfStream(), ea.pipeline = requirePipeline(), ea.Stream = ea;

	function ea() {
		ue.call(this)
	}
	return ea.prototype.pipe = function(ta, na) {
		var ra = this;

		function ia(da) {
			ta.writable && ta.write(da) === !1 && ra.pause && ra.pause()
		}
		ra.on("data", ia);

		function aa() {
			ra.readable && ra.resume && ra.resume()
		}
		ta.on("drain", aa), !ta._isStdio && (!na || na.end !== !1) && (ra.on("end", la), ra.on("close", sa));
		var oa = !1;

		function la() {
			oa || (oa = !0, ta.end())
		}

		function sa() {
			oa || (oa = !0, typeof ta.destroy == "function" && ta.destroy())
		}

		function ca(da) {
			if (ua(), ue.listenerCount(this, "error") === 0) throw da
		}
		ra.on("error", ca), ta.on("error", ca);

		function ua() {
			ra.removeListener("data", ia), ta.removeListener("drain", aa), ra.removeListener("end", la), ra.removeListener("close", sa), ra.removeListener("error", ca), ta.removeListener("error", ca), ra.removeListener("end", ua), ra.removeListener("close", ua), ta.removeListener("close", ua)
		}
		return ra.on("end", ua), ra.on("close", ua), ta.on("close", ua), ta.emit("pipe", ra), ta
	}, streamBrowserify
}
var cipherBase, hasRequiredCipherBase;

function requireCipherBase() {
	if (hasRequiredCipherBase) return cipherBase;
	hasRequiredCipherBase = 1;
	var ue = requireSafeBuffer$1().Buffer,
		Yi = requireStreamBrowserify().Transform,
		ea = requireString_decoder().StringDecoder,
		ta = requireInherits_browser();

	function na(ra) {
		Yi.call(this), this.hashMode = typeof ra == "string", this.hashMode ? this[ra] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null
	}
	return ta(na, Yi), na.prototype.update = function(ra, ia, aa) {
		typeof ra == "string" && (ra = ue.from(ra, ia));
		var oa = this._update(ra);
		return this.hashMode ? this : (aa && (oa = this._toString(oa, aa)), oa)
	}, na.prototype.setAutoPadding = function() {}, na.prototype.getAuthTag = function() {
		throw new Error("trying to get auth tag in unsupported state")
	}, na.prototype.setAuthTag = function() {
		throw new Error("trying to set auth tag in unsupported state")
	}, na.prototype.setAAD = function() {
		throw new Error("trying to set aad in unsupported state")
	}, na.prototype._transform = function(ra, ia, aa) {
		var oa;
		try {
			this.hashMode ? this._update(ra) : this.push(this._update(ra))
		} catch (la) {
			oa = la
		} finally {
			aa(oa)
		}
	}, na.prototype._flush = function(ra) {
		var ia;
		try {
			this.push(this.__final())
		} catch (aa) {
			ia = aa
		}
		ra(ia)
	}, na.prototype._finalOrDigest = function(ra) {
		var ia = this.__final() || ue.alloc(0);
		return ra && (ia = this._toString(ia, ra, !0)), ia
	}, na.prototype._toString = function(ra, ia, aa) {
		if (this._decoder || (this._decoder = new ea(ia), this._encoding = ia), this._encoding !== ia) throw new Error("can't switch encodings");
		var oa = this._decoder.write(ra);
		return aa && (oa += this._decoder.end()), oa
	}, cipherBase = na, cipherBase
}
var browser$9, hasRequiredBrowser$9;

function requireBrowser$9() {
	if (hasRequiredBrowser$9) return browser$9;
	hasRequiredBrowser$9 = 1;
	var ue = requireInherits_browser(),
		Yi = requireMd5_js(),
		ea = requireRipemd160(),
		ta = requireSha_js(),
		na = requireCipherBase();

	function ra(ia) {
		na.call(this, "digest"), this._hash = ia
	}
	return ue(ra, na), ra.prototype._update = function(ia) {
		this._hash.update(ia)
	}, ra.prototype._final = function() {
		return this._hash.digest()
	}, browser$9 = function(aa) {
		return aa = aa.toLowerCase(), aa === "md5" ? new Yi : aa === "rmd160" || aa === "ripemd160" ? new ea : new ra(ta(aa))
	}, browser$9
}
var legacy, hasRequiredLegacy;

function requireLegacy() {
	if (hasRequiredLegacy) return legacy;
	hasRequiredLegacy = 1;
	var ue = requireInherits_browser(),
		Yi = requireSafeBuffer$1().Buffer,
		ea = requireCipherBase(),
		ta = Yi.alloc(128),
		na = 64;

	function ra(ia, aa) {
		ea.call(this, "digest"), typeof aa == "string" && (aa = Yi.from(aa)), this._alg = ia, this._key = aa, aa.length > na ? aa = ia(aa) : aa.length < na && (aa = Yi.concat([aa, ta], na));
		for (var oa = this._ipad = Yi.allocUnsafe(na), la = this._opad = Yi.allocUnsafe(na), sa = 0; sa < na; sa++) oa[sa] = aa[sa] ^ 54, la[sa] = aa[sa] ^ 92;
		this._hash = [oa]
	}
	return ue(ra, ea), ra.prototype._update = function(ia) {
		this._hash.push(ia)
	}, ra.prototype._final = function() {
		var ia = this._alg(Yi.concat(this._hash));
		return this._alg(Yi.concat([this._opad, ia]))
	}, legacy = ra, legacy
}
var md5, hasRequiredMd5;

function requireMd5() {
	if (hasRequiredMd5) return md5;
	hasRequiredMd5 = 1;
	var ue = requireMd5_js();
	return md5 = function(Yi) {
		return new ue().update(Yi).digest()
	}, md5
}
var browser$8, hasRequiredBrowser$8;

function requireBrowser$8() {
	if (hasRequiredBrowser$8) return browser$8;
	hasRequiredBrowser$8 = 1;
	var ue = requireInherits_browser(),
		Yi = requireLegacy(),
		ea = requireCipherBase(),
		ta = requireSafeBuffer$1().Buffer,
		na = requireMd5(),
		ra = requireRipemd160(),
		ia = requireSha_js(),
		aa = ta.alloc(128);

	function oa(la, sa) {
		ea.call(this, "digest"), typeof sa == "string" && (sa = ta.from(sa));
		var ca = la === "sha512" || la === "sha384" ? 128 : 64;
		if (this._alg = la, this._key = sa, sa.length > ca) {
			var ua = la === "rmd160" ? new ra : ia(la);
			sa = ua.update(sa).digest()
		} else sa.length < ca && (sa = ta.concat([sa, aa], ca));
		for (var da = this._ipad = ta.allocUnsafe(ca), ha = this._opad = ta.allocUnsafe(ca), pa = 0; pa < ca; pa++) da[pa] = sa[pa] ^ 54, ha[pa] = sa[pa] ^ 92;
		this._hash = la === "rmd160" ? new ra : ia(la), this._hash.update(da)
	}
	return ue(oa, ea), oa.prototype._update = function(la) {
		this._hash.update(la)
	}, oa.prototype._final = function() {
		var la = this._hash.digest(),
			sa = this._alg === "rmd160" ? new ra : ia(this._alg);
		return sa.update(this._opad).update(la).digest()
	}, browser$8 = function(sa, ca) {
		return sa = sa.toLowerCase(), sa === "rmd160" || sa === "ripemd160" ? new oa("rmd160", ca) : sa === "md5" ? new Yi(na, ca) : new oa(sa, ca)
	}, browser$8
}
const sha224WithRSAEncryption = {
		sign: "rsa",
		hash: "sha224",
		id: "302d300d06096086480165030402040500041c"
	},
	sha256WithRSAEncryption = {
		sign: "rsa",
		hash: "sha256",
		id: "3031300d060960864801650304020105000420"
	},
	sha384WithRSAEncryption = {
		sign: "rsa",
		hash: "sha384",
		id: "3041300d060960864801650304020205000430"
	},
	sha512WithRSAEncryption = {
		sign: "rsa",
		hash: "sha512",
		id: "3051300d060960864801650304020305000440"
	},
	sha256 = {
		sign: "ecdsa",
		hash: "sha256",
		id: ""
	},
	sha224 = {
		sign: "ecdsa",
		hash: "sha224",
		id: ""
	},
	sha384 = {
		sign: "ecdsa",
		hash: "sha384",
		id: ""
	},
	sha512 = {
		sign: "ecdsa",
		hash: "sha512",
		id: ""
	},
	DSA = {
		sign: "dsa",
		hash: "sha1",
		id: ""
	},
	ripemd160WithRSA = {
		sign: "rsa",
		hash: "rmd160",
		id: "3021300906052b2403020105000414"
	},
	md5WithRSAEncryption = {
		sign: "rsa",
		hash: "md5",
		id: "3020300c06082a864886f70d020505000410"
	},
	require$$6 = {
		sha224WithRSAEncryption,
		"RSA-SHA224": {
			sign: "ecdsa/rsa",
			hash: "sha224",
			id: "302d300d06096086480165030402040500041c"
		},
		sha256WithRSAEncryption,
		"RSA-SHA256": {
			sign: "ecdsa/rsa",
			hash: "sha256",
			id: "3031300d060960864801650304020105000420"
		},
		sha384WithRSAEncryption,
		"RSA-SHA384": {
			sign: "ecdsa/rsa",
			hash: "sha384",
			id: "3041300d060960864801650304020205000430"
		},
		sha512WithRSAEncryption,
		"RSA-SHA512": {
			sign: "ecdsa/rsa",
			hash: "sha512",
			id: "3051300d060960864801650304020305000440"
		},
		"RSA-SHA1": {
			sign: "rsa",
			hash: "sha1",
			id: "3021300906052b0e03021a05000414"
		},
		"ecdsa-with-SHA1": {
			sign: "ecdsa",
			hash: "sha1",
			id: ""
		},
		sha256,
		sha224,
		sha384,
		sha512,
		"DSA-SHA": {
			sign: "dsa",
			hash: "sha1",
			id: ""
		},
		"DSA-SHA1": {
			sign: "dsa",
			hash: "sha1",
			id: ""
		},
		DSA,
		"DSA-WITH-SHA224": {
			sign: "dsa",
			hash: "sha224",
			id: ""
		},
		"DSA-SHA224": {
			sign: "dsa",
			hash: "sha224",
			id: ""
		},
		"DSA-WITH-SHA256": {
			sign: "dsa",
			hash: "sha256",
			id: ""
		},
		"DSA-SHA256": {
			sign: "dsa",
			hash: "sha256",
			id: ""
		},
		"DSA-WITH-SHA384": {
			sign: "dsa",
			hash: "sha384",
			id: ""
		},
		"DSA-SHA384": {
			sign: "dsa",
			hash: "sha384",
			id: ""
		},
		"DSA-WITH-SHA512": {
			sign: "dsa",
			hash: "sha512",
			id: ""
		},
		"DSA-SHA512": {
			sign: "dsa",
			hash: "sha512",
			id: ""
		},
		"DSA-RIPEMD160": {
			sign: "dsa",
			hash: "rmd160",
			id: ""
		},
		ripemd160WithRSA,
		"RSA-RIPEMD160": {
			sign: "rsa",
			hash: "rmd160",
			id: "3021300906052b2403020105000414"
		},
		md5WithRSAEncryption,
		"RSA-MD5": {
			sign: "rsa",
			hash: "md5",
			id: "3020300c06082a864886f70d020505000410"
		}
	};
var algos, hasRequiredAlgos;

function requireAlgos() {
	return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos
}
var browser$7 = {},
	precondition, hasRequiredPrecondition;

function requirePrecondition() {
	if (hasRequiredPrecondition) return precondition;
	hasRequiredPrecondition = 1;
	var ue = Math.pow(2, 30) - 1;
	return precondition = function(Yi, ea) {
		if (typeof Yi != "number") throw new TypeError("Iterations not a number");
		if (Yi < 0) throw new TypeError("Bad iterations");
		if (typeof ea != "number") throw new TypeError("Key length not a number");
		if (ea < 0 || ea > ue || ea !== ea) throw new TypeError("Bad key length")
	}, precondition
}
var defaultEncoding_1, hasRequiredDefaultEncoding;

function requireDefaultEncoding() {
	if (hasRequiredDefaultEncoding) return defaultEncoding_1;
	hasRequiredDefaultEncoding = 1;
	var ue;
	if (commonjsGlobal.process && commonjsGlobal.process.browser) ue = "utf-8";
	else if (commonjsGlobal.process && commonjsGlobal.process.version) {
		var Yi = parseInt(process$1.version.split(".")[0].slice(1), 10);
		ue = Yi >= 6 ? "utf-8" : "binary"
	} else ue = "utf-8";
	return defaultEncoding_1 = ue, defaultEncoding_1
}
var toBuffer, hasRequiredToBuffer;

function requireToBuffer() {
	if (hasRequiredToBuffer) return toBuffer;
	hasRequiredToBuffer = 1;
	var ue = requireSafeBuffer$1().Buffer;
	return toBuffer = function(Yi, ea, ta) {
		if (ue.isBuffer(Yi)) return Yi;
		if (typeof Yi == "string") return ue.from(Yi, ea);
		if (ArrayBuffer.isView(Yi)) return ue.from(Yi.buffer);
		throw new TypeError(ta + " must be a string, a Buffer, a typed array or a DataView")
	}, toBuffer
}
var syncBrowser, hasRequiredSyncBrowser;

function requireSyncBrowser() {
	if (hasRequiredSyncBrowser) return syncBrowser;
	hasRequiredSyncBrowser = 1;
	var ue = requireMd5(),
		Yi = requireRipemd160(),
		ea = requireSha_js(),
		ta = requireSafeBuffer$1().Buffer,
		na = requirePrecondition(),
		ra = requireDefaultEncoding(),
		ia = requireToBuffer(),
		aa = ta.alloc(128),
		oa = {
			md5: 16,
			sha1: 20,
			sha224: 28,
			sha256: 32,
			sha384: 48,
			sha512: 64,
			rmd160: 20,
			ripemd160: 20
		};

	function la(ua, da, ha) {
		var pa = sa(ua),
			va = ua === "sha512" || ua === "sha384" ? 128 : 64;
		da.length > va ? da = pa(da) : da.length < va && (da = ta.concat([da, aa], va));
		for (var ba = ta.allocUnsafe(va + oa[ua]), Ea = ta.allocUnsafe(va + oa[ua]), Sa = 0; Sa < va; Sa++) ba[Sa] = da[Sa] ^ 54, Ea[Sa] = da[Sa] ^ 92;
		var Ca = ta.allocUnsafe(va + ha + 4);
		ba.copy(Ca, 0, 0, va), this.ipad1 = Ca, this.ipad2 = ba, this.opad = Ea, this.alg = ua, this.blocksize = va, this.hash = pa, this.size = oa[ua]
	}
	la.prototype.run = function(ua, da) {
		ua.copy(da, this.blocksize);
		var ha = this.hash(da);
		return ha.copy(this.opad, this.blocksize), this.hash(this.opad)
	};

	function sa(ua) {
		function da(pa) {
			return ea(ua).update(pa).digest()
		}

		function ha(pa) {
			return new Yi().update(pa).digest()
		}
		return ua === "rmd160" || ua === "ripemd160" ? ha : ua === "md5" ? ue : da
	}

	function ca(ua, da, ha, pa, va) {
		na(ha, pa), ua = ia(ua, ra, "Password"), da = ia(da, ra, "Salt"), va = va || "sha1";
		var ba = new la(va, ua, da.length),
			Ea = ta.allocUnsafe(pa),
			Sa = ta.allocUnsafe(da.length + 4);
		da.copy(Sa, 0, 0, da.length);
		for (var Ca = 0, ka = oa[va], Pa = Math.ceil(pa / ka), ja = 1; ja <= Pa; ja++) {
			Sa.writeUInt32BE(ja, da.length);
			for (var Za = ba.run(Sa, ba.ipad1), Ga = Za, Ja = 1; Ja < ha; Ja++) {
				Ga = ba.run(Ga, ba.ipad2);
				for (var Ua = 0; Ua < ka; Ua++) Za[Ua] ^= Ga[Ua]
			}
			Za.copy(Ea, Ca), Ca += ka
		}
		return Ea
	}
	return syncBrowser = ca, syncBrowser
}
var async, hasRequiredAsync;

function requireAsync() {
	if (hasRequiredAsync) return async;
	hasRequiredAsync = 1;
	var ue = requireSafeBuffer$1().Buffer,
		Yi = requirePrecondition(),
		ea = requireDefaultEncoding(),
		ta = requireSyncBrowser(),
		na = requireToBuffer(),
		ra, ia = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle,
		aa = {
			sha: "SHA-1",
			"sha-1": "SHA-1",
			sha1: "SHA-1",
			sha256: "SHA-256",
			"sha-256": "SHA-256",
			sha384: "SHA-384",
			"sha-384": "SHA-384",
			"sha-512": "SHA-512",
			sha512: "SHA-512"
		},
		oa = [];

	function la(ha) {
		if (commonjsGlobal.process && !commonjsGlobal.process.browser || !ia || !ia.importKey || !ia.deriveBits) return Promise.resolve(!1);
		if (oa[ha] !== void 0) return oa[ha];
		ra = ra || ue.alloc(8);
		var pa = ua(ra, ra, 10, 128, ha).then(function() {
			return !0
		}).catch(function() {
			return !1
		});
		return oa[ha] = pa, pa
	}
	var sa;

	function ca() {
		return sa || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? sa = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? sa = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? sa = commonjsGlobal.setImmediate : sa = commonjsGlobal.setTimeout, sa)
	}

	function ua(ha, pa, va, ba, Ea) {
		return ia.importKey("raw", ha, {
			name: "PBKDF2"
		}, !1, ["deriveBits"]).then(function(Sa) {
			return ia.deriveBits({
				name: "PBKDF2",
				salt: pa,
				iterations: va,
				hash: {
					name: Ea
				}
			}, Sa, ba << 3)
		}).then(function(Sa) {
			return ue.from(Sa)
		})
	}

	function da(ha, pa) {
		ha.then(function(va) {
			ca()(function() {
				pa(null, va)
			})
		}, function(va) {
			ca()(function() {
				pa(va)
			})
		})
	}
	return async = function(ha, pa, va, ba, Ea, Sa) {
		typeof Ea == "function" && (Sa = Ea, Ea = void 0), Ea = Ea || "sha1";
		var Ca = aa[Ea.toLowerCase()];
		if (!Ca || typeof globalThis.Promise != "function") {
			ca()(function() {
				var ka;
				try {
					ka = ta(ha, pa, va, ba, Ea)
				} catch (Pa) {
					return Sa(Pa)
				}
				Sa(null, ka)
			});
			return
		}
		if (Yi(va, ba), ha = na(ha, ea, "Password"), pa = na(pa, ea, "Salt"), typeof Sa != "function") throw new Error("No callback provided to pbkdf2");
		da(la(Ca).then(function(ka) {
			return ka ? ua(ha, pa, va, ba, Ca) : ta(ha, pa, va, ba, Ea)
		}), Sa)
	}, async
}
var hasRequiredBrowser$7;

function requireBrowser$7() {
	return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$7.pbkdf2 = requireAsync(), browser$7.pbkdf2Sync = requireSyncBrowser()), browser$7
}
var browser$6 = {},
	des$1 = {},
	utils$3 = {},
	hasRequiredUtils$3;

function requireUtils$3() {
	if (hasRequiredUtils$3) return utils$3;
	hasRequiredUtils$3 = 1, utils$3.readUInt32BE = function(na, ra) {
		var ia = na[0 + ra] << 24 | na[1 + ra] << 16 | na[2 + ra] << 8 | na[3 + ra];
		return ia >>> 0
	}, utils$3.writeUInt32BE = function(na, ra, ia) {
		na[0 + ia] = ra >>> 24, na[1 + ia] = ra >>> 16 & 255, na[2 + ia] = ra >>> 8 & 255, na[3 + ia] = ra & 255
	}, utils$3.ip = function(na, ra, ia, aa) {
		for (var oa = 0, la = 0, sa = 6; sa >= 0; sa -= 2) {
			for (var ca = 0; ca <= 24; ca += 8) oa <<= 1, oa |= ra >>> ca + sa & 1;
			for (var ca = 0; ca <= 24; ca += 8) oa <<= 1, oa |= na >>> ca + sa & 1
		}
		for (var sa = 6; sa >= 0; sa -= 2) {
			for (var ca = 1; ca <= 25; ca += 8) la <<= 1, la |= ra >>> ca + sa & 1;
			for (var ca = 1; ca <= 25; ca += 8) la <<= 1, la |= na >>> ca + sa & 1
		}
		ia[aa + 0] = oa >>> 0, ia[aa + 1] = la >>> 0
	}, utils$3.rip = function(na, ra, ia, aa) {
		for (var oa = 0, la = 0, sa = 0; sa < 4; sa++)
			for (var ca = 24; ca >= 0; ca -= 8) oa <<= 1, oa |= ra >>> ca + sa & 1, oa <<= 1, oa |= na >>> ca + sa & 1;
		for (var sa = 4; sa < 8; sa++)
			for (var ca = 24; ca >= 0; ca -= 8) la <<= 1, la |= ra >>> ca + sa & 1, la <<= 1, la |= na >>> ca + sa & 1;
		ia[aa + 0] = oa >>> 0, ia[aa + 1] = la >>> 0
	}, utils$3.pc1 = function(na, ra, ia, aa) {
		for (var oa = 0, la = 0, sa = 7; sa >= 5; sa--) {
			for (var ca = 0; ca <= 24; ca += 8) oa <<= 1, oa |= ra >> ca + sa & 1;
			for (var ca = 0; ca <= 24; ca += 8) oa <<= 1, oa |= na >> ca + sa & 1
		}
		for (var ca = 0; ca <= 24; ca += 8) oa <<= 1, oa |= ra >> ca + sa & 1;
		for (var sa = 1; sa <= 3; sa++) {
			for (var ca = 0; ca <= 24; ca += 8) la <<= 1, la |= ra >> ca + sa & 1;
			for (var ca = 0; ca <= 24; ca += 8) la <<= 1, la |= na >> ca + sa & 1
		}
		for (var ca = 0; ca <= 24; ca += 8) la <<= 1, la |= na >> ca + sa & 1;
		ia[aa + 0] = oa >>> 0, ia[aa + 1] = la >>> 0
	}, utils$3.r28shl = function(na, ra) {
		return na << ra & 268435455 | na >>> 28 - ra
	};
	var ue = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
	utils$3.pc2 = function(na, ra, ia, aa) {
		for (var oa = 0, la = 0, sa = ue.length >>> 1, ca = 0; ca < sa; ca++) oa <<= 1, oa |= na >>> ue[ca] & 1;
		for (var ca = sa; ca < ue.length; ca++) la <<= 1, la |= ra >>> ue[ca] & 1;
		ia[aa + 0] = oa >>> 0, ia[aa + 1] = la >>> 0
	}, utils$3.expand = function(na, ra, ia) {
		var aa = 0,
			oa = 0;
		aa = (na & 1) << 5 | na >>> 27;
		for (var la = 23; la >= 15; la -= 4) aa <<= 6, aa |= na >>> la & 63;
		for (var la = 11; la >= 3; la -= 4) oa |= na >>> la & 63, oa <<= 6;
		oa |= (na & 31) << 1 | na >>> 31, ra[ia + 0] = aa >>> 0, ra[ia + 1] = oa >>> 0
	};
	var Yi = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
	utils$3.substitute = function(na, ra) {
		for (var ia = 0, aa = 0; aa < 4; aa++) {
			var oa = na >>> 18 - aa * 6 & 63,
				la = Yi[aa * 64 + oa];
			ia <<= 4, ia |= la
		}
		for (var aa = 0; aa < 4; aa++) {
			var oa = ra >>> 18 - aa * 6 & 63,
				la = Yi[4 * 64 + aa * 64 + oa];
			ia <<= 4, ia |= la
		}
		return ia >>> 0
	};
	var ea = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
	return utils$3.permute = function(na) {
		for (var ra = 0, ia = 0; ia < ea.length; ia++) ra <<= 1, ra |= na >>> ea[ia] & 1;
		return ra >>> 0
	}, utils$3.padSplit = function(na, ra, ia) {
		for (var aa = na.toString(2); aa.length < ra;) aa = "0" + aa;
		for (var oa = [], la = 0; la < ra; la += ia) oa.push(aa.slice(la, la + ia));
		return oa.join(" ")
	}, utils$3
}
var minimalisticAssert, hasRequiredMinimalisticAssert;

function requireMinimalisticAssert() {
	if (hasRequiredMinimalisticAssert) return minimalisticAssert;
	hasRequiredMinimalisticAssert = 1, minimalisticAssert = ue;

	function ue(Yi, ea) {
		if (!Yi) throw new Error(ea || "Assertion failed")
	}
	return ue.equal = function(ea, ta, na) {
		if (ea != ta) throw new Error(na || "Assertion failed: " + ea + " != " + ta)
	}, minimalisticAssert
}
var cipher, hasRequiredCipher;

function requireCipher() {
	if (hasRequiredCipher) return cipher;
	hasRequiredCipher = 1;
	var ue = requireMinimalisticAssert();

	function Yi(ea) {
		this.options = ea, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = ea.padding !== !1
	}
	return cipher = Yi, Yi.prototype._init = function() {}, Yi.prototype.update = function(ta) {
		return ta.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(ta) : this._updateEncrypt(ta)
	}, Yi.prototype._buffer = function(ta, na) {
		for (var ra = Math.min(this.buffer.length - this.bufferOff, ta.length - na), ia = 0; ia < ra; ia++) this.buffer[this.bufferOff + ia] = ta[na + ia];
		return this.bufferOff += ra, ra
	}, Yi.prototype._flushBuffer = function(ta, na) {
		return this._update(this.buffer, 0, ta, na), this.bufferOff = 0, this.blockSize
	}, Yi.prototype._updateEncrypt = function(ta) {
		var na = 0,
			ra = 0,
			ia = (this.bufferOff + ta.length) / this.blockSize | 0,
			aa = new Array(ia * this.blockSize);
		this.bufferOff !== 0 && (na += this._buffer(ta, na), this.bufferOff === this.buffer.length && (ra += this._flushBuffer(aa, ra)));
		for (var oa = ta.length - (ta.length - na) % this.blockSize; na < oa; na += this.blockSize) this._update(ta, na, aa, ra), ra += this.blockSize;
		for (; na < ta.length; na++, this.bufferOff++) this.buffer[this.bufferOff] = ta[na];
		return aa
	}, Yi.prototype._updateDecrypt = function(ta) {
		for (var na = 0, ra = 0, ia = Math.ceil((this.bufferOff + ta.length) / this.blockSize) - 1, aa = new Array(ia * this.blockSize); ia > 0; ia--) na += this._buffer(ta, na), ra += this._flushBuffer(aa, ra);
		return na += this._buffer(ta, na), aa
	}, Yi.prototype.final = function(ta) {
		var na;
		ta && (na = this.update(ta));
		var ra;
		return this.type === "encrypt" ? ra = this._finalEncrypt() : ra = this._finalDecrypt(), na ? na.concat(ra) : ra
	}, Yi.prototype._pad = function(ta, na) {
		if (na === 0) return !1;
		for (; na < ta.length;) ta[na++] = 0;
		return !0
	}, Yi.prototype._finalEncrypt = function() {
		if (!this._pad(this.buffer, this.bufferOff)) return [];
		var ta = new Array(this.blockSize);
		return this._update(this.buffer, 0, ta, 0), ta
	}, Yi.prototype._unpad = function(ta) {
		return ta
	}, Yi.prototype._finalDecrypt = function() {
		ue.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
		var ta = new Array(this.blockSize);
		return this._flushBuffer(ta, 0), this._unpad(ta)
	}, cipher
}
var des, hasRequiredDes$1;

function requireDes$1() {
	if (hasRequiredDes$1) return des;
	hasRequiredDes$1 = 1;
	var ue = requireMinimalisticAssert(),
		Yi = requireInherits_browser(),
		ea = requireUtils$3(),
		ta = requireCipher();

	function na() {
		this.tmp = new Array(2), this.keys = null
	}

	function ra(aa) {
		ta.call(this, aa);
		var oa = new na;
		this._desState = oa, this.deriveKeys(oa, aa.key)
	}
	Yi(ra, ta), des = ra, ra.create = function(oa) {
		return new ra(oa)
	};
	var ia = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
	return ra.prototype.deriveKeys = function(oa, la) {
		oa.keys = new Array(16 * 2), ue.equal(la.length, this.blockSize, "Invalid key length");
		var sa = ea.readUInt32BE(la, 0),
			ca = ea.readUInt32BE(la, 4);
		ea.pc1(sa, ca, oa.tmp, 0), sa = oa.tmp[0], ca = oa.tmp[1];
		for (var ua = 0; ua < oa.keys.length; ua += 2) {
			var da = ia[ua >>> 1];
			sa = ea.r28shl(sa, da), ca = ea.r28shl(ca, da), ea.pc2(sa, ca, oa.keys, ua)
		}
	}, ra.prototype._update = function(oa, la, sa, ca) {
		var ua = this._desState,
			da = ea.readUInt32BE(oa, la),
			ha = ea.readUInt32BE(oa, la + 4);
		ea.ip(da, ha, ua.tmp, 0), da = ua.tmp[0], ha = ua.tmp[1], this.type === "encrypt" ? this._encrypt(ua, da, ha, ua.tmp, 0) : this._decrypt(ua, da, ha, ua.tmp, 0), da = ua.tmp[0], ha = ua.tmp[1], ea.writeUInt32BE(sa, da, ca), ea.writeUInt32BE(sa, ha, ca + 4)
	}, ra.prototype._pad = function(oa, la) {
		if (this.padding === !1) return !1;
		for (var sa = oa.length - la, ca = la; ca < oa.length; ca++) oa[ca] = sa;
		return !0
	}, ra.prototype._unpad = function(oa) {
		if (this.padding === !1) return oa;
		for (var la = oa[oa.length - 1], sa = oa.length - la; sa < oa.length; sa++) ue.equal(oa[sa], la);
		return oa.slice(0, oa.length - la)
	}, ra.prototype._encrypt = function(oa, la, sa, ca, ua) {
		for (var da = la, ha = sa, pa = 0; pa < oa.keys.length; pa += 2) {
			var va = oa.keys[pa],
				ba = oa.keys[pa + 1];
			ea.expand(ha, oa.tmp, 0), va ^= oa.tmp[0], ba ^= oa.tmp[1];
			var Ea = ea.substitute(va, ba),
				Sa = ea.permute(Ea),
				Ca = ha;
			ha = (da ^ Sa) >>> 0, da = Ca
		}
		ea.rip(ha, da, ca, ua)
	}, ra.prototype._decrypt = function(oa, la, sa, ca, ua) {
		for (var da = sa, ha = la, pa = oa.keys.length - 2; pa >= 0; pa -= 2) {
			var va = oa.keys[pa],
				ba = oa.keys[pa + 1];
			ea.expand(da, oa.tmp, 0), va ^= oa.tmp[0], ba ^= oa.tmp[1];
			var Ea = ea.substitute(va, ba),
				Sa = ea.permute(Ea),
				Ca = da;
			da = (ha ^ Sa) >>> 0, ha = Ca
		}
		ea.rip(da, ha, ca, ua)
	}, des
}
var cbc$1 = {},
	hasRequiredCbc$1;

function requireCbc$1() {
	if (hasRequiredCbc$1) return cbc$1;
	hasRequiredCbc$1 = 1;
	var ue = requireMinimalisticAssert(),
		Yi = requireInherits_browser(),
		ea = {};

	function ta(ra) {
		ue.equal(ra.length, 8, "Invalid IV length"), this.iv = new Array(8);
		for (var ia = 0; ia < this.iv.length; ia++) this.iv[ia] = ra[ia]
	}

	function na(ra) {
		function ia(sa) {
			ra.call(this, sa), this._cbcInit()
		}
		Yi(ia, ra);
		for (var aa = Object.keys(ea), oa = 0; oa < aa.length; oa++) {
			var la = aa[oa];
			ia.prototype[la] = ea[la]
		}
		return ia.create = function(ca) {
			return new ia(ca)
		}, ia
	}
	return cbc$1.instantiate = na, ea._cbcInit = function() {
		var ia = new ta(this.options.iv);
		this._cbcState = ia
	}, ea._update = function(ia, aa, oa, la) {
		var sa = this._cbcState,
			ca = this.constructor.super_.prototype,
			ua = sa.iv;
		if (this.type === "encrypt") {
			for (var da = 0; da < this.blockSize; da++) ua[da] ^= ia[aa + da];
			ca._update.call(this, ua, 0, oa, la);
			for (var da = 0; da < this.blockSize; da++) ua[da] = oa[la + da]
		} else {
			ca._update.call(this, ia, aa, oa, la);
			for (var da = 0; da < this.blockSize; da++) oa[la + da] ^= ua[da];
			for (var da = 0; da < this.blockSize; da++) ua[da] = ia[aa + da]
		}
	}, cbc$1
}
var ede, hasRequiredEde;

function requireEde() {
	if (hasRequiredEde) return ede;
	hasRequiredEde = 1;
	var ue = requireMinimalisticAssert(),
		Yi = requireInherits_browser(),
		ea = requireCipher(),
		ta = requireDes$1();

	function na(ia, aa) {
		ue.equal(aa.length, 24, "Invalid key length");
		var oa = aa.slice(0, 8),
			la = aa.slice(8, 16),
			sa = aa.slice(16, 24);
		ia === "encrypt" ? this.ciphers = [ta.create({
			type: "encrypt",
			key: oa
		}), ta.create({
			type: "decrypt",
			key: la
		}), ta.create({
			type: "encrypt",
			key: sa
		})] : this.ciphers = [ta.create({
			type: "decrypt",
			key: sa
		}), ta.create({
			type: "encrypt",
			key: la
		}), ta.create({
			type: "decrypt",
			key: oa
		})]
	}

	function ra(ia) {
		ea.call(this, ia);
		var aa = new na(this.type, this.options.key);
		this._edeState = aa
	}
	return Yi(ra, ea), ede = ra, ra.create = function(aa) {
		return new ra(aa)
	}, ra.prototype._update = function(aa, oa, la, sa) {
		var ca = this._edeState;
		ca.ciphers[0]._update(aa, oa, la, sa), ca.ciphers[1]._update(la, sa, la, sa), ca.ciphers[2]._update(la, sa, la, sa)
	}, ra.prototype._pad = ta.prototype._pad, ra.prototype._unpad = ta.prototype._unpad, ede
}
var hasRequiredDes;

function requireDes() {
	return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$3(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1
}
var browserifyDes, hasRequiredBrowserifyDes;

function requireBrowserifyDes() {
	if (hasRequiredBrowserifyDes) return browserifyDes;
	hasRequiredBrowserifyDes = 1;
	var ue = requireCipherBase(),
		Yi = requireDes(),
		ea = requireInherits_browser(),
		ta = requireSafeBuffer$1().Buffer,
		na = {
			"des-ede3-cbc": Yi.CBC.instantiate(Yi.EDE),
			"des-ede3": Yi.EDE,
			"des-ede-cbc": Yi.CBC.instantiate(Yi.EDE),
			"des-ede": Yi.EDE,
			"des-cbc": Yi.CBC.instantiate(Yi.DES),
			"des-ecb": Yi.DES
		};
	na.des = na["des-cbc"], na.des3 = na["des-ede3-cbc"], browserifyDes = ra, ea(ra, ue);

	function ra(ia) {
		ue.call(this);
		var aa = ia.mode.toLowerCase(),
			oa = na[aa],
			la;
		ia.decrypt ? la = "decrypt" : la = "encrypt";
		var sa = ia.key;
		ta.isBuffer(sa) || (sa = ta.from(sa)), (aa === "des-ede" || aa === "des-ede-cbc") && (sa = ta.concat([sa, sa.slice(0, 8)]));
		var ca = ia.iv;
		ta.isBuffer(ca) || (ca = ta.from(ca)), this._des = oa.create({
			key: sa,
			iv: ca,
			type: la
		})
	}
	return ra.prototype._update = function(ia) {
		return ta.from(this._des.update(ia))
	}, ra.prototype._final = function() {
		return ta.from(this._des.final())
	}, browserifyDes
}
var browser$5 = {},
	encrypter = {},
	ecb = {},
	hasRequiredEcb;

function requireEcb() {
	return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(ue, Yi) {
		return ue._cipher.encryptBlock(Yi)
	}, ecb.decrypt = function(ue, Yi) {
		return ue._cipher.decryptBlock(Yi)
	}), ecb
}
var cbc = {},
	bufferXor, hasRequiredBufferXor;

function requireBufferXor() {
	return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(Yi, ea) {
		for (var ta = Math.min(Yi.length, ea.length), na = new Buffer(ta), ra = 0; ra < ta; ++ra) na[ra] = Yi[ra] ^ ea[ra];
		return na
	}), bufferXor
}
var hasRequiredCbc;

function requireCbc() {
	if (hasRequiredCbc) return cbc;
	hasRequiredCbc = 1;
	var ue = requireBufferXor();
	return cbc.encrypt = function(Yi, ea) {
		var ta = ue(ea, Yi._prev);
		return Yi._prev = Yi._cipher.encryptBlock(ta), Yi._prev
	}, cbc.decrypt = function(Yi, ea) {
		var ta = Yi._prev;
		Yi._prev = ea;
		var na = Yi._cipher.decryptBlock(ea);
		return ue(na, ta)
	}, cbc
}
var cfb = {},
	hasRequiredCfb;

function requireCfb() {
	if (hasRequiredCfb) return cfb;
	hasRequiredCfb = 1;
	var ue = requireSafeBuffer$1().Buffer,
		Yi = requireBufferXor();

	function ea(ta, na, ra) {
		var ia = na.length,
			aa = Yi(na, ta._cache);
		return ta._cache = ta._cache.slice(ia), ta._prev = ue.concat([ta._prev, ra ? na : aa]), aa
	}
	return cfb.encrypt = function(ta, na, ra) {
		for (var ia = ue.allocUnsafe(0), aa; na.length;)
			if (ta._cache.length === 0 && (ta._cache = ta._cipher.encryptBlock(ta._prev), ta._prev = ue.allocUnsafe(0)), ta._cache.length <= na.length) aa = ta._cache.length, ia = ue.concat([ia, ea(ta, na.slice(0, aa), ra)]), na = na.slice(aa);
			else {
				ia = ue.concat([ia, ea(ta, na, ra)]);
				break
			} return ia
	}, cfb
}
var cfb8 = {},
	hasRequiredCfb8;

function requireCfb8() {
	if (hasRequiredCfb8) return cfb8;
	hasRequiredCfb8 = 1;
	var ue = requireSafeBuffer$1().Buffer;

	function Yi(ea, ta, na) {
		var ra = ea._cipher.encryptBlock(ea._prev),
			ia = ra[0] ^ ta;
		return ea._prev = ue.concat([ea._prev.slice(1), ue.from([na ? ta : ia])]), ia
	}
	return cfb8.encrypt = function(ea, ta, na) {
		for (var ra = ta.length, ia = ue.allocUnsafe(ra), aa = -1; ++aa < ra;) ia[aa] = Yi(ea, ta[aa], na);
		return ia
	}, cfb8
}
var cfb1 = {},
	hasRequiredCfb1;

function requireCfb1() {
	if (hasRequiredCfb1) return cfb1;
	hasRequiredCfb1 = 1;
	var ue = requireSafeBuffer$1().Buffer;

	function Yi(ta, na, ra) {
		for (var ia, aa = -1, oa = 8, la = 0, sa, ca; ++aa < oa;) ia = ta._cipher.encryptBlock(ta._prev), sa = na & 1 << 7 - aa ? 128 : 0, ca = ia[0] ^ sa, la += (ca & 128) >> aa % 8, ta._prev = ea(ta._prev, ra ? sa : ca);
		return la
	}

	function ea(ta, na) {
		var ra = ta.length,
			ia = -1,
			aa = ue.allocUnsafe(ta.length);
		for (ta = ue.concat([ta, ue.from([na])]); ++ia < ra;) aa[ia] = ta[ia] << 1 | ta[ia + 1] >> 7;
		return aa
	}
	return cfb1.encrypt = function(ta, na, ra) {
		for (var ia = na.length, aa = ue.allocUnsafe(ia), oa = -1; ++oa < ia;) aa[oa] = Yi(ta, na[oa], ra);
		return aa
	}, cfb1
}
var ofb = {},
	hasRequiredOfb;

function requireOfb() {
	if (hasRequiredOfb) return ofb;
	hasRequiredOfb = 1;
	var ue = requireBufferXor();

	function Yi(ea) {
		return ea._prev = ea._cipher.encryptBlock(ea._prev), ea._prev
	}
	return ofb.encrypt = function(ea, ta) {
		for (; ea._cache.length < ta.length;) ea._cache = Buffer.concat([ea._cache, Yi(ea)]);
		var na = ea._cache.slice(0, ta.length);
		return ea._cache = ea._cache.slice(ta.length), ue(ta, na)
	}, ofb
}
var ctr = {},
	incr32_1, hasRequiredIncr32;

function requireIncr32() {
	if (hasRequiredIncr32) return incr32_1;
	hasRequiredIncr32 = 1;

	function ue(Yi) {
		for (var ea = Yi.length, ta; ea--;)
			if (ta = Yi.readUInt8(ea), ta === 255) Yi.writeUInt8(0, ea);
			else {
				ta++, Yi.writeUInt8(ta, ea);
				break
			}
	}
	return incr32_1 = ue, incr32_1
}
var hasRequiredCtr;

function requireCtr() {
	if (hasRequiredCtr) return ctr;
	hasRequiredCtr = 1;
	var ue = requireBufferXor(),
		Yi = requireSafeBuffer$1().Buffer,
		ea = requireIncr32();

	function ta(ra) {
		var ia = ra._cipher.encryptBlockRaw(ra._prev);
		return ea(ra._prev), ia
	}
	var na = 16;
	return ctr.encrypt = function(ra, ia) {
		var aa = Math.ceil(ia.length / na),
			oa = ra._cache.length;
		ra._cache = Yi.concat([ra._cache, Yi.allocUnsafe(aa * na)]);
		for (var la = 0; la < aa; la++) {
			var sa = ta(ra),
				ca = oa + la * na;
			ra._cache.writeUInt32BE(sa[0], ca + 0), ra._cache.writeUInt32BE(sa[1], ca + 4), ra._cache.writeUInt32BE(sa[2], ca + 8), ra._cache.writeUInt32BE(sa[3], ca + 12)
		}
		var ua = ra._cache.slice(0, ia.length);
		return ra._cache = ra._cache.slice(ia.length), ue(ia, ua)
	}, ctr
}
const aes128 = {
		cipher: "AES",
		key: 128,
		iv: 16,
		mode: "CBC",
		type: "block"
	},
	aes192 = {
		cipher: "AES",
		key: 192,
		iv: 16,
		mode: "CBC",
		type: "block"
	},
	aes256 = {
		cipher: "AES",
		key: 256,
		iv: 16,
		mode: "CBC",
		type: "block"
	},
	require$$2 = {
		"aes-128-ecb": {
			cipher: "AES",
			key: 128,
			iv: 0,
			mode: "ECB",
			type: "block"
		},
		"aes-192-ecb": {
			cipher: "AES",
			key: 192,
			iv: 0,
			mode: "ECB",
			type: "block"
		},
		"aes-256-ecb": {
			cipher: "AES",
			key: 256,
			iv: 0,
			mode: "ECB",
			type: "block"
		},
		"aes-128-cbc": {
			cipher: "AES",
			key: 128,
			iv: 16,
			mode: "CBC",
			type: "block"
		},
		"aes-192-cbc": {
			cipher: "AES",
			key: 192,
			iv: 16,
			mode: "CBC",
			type: "block"
		},
		"aes-256-cbc": {
			cipher: "AES",
			key: 256,
			iv: 16,
			mode: "CBC",
			type: "block"
		},
		aes128,
		aes192,
		aes256,
		"aes-128-cfb": {
			cipher: "AES",
			key: 128,
			iv: 16,
			mode: "CFB",
			type: "stream"
		},
		"aes-192-cfb": {
			cipher: "AES",
			key: 192,
			iv: 16,
			mode: "CFB",
			type: "stream"
		},
		"aes-256-cfb": {
			cipher: "AES",
			key: 256,
			iv: 16,
			mode: "CFB",
			type: "stream"
		},
		"aes-128-cfb8": {
			cipher: "AES",
			key: 128,
			iv: 16,
			mode: "CFB8",
			type: "stream"
		},
		"aes-192-cfb8": {
			cipher: "AES",
			key: 192,
			iv: 16,
			mode: "CFB8",
			type: "stream"
		},
		"aes-256-cfb8": {
			cipher: "AES",
			key: 256,
			iv: 16,
			mode: "CFB8",
			type: "stream"
		},
		"aes-128-cfb1": {
			cipher: "AES",
			key: 128,
			iv: 16,
			mode: "CFB1",
			type: "stream"
		},
		"aes-192-cfb1": {
			cipher: "AES",
			key: 192,
			iv: 16,
			mode: "CFB1",
			type: "stream"
		},
		"aes-256-cfb1": {
			cipher: "AES",
			key: 256,
			iv: 16,
			mode: "CFB1",
			type: "stream"
		},
		"aes-128-ofb": {
			cipher: "AES",
			key: 128,
			iv: 16,
			mode: "OFB",
			type: "stream"
		},
		"aes-192-ofb": {
			cipher: "AES",
			key: 192,
			iv: 16,
			mode: "OFB",
			type: "stream"
		},
		"aes-256-ofb": {
			cipher: "AES",
			key: 256,
			iv: 16,
			mode: "OFB",
			type: "stream"
		},
		"aes-128-ctr": {
			cipher: "AES",
			key: 128,
			iv: 16,
			mode: "CTR",
			type: "stream"
		},
		"aes-192-ctr": {
			cipher: "AES",
			key: 192,
			iv: 16,
			mode: "CTR",
			type: "stream"
		},
		"aes-256-ctr": {
			cipher: "AES",
			key: 256,
			iv: 16,
			mode: "CTR",
			type: "stream"
		},
		"aes-128-gcm": {
			cipher: "AES",
			key: 128,
			iv: 12,
			mode: "GCM",
			type: "auth"
		},
		"aes-192-gcm": {
			cipher: "AES",
			key: 192,
			iv: 12,
			mode: "GCM",
			type: "auth"
		},
		"aes-256-gcm": {
			cipher: "AES",
			key: 256,
			iv: 12,
			mode: "GCM",
			type: "auth"
		}
	};
var modes_1, hasRequiredModes$1;

function requireModes$1() {
	if (hasRequiredModes$1) return modes_1;
	hasRequiredModes$1 = 1;
	var ue = {
			ECB: requireEcb(),
			CBC: requireCbc(),
			CFB: requireCfb(),
			CFB8: requireCfb8(),
			CFB1: requireCfb1(),
			OFB: requireOfb(),
			CTR: requireCtr(),
			GCM: requireCtr()
		},
		Yi = require$$2;
	for (var ea in Yi) Yi[ea].module = ue[Yi[ea].mode];
	return modes_1 = Yi, modes_1
}
var aes = {},
	hasRequiredAes;

function requireAes() {
	if (hasRequiredAes) return aes;
	hasRequiredAes = 1;
	var ue = requireSafeBuffer$1().Buffer;

	function Yi(aa) {
		ue.isBuffer(aa) || (aa = ue.from(aa));
		for (var oa = aa.length / 4 | 0, la = new Array(oa), sa = 0; sa < oa; sa++) la[sa] = aa.readUInt32BE(sa * 4);
		return la
	}

	function ea(aa) {
		for (var oa = 0; oa < aa.length; aa++) aa[oa] = 0
	}

	function ta(aa, oa, la, sa, ca) {
		for (var ua = la[0], da = la[1], ha = la[2], pa = la[3], va = aa[0] ^ oa[0], ba = aa[1] ^ oa[1], Ea = aa[2] ^ oa[2], Sa = aa[3] ^ oa[3], Ca, ka, Pa, ja, Za = 4, Ga = 1; Ga < ca; Ga++) Ca = ua[va >>> 24] ^ da[ba >>> 16 & 255] ^ ha[Ea >>> 8 & 255] ^ pa[Sa & 255] ^ oa[Za++], ka = ua[ba >>> 24] ^ da[Ea >>> 16 & 255] ^ ha[Sa >>> 8 & 255] ^ pa[va & 255] ^ oa[Za++], Pa = ua[Ea >>> 24] ^ da[Sa >>> 16 & 255] ^ ha[va >>> 8 & 255] ^ pa[ba & 255] ^ oa[Za++], ja = ua[Sa >>> 24] ^ da[va >>> 16 & 255] ^ ha[ba >>> 8 & 255] ^ pa[Ea & 255] ^ oa[Za++], va = Ca, ba = ka, Ea = Pa, Sa = ja;
		return Ca = (sa[va >>> 24] << 24 | sa[ba >>> 16 & 255] << 16 | sa[Ea >>> 8 & 255] << 8 | sa[Sa & 255]) ^ oa[Za++], ka = (sa[ba >>> 24] << 24 | sa[Ea >>> 16 & 255] << 16 | sa[Sa >>> 8 & 255] << 8 | sa[va & 255]) ^ oa[Za++], Pa = (sa[Ea >>> 24] << 24 | sa[Sa >>> 16 & 255] << 16 | sa[va >>> 8 & 255] << 8 | sa[ba & 255]) ^ oa[Za++], ja = (sa[Sa >>> 24] << 24 | sa[va >>> 16 & 255] << 16 | sa[ba >>> 8 & 255] << 8 | sa[Ea & 255]) ^ oa[Za++], Ca = Ca >>> 0, ka = ka >>> 0, Pa = Pa >>> 0, ja = ja >>> 0, [Ca, ka, Pa, ja]
	}
	var na = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
		ra = function() {
			for (var aa = new Array(256), oa = 0; oa < 256; oa++) oa < 128 ? aa[oa] = oa << 1 : aa[oa] = oa << 1 ^ 283;
			for (var la = [], sa = [], ca = [
					[],
					[],
					[],
					[]
				], ua = [
					[],
					[],
					[],
					[]
				], da = 0, ha = 0, pa = 0; pa < 256; ++pa) {
				var va = ha ^ ha << 1 ^ ha << 2 ^ ha << 3 ^ ha << 4;
				va = va >>> 8 ^ va & 255 ^ 99, la[da] = va, sa[va] = da;
				var ba = aa[da],
					Ea = aa[ba],
					Sa = aa[Ea],
					Ca = aa[va] * 257 ^ va * 16843008;
				ca[0][da] = Ca << 24 | Ca >>> 8, ca[1][da] = Ca << 16 | Ca >>> 16, ca[2][da] = Ca << 8 | Ca >>> 24, ca[3][da] = Ca, Ca = Sa * 16843009 ^ Ea * 65537 ^ ba * 257 ^ da * 16843008, ua[0][va] = Ca << 24 | Ca >>> 8, ua[1][va] = Ca << 16 | Ca >>> 16, ua[2][va] = Ca << 8 | Ca >>> 24, ua[3][va] = Ca, da === 0 ? da = ha = 1 : (da = ba ^ aa[aa[aa[Sa ^ ba]]], ha ^= aa[aa[ha]])
			}
			return {
				SBOX: la,
				INV_SBOX: sa,
				SUB_MIX: ca,
				INV_SUB_MIX: ua
			}
		}();

	function ia(aa) {
		this._key = Yi(aa), this._reset()
	}
	return ia.blockSize = 4 * 4, ia.keySize = 256 / 8, ia.prototype.blockSize = ia.blockSize, ia.prototype.keySize = ia.keySize, ia.prototype._reset = function() {
		for (var aa = this._key, oa = aa.length, la = oa + 6, sa = (la + 1) * 4, ca = [], ua = 0; ua < oa; ua++) ca[ua] = aa[ua];
		for (ua = oa; ua < sa; ua++) {
			var da = ca[ua - 1];
			ua % oa === 0 ? (da = da << 8 | da >>> 24, da = ra.SBOX[da >>> 24] << 24 | ra.SBOX[da >>> 16 & 255] << 16 | ra.SBOX[da >>> 8 & 255] << 8 | ra.SBOX[da & 255], da ^= na[ua / oa | 0] << 24) : oa > 6 && ua % oa === 4 && (da = ra.SBOX[da >>> 24] << 24 | ra.SBOX[da >>> 16 & 255] << 16 | ra.SBOX[da >>> 8 & 255] << 8 | ra.SBOX[da & 255]), ca[ua] = ca[ua - oa] ^ da
		}
		for (var ha = [], pa = 0; pa < sa; pa++) {
			var va = sa - pa,
				ba = ca[va - (pa % 4 ? 0 : 4)];
			pa < 4 || va <= 4 ? ha[pa] = ba : ha[pa] = ra.INV_SUB_MIX[0][ra.SBOX[ba >>> 24]] ^ ra.INV_SUB_MIX[1][ra.SBOX[ba >>> 16 & 255]] ^ ra.INV_SUB_MIX[2][ra.SBOX[ba >>> 8 & 255]] ^ ra.INV_SUB_MIX[3][ra.SBOX[ba & 255]]
		}
		this._nRounds = la, this._keySchedule = ca, this._invKeySchedule = ha
	}, ia.prototype.encryptBlockRaw = function(aa) {
		return aa = Yi(aa), ta(aa, this._keySchedule, ra.SUB_MIX, ra.SBOX, this._nRounds)
	}, ia.prototype.encryptBlock = function(aa) {
		var oa = this.encryptBlockRaw(aa),
			la = ue.allocUnsafe(16);
		return la.writeUInt32BE(oa[0], 0), la.writeUInt32BE(oa[1], 4), la.writeUInt32BE(oa[2], 8), la.writeUInt32BE(oa[3], 12), la
	}, ia.prototype.decryptBlock = function(aa) {
		aa = Yi(aa);
		var oa = aa[1];
		aa[1] = aa[3], aa[3] = oa;
		var la = ta(aa, this._invKeySchedule, ra.INV_SUB_MIX, ra.INV_SBOX, this._nRounds),
			sa = ue.allocUnsafe(16);
		return sa.writeUInt32BE(la[0], 0), sa.writeUInt32BE(la[3], 4), sa.writeUInt32BE(la[2], 8), sa.writeUInt32BE(la[1], 12), sa
	}, ia.prototype.scrub = function() {
		ea(this._keySchedule), ea(this._invKeySchedule), ea(this._key)
	}, aes.AES = ia, aes
}
var ghash, hasRequiredGhash;

function requireGhash() {
	if (hasRequiredGhash) return ghash;
	hasRequiredGhash = 1;
	var ue = requireSafeBuffer$1().Buffer,
		Yi = ue.alloc(16, 0);

	function ea(ra) {
		return [ra.readUInt32BE(0), ra.readUInt32BE(4), ra.readUInt32BE(8), ra.readUInt32BE(12)]
	}

	function ta(ra) {
		var ia = ue.allocUnsafe(16);
		return ia.writeUInt32BE(ra[0] >>> 0, 0), ia.writeUInt32BE(ra[1] >>> 0, 4), ia.writeUInt32BE(ra[2] >>> 0, 8), ia.writeUInt32BE(ra[3] >>> 0, 12), ia
	}

	function na(ra) {
		this.h = ra, this.state = ue.alloc(16, 0), this.cache = ue.allocUnsafe(0)
	}
	return na.prototype.ghash = function(ra) {
		for (var ia = -1; ++ia < ra.length;) this.state[ia] ^= ra[ia];
		this._multiply()
	}, na.prototype._multiply = function() {
		for (var ra = ea(this.h), ia = [0, 0, 0, 0], aa, oa, la, sa = -1; ++sa < 128;) {
			for (oa = (this.state[~~(sa / 8)] & 1 << 7 - sa % 8) !== 0, oa && (ia[0] ^= ra[0], ia[1] ^= ra[1], ia[2] ^= ra[2], ia[3] ^= ra[3]), la = (ra[3] & 1) !== 0, aa = 3; aa > 0; aa--) ra[aa] = ra[aa] >>> 1 | (ra[aa - 1] & 1) << 31;
			ra[0] = ra[0] >>> 1, la && (ra[0] = ra[0] ^ 225 << 24)
		}
		this.state = ta(ia)
	}, na.prototype.update = function(ra) {
		this.cache = ue.concat([this.cache, ra]);
		for (var ia; this.cache.length >= 16;) ia = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(ia)
	}, na.prototype.final = function(ra, ia) {
		return this.cache.length && this.ghash(ue.concat([this.cache, Yi], 16)), this.ghash(ta([0, ra, 0, ia])), this.state
	}, ghash = na, ghash
}
var authCipher, hasRequiredAuthCipher;

function requireAuthCipher() {
	if (hasRequiredAuthCipher) return authCipher;
	hasRequiredAuthCipher = 1;
	var ue = requireAes(),
		Yi = requireSafeBuffer$1().Buffer,
		ea = requireCipherBase(),
		ta = requireInherits_browser(),
		na = requireGhash(),
		ra = requireBufferXor(),
		ia = requireIncr32();

	function aa(sa, ca) {
		var ua = 0;
		sa.length !== ca.length && ua++;
		for (var da = Math.min(sa.length, ca.length), ha = 0; ha < da; ++ha) ua += sa[ha] ^ ca[ha];
		return ua
	}

	function oa(sa, ca, ua) {
		if (ca.length === 12) return sa._finID = Yi.concat([ca, Yi.from([0, 0, 0, 1])]), Yi.concat([ca, Yi.from([0, 0, 0, 2])]);
		var da = new na(ua),
			ha = ca.length,
			pa = ha % 16;
		da.update(ca), pa && (pa = 16 - pa, da.update(Yi.alloc(pa, 0))), da.update(Yi.alloc(8, 0));
		var va = ha * 8,
			ba = Yi.alloc(8);
		ba.writeUIntBE(va, 0, 8), da.update(ba), sa._finID = da.state;
		var Ea = Yi.from(sa._finID);
		return ia(Ea), Ea
	}

	function la(sa, ca, ua, da) {
		ea.call(this);
		var ha = Yi.alloc(4, 0);
		this._cipher = new ue.AES(ca);
		var pa = this._cipher.encryptBlock(ha);
		this._ghash = new na(pa), ua = oa(this, ua, pa), this._prev = Yi.from(ua), this._cache = Yi.allocUnsafe(0), this._secCache = Yi.allocUnsafe(0), this._decrypt = da, this._alen = 0, this._len = 0, this._mode = sa, this._authTag = null, this._called = !1
	}
	return ta(la, ea), la.prototype._update = function(sa) {
		if (!this._called && this._alen) {
			var ca = 16 - this._alen % 16;
			ca < 16 && (ca = Yi.alloc(ca, 0), this._ghash.update(ca))
		}
		this._called = !0;
		var ua = this._mode.encrypt(this, sa);
		return this._decrypt ? this._ghash.update(sa) : this._ghash.update(ua), this._len += sa.length, ua
	}, la.prototype._final = function() {
		if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
		var sa = ra(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
		if (this._decrypt && aa(sa, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
		this._authTag = sa, this._cipher.scrub()
	}, la.prototype.getAuthTag = function() {
		if (this._decrypt || !Yi.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
		return this._authTag
	}, la.prototype.setAuthTag = function(ca) {
		if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
		this._authTag = ca
	}, la.prototype.setAAD = function(ca) {
		if (this._called) throw new Error("Attempting to set AAD in unsupported state");
		this._ghash.update(ca), this._alen += ca.length
	}, authCipher = la, authCipher
}
var streamCipher, hasRequiredStreamCipher;

function requireStreamCipher() {
	if (hasRequiredStreamCipher) return streamCipher;
	hasRequiredStreamCipher = 1;
	var ue = requireAes(),
		Yi = requireSafeBuffer$1().Buffer,
		ea = requireCipherBase(),
		ta = requireInherits_browser();

	function na(ra, ia, aa, oa) {
		ea.call(this), this._cipher = new ue.AES(ia), this._prev = Yi.from(aa), this._cache = Yi.allocUnsafe(0), this._secCache = Yi.allocUnsafe(0), this._decrypt = oa, this._mode = ra
	}
	return ta(na, ea), na.prototype._update = function(ra) {
		return this._mode.encrypt(this, ra, this._decrypt)
	}, na.prototype._final = function() {
		this._cipher.scrub()
	}, streamCipher = na, streamCipher
}
var evp_bytestokey, hasRequiredEvp_bytestokey;

function requireEvp_bytestokey() {
	if (hasRequiredEvp_bytestokey) return evp_bytestokey;
	hasRequiredEvp_bytestokey = 1;
	var ue = requireSafeBuffer$1().Buffer,
		Yi = requireMd5_js();

	function ea(ta, na, ra, ia) {
		if (ue.isBuffer(ta) || (ta = ue.from(ta, "binary")), na && (ue.isBuffer(na) || (na = ue.from(na, "binary")), na.length !== 8)) throw new RangeError("salt should be Buffer with 8 byte length");
		for (var aa = ra / 8, oa = ue.alloc(aa), la = ue.alloc(ia || 0), sa = ue.alloc(0); aa > 0 || ia > 0;) {
			var ca = new Yi;
			ca.update(sa), ca.update(ta), na && ca.update(na), sa = ca.digest();
			var ua = 0;
			if (aa > 0) {
				var da = oa.length - aa;
				ua = Math.min(aa, sa.length), sa.copy(oa, da, 0, ua), aa -= ua
			}
			if (ua < sa.length && ia > 0) {
				var ha = la.length - ia,
					pa = Math.min(ia, sa.length - ua);
				sa.copy(la, ha, ua, ua + pa), ia -= pa
			}
		}
		return sa.fill(0), {
			key: oa,
			iv: la
		}
	}
	return evp_bytestokey = ea, evp_bytestokey
}
var hasRequiredEncrypter;

function requireEncrypter() {
	if (hasRequiredEncrypter) return encrypter;
	hasRequiredEncrypter = 1;
	var ue = requireModes$1(),
		Yi = requireAuthCipher(),
		ea = requireSafeBuffer$1().Buffer,
		ta = requireStreamCipher(),
		na = requireCipherBase(),
		ra = requireAes(),
		ia = requireEvp_bytestokey(),
		aa = requireInherits_browser();

	function oa(da, ha, pa) {
		na.call(this), this._cache = new sa, this._cipher = new ra.AES(ha), this._prev = ea.from(pa), this._mode = da, this._autopadding = !0
	}
	aa(oa, na), oa.prototype._update = function(da) {
		this._cache.add(da);
		for (var ha, pa, va = []; ha = this._cache.get();) pa = this._mode.encrypt(this, ha), va.push(pa);
		return ea.concat(va)
	};
	var la = ea.alloc(16, 16);
	oa.prototype._final = function() {
		var da = this._cache.flush();
		if (this._autopadding) return da = this._mode.encrypt(this, da), this._cipher.scrub(), da;
		if (!da.equals(la)) throw this._cipher.scrub(), new Error("data not multiple of block length")
	}, oa.prototype.setAutoPadding = function(da) {
		return this._autopadding = !!da, this
	};

	function sa() {
		this.cache = ea.allocUnsafe(0)
	}
	sa.prototype.add = function(da) {
		this.cache = ea.concat([this.cache, da])
	}, sa.prototype.get = function() {
		if (this.cache.length > 15) {
			var da = this.cache.slice(0, 16);
			return this.cache = this.cache.slice(16), da
		}
		return null
	}, sa.prototype.flush = function() {
		for (var da = 16 - this.cache.length, ha = ea.allocUnsafe(da), pa = -1; ++pa < da;) ha.writeUInt8(da, pa);
		return ea.concat([this.cache, ha])
	};

	function ca(da, ha, pa) {
		var va = ue[da.toLowerCase()];
		if (!va) throw new TypeError("invalid suite type");
		if (typeof ha == "string" && (ha = ea.from(ha)), ha.length !== va.key / 8) throw new TypeError("invalid key length " + ha.length);
		if (typeof pa == "string" && (pa = ea.from(pa)), va.mode !== "GCM" && pa.length !== va.iv) throw new TypeError("invalid iv length " + pa.length);
		return va.type === "stream" ? new ta(va.module, ha, pa) : va.type === "auth" ? new Yi(va.module, ha, pa) : new oa(va.module, ha, pa)
	}

	function ua(da, ha) {
		var pa = ue[da.toLowerCase()];
		if (!pa) throw new TypeError("invalid suite type");
		var va = ia(ha, !1, pa.key, pa.iv);
		return ca(da, va.key, va.iv)
	}
	return encrypter.createCipheriv = ca, encrypter.createCipher = ua, encrypter
}
var decrypter = {},
	hasRequiredDecrypter;

function requireDecrypter() {
	if (hasRequiredDecrypter) return decrypter;
	hasRequiredDecrypter = 1;
	var ue = requireAuthCipher(),
		Yi = requireSafeBuffer$1().Buffer,
		ea = requireModes$1(),
		ta = requireStreamCipher(),
		na = requireCipherBase(),
		ra = requireAes(),
		ia = requireEvp_bytestokey(),
		aa = requireInherits_browser();

	function oa(da, ha, pa) {
		na.call(this), this._cache = new la, this._last = void 0, this._cipher = new ra.AES(ha), this._prev = Yi.from(pa), this._mode = da, this._autopadding = !0
	}
	aa(oa, na), oa.prototype._update = function(da) {
		this._cache.add(da);
		for (var ha, pa, va = []; ha = this._cache.get(this._autopadding);) pa = this._mode.decrypt(this, ha), va.push(pa);
		return Yi.concat(va)
	}, oa.prototype._final = function() {
		var da = this._cache.flush();
		if (this._autopadding) return sa(this._mode.decrypt(this, da));
		if (da) throw new Error("data not multiple of block length")
	}, oa.prototype.setAutoPadding = function(da) {
		return this._autopadding = !!da, this
	};

	function la() {
		this.cache = Yi.allocUnsafe(0)
	}
	la.prototype.add = function(da) {
		this.cache = Yi.concat([this.cache, da])
	}, la.prototype.get = function(da) {
		var ha;
		if (da) {
			if (this.cache.length > 16) return ha = this.cache.slice(0, 16), this.cache = this.cache.slice(16), ha
		} else if (this.cache.length >= 16) return ha = this.cache.slice(0, 16), this.cache = this.cache.slice(16), ha;
		return null
	}, la.prototype.flush = function() {
		if (this.cache.length) return this.cache
	};

	function sa(da) {
		var ha = da[15];
		if (ha < 1 || ha > 16) throw new Error("unable to decrypt data");
		for (var pa = -1; ++pa < ha;)
			if (da[pa + (16 - ha)] !== ha) throw new Error("unable to decrypt data");
		if (ha !== 16) return da.slice(0, 16 - ha)
	}

	function ca(da, ha, pa) {
		var va = ea[da.toLowerCase()];
		if (!va) throw new TypeError("invalid suite type");
		if (typeof pa == "string" && (pa = Yi.from(pa)), va.mode !== "GCM" && pa.length !== va.iv) throw new TypeError("invalid iv length " + pa.length);
		if (typeof ha == "string" && (ha = Yi.from(ha)), ha.length !== va.key / 8) throw new TypeError("invalid key length " + ha.length);
		return va.type === "stream" ? new ta(va.module, ha, pa, !0) : va.type === "auth" ? new ue(va.module, ha, pa, !0) : new oa(va.module, ha, pa)
	}

	function ua(da, ha) {
		var pa = ea[da.toLowerCase()];
		if (!pa) throw new TypeError("invalid suite type");
		var va = ia(ha, !1, pa.key, pa.iv);
		return ca(da, va.key, va.iv)
	}
	return decrypter.createDecipher = ua, decrypter.createDecipheriv = ca, decrypter
}
var hasRequiredBrowser$6;

function requireBrowser$6() {
	if (hasRequiredBrowser$6) return browser$5;
	hasRequiredBrowser$6 = 1;
	var ue = requireEncrypter(),
		Yi = requireDecrypter(),
		ea = require$$2;

	function ta() {
		return Object.keys(ea)
	}
	return browser$5.createCipher = browser$5.Cipher = ue.createCipher, browser$5.createCipheriv = browser$5.Cipheriv = ue.createCipheriv, browser$5.createDecipher = browser$5.Decipher = Yi.createDecipher, browser$5.createDecipheriv = browser$5.Decipheriv = Yi.createDecipheriv, browser$5.listCiphers = browser$5.getCiphers = ta, browser$5
}
var modes = {},
	hasRequiredModes;

function requireModes() {
	return hasRequiredModes || (hasRequiredModes = 1, function(ue) {
		ue["des-ecb"] = {
			key: 8,
			iv: 0
		}, ue["des-cbc"] = ue.des = {
			key: 8,
			iv: 8
		}, ue["des-ede3-cbc"] = ue.des3 = {
			key: 24,
			iv: 8
		}, ue["des-ede3"] = {
			key: 24,
			iv: 0
		}, ue["des-ede-cbc"] = {
			key: 16,
			iv: 8
		}, ue["des-ede"] = {
			key: 16,
			iv: 0
		}
	}(modes)), modes
}
var hasRequiredBrowser$5;

function requireBrowser$5() {
	if (hasRequiredBrowser$5) return browser$6;
	hasRequiredBrowser$5 = 1;
	var ue = requireBrowserifyDes(),
		Yi = requireBrowser$6(),
		ea = requireModes$1(),
		ta = requireModes(),
		na = requireEvp_bytestokey();

	function ra(sa, ca) {
		sa = sa.toLowerCase();
		var ua, da;
		if (ea[sa]) ua = ea[sa].key, da = ea[sa].iv;
		else if (ta[sa]) ua = ta[sa].key * 8, da = ta[sa].iv;
		else throw new TypeError("invalid suite type");
		var ha = na(ca, !1, ua, da);
		return aa(sa, ha.key, ha.iv)
	}

	function ia(sa, ca) {
		sa = sa.toLowerCase();
		var ua, da;
		if (ea[sa]) ua = ea[sa].key, da = ea[sa].iv;
		else if (ta[sa]) ua = ta[sa].key * 8, da = ta[sa].iv;
		else throw new TypeError("invalid suite type");
		var ha = na(ca, !1, ua, da);
		return oa(sa, ha.key, ha.iv)
	}

	function aa(sa, ca, ua) {
		if (sa = sa.toLowerCase(), ea[sa]) return Yi.createCipheriv(sa, ca, ua);
		if (ta[sa]) return new ue({
			key: ca,
			iv: ua,
			mode: sa
		});
		throw new TypeError("invalid suite type")
	}

	function oa(sa, ca, ua) {
		if (sa = sa.toLowerCase(), ea[sa]) return Yi.createDecipheriv(sa, ca, ua);
		if (ta[sa]) return new ue({
			key: ca,
			iv: ua,
			mode: sa,
			decrypt: !0
		});
		throw new TypeError("invalid suite type")
	}

	function la() {
		return Object.keys(ta).concat(Yi.getCiphers())
	}
	return browser$6.createCipher = browser$6.Cipher = ra, browser$6.createCipheriv = browser$6.Cipheriv = aa, browser$6.createDecipher = browser$6.Decipher = ia, browser$6.createDecipheriv = browser$6.Decipheriv = oa, browser$6.listCiphers = browser$6.getCiphers = la, browser$6
}
var browser$4 = {},
	bn$3 = {
		exports: {}
	};
bn$3.exports;
var hasRequiredBn$2;

function requireBn$2() {
	return hasRequiredBn$2 || (hasRequiredBn$2 = 1, function(ue) {
		(function(Yi, ea) {
			function ta(Ua, xa) {
				if (!Ua) throw new Error(xa || "Assertion failed")
			}

			function na(Ua, xa) {
				Ua.super_ = xa;
				var ma = function() {};
				ma.prototype = xa.prototype, Ua.prototype = new ma, Ua.prototype.constructor = Ua
			}

			function ra(Ua, xa, ma) {
				if (ra.isBN(Ua)) return Ua;
				this.negative = 0, this.words = null, this.length = 0, this.red = null, Ua !== null && ((xa === "le" || xa === "be") && (ma = xa, xa = 10), this._init(Ua || 0, xa || 10, ma || "be"))
			}
			typeof Yi == "object" ? Yi.exports = ra : ea.BN = ra, ra.BN = ra, ra.wordSize = 26;
			var ia;
			try {
				typeof window < "u" && typeof window.Buffer < "u" ? ia = window.Buffer : ia = require$$1$2.Buffer
			} catch {}
			ra.isBN = function(xa) {
				return xa instanceof ra ? !0 : xa !== null && typeof xa == "object" && xa.constructor.wordSize === ra.wordSize && Array.isArray(xa.words)
			}, ra.max = function(xa, ma) {
				return xa.cmp(ma) > 0 ? xa : ma
			}, ra.min = function(xa, ma) {
				return xa.cmp(ma) < 0 ? xa : ma
			}, ra.prototype._init = function(xa, ma, fa) {
				if (typeof xa == "number") return this._initNumber(xa, ma, fa);
				if (typeof xa == "object") return this._initArray(xa, ma, fa);
				ma === "hex" && (ma = 16), ta(ma === (ma | 0) && ma >= 2 && ma <= 36), xa = xa.toString().replace(/\s+/g, "");
				var ga = 0;
				xa[0] === "-" && (ga++, this.negative = 1), ga < xa.length && (ma === 16 ? this._parseHex(xa, ga, fa) : (this._parseBase(xa, ma, ga), fa === "le" && this._initArray(this.toArray(), ma, fa)))
			}, ra.prototype._initNumber = function(xa, ma, fa) {
				xa < 0 && (this.negative = 1, xa = -xa), xa < 67108864 ? (this.words = [xa & 67108863], this.length = 1) : xa < 4503599627370496 ? (this.words = [xa & 67108863, xa / 67108864 & 67108863], this.length = 2) : (ta(xa < 9007199254740992), this.words = [xa & 67108863, xa / 67108864 & 67108863, 1], this.length = 3), fa === "le" && this._initArray(this.toArray(), ma, fa)
			}, ra.prototype._initArray = function(xa, ma, fa) {
				if (ta(typeof xa.length == "number"), xa.length <= 0) return this.words = [0], this.length = 1, this;
				this.length = Math.ceil(xa.length / 3), this.words = new Array(this.length);
				for (var ga = 0; ga < this.length; ga++) this.words[ga] = 0;
				var wa, Ma, Aa = 0;
				if (fa === "be")
					for (ga = xa.length - 1, wa = 0; ga >= 0; ga -= 3) Ma = xa[ga] | xa[ga - 1] << 8 | xa[ga - 2] << 16, this.words[wa] |= Ma << Aa & 67108863, this.words[wa + 1] = Ma >>> 26 - Aa & 67108863, Aa += 24, Aa >= 26 && (Aa -= 26, wa++);
				else if (fa === "le")
					for (ga = 0, wa = 0; ga < xa.length; ga += 3) Ma = xa[ga] | xa[ga + 1] << 8 | xa[ga + 2] << 16, this.words[wa] |= Ma << Aa & 67108863, this.words[wa + 1] = Ma >>> 26 - Aa & 67108863, Aa += 24, Aa >= 26 && (Aa -= 26, wa++);
				return this.strip()
			};

			function aa(Ua, xa) {
				var ma = Ua.charCodeAt(xa);
				return ma >= 65 && ma <= 70 ? ma - 55 : ma >= 97 && ma <= 102 ? ma - 87 : ma - 48 & 15
			}

			function oa(Ua, xa, ma) {
				var fa = aa(Ua, ma);
				return ma - 1 >= xa && (fa |= aa(Ua, ma - 1) << 4), fa
			}
			ra.prototype._parseHex = function(xa, ma, fa) {
				this.length = Math.ceil((xa.length - ma) / 6), this.words = new Array(this.length);
				for (var ga = 0; ga < this.length; ga++) this.words[ga] = 0;
				var wa = 0,
					Ma = 0,
					Aa;
				if (fa === "be")
					for (ga = xa.length - 1; ga >= ma; ga -= 2) Aa = oa(xa, ma, ga) << wa, this.words[Ma] |= Aa & 67108863, wa >= 18 ? (wa -= 18, Ma += 1, this.words[Ma] |= Aa >>> 26) : wa += 8;
				else {
					var Ra = xa.length - ma;
					for (ga = Ra % 2 === 0 ? ma + 1 : ma; ga < xa.length; ga += 2) Aa = oa(xa, ma, ga) << wa, this.words[Ma] |= Aa & 67108863, wa >= 18 ? (wa -= 18, Ma += 1, this.words[Ma] |= Aa >>> 26) : wa += 8
				}
				this.strip()
			};

			function la(Ua, xa, ma, fa) {
				for (var ga = 0, wa = Math.min(Ua.length, ma), Ma = xa; Ma < wa; Ma++) {
					var Aa = Ua.charCodeAt(Ma) - 48;
					ga *= fa, Aa >= 49 ? ga += Aa - 49 + 10 : Aa >= 17 ? ga += Aa - 17 + 10 : ga += Aa
				}
				return ga
			}
			ra.prototype._parseBase = function(xa, ma, fa) {
				this.words = [0], this.length = 1;
				for (var ga = 0, wa = 1; wa <= 67108863; wa *= ma) ga++;
				ga--, wa = wa / ma | 0;
				for (var Ma = xa.length - fa, Aa = Ma % ga, Ra = Math.min(Ma, Ma - Aa) + fa, Ta = 0, La = fa; La < Ra; La += ga) Ta = la(xa, La, La + ga, ma), this.imuln(wa), this.words[0] + Ta < 67108864 ? this.words[0] += Ta : this._iaddn(Ta);
				if (Aa !== 0) {
					var ya = 1;
					for (Ta = la(xa, La, xa.length, ma), La = 0; La < Aa; La++) ya *= ma;
					this.imuln(ya), this.words[0] + Ta < 67108864 ? this.words[0] += Ta : this._iaddn(Ta)
				}
				this.strip()
			}, ra.prototype.copy = function(xa) {
				xa.words = new Array(this.length);
				for (var ma = 0; ma < this.length; ma++) xa.words[ma] = this.words[ma];
				xa.length = this.length, xa.negative = this.negative, xa.red = this.red
			}, ra.prototype.clone = function() {
				var xa = new ra(null);
				return this.copy(xa), xa
			}, ra.prototype._expand = function(xa) {
				for (; this.length < xa;) this.words[this.length++] = 0;
				return this
			}, ra.prototype.strip = function() {
				for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
				return this._normSign()
			}, ra.prototype._normSign = function() {
				return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
			}, ra.prototype.inspect = function() {
				return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
			};
			var sa = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
				ca = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
				ua = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
			ra.prototype.toString = function(xa, ma) {
				xa = xa || 10, ma = ma | 0 || 1;
				var fa;
				if (xa === 16 || xa === "hex") {
					fa = "";
					for (var ga = 0, wa = 0, Ma = 0; Ma < this.length; Ma++) {
						var Aa = this.words[Ma],
							Ra = ((Aa << ga | wa) & 16777215).toString(16);
						wa = Aa >>> 24 - ga & 16777215, wa !== 0 || Ma !== this.length - 1 ? fa = sa[6 - Ra.length] + Ra + fa : fa = Ra + fa, ga += 2, ga >= 26 && (ga -= 26, Ma--)
					}
					for (wa !== 0 && (fa = wa.toString(16) + fa); fa.length % ma !== 0;) fa = "0" + fa;
					return this.negative !== 0 && (fa = "-" + fa), fa
				}
				if (xa === (xa | 0) && xa >= 2 && xa <= 36) {
					var Ta = ca[xa],
						La = ua[xa];
					fa = "";
					var ya = this.clone();
					for (ya.negative = 0; !ya.isZero();) {
						var Ba = ya.modn(La).toString(xa);
						ya = ya.idivn(La), ya.isZero() ? fa = Ba + fa : fa = sa[Ta - Ba.length] + Ba + fa
					}
					for (this.isZero() && (fa = "0" + fa); fa.length % ma !== 0;) fa = "0" + fa;
					return this.negative !== 0 && (fa = "-" + fa), fa
				}
				ta(!1, "Base should be between 2 and 36")
			}, ra.prototype.toNumber = function() {
				var xa = this.words[0];
				return this.length === 2 ? xa += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? xa += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && ta(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -xa : xa
			}, ra.prototype.toJSON = function() {
				return this.toString(16)
			}, ra.prototype.toBuffer = function(xa, ma) {
				return ta(typeof ia < "u"), this.toArrayLike(ia, xa, ma)
			}, ra.prototype.toArray = function(xa, ma) {
				return this.toArrayLike(Array, xa, ma)
			}, ra.prototype.toArrayLike = function(xa, ma, fa) {
				var ga = this.byteLength(),
					wa = fa || Math.max(1, ga);
				ta(ga <= wa, "byte array longer than desired length"), ta(wa > 0, "Requested array length <= 0"), this.strip();
				var Ma = ma === "le",
					Aa = new xa(wa),
					Ra, Ta, La = this.clone();
				if (Ma) {
					for (Ta = 0; !La.isZero(); Ta++) Ra = La.andln(255), La.iushrn(8), Aa[Ta] = Ra;
					for (; Ta < wa; Ta++) Aa[Ta] = 0
				} else {
					for (Ta = 0; Ta < wa - ga; Ta++) Aa[Ta] = 0;
					for (Ta = 0; !La.isZero(); Ta++) Ra = La.andln(255), La.iushrn(8), Aa[wa - Ta - 1] = Ra
				}
				return Aa
			}, Math.clz32 ? ra.prototype._countBits = function(xa) {
				return 32 - Math.clz32(xa)
			} : ra.prototype._countBits = function(xa) {
				var ma = xa,
					fa = 0;
				return ma >= 4096 && (fa += 13, ma >>>= 13), ma >= 64 && (fa += 7, ma >>>= 7), ma >= 8 && (fa += 4, ma >>>= 4), ma >= 2 && (fa += 2, ma >>>= 2), fa + ma
			}, ra.prototype._zeroBits = function(xa) {
				if (xa === 0) return 26;
				var ma = xa,
					fa = 0;
				return ma & 8191 || (fa += 13, ma >>>= 13), ma & 127 || (fa += 7, ma >>>= 7), ma & 15 || (fa += 4, ma >>>= 4), ma & 3 || (fa += 2, ma >>>= 2), ma & 1 || fa++, fa
			}, ra.prototype.bitLength = function() {
				var xa = this.words[this.length - 1],
					ma = this._countBits(xa);
				return (this.length - 1) * 26 + ma
			};

			function da(Ua) {
				for (var xa = new Array(Ua.bitLength()), ma = 0; ma < xa.length; ma++) {
					var fa = ma / 26 | 0,
						ga = ma % 26;
					xa[ma] = (Ua.words[fa] & 1 << ga) >>> ga
				}
				return xa
			}
			ra.prototype.zeroBits = function() {
				if (this.isZero()) return 0;
				for (var xa = 0, ma = 0; ma < this.length; ma++) {
					var fa = this._zeroBits(this.words[ma]);
					if (xa += fa, fa !== 26) break
				}
				return xa
			}, ra.prototype.byteLength = function() {
				return Math.ceil(this.bitLength() / 8)
			}, ra.prototype.toTwos = function(xa) {
				return this.negative !== 0 ? this.abs().inotn(xa).iaddn(1) : this.clone()
			}, ra.prototype.fromTwos = function(xa) {
				return this.testn(xa - 1) ? this.notn(xa).iaddn(1).ineg() : this.clone()
			}, ra.prototype.isNeg = function() {
				return this.negative !== 0
			}, ra.prototype.neg = function() {
				return this.clone().ineg()
			}, ra.prototype.ineg = function() {
				return this.isZero() || (this.negative ^= 1), this
			}, ra.prototype.iuor = function(xa) {
				for (; this.length < xa.length;) this.words[this.length++] = 0;
				for (var ma = 0; ma < xa.length; ma++) this.words[ma] = this.words[ma] | xa.words[ma];
				return this.strip()
			}, ra.prototype.ior = function(xa) {
				return ta((this.negative | xa.negative) === 0), this.iuor(xa)
			}, ra.prototype.or = function(xa) {
				return this.length > xa.length ? this.clone().ior(xa) : xa.clone().ior(this)
			}, ra.prototype.uor = function(xa) {
				return this.length > xa.length ? this.clone().iuor(xa) : xa.clone().iuor(this)
			}, ra.prototype.iuand = function(xa) {
				var ma;
				this.length > xa.length ? ma = xa : ma = this;
				for (var fa = 0; fa < ma.length; fa++) this.words[fa] = this.words[fa] & xa.words[fa];
				return this.length = ma.length, this.strip()
			}, ra.prototype.iand = function(xa) {
				return ta((this.negative | xa.negative) === 0), this.iuand(xa)
			}, ra.prototype.and = function(xa) {
				return this.length > xa.length ? this.clone().iand(xa) : xa.clone().iand(this)
			}, ra.prototype.uand = function(xa) {
				return this.length > xa.length ? this.clone().iuand(xa) : xa.clone().iuand(this)
			}, ra.prototype.iuxor = function(xa) {
				var ma, fa;
				this.length > xa.length ? (ma = this, fa = xa) : (ma = xa, fa = this);
				for (var ga = 0; ga < fa.length; ga++) this.words[ga] = ma.words[ga] ^ fa.words[ga];
				if (this !== ma)
					for (; ga < ma.length; ga++) this.words[ga] = ma.words[ga];
				return this.length = ma.length, this.strip()
			}, ra.prototype.ixor = function(xa) {
				return ta((this.negative | xa.negative) === 0), this.iuxor(xa)
			}, ra.prototype.xor = function(xa) {
				return this.length > xa.length ? this.clone().ixor(xa) : xa.clone().ixor(this)
			}, ra.prototype.uxor = function(xa) {
				return this.length > xa.length ? this.clone().iuxor(xa) : xa.clone().iuxor(this)
			}, ra.prototype.inotn = function(xa) {
				ta(typeof xa == "number" && xa >= 0);
				var ma = Math.ceil(xa / 26) | 0,
					fa = xa % 26;
				this._expand(ma), fa > 0 && ma--;
				for (var ga = 0; ga < ma; ga++) this.words[ga] = ~this.words[ga] & 67108863;
				return fa > 0 && (this.words[ga] = ~this.words[ga] & 67108863 >> 26 - fa), this.strip()
			}, ra.prototype.notn = function(xa) {
				return this.clone().inotn(xa)
			}, ra.prototype.setn = function(xa, ma) {
				ta(typeof xa == "number" && xa >= 0);
				var fa = xa / 26 | 0,
					ga = xa % 26;
				return this._expand(fa + 1), ma ? this.words[fa] = this.words[fa] | 1 << ga : this.words[fa] = this.words[fa] & ~(1 << ga), this.strip()
			}, ra.prototype.iadd = function(xa) {
				var ma;
				if (this.negative !== 0 && xa.negative === 0) return this.negative = 0, ma = this.isub(xa), this.negative ^= 1, this._normSign();
				if (this.negative === 0 && xa.negative !== 0) return xa.negative = 0, ma = this.isub(xa), xa.negative = 1, ma._normSign();
				var fa, ga;
				this.length > xa.length ? (fa = this, ga = xa) : (fa = xa, ga = this);
				for (var wa = 0, Ma = 0; Ma < ga.length; Ma++) ma = (fa.words[Ma] | 0) + (ga.words[Ma] | 0) + wa, this.words[Ma] = ma & 67108863, wa = ma >>> 26;
				for (; wa !== 0 && Ma < fa.length; Ma++) ma = (fa.words[Ma] | 0) + wa, this.words[Ma] = ma & 67108863, wa = ma >>> 26;
				if (this.length = fa.length, wa !== 0) this.words[this.length] = wa, this.length++;
				else if (fa !== this)
					for (; Ma < fa.length; Ma++) this.words[Ma] = fa.words[Ma];
				return this
			}, ra.prototype.add = function(xa) {
				var ma;
				return xa.negative !== 0 && this.negative === 0 ? (xa.negative = 0, ma = this.sub(xa), xa.negative ^= 1, ma) : xa.negative === 0 && this.negative !== 0 ? (this.negative = 0, ma = xa.sub(this), this.negative = 1, ma) : this.length > xa.length ? this.clone().iadd(xa) : xa.clone().iadd(this)
			}, ra.prototype.isub = function(xa) {
				if (xa.negative !== 0) {
					xa.negative = 0;
					var ma = this.iadd(xa);
					return xa.negative = 1, ma._normSign()
				} else if (this.negative !== 0) return this.negative = 0, this.iadd(xa), this.negative = 1, this._normSign();
				var fa = this.cmp(xa);
				if (fa === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
				var ga, wa;
				fa > 0 ? (ga = this, wa = xa) : (ga = xa, wa = this);
				for (var Ma = 0, Aa = 0; Aa < wa.length; Aa++) ma = (ga.words[Aa] | 0) - (wa.words[Aa] | 0) + Ma, Ma = ma >> 26, this.words[Aa] = ma & 67108863;
				for (; Ma !== 0 && Aa < ga.length; Aa++) ma = (ga.words[Aa] | 0) + Ma, Ma = ma >> 26, this.words[Aa] = ma & 67108863;
				if (Ma === 0 && Aa < ga.length && ga !== this)
					for (; Aa < ga.length; Aa++) this.words[Aa] = ga.words[Aa];
				return this.length = Math.max(this.length, Aa), ga !== this && (this.negative = 1), this.strip()
			}, ra.prototype.sub = function(xa) {
				return this.clone().isub(xa)
			};

			function ha(Ua, xa, ma) {
				ma.negative = xa.negative ^ Ua.negative;
				var fa = Ua.length + xa.length | 0;
				ma.length = fa, fa = fa - 1 | 0;
				var ga = Ua.words[0] | 0,
					wa = xa.words[0] | 0,
					Ma = ga * wa,
					Aa = Ma & 67108863,
					Ra = Ma / 67108864 | 0;
				ma.words[0] = Aa;
				for (var Ta = 1; Ta < fa; Ta++) {
					for (var La = Ra >>> 26, ya = Ra & 67108863, Ba = Math.min(Ta, xa.length - 1), io = Math.max(0, Ta - Ua.length + 1); io <= Ba; io++) {
						var oo = Ta - io | 0;
						ga = Ua.words[oo] | 0, wa = xa.words[io] | 0, Ma = ga * wa + ya, La += Ma / 67108864 | 0, ya = Ma & 67108863
					}
					ma.words[Ta] = ya | 0, Ra = La | 0
				}
				return Ra !== 0 ? ma.words[Ta] = Ra | 0 : ma.length--, ma.strip()
			}
			var pa = function(xa, ma, fa) {
				var ga = xa.words,
					wa = ma.words,
					Ma = fa.words,
					Aa = 0,
					Ra, Ta, La, ya = ga[0] | 0,
					Ba = ya & 8191,
					io = ya >>> 13,
					oo = ga[1] | 0,
					ao = oo & 8191,
					Ia = oo >>> 13,
					Na = ga[2] | 0,
					za = Na & 8191,
					ro = Na >>> 13,
					Va = ga[3] | 0,
					Wa = Va & 8191,
					qa = Va >>> 13,
					Ka = ga[4] | 0,
					lo = Ka & 8191,
					yo = Ka >>> 13,
					fo = ga[5] | 0,
					vo = fo & 8191,
					so = fo >>> 13,
					Xa = ga[6] | 0,
					to = Xa & 8191,
					ho = Xa >>> 13,
					Eo = ga[7] | 0,
					wo = Eo & 8191,
					Ao = Eo >>> 13,
					_o = ga[8] | 0,
					Lo = _o & 8191,
					Fo = _o >>> 13,
					jo = ga[9] | 0,
					eo = jo & 8191,
					Oa = jo >>> 13,
					Da = wa[0] | 0,
					Qa = Da & 8191,
					uo = Da >>> 13,
					bo = wa[1] | 0,
					So = bo & 8191,
					Wo = bo >>> 13,
					Po = wa[2] | 0,
					Ro = Po & 8191,
					Ho = Po >>> 13,
					Oo = wa[3] | 0,
					No = Oo & 8191,
					ps = Oo >>> 13,
					Ko = wa[4] | 0,
					Go = Ko & 8191,
					bs = Ko >>> 13,
					vs = wa[5] | 0,
					ls = vs & 8191,
					Es = vs >>> 13,
					ws = wa[6] | 0,
					as = ws & 8191,
					go = ws >>> 13,
					Ha = wa[7] | 0,
					Fa = Ha & 8191,
					Ya = Ha >>> 13,
					$a = wa[8] | 0,
					no = $a & 8191,
					Co = $a >>> 13,
					co = wa[9] | 0,
					mo = co & 8191,
					xo = co >>> 13;
				fa.negative = xa.negative ^ ma.negative, fa.length = 19, Ra = Math.imul(Ba, Qa), Ta = Math.imul(Ba, uo), Ta = Ta + Math.imul(io, Qa) | 0, La = Math.imul(io, uo);
				var ko = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + (ko >>> 26) | 0, ko &= 67108863, Ra = Math.imul(ao, Qa), Ta = Math.imul(ao, uo), Ta = Ta + Math.imul(Ia, Qa) | 0, La = Math.imul(Ia, uo), Ra = Ra + Math.imul(Ba, So) | 0, Ta = Ta + Math.imul(Ba, Wo) | 0, Ta = Ta + Math.imul(io, So) | 0, La = La + Math.imul(io, Wo) | 0;
				var $o = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + ($o >>> 26) | 0, $o &= 67108863, Ra = Math.imul(za, Qa), Ta = Math.imul(za, uo), Ta = Ta + Math.imul(ro, Qa) | 0, La = Math.imul(ro, uo), Ra = Ra + Math.imul(ao, So) | 0, Ta = Ta + Math.imul(ao, Wo) | 0, Ta = Ta + Math.imul(Ia, So) | 0, La = La + Math.imul(Ia, Wo) | 0, Ra = Ra + Math.imul(Ba, Ro) | 0, Ta = Ta + Math.imul(Ba, Ho) | 0, Ta = Ta + Math.imul(io, Ro) | 0, La = La + Math.imul(io, Ho) | 0;
				var Ss = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + (Ss >>> 26) | 0, Ss &= 67108863, Ra = Math.imul(Wa, Qa), Ta = Math.imul(Wa, uo), Ta = Ta + Math.imul(qa, Qa) | 0, La = Math.imul(qa, uo), Ra = Ra + Math.imul(za, So) | 0, Ta = Ta + Math.imul(za, Wo) | 0, Ta = Ta + Math.imul(ro, So) | 0, La = La + Math.imul(ro, Wo) | 0, Ra = Ra + Math.imul(ao, Ro) | 0, Ta = Ta + Math.imul(ao, Ho) | 0, Ta = Ta + Math.imul(Ia, Ro) | 0, La = La + Math.imul(Ia, Ho) | 0, Ra = Ra + Math.imul(Ba, No) | 0, Ta = Ta + Math.imul(Ba, ps) | 0, Ta = Ta + Math.imul(io, No) | 0, La = La + Math.imul(io, ps) | 0;
				var Xo = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + (Xo >>> 26) | 0, Xo &= 67108863, Ra = Math.imul(lo, Qa), Ta = Math.imul(lo, uo), Ta = Ta + Math.imul(yo, Qa) | 0, La = Math.imul(yo, uo), Ra = Ra + Math.imul(Wa, So) | 0, Ta = Ta + Math.imul(Wa, Wo) | 0, Ta = Ta + Math.imul(qa, So) | 0, La = La + Math.imul(qa, Wo) | 0, Ra = Ra + Math.imul(za, Ro) | 0, Ta = Ta + Math.imul(za, Ho) | 0, Ta = Ta + Math.imul(ro, Ro) | 0, La = La + Math.imul(ro, Ho) | 0, Ra = Ra + Math.imul(ao, No) | 0, Ta = Ta + Math.imul(ao, ps) | 0, Ta = Ta + Math.imul(Ia, No) | 0, La = La + Math.imul(Ia, ps) | 0, Ra = Ra + Math.imul(Ba, Go) | 0, Ta = Ta + Math.imul(Ba, bs) | 0, Ta = Ta + Math.imul(io, Go) | 0, La = La + Math.imul(io, bs) | 0;
				var ms = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + (ms >>> 26) | 0, ms &= 67108863, Ra = Math.imul(vo, Qa), Ta = Math.imul(vo, uo), Ta = Ta + Math.imul(so, Qa) | 0, La = Math.imul(so, uo), Ra = Ra + Math.imul(lo, So) | 0, Ta = Ta + Math.imul(lo, Wo) | 0, Ta = Ta + Math.imul(yo, So) | 0, La = La + Math.imul(yo, Wo) | 0, Ra = Ra + Math.imul(Wa, Ro) | 0, Ta = Ta + Math.imul(Wa, Ho) | 0, Ta = Ta + Math.imul(qa, Ro) | 0, La = La + Math.imul(qa, Ho) | 0, Ra = Ra + Math.imul(za, No) | 0, Ta = Ta + Math.imul(za, ps) | 0, Ta = Ta + Math.imul(ro, No) | 0, La = La + Math.imul(ro, ps) | 0, Ra = Ra + Math.imul(ao, Go) | 0, Ta = Ta + Math.imul(ao, bs) | 0, Ta = Ta + Math.imul(Ia, Go) | 0, La = La + Math.imul(Ia, bs) | 0, Ra = Ra + Math.imul(Ba, ls) | 0, Ta = Ta + Math.imul(Ba, Es) | 0, Ta = Ta + Math.imul(io, ls) | 0, La = La + Math.imul(io, Es) | 0;
				var gs = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + (gs >>> 26) | 0, gs &= 67108863, Ra = Math.imul(to, Qa), Ta = Math.imul(to, uo), Ta = Ta + Math.imul(ho, Qa) | 0, La = Math.imul(ho, uo), Ra = Ra + Math.imul(vo, So) | 0, Ta = Ta + Math.imul(vo, Wo) | 0, Ta = Ta + Math.imul(so, So) | 0, La = La + Math.imul(so, Wo) | 0, Ra = Ra + Math.imul(lo, Ro) | 0, Ta = Ta + Math.imul(lo, Ho) | 0, Ta = Ta + Math.imul(yo, Ro) | 0, La = La + Math.imul(yo, Ho) | 0, Ra = Ra + Math.imul(Wa, No) | 0, Ta = Ta + Math.imul(Wa, ps) | 0, Ta = Ta + Math.imul(qa, No) | 0, La = La + Math.imul(qa, ps) | 0, Ra = Ra + Math.imul(za, Go) | 0, Ta = Ta + Math.imul(za, bs) | 0, Ta = Ta + Math.imul(ro, Go) | 0, La = La + Math.imul(ro, bs) | 0, Ra = Ra + Math.imul(ao, ls) | 0, Ta = Ta + Math.imul(ao, Es) | 0, Ta = Ta + Math.imul(Ia, ls) | 0, La = La + Math.imul(Ia, Es) | 0, Ra = Ra + Math.imul(Ba, as) | 0, Ta = Ta + Math.imul(Ba, go) | 0, Ta = Ta + Math.imul(io, as) | 0, La = La + Math.imul(io, go) | 0;
				var ys = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + (ys >>> 26) | 0, ys &= 67108863, Ra = Math.imul(wo, Qa), Ta = Math.imul(wo, uo), Ta = Ta + Math.imul(Ao, Qa) | 0, La = Math.imul(Ao, uo), Ra = Ra + Math.imul(to, So) | 0, Ta = Ta + Math.imul(to, Wo) | 0, Ta = Ta + Math.imul(ho, So) | 0, La = La + Math.imul(ho, Wo) | 0, Ra = Ra + Math.imul(vo, Ro) | 0, Ta = Ta + Math.imul(vo, Ho) | 0, Ta = Ta + Math.imul(so, Ro) | 0, La = La + Math.imul(so, Ho) | 0, Ra = Ra + Math.imul(lo, No) | 0, Ta = Ta + Math.imul(lo, ps) | 0, Ta = Ta + Math.imul(yo, No) | 0, La = La + Math.imul(yo, ps) | 0, Ra = Ra + Math.imul(Wa, Go) | 0, Ta = Ta + Math.imul(Wa, bs) | 0, Ta = Ta + Math.imul(qa, Go) | 0, La = La + Math.imul(qa, bs) | 0, Ra = Ra + Math.imul(za, ls) | 0, Ta = Ta + Math.imul(za, Es) | 0, Ta = Ta + Math.imul(ro, ls) | 0, La = La + Math.imul(ro, Es) | 0, Ra = Ra + Math.imul(ao, as) | 0, Ta = Ta + Math.imul(ao, go) | 0, Ta = Ta + Math.imul(Ia, as) | 0, La = La + Math.imul(Ia, go) | 0, Ra = Ra + Math.imul(Ba, Fa) | 0, Ta = Ta + Math.imul(Ba, Ya) | 0, Ta = Ta + Math.imul(io, Fa) | 0, La = La + Math.imul(io, Ya) | 0;
				var Vo = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + (Vo >>> 26) | 0, Vo &= 67108863, Ra = Math.imul(Lo, Qa), Ta = Math.imul(Lo, uo), Ta = Ta + Math.imul(Fo, Qa) | 0, La = Math.imul(Fo, uo), Ra = Ra + Math.imul(wo, So) | 0, Ta = Ta + Math.imul(wo, Wo) | 0, Ta = Ta + Math.imul(Ao, So) | 0, La = La + Math.imul(Ao, Wo) | 0, Ra = Ra + Math.imul(to, Ro) | 0, Ta = Ta + Math.imul(to, Ho) | 0, Ta = Ta + Math.imul(ho, Ro) | 0, La = La + Math.imul(ho, Ho) | 0, Ra = Ra + Math.imul(vo, No) | 0, Ta = Ta + Math.imul(vo, ps) | 0, Ta = Ta + Math.imul(so, No) | 0, La = La + Math.imul(so, ps) | 0, Ra = Ra + Math.imul(lo, Go) | 0, Ta = Ta + Math.imul(lo, bs) | 0, Ta = Ta + Math.imul(yo, Go) | 0, La = La + Math.imul(yo, bs) | 0, Ra = Ra + Math.imul(Wa, ls) | 0, Ta = Ta + Math.imul(Wa, Es) | 0, Ta = Ta + Math.imul(qa, ls) | 0, La = La + Math.imul(qa, Es) | 0, Ra = Ra + Math.imul(za, as) | 0, Ta = Ta + Math.imul(za, go) | 0, Ta = Ta + Math.imul(ro, as) | 0, La = La + Math.imul(ro, go) | 0, Ra = Ra + Math.imul(ao, Fa) | 0, Ta = Ta + Math.imul(ao, Ya) | 0, Ta = Ta + Math.imul(Ia, Fa) | 0, La = La + Math.imul(Ia, Ya) | 0, Ra = Ra + Math.imul(Ba, no) | 0, Ta = Ta + Math.imul(Ba, Co) | 0, Ta = Ta + Math.imul(io, no) | 0, La = La + Math.imul(io, Co) | 0;
				var cs = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + (cs >>> 26) | 0, cs &= 67108863, Ra = Math.imul(eo, Qa), Ta = Math.imul(eo, uo), Ta = Ta + Math.imul(Oa, Qa) | 0, La = Math.imul(Oa, uo), Ra = Ra + Math.imul(Lo, So) | 0, Ta = Ta + Math.imul(Lo, Wo) | 0, Ta = Ta + Math.imul(Fo, So) | 0, La = La + Math.imul(Fo, Wo) | 0, Ra = Ra + Math.imul(wo, Ro) | 0, Ta = Ta + Math.imul(wo, Ho) | 0, Ta = Ta + Math.imul(Ao, Ro) | 0, La = La + Math.imul(Ao, Ho) | 0, Ra = Ra + Math.imul(to, No) | 0, Ta = Ta + Math.imul(to, ps) | 0, Ta = Ta + Math.imul(ho, No) | 0, La = La + Math.imul(ho, ps) | 0, Ra = Ra + Math.imul(vo, Go) | 0, Ta = Ta + Math.imul(vo, bs) | 0, Ta = Ta + Math.imul(so, Go) | 0, La = La + Math.imul(so, bs) | 0, Ra = Ra + Math.imul(lo, ls) | 0, Ta = Ta + Math.imul(lo, Es) | 0, Ta = Ta + Math.imul(yo, ls) | 0, La = La + Math.imul(yo, Es) | 0, Ra = Ra + Math.imul(Wa, as) | 0, Ta = Ta + Math.imul(Wa, go) | 0, Ta = Ta + Math.imul(qa, as) | 0, La = La + Math.imul(qa, go) | 0, Ra = Ra + Math.imul(za, Fa) | 0, Ta = Ta + Math.imul(za, Ya) | 0, Ta = Ta + Math.imul(ro, Fa) | 0, La = La + Math.imul(ro, Ya) | 0, Ra = Ra + Math.imul(ao, no) | 0, Ta = Ta + Math.imul(ao, Co) | 0, Ta = Ta + Math.imul(Ia, no) | 0, La = La + Math.imul(Ia, Co) | 0, Ra = Ra + Math.imul(Ba, mo) | 0, Ta = Ta + Math.imul(Ba, xo) | 0, Ta = Ta + Math.imul(io, mo) | 0, La = La + Math.imul(io, xo) | 0;
				var Zo = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + (Zo >>> 26) | 0, Zo &= 67108863, Ra = Math.imul(eo, So), Ta = Math.imul(eo, Wo), Ta = Ta + Math.imul(Oa, So) | 0, La = Math.imul(Oa, Wo), Ra = Ra + Math.imul(Lo, Ro) | 0, Ta = Ta + Math.imul(Lo, Ho) | 0, Ta = Ta + Math.imul(Fo, Ro) | 0, La = La + Math.imul(Fo, Ho) | 0, Ra = Ra + Math.imul(wo, No) | 0, Ta = Ta + Math.imul(wo, ps) | 0, Ta = Ta + Math.imul(Ao, No) | 0, La = La + Math.imul(Ao, ps) | 0, Ra = Ra + Math.imul(to, Go) | 0, Ta = Ta + Math.imul(to, bs) | 0, Ta = Ta + Math.imul(ho, Go) | 0, La = La + Math.imul(ho, bs) | 0, Ra = Ra + Math.imul(vo, ls) | 0, Ta = Ta + Math.imul(vo, Es) | 0, Ta = Ta + Math.imul(so, ls) | 0, La = La + Math.imul(so, Es) | 0, Ra = Ra + Math.imul(lo, as) | 0, Ta = Ta + Math.imul(lo, go) | 0, Ta = Ta + Math.imul(yo, as) | 0, La = La + Math.imul(yo, go) | 0, Ra = Ra + Math.imul(Wa, Fa) | 0, Ta = Ta + Math.imul(Wa, Ya) | 0, Ta = Ta + Math.imul(qa, Fa) | 0, La = La + Math.imul(qa, Ya) | 0, Ra = Ra + Math.imul(za, no) | 0, Ta = Ta + Math.imul(za, Co) | 0, Ta = Ta + Math.imul(ro, no) | 0, La = La + Math.imul(ro, Co) | 0, Ra = Ra + Math.imul(ao, mo) | 0, Ta = Ta + Math.imul(ao, xo) | 0, Ta = Ta + Math.imul(Ia, mo) | 0, La = La + Math.imul(Ia, xo) | 0;
				var us = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + (us >>> 26) | 0, us &= 67108863, Ra = Math.imul(eo, Ro), Ta = Math.imul(eo, Ho), Ta = Ta + Math.imul(Oa, Ro) | 0, La = Math.imul(Oa, Ho), Ra = Ra + Math.imul(Lo, No) | 0, Ta = Ta + Math.imul(Lo, ps) | 0, Ta = Ta + Math.imul(Fo, No) | 0, La = La + Math.imul(Fo, ps) | 0, Ra = Ra + Math.imul(wo, Go) | 0, Ta = Ta + Math.imul(wo, bs) | 0, Ta = Ta + Math.imul(Ao, Go) | 0, La = La + Math.imul(Ao, bs) | 0, Ra = Ra + Math.imul(to, ls) | 0, Ta = Ta + Math.imul(to, Es) | 0, Ta = Ta + Math.imul(ho, ls) | 0, La = La + Math.imul(ho, Es) | 0, Ra = Ra + Math.imul(vo, as) | 0, Ta = Ta + Math.imul(vo, go) | 0, Ta = Ta + Math.imul(so, as) | 0, La = La + Math.imul(so, go) | 0, Ra = Ra + Math.imul(lo, Fa) | 0, Ta = Ta + Math.imul(lo, Ya) | 0, Ta = Ta + Math.imul(yo, Fa) | 0, La = La + Math.imul(yo, Ya) | 0, Ra = Ra + Math.imul(Wa, no) | 0, Ta = Ta + Math.imul(Wa, Co) | 0, Ta = Ta + Math.imul(qa, no) | 0, La = La + Math.imul(qa, Co) | 0, Ra = Ra + Math.imul(za, mo) | 0, Ta = Ta + Math.imul(za, xo) | 0, Ta = Ta + Math.imul(ro, mo) | 0, La = La + Math.imul(ro, xo) | 0;
				var Jo = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + (Jo >>> 26) | 0, Jo &= 67108863, Ra = Math.imul(eo, No), Ta = Math.imul(eo, ps), Ta = Ta + Math.imul(Oa, No) | 0, La = Math.imul(Oa, ps), Ra = Ra + Math.imul(Lo, Go) | 0, Ta = Ta + Math.imul(Lo, bs) | 0, Ta = Ta + Math.imul(Fo, Go) | 0, La = La + Math.imul(Fo, bs) | 0, Ra = Ra + Math.imul(wo, ls) | 0, Ta = Ta + Math.imul(wo, Es) | 0, Ta = Ta + Math.imul(Ao, ls) | 0, La = La + Math.imul(Ao, Es) | 0, Ra = Ra + Math.imul(to, as) | 0, Ta = Ta + Math.imul(to, go) | 0, Ta = Ta + Math.imul(ho, as) | 0, La = La + Math.imul(ho, go) | 0, Ra = Ra + Math.imul(vo, Fa) | 0, Ta = Ta + Math.imul(vo, Ya) | 0, Ta = Ta + Math.imul(so, Fa) | 0, La = La + Math.imul(so, Ya) | 0, Ra = Ra + Math.imul(lo, no) | 0, Ta = Ta + Math.imul(lo, Co) | 0, Ta = Ta + Math.imul(yo, no) | 0, La = La + Math.imul(yo, Co) | 0, Ra = Ra + Math.imul(Wa, mo) | 0, Ta = Ta + Math.imul(Wa, xo) | 0, Ta = Ta + Math.imul(qa, mo) | 0, La = La + Math.imul(qa, xo) | 0;
				var hs = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + (hs >>> 26) | 0, hs &= 67108863, Ra = Math.imul(eo, Go), Ta = Math.imul(eo, bs), Ta = Ta + Math.imul(Oa, Go) | 0, La = Math.imul(Oa, bs), Ra = Ra + Math.imul(Lo, ls) | 0, Ta = Ta + Math.imul(Lo, Es) | 0, Ta = Ta + Math.imul(Fo, ls) | 0, La = La + Math.imul(Fo, Es) | 0, Ra = Ra + Math.imul(wo, as) | 0, Ta = Ta + Math.imul(wo, go) | 0, Ta = Ta + Math.imul(Ao, as) | 0, La = La + Math.imul(Ao, go) | 0, Ra = Ra + Math.imul(to, Fa) | 0, Ta = Ta + Math.imul(to, Ya) | 0, Ta = Ta + Math.imul(ho, Fa) | 0, La = La + Math.imul(ho, Ya) | 0, Ra = Ra + Math.imul(vo, no) | 0, Ta = Ta + Math.imul(vo, Co) | 0, Ta = Ta + Math.imul(so, no) | 0, La = La + Math.imul(so, Co) | 0, Ra = Ra + Math.imul(lo, mo) | 0, Ta = Ta + Math.imul(lo, xo) | 0, Ta = Ta + Math.imul(yo, mo) | 0, La = La + Math.imul(yo, xo) | 0;
				var Qo = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + (Qo >>> 26) | 0, Qo &= 67108863, Ra = Math.imul(eo, ls), Ta = Math.imul(eo, Es), Ta = Ta + Math.imul(Oa, ls) | 0, La = Math.imul(Oa, Es), Ra = Ra + Math.imul(Lo, as) | 0, Ta = Ta + Math.imul(Lo, go) | 0, Ta = Ta + Math.imul(Fo, as) | 0, La = La + Math.imul(Fo, go) | 0, Ra = Ra + Math.imul(wo, Fa) | 0, Ta = Ta + Math.imul(wo, Ya) | 0, Ta = Ta + Math.imul(Ao, Fa) | 0, La = La + Math.imul(Ao, Ya) | 0, Ra = Ra + Math.imul(to, no) | 0, Ta = Ta + Math.imul(to, Co) | 0, Ta = Ta + Math.imul(ho, no) | 0, La = La + Math.imul(ho, Co) | 0, Ra = Ra + Math.imul(vo, mo) | 0, Ta = Ta + Math.imul(vo, xo) | 0, Ta = Ta + Math.imul(so, mo) | 0, La = La + Math.imul(so, xo) | 0;
				var fs = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + (fs >>> 26) | 0, fs &= 67108863, Ra = Math.imul(eo, as), Ta = Math.imul(eo, go), Ta = Ta + Math.imul(Oa, as) | 0, La = Math.imul(Oa, go), Ra = Ra + Math.imul(Lo, Fa) | 0, Ta = Ta + Math.imul(Lo, Ya) | 0, Ta = Ta + Math.imul(Fo, Fa) | 0, La = La + Math.imul(Fo, Ya) | 0, Ra = Ra + Math.imul(wo, no) | 0, Ta = Ta + Math.imul(wo, Co) | 0, Ta = Ta + Math.imul(Ao, no) | 0, La = La + Math.imul(Ao, Co) | 0, Ra = Ra + Math.imul(to, mo) | 0, Ta = Ta + Math.imul(to, xo) | 0, Ta = Ta + Math.imul(ho, mo) | 0, La = La + Math.imul(ho, xo) | 0;
				var ds = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + (ds >>> 26) | 0, ds &= 67108863, Ra = Math.imul(eo, Fa), Ta = Math.imul(eo, Ya), Ta = Ta + Math.imul(Oa, Fa) | 0, La = Math.imul(Oa, Ya), Ra = Ra + Math.imul(Lo, no) | 0, Ta = Ta + Math.imul(Lo, Co) | 0, Ta = Ta + Math.imul(Fo, no) | 0, La = La + Math.imul(Fo, Co) | 0, Ra = Ra + Math.imul(wo, mo) | 0, Ta = Ta + Math.imul(wo, xo) | 0, Ta = Ta + Math.imul(Ao, mo) | 0, La = La + Math.imul(Ao, xo) | 0;
				var Yo = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + (Yo >>> 26) | 0, Yo &= 67108863, Ra = Math.imul(eo, no), Ta = Math.imul(eo, Co), Ta = Ta + Math.imul(Oa, no) | 0, La = Math.imul(Oa, Co), Ra = Ra + Math.imul(Lo, mo) | 0, Ta = Ta + Math.imul(Lo, xo) | 0, Ta = Ta + Math.imul(Fo, mo) | 0, La = La + Math.imul(Fo, xo) | 0;
				var Bo = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				Aa = (La + (Ta >>> 13) | 0) + (Bo >>> 26) | 0, Bo &= 67108863, Ra = Math.imul(eo, mo), Ta = Math.imul(eo, xo), Ta = Ta + Math.imul(Oa, mo) | 0, La = Math.imul(Oa, xo);
				var Mo = (Aa + Ra | 0) + ((Ta & 8191) << 13) | 0;
				return Aa = (La + (Ta >>> 13) | 0) + (Mo >>> 26) | 0, Mo &= 67108863, Ma[0] = ko, Ma[1] = $o, Ma[2] = Ss, Ma[3] = Xo, Ma[4] = ms, Ma[5] = gs, Ma[6] = ys, Ma[7] = Vo, Ma[8] = cs, Ma[9] = Zo, Ma[10] = us, Ma[11] = Jo, Ma[12] = hs, Ma[13] = Qo, Ma[14] = fs, Ma[15] = ds, Ma[16] = Yo, Ma[17] = Bo, Ma[18] = Mo, Aa !== 0 && (Ma[19] = Aa, fa.length++), fa
			};
			Math.imul || (pa = ha);

			function va(Ua, xa, ma) {
				ma.negative = xa.negative ^ Ua.negative, ma.length = Ua.length + xa.length;
				for (var fa = 0, ga = 0, wa = 0; wa < ma.length - 1; wa++) {
					var Ma = ga;
					ga = 0;
					for (var Aa = fa & 67108863, Ra = Math.min(wa, xa.length - 1), Ta = Math.max(0, wa - Ua.length + 1); Ta <= Ra; Ta++) {
						var La = wa - Ta,
							ya = Ua.words[La] | 0,
							Ba = xa.words[Ta] | 0,
							io = ya * Ba,
							oo = io & 67108863;
						Ma = Ma + (io / 67108864 | 0) | 0, oo = oo + Aa | 0, Aa = oo & 67108863, Ma = Ma + (oo >>> 26) | 0, ga += Ma >>> 26, Ma &= 67108863
					}
					ma.words[wa] = Aa, fa = Ma, Ma = ga
				}
				return fa !== 0 ? ma.words[wa] = fa : ma.length--, ma.strip()
			}

			function ba(Ua, xa, ma) {
				var fa = new Ea;
				return fa.mulp(Ua, xa, ma)
			}
			ra.prototype.mulTo = function(xa, ma) {
				var fa, ga = this.length + xa.length;
				return this.length === 10 && xa.length === 10 ? fa = pa(this, xa, ma) : ga < 63 ? fa = ha(this, xa, ma) : ga < 1024 ? fa = va(this, xa, ma) : fa = ba(this, xa, ma), fa
			};

			function Ea(Ua, xa) {
				this.x = Ua, this.y = xa
			}
			Ea.prototype.makeRBT = function(xa) {
				for (var ma = new Array(xa), fa = ra.prototype._countBits(xa) - 1, ga = 0; ga < xa; ga++) ma[ga] = this.revBin(ga, fa, xa);
				return ma
			}, Ea.prototype.revBin = function(xa, ma, fa) {
				if (xa === 0 || xa === fa - 1) return xa;
				for (var ga = 0, wa = 0; wa < ma; wa++) ga |= (xa & 1) << ma - wa - 1, xa >>= 1;
				return ga
			}, Ea.prototype.permute = function(xa, ma, fa, ga, wa, Ma) {
				for (var Aa = 0; Aa < Ma; Aa++) ga[Aa] = ma[xa[Aa]], wa[Aa] = fa[xa[Aa]]
			}, Ea.prototype.transform = function(xa, ma, fa, ga, wa, Ma) {
				this.permute(Ma, xa, ma, fa, ga, wa);
				for (var Aa = 1; Aa < wa; Aa <<= 1)
					for (var Ra = Aa << 1, Ta = Math.cos(2 * Math.PI / Ra), La = Math.sin(2 * Math.PI / Ra), ya = 0; ya < wa; ya += Ra)
						for (var Ba = Ta, io = La, oo = 0; oo < Aa; oo++) {
							var ao = fa[ya + oo],
								Ia = ga[ya + oo],
								Na = fa[ya + oo + Aa],
								za = ga[ya + oo + Aa],
								ro = Ba * Na - io * za;
							za = Ba * za + io * Na, Na = ro, fa[ya + oo] = ao + Na, ga[ya + oo] = Ia + za, fa[ya + oo + Aa] = ao - Na, ga[ya + oo + Aa] = Ia - za, oo !== Ra && (ro = Ta * Ba - La * io, io = Ta * io + La * Ba, Ba = ro)
						}
			}, Ea.prototype.guessLen13b = function(xa, ma) {
				var fa = Math.max(ma, xa) | 1,
					ga = fa & 1,
					wa = 0;
				for (fa = fa / 2 | 0; fa; fa = fa >>> 1) wa++;
				return 1 << wa + 1 + ga
			}, Ea.prototype.conjugate = function(xa, ma, fa) {
				if (!(fa <= 1))
					for (var ga = 0; ga < fa / 2; ga++) {
						var wa = xa[ga];
						xa[ga] = xa[fa - ga - 1], xa[fa - ga - 1] = wa, wa = ma[ga], ma[ga] = -ma[fa - ga - 1], ma[fa - ga - 1] = -wa
					}
			}, Ea.prototype.normalize13b = function(xa, ma) {
				for (var fa = 0, ga = 0; ga < ma / 2; ga++) {
					var wa = Math.round(xa[2 * ga + 1] / ma) * 8192 + Math.round(xa[2 * ga] / ma) + fa;
					xa[ga] = wa & 67108863, wa < 67108864 ? fa = 0 : fa = wa / 67108864 | 0
				}
				return xa
			}, Ea.prototype.convert13b = function(xa, ma, fa, ga) {
				for (var wa = 0, Ma = 0; Ma < ma; Ma++) wa = wa + (xa[Ma] | 0), fa[2 * Ma] = wa & 8191, wa = wa >>> 13, fa[2 * Ma + 1] = wa & 8191, wa = wa >>> 13;
				for (Ma = 2 * ma; Ma < ga; ++Ma) fa[Ma] = 0;
				ta(wa === 0), ta((wa & -8192) === 0)
			}, Ea.prototype.stub = function(xa) {
				for (var ma = new Array(xa), fa = 0; fa < xa; fa++) ma[fa] = 0;
				return ma
			}, Ea.prototype.mulp = function(xa, ma, fa) {
				var ga = 2 * this.guessLen13b(xa.length, ma.length),
					wa = this.makeRBT(ga),
					Ma = this.stub(ga),
					Aa = new Array(ga),
					Ra = new Array(ga),
					Ta = new Array(ga),
					La = new Array(ga),
					ya = new Array(ga),
					Ba = new Array(ga),
					io = fa.words;
				io.length = ga, this.convert13b(xa.words, xa.length, Aa, ga), this.convert13b(ma.words, ma.length, La, ga), this.transform(Aa, Ma, Ra, Ta, ga, wa), this.transform(La, Ma, ya, Ba, ga, wa);
				for (var oo = 0; oo < ga; oo++) {
					var ao = Ra[oo] * ya[oo] - Ta[oo] * Ba[oo];
					Ta[oo] = Ra[oo] * Ba[oo] + Ta[oo] * ya[oo], Ra[oo] = ao
				}
				return this.conjugate(Ra, Ta, ga), this.transform(Ra, Ta, io, Ma, ga, wa), this.conjugate(io, Ma, ga), this.normalize13b(io, ga), fa.negative = xa.negative ^ ma.negative, fa.length = xa.length + ma.length, fa.strip()
			}, ra.prototype.mul = function(xa) {
				var ma = new ra(null);
				return ma.words = new Array(this.length + xa.length), this.mulTo(xa, ma)
			}, ra.prototype.mulf = function(xa) {
				var ma = new ra(null);
				return ma.words = new Array(this.length + xa.length), ba(this, xa, ma)
			}, ra.prototype.imul = function(xa) {
				return this.clone().mulTo(xa, this)
			}, ra.prototype.imuln = function(xa) {
				ta(typeof xa == "number"), ta(xa < 67108864);
				for (var ma = 0, fa = 0; fa < this.length; fa++) {
					var ga = (this.words[fa] | 0) * xa,
						wa = (ga & 67108863) + (ma & 67108863);
					ma >>= 26, ma += ga / 67108864 | 0, ma += wa >>> 26, this.words[fa] = wa & 67108863
				}
				return ma !== 0 && (this.words[fa] = ma, this.length++), this
			}, ra.prototype.muln = function(xa) {
				return this.clone().imuln(xa)
			}, ra.prototype.sqr = function() {
				return this.mul(this)
			}, ra.prototype.isqr = function() {
				return this.imul(this.clone())
			}, ra.prototype.pow = function(xa) {
				var ma = da(xa);
				if (ma.length === 0) return new ra(1);
				for (var fa = this, ga = 0; ga < ma.length && ma[ga] === 0; ga++, fa = fa.sqr());
				if (++ga < ma.length)
					for (var wa = fa.sqr(); ga < ma.length; ga++, wa = wa.sqr()) ma[ga] !== 0 && (fa = fa.mul(wa));
				return fa
			}, ra.prototype.iushln = function(xa) {
				ta(typeof xa == "number" && xa >= 0);
				var ma = xa % 26,
					fa = (xa - ma) / 26,
					ga = 67108863 >>> 26 - ma << 26 - ma,
					wa;
				if (ma !== 0) {
					var Ma = 0;
					for (wa = 0; wa < this.length; wa++) {
						var Aa = this.words[wa] & ga,
							Ra = (this.words[wa] | 0) - Aa << ma;
						this.words[wa] = Ra | Ma, Ma = Aa >>> 26 - ma
					}
					Ma && (this.words[wa] = Ma, this.length++)
				}
				if (fa !== 0) {
					for (wa = this.length - 1; wa >= 0; wa--) this.words[wa + fa] = this.words[wa];
					for (wa = 0; wa < fa; wa++) this.words[wa] = 0;
					this.length += fa
				}
				return this.strip()
			}, ra.prototype.ishln = function(xa) {
				return ta(this.negative === 0), this.iushln(xa)
			}, ra.prototype.iushrn = function(xa, ma, fa) {
				ta(typeof xa == "number" && xa >= 0);
				var ga;
				ma ? ga = (ma - ma % 26) / 26 : ga = 0;
				var wa = xa % 26,
					Ma = Math.min((xa - wa) / 26, this.length),
					Aa = 67108863 ^ 67108863 >>> wa << wa,
					Ra = fa;
				if (ga -= Ma, ga = Math.max(0, ga), Ra) {
					for (var Ta = 0; Ta < Ma; Ta++) Ra.words[Ta] = this.words[Ta];
					Ra.length = Ma
				}
				if (Ma !== 0)
					if (this.length > Ma)
						for (this.length -= Ma, Ta = 0; Ta < this.length; Ta++) this.words[Ta] = this.words[Ta + Ma];
					else this.words[0] = 0, this.length = 1;
				var La = 0;
				for (Ta = this.length - 1; Ta >= 0 && (La !== 0 || Ta >= ga); Ta--) {
					var ya = this.words[Ta] | 0;
					this.words[Ta] = La << 26 - wa | ya >>> wa, La = ya & Aa
				}
				return Ra && La !== 0 && (Ra.words[Ra.length++] = La), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip()
			}, ra.prototype.ishrn = function(xa, ma, fa) {
				return ta(this.negative === 0), this.iushrn(xa, ma, fa)
			}, ra.prototype.shln = function(xa) {
				return this.clone().ishln(xa)
			}, ra.prototype.ushln = function(xa) {
				return this.clone().iushln(xa)
			}, ra.prototype.shrn = function(xa) {
				return this.clone().ishrn(xa)
			}, ra.prototype.ushrn = function(xa) {
				return this.clone().iushrn(xa)
			}, ra.prototype.testn = function(xa) {
				ta(typeof xa == "number" && xa >= 0);
				var ma = xa % 26,
					fa = (xa - ma) / 26,
					ga = 1 << ma;
				if (this.length <= fa) return !1;
				var wa = this.words[fa];
				return !!(wa & ga)
			}, ra.prototype.imaskn = function(xa) {
				ta(typeof xa == "number" && xa >= 0);
				var ma = xa % 26,
					fa = (xa - ma) / 26;
				if (ta(this.negative === 0, "imaskn works only with positive numbers"), this.length <= fa) return this;
				if (ma !== 0 && fa++, this.length = Math.min(fa, this.length), ma !== 0) {
					var ga = 67108863 ^ 67108863 >>> ma << ma;
					this.words[this.length - 1] &= ga
				}
				return this.strip()
			}, ra.prototype.maskn = function(xa) {
				return this.clone().imaskn(xa)
			}, ra.prototype.iaddn = function(xa) {
				return ta(typeof xa == "number"), ta(xa < 67108864), xa < 0 ? this.isubn(-xa) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < xa ? (this.words[0] = xa - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(xa), this.negative = 1, this) : this._iaddn(xa)
			}, ra.prototype._iaddn = function(xa) {
				this.words[0] += xa;
				for (var ma = 0; ma < this.length && this.words[ma] >= 67108864; ma++) this.words[ma] -= 67108864, ma === this.length - 1 ? this.words[ma + 1] = 1 : this.words[ma + 1]++;
				return this.length = Math.max(this.length, ma + 1), this
			}, ra.prototype.isubn = function(xa) {
				if (ta(typeof xa == "number"), ta(xa < 67108864), xa < 0) return this.iaddn(-xa);
				if (this.negative !== 0) return this.negative = 0, this.iaddn(xa), this.negative = 1, this;
				if (this.words[0] -= xa, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
				else
					for (var ma = 0; ma < this.length && this.words[ma] < 0; ma++) this.words[ma] += 67108864, this.words[ma + 1] -= 1;
				return this.strip()
			}, ra.prototype.addn = function(xa) {
				return this.clone().iaddn(xa)
			}, ra.prototype.subn = function(xa) {
				return this.clone().isubn(xa)
			}, ra.prototype.iabs = function() {
				return this.negative = 0, this
			}, ra.prototype.abs = function() {
				return this.clone().iabs()
			}, ra.prototype._ishlnsubmul = function(xa, ma, fa) {
				var ga = xa.length + fa,
					wa;
				this._expand(ga);
				var Ma, Aa = 0;
				for (wa = 0; wa < xa.length; wa++) {
					Ma = (this.words[wa + fa] | 0) + Aa;
					var Ra = (xa.words[wa] | 0) * ma;
					Ma -= Ra & 67108863, Aa = (Ma >> 26) - (Ra / 67108864 | 0), this.words[wa + fa] = Ma & 67108863
				}
				for (; wa < this.length - fa; wa++) Ma = (this.words[wa + fa] | 0) + Aa, Aa = Ma >> 26, this.words[wa + fa] = Ma & 67108863;
				if (Aa === 0) return this.strip();
				for (ta(Aa === -1), Aa = 0, wa = 0; wa < this.length; wa++) Ma = -(this.words[wa] | 0) + Aa, Aa = Ma >> 26, this.words[wa] = Ma & 67108863;
				return this.negative = 1, this.strip()
			}, ra.prototype._wordDiv = function(xa, ma) {
				var fa = this.length - xa.length,
					ga = this.clone(),
					wa = xa,
					Ma = wa.words[wa.length - 1] | 0,
					Aa = this._countBits(Ma);
				fa = 26 - Aa, fa !== 0 && (wa = wa.ushln(fa), ga.iushln(fa), Ma = wa.words[wa.length - 1] | 0);
				var Ra = ga.length - wa.length,
					Ta;
				if (ma !== "mod") {
					Ta = new ra(null), Ta.length = Ra + 1, Ta.words = new Array(Ta.length);
					for (var La = 0; La < Ta.length; La++) Ta.words[La] = 0
				}
				var ya = ga.clone()._ishlnsubmul(wa, 1, Ra);
				ya.negative === 0 && (ga = ya, Ta && (Ta.words[Ra] = 1));
				for (var Ba = Ra - 1; Ba >= 0; Ba--) {
					var io = (ga.words[wa.length + Ba] | 0) * 67108864 + (ga.words[wa.length + Ba - 1] | 0);
					for (io = Math.min(io / Ma | 0, 67108863), ga._ishlnsubmul(wa, io, Ba); ga.negative !== 0;) io--, ga.negative = 0, ga._ishlnsubmul(wa, 1, Ba), ga.isZero() || (ga.negative ^= 1);
					Ta && (Ta.words[Ba] = io)
				}
				return Ta && Ta.strip(), ga.strip(), ma !== "div" && fa !== 0 && ga.iushrn(fa), {
					div: Ta || null,
					mod: ga
				}
			}, ra.prototype.divmod = function(xa, ma, fa) {
				if (ta(!xa.isZero()), this.isZero()) return {
					div: new ra(0),
					mod: new ra(0)
				};
				var ga, wa, Ma;
				return this.negative !== 0 && xa.negative === 0 ? (Ma = this.neg().divmod(xa, ma), ma !== "mod" && (ga = Ma.div.neg()), ma !== "div" && (wa = Ma.mod.neg(), fa && wa.negative !== 0 && wa.iadd(xa)), {
					div: ga,
					mod: wa
				}) : this.negative === 0 && xa.negative !== 0 ? (Ma = this.divmod(xa.neg(), ma), ma !== "mod" && (ga = Ma.div.neg()), {
					div: ga,
					mod: Ma.mod
				}) : this.negative & xa.negative ? (Ma = this.neg().divmod(xa.neg(), ma), ma !== "div" && (wa = Ma.mod.neg(), fa && wa.negative !== 0 && wa.isub(xa)), {
					div: Ma.div,
					mod: wa
				}) : xa.length > this.length || this.cmp(xa) < 0 ? {
					div: new ra(0),
					mod: this
				} : xa.length === 1 ? ma === "div" ? {
					div: this.divn(xa.words[0]),
					mod: null
				} : ma === "mod" ? {
					div: null,
					mod: new ra(this.modn(xa.words[0]))
				} : {
					div: this.divn(xa.words[0]),
					mod: new ra(this.modn(xa.words[0]))
				} : this._wordDiv(xa, ma)
			}, ra.prototype.div = function(xa) {
				return this.divmod(xa, "div", !1).div
			}, ra.prototype.mod = function(xa) {
				return this.divmod(xa, "mod", !1).mod
			}, ra.prototype.umod = function(xa) {
				return this.divmod(xa, "mod", !0).mod
			}, ra.prototype.divRound = function(xa) {
				var ma = this.divmod(xa);
				if (ma.mod.isZero()) return ma.div;
				var fa = ma.div.negative !== 0 ? ma.mod.isub(xa) : ma.mod,
					ga = xa.ushrn(1),
					wa = xa.andln(1),
					Ma = fa.cmp(ga);
				return Ma < 0 || wa === 1 && Ma === 0 ? ma.div : ma.div.negative !== 0 ? ma.div.isubn(1) : ma.div.iaddn(1)
			}, ra.prototype.modn = function(xa) {
				ta(xa <= 67108863);
				for (var ma = (1 << 26) % xa, fa = 0, ga = this.length - 1; ga >= 0; ga--) fa = (ma * fa + (this.words[ga] | 0)) % xa;
				return fa
			}, ra.prototype.idivn = function(xa) {
				ta(xa <= 67108863);
				for (var ma = 0, fa = this.length - 1; fa >= 0; fa--) {
					var ga = (this.words[fa] | 0) + ma * 67108864;
					this.words[fa] = ga / xa | 0, ma = ga % xa
				}
				return this.strip()
			}, ra.prototype.divn = function(xa) {
				return this.clone().idivn(xa)
			}, ra.prototype.egcd = function(xa) {
				ta(xa.negative === 0), ta(!xa.isZero());
				var ma = this,
					fa = xa.clone();
				ma.negative !== 0 ? ma = ma.umod(xa) : ma = ma.clone();
				for (var ga = new ra(1), wa = new ra(0), Ma = new ra(0), Aa = new ra(1), Ra = 0; ma.isEven() && fa.isEven();) ma.iushrn(1), fa.iushrn(1), ++Ra;
				for (var Ta = fa.clone(), La = ma.clone(); !ma.isZero();) {
					for (var ya = 0, Ba = 1; !(ma.words[0] & Ba) && ya < 26; ++ya, Ba <<= 1);
					if (ya > 0)
						for (ma.iushrn(ya); ya-- > 0;)(ga.isOdd() || wa.isOdd()) && (ga.iadd(Ta), wa.isub(La)), ga.iushrn(1), wa.iushrn(1);
					for (var io = 0, oo = 1; !(fa.words[0] & oo) && io < 26; ++io, oo <<= 1);
					if (io > 0)
						for (fa.iushrn(io); io-- > 0;)(Ma.isOdd() || Aa.isOdd()) && (Ma.iadd(Ta), Aa.isub(La)), Ma.iushrn(1), Aa.iushrn(1);
					ma.cmp(fa) >= 0 ? (ma.isub(fa), ga.isub(Ma), wa.isub(Aa)) : (fa.isub(ma), Ma.isub(ga), Aa.isub(wa))
				}
				return {
					a: Ma,
					b: Aa,
					gcd: fa.iushln(Ra)
				}
			}, ra.prototype._invmp = function(xa) {
				ta(xa.negative === 0), ta(!xa.isZero());
				var ma = this,
					fa = xa.clone();
				ma.negative !== 0 ? ma = ma.umod(xa) : ma = ma.clone();
				for (var ga = new ra(1), wa = new ra(0), Ma = fa.clone(); ma.cmpn(1) > 0 && fa.cmpn(1) > 0;) {
					for (var Aa = 0, Ra = 1; !(ma.words[0] & Ra) && Aa < 26; ++Aa, Ra <<= 1);
					if (Aa > 0)
						for (ma.iushrn(Aa); Aa-- > 0;) ga.isOdd() && ga.iadd(Ma), ga.iushrn(1);
					for (var Ta = 0, La = 1; !(fa.words[0] & La) && Ta < 26; ++Ta, La <<= 1);
					if (Ta > 0)
						for (fa.iushrn(Ta); Ta-- > 0;) wa.isOdd() && wa.iadd(Ma), wa.iushrn(1);
					ma.cmp(fa) >= 0 ? (ma.isub(fa), ga.isub(wa)) : (fa.isub(ma), wa.isub(ga))
				}
				var ya;
				return ma.cmpn(1) === 0 ? ya = ga : ya = wa, ya.cmpn(0) < 0 && ya.iadd(xa), ya
			}, ra.prototype.gcd = function(xa) {
				if (this.isZero()) return xa.abs();
				if (xa.isZero()) return this.abs();
				var ma = this.clone(),
					fa = xa.clone();
				ma.negative = 0, fa.negative = 0;
				for (var ga = 0; ma.isEven() && fa.isEven(); ga++) ma.iushrn(1), fa.iushrn(1);
				do {
					for (; ma.isEven();) ma.iushrn(1);
					for (; fa.isEven();) fa.iushrn(1);
					var wa = ma.cmp(fa);
					if (wa < 0) {
						var Ma = ma;
						ma = fa, fa = Ma
					} else if (wa === 0 || fa.cmpn(1) === 0) break;
					ma.isub(fa)
				} while (!0);
				return fa.iushln(ga)
			}, ra.prototype.invm = function(xa) {
				return this.egcd(xa).a.umod(xa)
			}, ra.prototype.isEven = function() {
				return (this.words[0] & 1) === 0
			}, ra.prototype.isOdd = function() {
				return (this.words[0] & 1) === 1
			}, ra.prototype.andln = function(xa) {
				return this.words[0] & xa
			}, ra.prototype.bincn = function(xa) {
				ta(typeof xa == "number");
				var ma = xa % 26,
					fa = (xa - ma) / 26,
					ga = 1 << ma;
				if (this.length <= fa) return this._expand(fa + 1), this.words[fa] |= ga, this;
				for (var wa = ga, Ma = fa; wa !== 0 && Ma < this.length; Ma++) {
					var Aa = this.words[Ma] | 0;
					Aa += wa, wa = Aa >>> 26, Aa &= 67108863, this.words[Ma] = Aa
				}
				return wa !== 0 && (this.words[Ma] = wa, this.length++), this
			}, ra.prototype.isZero = function() {
				return this.length === 1 && this.words[0] === 0
			}, ra.prototype.cmpn = function(xa) {
				var ma = xa < 0;
				if (this.negative !== 0 && !ma) return -1;
				if (this.negative === 0 && ma) return 1;
				this.strip();
				var fa;
				if (this.length > 1) fa = 1;
				else {
					ma && (xa = -xa), ta(xa <= 67108863, "Number is too big");
					var ga = this.words[0] | 0;
					fa = ga === xa ? 0 : ga < xa ? -1 : 1
				}
				return this.negative !== 0 ? -fa | 0 : fa
			}, ra.prototype.cmp = function(xa) {
				if (this.negative !== 0 && xa.negative === 0) return -1;
				if (this.negative === 0 && xa.negative !== 0) return 1;
				var ma = this.ucmp(xa);
				return this.negative !== 0 ? -ma | 0 : ma
			}, ra.prototype.ucmp = function(xa) {
				if (this.length > xa.length) return 1;
				if (this.length < xa.length) return -1;
				for (var ma = 0, fa = this.length - 1; fa >= 0; fa--) {
					var ga = this.words[fa] | 0,
						wa = xa.words[fa] | 0;
					if (ga !== wa) {
						ga < wa ? ma = -1 : ga > wa && (ma = 1);
						break
					}
				}
				return ma
			}, ra.prototype.gtn = function(xa) {
				return this.cmpn(xa) === 1
			}, ra.prototype.gt = function(xa) {
				return this.cmp(xa) === 1
			}, ra.prototype.gten = function(xa) {
				return this.cmpn(xa) >= 0
			}, ra.prototype.gte = function(xa) {
				return this.cmp(xa) >= 0
			}, ra.prototype.ltn = function(xa) {
				return this.cmpn(xa) === -1
			}, ra.prototype.lt = function(xa) {
				return this.cmp(xa) === -1
			}, ra.prototype.lten = function(xa) {
				return this.cmpn(xa) <= 0
			}, ra.prototype.lte = function(xa) {
				return this.cmp(xa) <= 0
			}, ra.prototype.eqn = function(xa) {
				return this.cmpn(xa) === 0
			}, ra.prototype.eq = function(xa) {
				return this.cmp(xa) === 0
			}, ra.red = function(xa) {
				return new Ga(xa)
			}, ra.prototype.toRed = function(xa) {
				return ta(!this.red, "Already a number in reduction context"), ta(this.negative === 0, "red works only with positives"), xa.convertTo(this)._forceRed(xa)
			}, ra.prototype.fromRed = function() {
				return ta(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
			}, ra.prototype._forceRed = function(xa) {
				return this.red = xa, this
			}, ra.prototype.forceRed = function(xa) {
				return ta(!this.red, "Already a number in reduction context"), this._forceRed(xa)
			}, ra.prototype.redAdd = function(xa) {
				return ta(this.red, "redAdd works only with red numbers"), this.red.add(this, xa)
			}, ra.prototype.redIAdd = function(xa) {
				return ta(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, xa)
			}, ra.prototype.redSub = function(xa) {
				return ta(this.red, "redSub works only with red numbers"), this.red.sub(this, xa)
			}, ra.prototype.redISub = function(xa) {
				return ta(this.red, "redISub works only with red numbers"), this.red.isub(this, xa)
			}, ra.prototype.redShl = function(xa) {
				return ta(this.red, "redShl works only with red numbers"), this.red.shl(this, xa)
			}, ra.prototype.redMul = function(xa) {
				return ta(this.red, "redMul works only with red numbers"), this.red._verify2(this, xa), this.red.mul(this, xa)
			}, ra.prototype.redIMul = function(xa) {
				return ta(this.red, "redMul works only with red numbers"), this.red._verify2(this, xa), this.red.imul(this, xa)
			}, ra.prototype.redSqr = function() {
				return ta(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
			}, ra.prototype.redISqr = function() {
				return ta(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
			}, ra.prototype.redSqrt = function() {
				return ta(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
			}, ra.prototype.redInvm = function() {
				return ta(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
			}, ra.prototype.redNeg = function() {
				return ta(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
			}, ra.prototype.redPow = function(xa) {
				return ta(this.red && !xa.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, xa)
			};
			var Sa = {
				k256: null,
				p224: null,
				p192: null,
				p25519: null
			};

			function Ca(Ua, xa) {
				this.name = Ua, this.p = new ra(xa, 16), this.n = this.p.bitLength(), this.k = new ra(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
			}
			Ca.prototype._tmp = function() {
				var xa = new ra(null);
				return xa.words = new Array(Math.ceil(this.n / 13)), xa
			}, Ca.prototype.ireduce = function(xa) {
				var ma = xa,
					fa;
				do this.split(ma, this.tmp), ma = this.imulK(ma), ma = ma.iadd(this.tmp), fa = ma.bitLength(); while (fa > this.n);
				var ga = fa < this.n ? -1 : ma.ucmp(this.p);
				return ga === 0 ? (ma.words[0] = 0, ma.length = 1) : ga > 0 ? ma.isub(this.p) : ma.strip !== void 0 ? ma.strip() : ma._strip(), ma
			}, Ca.prototype.split = function(xa, ma) {
				xa.iushrn(this.n, 0, ma)
			}, Ca.prototype.imulK = function(xa) {
				return xa.imul(this.k)
			};

			function ka() {
				Ca.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
			}
			na(ka, Ca), ka.prototype.split = function(xa, ma) {
				for (var fa = 4194303, ga = Math.min(xa.length, 9), wa = 0; wa < ga; wa++) ma.words[wa] = xa.words[wa];
				if (ma.length = ga, xa.length <= 9) {
					xa.words[0] = 0, xa.length = 1;
					return
				}
				var Ma = xa.words[9];
				for (ma.words[ma.length++] = Ma & fa, wa = 10; wa < xa.length; wa++) {
					var Aa = xa.words[wa] | 0;
					xa.words[wa - 10] = (Aa & fa) << 4 | Ma >>> 22, Ma = Aa
				}
				Ma >>>= 22, xa.words[wa - 10] = Ma, Ma === 0 && xa.length > 10 ? xa.length -= 10 : xa.length -= 9
			}, ka.prototype.imulK = function(xa) {
				xa.words[xa.length] = 0, xa.words[xa.length + 1] = 0, xa.length += 2;
				for (var ma = 0, fa = 0; fa < xa.length; fa++) {
					var ga = xa.words[fa] | 0;
					ma += ga * 977, xa.words[fa] = ma & 67108863, ma = ga * 64 + (ma / 67108864 | 0)
				}
				return xa.words[xa.length - 1] === 0 && (xa.length--, xa.words[xa.length - 1] === 0 && xa.length--), xa
			};

			function Pa() {
				Ca.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
			}
			na(Pa, Ca);

			function ja() {
				Ca.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
			}
			na(ja, Ca);

			function Za() {
				Ca.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
			}
			na(Za, Ca), Za.prototype.imulK = function(xa) {
				for (var ma = 0, fa = 0; fa < xa.length; fa++) {
					var ga = (xa.words[fa] | 0) * 19 + ma,
						wa = ga & 67108863;
					ga >>>= 26, xa.words[fa] = wa, ma = ga
				}
				return ma !== 0 && (xa.words[xa.length++] = ma), xa
			}, ra._prime = function(xa) {
				if (Sa[xa]) return Sa[xa];
				var ma;
				if (xa === "k256") ma = new ka;
				else if (xa === "p224") ma = new Pa;
				else if (xa === "p192") ma = new ja;
				else if (xa === "p25519") ma = new Za;
				else throw new Error("Unknown prime " + xa);
				return Sa[xa] = ma, ma
			};

			function Ga(Ua) {
				if (typeof Ua == "string") {
					var xa = ra._prime(Ua);
					this.m = xa.p, this.prime = xa
				} else ta(Ua.gtn(1), "modulus must be greater than 1"), this.m = Ua, this.prime = null
			}
			Ga.prototype._verify1 = function(xa) {
				ta(xa.negative === 0, "red works only with positives"), ta(xa.red, "red works only with red numbers")
			}, Ga.prototype._verify2 = function(xa, ma) {
				ta((xa.negative | ma.negative) === 0, "red works only with positives"), ta(xa.red && xa.red === ma.red, "red works only with red numbers")
			}, Ga.prototype.imod = function(xa) {
				return this.prime ? this.prime.ireduce(xa)._forceRed(this) : xa.umod(this.m)._forceRed(this)
			}, Ga.prototype.neg = function(xa) {
				return xa.isZero() ? xa.clone() : this.m.sub(xa)._forceRed(this)
			}, Ga.prototype.add = function(xa, ma) {
				this._verify2(xa, ma);
				var fa = xa.add(ma);
				return fa.cmp(this.m) >= 0 && fa.isub(this.m), fa._forceRed(this)
			}, Ga.prototype.iadd = function(xa, ma) {
				this._verify2(xa, ma);
				var fa = xa.iadd(ma);
				return fa.cmp(this.m) >= 0 && fa.isub(this.m), fa
			}, Ga.prototype.sub = function(xa, ma) {
				this._verify2(xa, ma);
				var fa = xa.sub(ma);
				return fa.cmpn(0) < 0 && fa.iadd(this.m), fa._forceRed(this)
			}, Ga.prototype.isub = function(xa, ma) {
				this._verify2(xa, ma);
				var fa = xa.isub(ma);
				return fa.cmpn(0) < 0 && fa.iadd(this.m), fa
			}, Ga.prototype.shl = function(xa, ma) {
				return this._verify1(xa), this.imod(xa.ushln(ma))
			}, Ga.prototype.imul = function(xa, ma) {
				return this._verify2(xa, ma), this.imod(xa.imul(ma))
			}, Ga.prototype.mul = function(xa, ma) {
				return this._verify2(xa, ma), this.imod(xa.mul(ma))
			}, Ga.prototype.isqr = function(xa) {
				return this.imul(xa, xa.clone())
			}, Ga.prototype.sqr = function(xa) {
				return this.mul(xa, xa)
			}, Ga.prototype.sqrt = function(xa) {
				if (xa.isZero()) return xa.clone();
				var ma = this.m.andln(3);
				if (ta(ma % 2 === 1), ma === 3) {
					var fa = this.m.add(new ra(1)).iushrn(2);
					return this.pow(xa, fa)
				}
				for (var ga = this.m.subn(1), wa = 0; !ga.isZero() && ga.andln(1) === 0;) wa++, ga.iushrn(1);
				ta(!ga.isZero());
				var Ma = new ra(1).toRed(this),
					Aa = Ma.redNeg(),
					Ra = this.m.subn(1).iushrn(1),
					Ta = this.m.bitLength();
				for (Ta = new ra(2 * Ta * Ta).toRed(this); this.pow(Ta, Ra).cmp(Aa) !== 0;) Ta.redIAdd(Aa);
				for (var La = this.pow(Ta, ga), ya = this.pow(xa, ga.addn(1).iushrn(1)), Ba = this.pow(xa, ga), io = wa; Ba.cmp(Ma) !== 0;) {
					for (var oo = Ba, ao = 0; oo.cmp(Ma) !== 0; ao++) oo = oo.redSqr();
					ta(ao < io);
					var Ia = this.pow(La, new ra(1).iushln(io - ao - 1));
					ya = ya.redMul(Ia), La = Ia.redSqr(), Ba = Ba.redMul(La), io = ao
				}
				return ya
			}, Ga.prototype.invm = function(xa) {
				var ma = xa._invmp(this.m);
				return ma.negative !== 0 ? (ma.negative = 0, this.imod(ma).redNeg()) : this.imod(ma)
			}, Ga.prototype.pow = function(xa, ma) {
				if (ma.isZero()) return new ra(1).toRed(this);
				if (ma.cmpn(1) === 0) return xa.clone();
				var fa = 4,
					ga = new Array(1 << fa);
				ga[0] = new ra(1).toRed(this), ga[1] = xa;
				for (var wa = 2; wa < ga.length; wa++) ga[wa] = this.mul(ga[wa - 1], xa);
				var Ma = ga[0],
					Aa = 0,
					Ra = 0,
					Ta = ma.bitLength() % 26;
				for (Ta === 0 && (Ta = 26), wa = ma.length - 1; wa >= 0; wa--) {
					for (var La = ma.words[wa], ya = Ta - 1; ya >= 0; ya--) {
						var Ba = La >> ya & 1;
						if (Ma !== ga[0] && (Ma = this.sqr(Ma)), Ba === 0 && Aa === 0) {
							Ra = 0;
							continue
						}
						Aa <<= 1, Aa |= Ba, Ra++, !(Ra !== fa && (wa !== 0 || ya !== 0)) && (Ma = this.mul(Ma, ga[Aa]), Ra = 0, Aa = 0)
					}
					Ta = 26
				}
				return Ma
			}, Ga.prototype.convertTo = function(xa) {
				var ma = xa.umod(this.m);
				return ma === xa ? ma.clone() : ma
			}, Ga.prototype.convertFrom = function(xa) {
				var ma = xa.clone();
				return ma.red = null, ma
			}, ra.mont = function(xa) {
				return new Ja(xa)
			};

			function Ja(Ua) {
				Ga.call(this, Ua), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ra(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
			}
			na(Ja, Ga), Ja.prototype.convertTo = function(xa) {
				return this.imod(xa.ushln(this.shift))
			}, Ja.prototype.convertFrom = function(xa) {
				var ma = this.imod(xa.mul(this.rinv));
				return ma.red = null, ma
			}, Ja.prototype.imul = function(xa, ma) {
				if (xa.isZero() || ma.isZero()) return xa.words[0] = 0, xa.length = 1, xa;
				var fa = xa.imul(ma),
					ga = fa.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
					wa = fa.isub(ga).iushrn(this.shift),
					Ma = wa;
				return wa.cmp(this.m) >= 0 ? Ma = wa.isub(this.m) : wa.cmpn(0) < 0 && (Ma = wa.iadd(this.m)), Ma._forceRed(this)
			}, Ja.prototype.mul = function(xa, ma) {
				if (xa.isZero() || ma.isZero()) return new ra(0)._forceRed(this);
				var fa = xa.mul(ma),
					ga = fa.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
					wa = fa.isub(ga).iushrn(this.shift),
					Ma = wa;
				return wa.cmp(this.m) >= 0 ? Ma = wa.isub(this.m) : wa.cmpn(0) < 0 && (Ma = wa.iadd(this.m)), Ma._forceRed(this)
			}, Ja.prototype.invm = function(xa) {
				var ma = this.imod(xa._invmp(this.m).mul(this.r2));
				return ma._forceRed(this)
			}
		})(ue, commonjsGlobal)
	}(bn$3)), bn$3.exports
}
var brorand = {
		exports: {}
	},
	hasRequiredBrorand;

function requireBrorand() {
	if (hasRequiredBrorand) return brorand.exports;
	hasRequiredBrorand = 1;
	var ue;
	brorand.exports = function(na) {
		return ue || (ue = new Yi(null)), ue.generate(na)
	};

	function Yi(ta) {
		this.rand = ta
	}
	if (brorand.exports.Rand = Yi, Yi.prototype.generate = function(na) {
			return this._rand(na)
		}, Yi.prototype._rand = function(na) {
			if (this.rand.getBytes) return this.rand.getBytes(na);
			for (var ra = new Uint8Array(na), ia = 0; ia < ra.length; ia++) ra[ia] = this.rand.getByte();
			return ra
		}, typeof self == "object") self.crypto && self.crypto.getRandomValues ? Yi.prototype._rand = function(na) {
		var ra = new Uint8Array(na);
		return self.crypto.getRandomValues(ra), ra
	} : self.msCrypto && self.msCrypto.getRandomValues ? Yi.prototype._rand = function(na) {
		var ra = new Uint8Array(na);
		return self.msCrypto.getRandomValues(ra), ra
	} : typeof window == "object" && (Yi.prototype._rand = function() {
		throw new Error("Not implemented yet")
	});
	else try {
		var ea = requireCryptoBrowserify();
		if (typeof ea.randomBytes != "function") throw new Error("Not supported");
		Yi.prototype._rand = function(na) {
			return ea.randomBytes(na)
		}
	} catch {}
	return brorand.exports
}
var mr$1, hasRequiredMr;

function requireMr() {
	if (hasRequiredMr) return mr$1;
	hasRequiredMr = 1;
	var ue = requireBn$2(),
		Yi = requireBrorand();

	function ea(ta) {
		this.rand = ta || new Yi.Rand
	}
	return mr$1 = ea, ea.create = function(na) {
		return new ea(na)
	}, ea.prototype._randbelow = function(na) {
		var ra = na.bitLength(),
			ia = Math.ceil(ra / 8);
		do var aa = new ue(this.rand.generate(ia)); while (aa.cmp(na) >= 0);
		return aa
	}, ea.prototype._randrange = function(na, ra) {
		var ia = ra.sub(na);
		return na.add(this._randbelow(ia))
	}, ea.prototype.test = function(na, ra, ia) {
		var aa = na.bitLength(),
			oa = ue.mont(na),
			la = new ue(1).toRed(oa);
		ra || (ra = Math.max(1, aa / 48 | 0));
		for (var sa = na.subn(1), ca = 0; !sa.testn(ca); ca++);
		for (var ua = na.shrn(ca), da = sa.toRed(oa), ha = !0; ra > 0; ra--) {
			var pa = this._randrange(new ue(2), sa);
			ia && ia(pa);
			var va = pa.toRed(oa).redPow(ua);
			if (!(va.cmp(la) === 0 || va.cmp(da) === 0)) {
				for (var ba = 1; ba < ca; ba++) {
					if (va = va.redSqr(), va.cmp(la) === 0) return !1;
					if (va.cmp(da) === 0) break
				}
				if (ba === ca) return !1
			}
		}
		return ha
	}, ea.prototype.getDivisor = function(na, ra) {
		var ia = na.bitLength(),
			aa = ue.mont(na),
			oa = new ue(1).toRed(aa);
		ra || (ra = Math.max(1, ia / 48 | 0));
		for (var la = na.subn(1), sa = 0; !la.testn(sa); sa++);
		for (var ca = na.shrn(sa), ua = la.toRed(aa); ra > 0; ra--) {
			var da = this._randrange(new ue(2), la),
				ha = na.gcd(da);
			if (ha.cmpn(1) !== 0) return ha;
			var pa = da.toRed(aa).redPow(ca);
			if (!(pa.cmp(oa) === 0 || pa.cmp(ua) === 0)) {
				for (var va = 1; va < sa; va++) {
					if (pa = pa.redSqr(), pa.cmp(oa) === 0) return pa.fromRed().subn(1).gcd(na);
					if (pa.cmp(ua) === 0) break
				}
				if (va === sa) return pa = pa.redSqr(), pa.fromRed().subn(1).gcd(na)
			}
		}
		return !1
	}, mr$1
}
var generatePrime, hasRequiredGeneratePrime;

function requireGeneratePrime() {
	if (hasRequiredGeneratePrime) return generatePrime;
	hasRequiredGeneratePrime = 1;
	var ue = requireBrowser$b();
	generatePrime = va, va.simpleSieve = ha, va.fermatTest = pa;
	var Yi = requireBn$2(),
		ea = new Yi(24),
		ta = requireMr(),
		na = new ta,
		ra = new Yi(1),
		ia = new Yi(2),
		aa = new Yi(5);
	new Yi(16), new Yi(8);
	var oa = new Yi(10),
		la = new Yi(3);
	new Yi(7);
	var sa = new Yi(11),
		ca = new Yi(4);
	new Yi(12);
	var ua = null;

	function da() {
		if (ua !== null) return ua;
		var ba = 1048576,
			Ea = [];
		Ea[0] = 2;
		for (var Sa = 1, Ca = 3; Ca < ba; Ca += 2) {
			for (var ka = Math.ceil(Math.sqrt(Ca)), Pa = 0; Pa < Sa && Ea[Pa] <= ka && Ca % Ea[Pa] !== 0; Pa++);
			Sa !== Pa && Ea[Pa] <= ka || (Ea[Sa++] = Ca)
		}
		return ua = Ea, Ea
	}

	function ha(ba) {
		for (var Ea = da(), Sa = 0; Sa < Ea.length; Sa++)
			if (ba.modn(Ea[Sa]) === 0) return ba.cmpn(Ea[Sa]) === 0;
		return !0
	}

	function pa(ba) {
		var Ea = Yi.mont(ba);
		return ia.toRed(Ea).redPow(ba.subn(1)).fromRed().cmpn(1) === 0
	}

	function va(ba, Ea) {
		if (ba < 16) return Ea === 2 || Ea === 5 ? new Yi([140, 123]) : new Yi([140, 39]);
		Ea = new Yi(Ea);
		for (var Sa, Ca;;) {
			for (Sa = new Yi(ue(Math.ceil(ba / 8))); Sa.bitLength() > ba;) Sa.ishrn(1);
			if (Sa.isEven() && Sa.iadd(ra), Sa.testn(1) || Sa.iadd(ia), Ea.cmp(ia)) {
				if (!Ea.cmp(aa))
					for (; Sa.mod(oa).cmp(la);) Sa.iadd(ca)
			} else
				for (; Sa.mod(ea).cmp(sa);) Sa.iadd(ca);
			if (Ca = Sa.shrn(1), ha(Ca) && ha(Sa) && pa(Ca) && pa(Sa) && na.test(Ca) && na.test(Sa)) return Sa
		}
	}
	return generatePrime
}
const modp1 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
	},
	modp2 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
	},
	modp5 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
	},
	modp14 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
	},
	modp15 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
	},
	modp16 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
	},
	modp17 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
	},
	modp18 = {
		gen: "02",
		prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
	},
	require$$1$1 = {
		modp1,
		modp2,
		modp5,
		modp14,
		modp15,
		modp16,
		modp17,
		modp18
	};
var dh, hasRequiredDh;

function requireDh() {
	if (hasRequiredDh) return dh;
	hasRequiredDh = 1;
	var ue = requireBn$2(),
		Yi = requireMr(),
		ea = new Yi,
		ta = new ue(24),
		na = new ue(11),
		ra = new ue(10),
		ia = new ue(3),
		aa = new ue(7),
		oa = requireGeneratePrime(),
		la = requireBrowser$b();
	dh = ha;

	function sa(va, ba) {
		return ba = ba || "utf8", Buffer.isBuffer(va) || (va = new Buffer(va, ba)), this._pub = new ue(va), this
	}

	function ca(va, ba) {
		return ba = ba || "utf8", Buffer.isBuffer(va) || (va = new Buffer(va, ba)), this._priv = new ue(va), this
	}
	var ua = {};

	function da(va, ba) {
		var Ea = ba.toString("hex"),
			Sa = [Ea, va.toString(16)].join("_");
		if (Sa in ua) return ua[Sa];
		var Ca = 0;
		if (va.isEven() || !oa.simpleSieve || !oa.fermatTest(va) || !ea.test(va)) return Ca += 1, Ea === "02" || Ea === "05" ? Ca += 8 : Ca += 4, ua[Sa] = Ca, Ca;
		ea.test(va.shrn(1)) || (Ca += 2);
		var ka;
		switch (Ea) {
			case "02":
				va.mod(ta).cmp(na) && (Ca += 8);
				break;
			case "05":
				ka = va.mod(ra), ka.cmp(ia) && ka.cmp(aa) && (Ca += 8);
				break;
			default:
				Ca += 4
		}
		return ua[Sa] = Ca, Ca
	}

	function ha(va, ba, Ea) {
		this.setGenerator(ba), this.__prime = new ue(va), this._prime = ue.mont(this.__prime), this._primeLen = va.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, Ea ? (this.setPublicKey = sa, this.setPrivateKey = ca) : this._primeCode = 8
	}
	Object.defineProperty(ha.prototype, "verifyError", {
		enumerable: !0,
		get: function() {
			return typeof this._primeCode != "number" && (this._primeCode = da(this.__prime, this.__gen)), this._primeCode
		}
	}), ha.prototype.generateKeys = function() {
		return this._priv || (this._priv = new ue(la(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey()
	}, ha.prototype.computeSecret = function(va) {
		va = new ue(va), va = va.toRed(this._prime);
		var ba = va.redPow(this._priv).fromRed(),
			Ea = new Buffer(ba.toArray()),
			Sa = this.getPrime();
		if (Ea.length < Sa.length) {
			var Ca = new Buffer(Sa.length - Ea.length);
			Ca.fill(0), Ea = Buffer.concat([Ca, Ea])
		}
		return Ea
	}, ha.prototype.getPublicKey = function(ba) {
		return pa(this._pub, ba)
	}, ha.prototype.getPrivateKey = function(ba) {
		return pa(this._priv, ba)
	}, ha.prototype.getPrime = function(va) {
		return pa(this.__prime, va)
	}, ha.prototype.getGenerator = function(va) {
		return pa(this._gen, va)
	}, ha.prototype.setGenerator = function(va, ba) {
		return ba = ba || "utf8", Buffer.isBuffer(va) || (va = new Buffer(va, ba)), this.__gen = va, this._gen = new ue(va), this
	};

	function pa(va, ba) {
		var Ea = new Buffer(va.toArray());
		return ba ? Ea.toString(ba) : Ea
	}
	return dh
}
var hasRequiredBrowser$4;

function requireBrowser$4() {
	if (hasRequiredBrowser$4) return browser$4;
	hasRequiredBrowser$4 = 1;
	var ue = requireGeneratePrime(),
		Yi = require$$1$1,
		ea = requireDh();

	function ta(ia) {
		var aa = new Buffer(Yi[ia].prime, "hex"),
			oa = new Buffer(Yi[ia].gen, "hex");
		return new ea(aa, oa)
	}
	var na = {
		binary: !0,
		hex: !0,
		base64: !0
	};

	function ra(ia, aa, oa, la) {
		return Buffer.isBuffer(aa) || na[aa] === void 0 ? ra(ia, "binary", aa, oa) : (aa = aa || "binary", la = la || "binary", oa = oa || new Buffer([2]), Buffer.isBuffer(oa) || (oa = new Buffer(oa, la)), typeof ia == "number" ? new ea(ue(ia, oa), oa, !0) : (Buffer.isBuffer(ia) || (ia = new Buffer(ia, aa)), new ea(ia, oa, !0)))
	}
	return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = ta, browser$4.createDiffieHellman = browser$4.DiffieHellman = ra, browser$4
}
var readableBrowser = {
		exports: {}
	},
	processNextickArgs = {
		exports: {}
	},
	hasRequiredProcessNextickArgs;

function requireProcessNextickArgs() {
	if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
	hasRequiredProcessNextickArgs = 1, typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = {
		nextTick: ue
	} : processNextickArgs.exports = process$1;

	function ue(Yi, ea, ta, na) {
		if (typeof Yi != "function") throw new TypeError('"callback" argument must be a function');
		var ra = arguments.length,
			ia, aa;
		switch (ra) {
			case 0:
			case 1:
				return process$1.nextTick(Yi);
			case 2:
				return process$1.nextTick(function() {
					Yi.call(null, ea)
				});
			case 3:
				return process$1.nextTick(function() {
					Yi.call(null, ea, ta)
				});
			case 4:
				return process$1.nextTick(function() {
					Yi.call(null, ea, ta, na)
				});
			default:
				for (ia = new Array(ra - 1), aa = 0; aa < ia.length;) ia[aa++] = arguments[aa];
				return process$1.nextTick(function() {
					Yi.apply(null, ia)
				})
		}
	}
	return processNextickArgs.exports
}
var isarray, hasRequiredIsarray;

function requireIsarray() {
	if (hasRequiredIsarray) return isarray;
	hasRequiredIsarray = 1;
	var ue = {}.toString;
	return isarray = Array.isArray || function(Yi) {
		return ue.call(Yi) == "[object Array]"
	}, isarray
}
var streamBrowser, hasRequiredStreamBrowser;

function requireStreamBrowser() {
	return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = requireEvents().EventEmitter), streamBrowser
}
var safeBuffer = {
		exports: {}
	},
	hasRequiredSafeBuffer;

function requireSafeBuffer() {
	return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(ue, Yi) {
		var ea = require$$1$2,
			ta = ea.Buffer;

		function na(ia, aa) {
			for (var oa in ia) aa[oa] = ia[oa]
		}
		ta.from && ta.alloc && ta.allocUnsafe && ta.allocUnsafeSlow ? ue.exports = ea : (na(ea, Yi), Yi.Buffer = ra);

		function ra(ia, aa, oa) {
			return ta(ia, aa, oa)
		}
		na(ta, ra), ra.from = function(ia, aa, oa) {
			if (typeof ia == "number") throw new TypeError("Argument must not be a number");
			return ta(ia, aa, oa)
		}, ra.alloc = function(ia, aa, oa) {
			if (typeof ia != "number") throw new TypeError("Argument must be a number");
			var la = ta(ia);
			return aa !== void 0 ? typeof oa == "string" ? la.fill(aa, oa) : la.fill(aa) : la.fill(0), la
		}, ra.allocUnsafe = function(ia) {
			if (typeof ia != "number") throw new TypeError("Argument must be a number");
			return ta(ia)
		}, ra.allocUnsafeSlow = function(ia) {
			if (typeof ia != "number") throw new TypeError("Argument must be a number");
			return ea.SlowBuffer(ia)
		}
	}(safeBuffer, safeBuffer.exports)), safeBuffer.exports
}
var util = {},
	hasRequiredUtil;

function requireUtil() {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;

	function ue(pa) {
		return Array.isArray ? Array.isArray(pa) : ha(pa) === "[object Array]"
	}
	util.isArray = ue;

	function Yi(pa) {
		return typeof pa == "boolean"
	}
	util.isBoolean = Yi;

	function ea(pa) {
		return pa === null
	}
	util.isNull = ea;

	function ta(pa) {
		return pa == null
	}
	util.isNullOrUndefined = ta;

	function na(pa) {
		return typeof pa == "number"
	}
	util.isNumber = na;

	function ra(pa) {
		return typeof pa == "string"
	}
	util.isString = ra;

	function ia(pa) {
		return typeof pa == "symbol"
	}
	util.isSymbol = ia;

	function aa(pa) {
		return pa === void 0
	}
	util.isUndefined = aa;

	function oa(pa) {
		return ha(pa) === "[object RegExp]"
	}
	util.isRegExp = oa;

	function la(pa) {
		return typeof pa == "object" && pa !== null
	}
	util.isObject = la;

	function sa(pa) {
		return ha(pa) === "[object Date]"
	}
	util.isDate = sa;

	function ca(pa) {
		return ha(pa) === "[object Error]" || pa instanceof Error
	}
	util.isError = ca;

	function ua(pa) {
		return typeof pa == "function"
	}
	util.isFunction = ua;

	function da(pa) {
		return pa === null || typeof pa == "boolean" || typeof pa == "number" || typeof pa == "string" || typeof pa == "symbol" || typeof pa > "u"
	}
	util.isPrimitive = da, util.isBuffer = require$$1$2.Buffer.isBuffer;

	function ha(pa) {
		return Object.prototype.toString.call(pa)
	}
	return util
}
var BufferList = {
		exports: {}
	},
	hasRequiredBufferList;

function requireBufferList() {
	return hasRequiredBufferList || (hasRequiredBufferList = 1, function(ue) {
		function Yi(ra, ia) {
			if (!(ra instanceof ia)) throw new TypeError("Cannot call a class as a function")
		}
		var ea = requireSafeBuffer().Buffer,
			ta = requireUtil$1();

		function na(ra, ia, aa) {
			ra.copy(ia, aa)
		}
		ue.exports = function() {
			function ra() {
				Yi(this, ra), this.head = null, this.tail = null, this.length = 0
			}
			return ra.prototype.push = function(aa) {
				var oa = {
					data: aa,
					next: null
				};
				this.length > 0 ? this.tail.next = oa : this.head = oa, this.tail = oa, ++this.length
			}, ra.prototype.unshift = function(aa) {
				var oa = {
					data: aa,
					next: this.head
				};
				this.length === 0 && (this.tail = oa), this.head = oa, ++this.length
			}, ra.prototype.shift = function() {
				if (this.length !== 0) {
					var aa = this.head.data;
					return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, aa
				}
			}, ra.prototype.clear = function() {
				this.head = this.tail = null, this.length = 0
			}, ra.prototype.join = function(aa) {
				if (this.length === 0) return "";
				for (var oa = this.head, la = "" + oa.data; oa = oa.next;) la += aa + oa.data;
				return la
			}, ra.prototype.concat = function(aa) {
				if (this.length === 0) return ea.alloc(0);
				for (var oa = ea.allocUnsafe(aa >>> 0), la = this.head, sa = 0; la;) na(la.data, oa, sa), sa += la.data.length, la = la.next;
				return oa
			}, ra
		}(), ta && ta.inspect && ta.inspect.custom && (ue.exports.prototype[ta.inspect.custom] = function() {
			var ra = ta.inspect({
				length: this.length
			});
			return this.constructor.name + " " + ra
		})
	}(BufferList)), BufferList.exports
}
var destroy_1, hasRequiredDestroy;

function requireDestroy() {
	if (hasRequiredDestroy) return destroy_1;
	hasRequiredDestroy = 1;
	var ue = requireProcessNextickArgs();

	function Yi(na, ra) {
		var ia = this,
			aa = this._readableState && this._readableState.destroyed,
			oa = this._writableState && this._writableState.destroyed;
		return aa || oa ? (ra ? ra(na) : na && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, ue.nextTick(ta, this, na)) : ue.nextTick(ta, this, na)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(na || null, function(la) {
			!ra && la ? ia._writableState ? ia._writableState.errorEmitted || (ia._writableState.errorEmitted = !0, ue.nextTick(ta, ia, la)) : ue.nextTick(ta, ia, la) : ra && ra(la)
		}), this)
	}

	function ea() {
		this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1)
	}

	function ta(na, ra) {
		na.emit("error", ra)
	}
	return destroy_1 = {
		destroy: Yi,
		undestroy: ea
	}, destroy_1
}
var _stream_writable, hasRequired_stream_writable;

function require_stream_writable() {
	if (hasRequired_stream_writable) return _stream_writable;
	hasRequired_stream_writable = 1;
	var ue = requireProcessNextickArgs();
	_stream_writable = pa;

	function Yi(Ma) {
		var Aa = this;
		this.next = null, this.entry = null, this.finish = function() {
			wa(Aa, Ma)
		}
	}
	var ea = ue.nextTick,
		ta;
	pa.WritableState = da;
	var na = Object.create(requireUtil());
	na.inherits = requireInherits_browser();
	var ra = {
			deprecate: requireBrowser$a()
		},
		ia = requireStreamBrowser(),
		aa = requireSafeBuffer().Buffer,
		oa = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};

	function la(Ma) {
		return aa.from(Ma)
	}

	function sa(Ma) {
		return aa.isBuffer(Ma) || Ma instanceof oa
	}
	var ca = requireDestroy();
	na.inherits(pa, ia);

	function ua() {}

	function da(Ma, Aa) {
		ta = ta || require_stream_duplex(), Ma = Ma || {};
		var Ra = Aa instanceof ta;
		this.objectMode = !!Ma.objectMode, Ra && (this.objectMode = this.objectMode || !!Ma.writableObjectMode);
		var Ta = Ma.highWaterMark,
			La = Ma.writableHighWaterMark,
			ya = this.objectMode ? 16 : 16 * 1024;
		Ta || Ta === 0 ? this.highWaterMark = Ta : Ra && (La || La === 0) ? this.highWaterMark = La : this.highWaterMark = ya, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
		var Ba = Ma.decodeStrings === !1;
		this.decodeStrings = !Ba, this.defaultEncoding = Ma.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(io) {
			ja(Aa, io)
		}, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Yi(this)
	}
	da.prototype.getBuffer = function() {
			for (var Aa = this.bufferedRequest, Ra = []; Aa;) Ra.push(Aa), Aa = Aa.next;
			return Ra
		},
		function() {
			try {
				Object.defineProperty(da.prototype, "buffer", {
					get: ra.deprecate(function() {
						return this.getBuffer()
					}, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
				})
			} catch {}
		}();
	var ha;
	typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ha = Function.prototype[Symbol.hasInstance], Object.defineProperty(pa, Symbol.hasInstance, {
		value: function(Ma) {
			return ha.call(this, Ma) ? !0 : this !== pa ? !1 : Ma && Ma._writableState instanceof da
		}
	})) : ha = function(Ma) {
		return Ma instanceof this
	};

	function pa(Ma) {
		if (ta = ta || require_stream_duplex(), !ha.call(pa, this) && !(this instanceof ta)) return new pa(Ma);
		this._writableState = new da(Ma, this), this.writable = !0, Ma && (typeof Ma.write == "function" && (this._write = Ma.write), typeof Ma.writev == "function" && (this._writev = Ma.writev), typeof Ma.destroy == "function" && (this._destroy = Ma.destroy), typeof Ma.final == "function" && (this._final = Ma.final)), ia.call(this)
	}
	pa.prototype.pipe = function() {
		this.emit("error", new Error("Cannot pipe, not readable"))
	};

	function va(Ma, Aa) {
		var Ra = new Error("write after end");
		Ma.emit("error", Ra), ue.nextTick(Aa, Ra)
	}

	function ba(Ma, Aa, Ra, Ta) {
		var La = !0,
			ya = !1;
		return Ra === null ? ya = new TypeError("May not write null values to stream") : typeof Ra != "string" && Ra !== void 0 && !Aa.objectMode && (ya = new TypeError("Invalid non-string/buffer chunk")), ya && (Ma.emit("error", ya), ue.nextTick(Ta, ya), La = !1), La
	}
	pa.prototype.write = function(Ma, Aa, Ra) {
		var Ta = this._writableState,
			La = !1,
			ya = !Ta.objectMode && sa(Ma);
		return ya && !aa.isBuffer(Ma) && (Ma = la(Ma)), typeof Aa == "function" && (Ra = Aa, Aa = null), ya ? Aa = "buffer" : Aa || (Aa = Ta.defaultEncoding), typeof Ra != "function" && (Ra = ua), Ta.ended ? va(this, Ra) : (ya || ba(this, Ta, Ma, Ra)) && (Ta.pendingcb++, La = Sa(this, Ta, ya, Ma, Aa, Ra)), La
	}, pa.prototype.cork = function() {
		var Ma = this._writableState;
		Ma.corked++
	}, pa.prototype.uncork = function() {
		var Ma = this._writableState;
		Ma.corked && (Ma.corked--, !Ma.writing && !Ma.corked && !Ma.bufferProcessing && Ma.bufferedRequest && Ja(this, Ma))
	}, pa.prototype.setDefaultEncoding = function(Aa) {
		if (typeof Aa == "string" && (Aa = Aa.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Aa + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + Aa);
		return this._writableState.defaultEncoding = Aa, this
	};

	function Ea(Ma, Aa, Ra) {
		return !Ma.objectMode && Ma.decodeStrings !== !1 && typeof Aa == "string" && (Aa = aa.from(Aa, Ra)), Aa
	}
	Object.defineProperty(pa.prototype, "writableHighWaterMark", {
		enumerable: !1,
		get: function() {
			return this._writableState.highWaterMark
		}
	});

	function Sa(Ma, Aa, Ra, Ta, La, ya) {
		if (!Ra) {
			var Ba = Ea(Aa, Ta, La);
			Ta !== Ba && (Ra = !0, La = "buffer", Ta = Ba)
		}
		var io = Aa.objectMode ? 1 : Ta.length;
		Aa.length += io;
		var oo = Aa.length < Aa.highWaterMark;
		if (oo || (Aa.needDrain = !0), Aa.writing || Aa.corked) {
			var ao = Aa.lastBufferedRequest;
			Aa.lastBufferedRequest = {
				chunk: Ta,
				encoding: La,
				isBuf: Ra,
				callback: ya,
				next: null
			}, ao ? ao.next = Aa.lastBufferedRequest : Aa.bufferedRequest = Aa.lastBufferedRequest, Aa.bufferedRequestCount += 1
		} else Ca(Ma, Aa, !1, io, Ta, La, ya);
		return oo
	}

	function Ca(Ma, Aa, Ra, Ta, La, ya, Ba) {
		Aa.writelen = Ta, Aa.writecb = Ba, Aa.writing = !0, Aa.sync = !0, Ra ? Ma._writev(La, Aa.onwrite) : Ma._write(La, ya, Aa.onwrite), Aa.sync = !1
	}

	function ka(Ma, Aa, Ra, Ta, La) {
		--Aa.pendingcb, Ra ? (ue.nextTick(La, Ta), ue.nextTick(fa, Ma, Aa), Ma._writableState.errorEmitted = !0, Ma.emit("error", Ta)) : (La(Ta), Ma._writableState.errorEmitted = !0, Ma.emit("error", Ta), fa(Ma, Aa))
	}

	function Pa(Ma) {
		Ma.writing = !1, Ma.writecb = null, Ma.length -= Ma.writelen, Ma.writelen = 0
	}

	function ja(Ma, Aa) {
		var Ra = Ma._writableState,
			Ta = Ra.sync,
			La = Ra.writecb;
		if (Pa(Ra), Aa) ka(Ma, Ra, Ta, Aa, La);
		else {
			var ya = Ua(Ra);
			!ya && !Ra.corked && !Ra.bufferProcessing && Ra.bufferedRequest && Ja(Ma, Ra), Ta ? ea(Za, Ma, Ra, ya, La) : Za(Ma, Ra, ya, La)
		}
	}

	function Za(Ma, Aa, Ra, Ta) {
		Ra || Ga(Ma, Aa), Aa.pendingcb--, Ta(), fa(Ma, Aa)
	}

	function Ga(Ma, Aa) {
		Aa.length === 0 && Aa.needDrain && (Aa.needDrain = !1, Ma.emit("drain"))
	}

	function Ja(Ma, Aa) {
		Aa.bufferProcessing = !0;
		var Ra = Aa.bufferedRequest;
		if (Ma._writev && Ra && Ra.next) {
			var Ta = Aa.bufferedRequestCount,
				La = new Array(Ta),
				ya = Aa.corkedRequestsFree;
			ya.entry = Ra;
			for (var Ba = 0, io = !0; Ra;) La[Ba] = Ra, Ra.isBuf || (io = !1), Ra = Ra.next, Ba += 1;
			La.allBuffers = io, Ca(Ma, Aa, !0, Aa.length, La, "", ya.finish), Aa.pendingcb++, Aa.lastBufferedRequest = null, ya.next ? (Aa.corkedRequestsFree = ya.next, ya.next = null) : Aa.corkedRequestsFree = new Yi(Aa), Aa.bufferedRequestCount = 0
		} else {
			for (; Ra;) {
				var oo = Ra.chunk,
					ao = Ra.encoding,
					Ia = Ra.callback,
					Na = Aa.objectMode ? 1 : oo.length;
				if (Ca(Ma, Aa, !1, Na, oo, ao, Ia), Ra = Ra.next, Aa.bufferedRequestCount--, Aa.writing) break
			}
			Ra === null && (Aa.lastBufferedRequest = null)
		}
		Aa.bufferedRequest = Ra, Aa.bufferProcessing = !1
	}
	pa.prototype._write = function(Ma, Aa, Ra) {
		Ra(new Error("_write() is not implemented"))
	}, pa.prototype._writev = null, pa.prototype.end = function(Ma, Aa, Ra) {
		var Ta = this._writableState;
		typeof Ma == "function" ? (Ra = Ma, Ma = null, Aa = null) : typeof Aa == "function" && (Ra = Aa, Aa = null), Ma != null && this.write(Ma, Aa), Ta.corked && (Ta.corked = 1, this.uncork()), Ta.ending || ga(this, Ta, Ra)
	};

	function Ua(Ma) {
		return Ma.ending && Ma.length === 0 && Ma.bufferedRequest === null && !Ma.finished && !Ma.writing
	}

	function xa(Ma, Aa) {
		Ma._final(function(Ra) {
			Aa.pendingcb--, Ra && Ma.emit("error", Ra), Aa.prefinished = !0, Ma.emit("prefinish"), fa(Ma, Aa)
		})
	}

	function ma(Ma, Aa) {
		!Aa.prefinished && !Aa.finalCalled && (typeof Ma._final == "function" ? (Aa.pendingcb++, Aa.finalCalled = !0, ue.nextTick(xa, Ma, Aa)) : (Aa.prefinished = !0, Ma.emit("prefinish")))
	}

	function fa(Ma, Aa) {
		var Ra = Ua(Aa);
		return Ra && (ma(Ma, Aa), Aa.pendingcb === 0 && (Aa.finished = !0, Ma.emit("finish"))), Ra
	}

	function ga(Ma, Aa, Ra) {
		Aa.ending = !0, fa(Ma, Aa), Ra && (Aa.finished ? ue.nextTick(Ra) : Ma.once("finish", Ra)), Aa.ended = !0, Ma.writable = !1
	}

	function wa(Ma, Aa, Ra) {
		var Ta = Ma.entry;
		for (Ma.entry = null; Ta;) {
			var La = Ta.callback;
			Aa.pendingcb--, La(Ra), Ta = Ta.next
		}
		Aa.corkedRequestsFree.next = Ma
	}
	return Object.defineProperty(pa.prototype, "destroyed", {
		get: function() {
			return this._writableState === void 0 ? !1 : this._writableState.destroyed
		},
		set: function(Ma) {
			this._writableState && (this._writableState.destroyed = Ma)
		}
	}), pa.prototype.destroy = ca.destroy, pa.prototype._undestroy = ca.undestroy, pa.prototype._destroy = function(Ma, Aa) {
		this.end(), Aa(Ma)
	}, _stream_writable
}
var _stream_duplex, hasRequired_stream_duplex;

function require_stream_duplex() {
	if (hasRequired_stream_duplex) return _stream_duplex;
	hasRequired_stream_duplex = 1;
	var ue = requireProcessNextickArgs(),
		Yi = Object.keys || function(ca) {
			var ua = [];
			for (var da in ca) ua.push(da);
			return ua
		};
	_stream_duplex = oa;
	var ea = Object.create(requireUtil());
	ea.inherits = requireInherits_browser();
	var ta = require_stream_readable(),
		na = require_stream_writable();
	ea.inherits(oa, ta);
	for (var ra = Yi(na.prototype), ia = 0; ia < ra.length; ia++) {
		var aa = ra[ia];
		oa.prototype[aa] || (oa.prototype[aa] = na.prototype[aa])
	}

	function oa(ca) {
		if (!(this instanceof oa)) return new oa(ca);
		ta.call(this, ca), na.call(this, ca), ca && ca.readable === !1 && (this.readable = !1), ca && ca.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, ca && ca.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", la)
	}
	Object.defineProperty(oa.prototype, "writableHighWaterMark", {
		enumerable: !1,
		get: function() {
			return this._writableState.highWaterMark
		}
	});

	function la() {
		this.allowHalfOpen || this._writableState.ended || ue.nextTick(sa, this)
	}

	function sa(ca) {
		ca.end()
	}
	return Object.defineProperty(oa.prototype, "destroyed", {
		get: function() {
			return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed
		},
		set: function(ca) {
			this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = ca, this._writableState.destroyed = ca)
		}
	}), oa.prototype._destroy = function(ca, ua) {
		this.push(null), this.end(), ue.nextTick(ua, ca)
	}, _stream_duplex
}
var _stream_readable, hasRequired_stream_readable;

function require_stream_readable() {
	if (hasRequired_stream_readable) return _stream_readable;
	hasRequired_stream_readable = 1;
	var ue = requireProcessNextickArgs();
	_stream_readable = Ea;
	var Yi = requireIsarray(),
		ea;
	Ea.ReadableState = ba, requireEvents().EventEmitter;
	var ta = function(Ia, Na) {
			return Ia.listeners(Na).length
		},
		na = requireStreamBrowser(),
		ra = requireSafeBuffer().Buffer,
		ia = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};

	function aa(Ia) {
		return ra.from(Ia)
	}

	function oa(Ia) {
		return ra.isBuffer(Ia) || Ia instanceof ia
	}
	var la = Object.create(requireUtil());
	la.inherits = requireInherits_browser();
	var sa = requireUtil$1(),
		ca = void 0;
	sa && sa.debuglog ? ca = sa.debuglog("stream") : ca = function() {};
	var ua = requireBufferList(),
		da = requireDestroy(),
		ha;
	la.inherits(Ea, na);
	var pa = ["error", "close", "destroy", "pause", "resume"];

	function va(Ia, Na, za) {
		if (typeof Ia.prependListener == "function") return Ia.prependListener(Na, za);
		!Ia._events || !Ia._events[Na] ? Ia.on(Na, za) : Yi(Ia._events[Na]) ? Ia._events[Na].unshift(za) : Ia._events[Na] = [za, Ia._events[Na]]
	}

	function ba(Ia, Na) {
		ea = ea || require_stream_duplex(), Ia = Ia || {};
		var za = Na instanceof ea;
		this.objectMode = !!Ia.objectMode, za && (this.objectMode = this.objectMode || !!Ia.readableObjectMode);
		var ro = Ia.highWaterMark,
			Va = Ia.readableHighWaterMark,
			Wa = this.objectMode ? 16 : 16 * 1024;
		ro || ro === 0 ? this.highWaterMark = ro : za && (Va || Va === 0) ? this.highWaterMark = Va : this.highWaterMark = Wa, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new ua, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Ia.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Ia.encoding && (ha || (ha = requireString_decoder().StringDecoder), this.decoder = new ha(Ia.encoding), this.encoding = Ia.encoding)
	}

	function Ea(Ia) {
		if (ea = ea || require_stream_duplex(), !(this instanceof Ea)) return new Ea(Ia);
		this._readableState = new ba(Ia, this), this.readable = !0, Ia && (typeof Ia.read == "function" && (this._read = Ia.read), typeof Ia.destroy == "function" && (this._destroy = Ia.destroy)), na.call(this)
	}
	Object.defineProperty(Ea.prototype, "destroyed", {
		get: function() {
			return this._readableState === void 0 ? !1 : this._readableState.destroyed
		},
		set: function(Ia) {
			this._readableState && (this._readableState.destroyed = Ia)
		}
	}), Ea.prototype.destroy = da.destroy, Ea.prototype._undestroy = da.undestroy, Ea.prototype._destroy = function(Ia, Na) {
		this.push(null), Na(Ia)
	}, Ea.prototype.push = function(Ia, Na) {
		var za = this._readableState,
			ro;
		return za.objectMode ? ro = !0 : typeof Ia == "string" && (Na = Na || za.defaultEncoding, Na !== za.encoding && (Ia = ra.from(Ia, Na), Na = ""), ro = !0), Sa(this, Ia, Na, !1, ro)
	}, Ea.prototype.unshift = function(Ia) {
		return Sa(this, Ia, null, !0, !1)
	};

	function Sa(Ia, Na, za, ro, Va) {
		var Wa = Ia._readableState;
		if (Na === null) Wa.reading = !1, Ja(Ia, Wa);
		else {
			var qa;
			Va || (qa = ka(Wa, Na)), qa ? Ia.emit("error", qa) : Wa.objectMode || Na && Na.length > 0 ? (typeof Na != "string" && !Wa.objectMode && Object.getPrototypeOf(Na) !== ra.prototype && (Na = aa(Na)), ro ? Wa.endEmitted ? Ia.emit("error", new Error("stream.unshift() after end event")) : Ca(Ia, Wa, Na, !0) : Wa.ended ? Ia.emit("error", new Error("stream.push() after EOF")) : (Wa.reading = !1, Wa.decoder && !za ? (Na = Wa.decoder.write(Na), Wa.objectMode || Na.length !== 0 ? Ca(Ia, Wa, Na, !1) : ma(Ia, Wa)) : Ca(Ia, Wa, Na, !1))) : ro || (Wa.reading = !1)
		}
		return Pa(Wa)
	}

	function Ca(Ia, Na, za, ro) {
		Na.flowing && Na.length === 0 && !Na.sync ? (Ia.emit("data", za), Ia.read(0)) : (Na.length += Na.objectMode ? 1 : za.length, ro ? Na.buffer.unshift(za) : Na.buffer.push(za), Na.needReadable && Ua(Ia)), ma(Ia, Na)
	}

	function ka(Ia, Na) {
		var za;
		return !oa(Na) && typeof Na != "string" && Na !== void 0 && !Ia.objectMode && (za = new TypeError("Invalid non-string/buffer chunk")), za
	}

	function Pa(Ia) {
		return !Ia.ended && (Ia.needReadable || Ia.length < Ia.highWaterMark || Ia.length === 0)
	}
	Ea.prototype.isPaused = function() {
		return this._readableState.flowing === !1
	}, Ea.prototype.setEncoding = function(Ia) {
		return ha || (ha = requireString_decoder().StringDecoder), this._readableState.decoder = new ha(Ia), this._readableState.encoding = Ia, this
	};
	var ja = 8388608;

	function Za(Ia) {
		return Ia >= ja ? Ia = ja : (Ia--, Ia |= Ia >>> 1, Ia |= Ia >>> 2, Ia |= Ia >>> 4, Ia |= Ia >>> 8, Ia |= Ia >>> 16, Ia++), Ia
	}

	function Ga(Ia, Na) {
		return Ia <= 0 || Na.length === 0 && Na.ended ? 0 : Na.objectMode ? 1 : Ia !== Ia ? Na.flowing && Na.length ? Na.buffer.head.data.length : Na.length : (Ia > Na.highWaterMark && (Na.highWaterMark = Za(Ia)), Ia <= Na.length ? Ia : Na.ended ? Na.length : (Na.needReadable = !0, 0))
	}
	Ea.prototype.read = function(Ia) {
		ca("read", Ia), Ia = parseInt(Ia, 10);
		var Na = this._readableState,
			za = Ia;
		if (Ia !== 0 && (Na.emittedReadable = !1), Ia === 0 && Na.needReadable && (Na.length >= Na.highWaterMark || Na.ended)) return ca("read: emitReadable", Na.length, Na.ended), Na.length === 0 && Na.ended ? io(this) : Ua(this), null;
		if (Ia = Ga(Ia, Na), Ia === 0 && Na.ended) return Na.length === 0 && io(this), null;
		var ro = Na.needReadable;
		ca("need readable", ro), (Na.length === 0 || Na.length - Ia < Na.highWaterMark) && (ro = !0, ca("length less than watermark", ro)), Na.ended || Na.reading ? (ro = !1, ca("reading or ended", ro)) : ro && (ca("do read"), Na.reading = !0, Na.sync = !0, Na.length === 0 && (Na.needReadable = !0), this._read(Na.highWaterMark), Na.sync = !1, Na.reading || (Ia = Ga(za, Na)));
		var Va;
		return Ia > 0 ? Va = Ta(Ia, Na) : Va = null, Va === null ? (Na.needReadable = !0, Ia = 0) : Na.length -= Ia, Na.length === 0 && (Na.ended || (Na.needReadable = !0), za !== Ia && Na.ended && io(this)), Va !== null && this.emit("data", Va), Va
	};

	function Ja(Ia, Na) {
		if (!Na.ended) {
			if (Na.decoder) {
				var za = Na.decoder.end();
				za && za.length && (Na.buffer.push(za), Na.length += Na.objectMode ? 1 : za.length)
			}
			Na.ended = !0, Ua(Ia)
		}
	}

	function Ua(Ia) {
		var Na = Ia._readableState;
		Na.needReadable = !1, Na.emittedReadable || (ca("emitReadable", Na.flowing), Na.emittedReadable = !0, Na.sync ? ue.nextTick(xa, Ia) : xa(Ia))
	}

	function xa(Ia) {
		ca("emit readable"), Ia.emit("readable"), Ra(Ia)
	}

	function ma(Ia, Na) {
		Na.readingMore || (Na.readingMore = !0, ue.nextTick(fa, Ia, Na))
	}

	function fa(Ia, Na) {
		for (var za = Na.length; !Na.reading && !Na.flowing && !Na.ended && Na.length < Na.highWaterMark && (ca("maybeReadMore read 0"), Ia.read(0), za !== Na.length);) za = Na.length;
		Na.readingMore = !1
	}
	Ea.prototype._read = function(Ia) {
		this.emit("error", new Error("_read() is not implemented"))
	}, Ea.prototype.pipe = function(Ia, Na) {
		var za = this,
			ro = this._readableState;
		switch (ro.pipesCount) {
			case 0:
				ro.pipes = Ia;
				break;
			case 1:
				ro.pipes = [ro.pipes, Ia];
				break;
			default:
				ro.pipes.push(Ia);
				break
		}
		ro.pipesCount += 1, ca("pipe count=%d opts=%j", ro.pipesCount, Na);
		var Va = (!Na || Na.end !== !1) && Ia !== process$1.stdout && Ia !== process$1.stderr,
			Wa = Va ? Ka : Eo;
		ro.endEmitted ? ue.nextTick(Wa) : za.once("end", Wa), Ia.on("unpipe", qa);

		function qa(wo, Ao) {
			ca("onunpipe"), wo === za && Ao && Ao.hasUnpiped === !1 && (Ao.hasUnpiped = !0, fo())
		}

		function Ka() {
			ca("onend"), Ia.end()
		}
		var lo = ga(za);
		Ia.on("drain", lo);
		var yo = !1;

		function fo() {
			ca("cleanup"), Ia.removeListener("close", to), Ia.removeListener("finish", ho), Ia.removeListener("drain", lo), Ia.removeListener("error", Xa), Ia.removeListener("unpipe", qa), za.removeListener("end", Ka), za.removeListener("end", Eo), za.removeListener("data", so), yo = !0, ro.awaitDrain && (!Ia._writableState || Ia._writableState.needDrain) && lo()
		}
		var vo = !1;
		za.on("data", so);

		function so(wo) {
			ca("ondata"), vo = !1;
			var Ao = Ia.write(wo);
			Ao === !1 && !vo && ((ro.pipesCount === 1 && ro.pipes === Ia || ro.pipesCount > 1 && ao(ro.pipes, Ia) !== -1) && !yo && (ca("false write response, pause", ro.awaitDrain), ro.awaitDrain++, vo = !0), za.pause())
		}

		function Xa(wo) {
			ca("onerror", wo), Eo(), Ia.removeListener("error", Xa), ta(Ia, "error") === 0 && Ia.emit("error", wo)
		}
		va(Ia, "error", Xa);

		function to() {
			Ia.removeListener("finish", ho), Eo()
		}
		Ia.once("close", to);

		function ho() {
			ca("onfinish"), Ia.removeListener("close", to), Eo()
		}
		Ia.once("finish", ho);

		function Eo() {
			ca("unpipe"), za.unpipe(Ia)
		}
		return Ia.emit("pipe", za), ro.flowing || (ca("pipe resume"), za.resume()), Ia
	};

	function ga(Ia) {
		return function() {
			var Na = Ia._readableState;
			ca("pipeOnDrain", Na.awaitDrain), Na.awaitDrain && Na.awaitDrain--, Na.awaitDrain === 0 && ta(Ia, "data") && (Na.flowing = !0, Ra(Ia))
		}
	}
	Ea.prototype.unpipe = function(Ia) {
		var Na = this._readableState,
			za = {
				hasUnpiped: !1
			};
		if (Na.pipesCount === 0) return this;
		if (Na.pipesCount === 1) return Ia && Ia !== Na.pipes ? this : (Ia || (Ia = Na.pipes), Na.pipes = null, Na.pipesCount = 0, Na.flowing = !1, Ia && Ia.emit("unpipe", this, za), this);
		if (!Ia) {
			var ro = Na.pipes,
				Va = Na.pipesCount;
			Na.pipes = null, Na.pipesCount = 0, Na.flowing = !1;
			for (var Wa = 0; Wa < Va; Wa++) ro[Wa].emit("unpipe", this, {
				hasUnpiped: !1
			});
			return this
		}
		var qa = ao(Na.pipes, Ia);
		return qa === -1 ? this : (Na.pipes.splice(qa, 1), Na.pipesCount -= 1, Na.pipesCount === 1 && (Na.pipes = Na.pipes[0]), Ia.emit("unpipe", this, za), this)
	}, Ea.prototype.on = function(Ia, Na) {
		var za = na.prototype.on.call(this, Ia, Na);
		if (Ia === "data") this._readableState.flowing !== !1 && this.resume();
		else if (Ia === "readable") {
			var ro = this._readableState;
			!ro.endEmitted && !ro.readableListening && (ro.readableListening = ro.needReadable = !0, ro.emittedReadable = !1, ro.reading ? ro.length && Ua(this) : ue.nextTick(wa, this))
		}
		return za
	}, Ea.prototype.addListener = Ea.prototype.on;

	function wa(Ia) {
		ca("readable nexttick read 0"), Ia.read(0)
	}
	Ea.prototype.resume = function() {
		var Ia = this._readableState;
		return Ia.flowing || (ca("resume"), Ia.flowing = !0, Ma(this, Ia)), this
	};

	function Ma(Ia, Na) {
		Na.resumeScheduled || (Na.resumeScheduled = !0, ue.nextTick(Aa, Ia, Na))
	}

	function Aa(Ia, Na) {
		Na.reading || (ca("resume read 0"), Ia.read(0)), Na.resumeScheduled = !1, Na.awaitDrain = 0, Ia.emit("resume"), Ra(Ia), Na.flowing && !Na.reading && Ia.read(0)
	}
	Ea.prototype.pause = function() {
		return ca("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ca("pause"), this._readableState.flowing = !1, this.emit("pause")), this
	};

	function Ra(Ia) {
		var Na = Ia._readableState;
		for (ca("flow", Na.flowing); Na.flowing && Ia.read() !== null;);
	}
	Ea.prototype.wrap = function(Ia) {
		var Na = this,
			za = this._readableState,
			ro = !1;
		Ia.on("end", function() {
			if (ca("wrapped end"), za.decoder && !za.ended) {
				var qa = za.decoder.end();
				qa && qa.length && Na.push(qa)
			}
			Na.push(null)
		}), Ia.on("data", function(qa) {
			if (ca("wrapped data"), za.decoder && (qa = za.decoder.write(qa)), !(za.objectMode && qa == null) && !(!za.objectMode && (!qa || !qa.length))) {
				var Ka = Na.push(qa);
				Ka || (ro = !0, Ia.pause())
			}
		});
		for (var Va in Ia) this[Va] === void 0 && typeof Ia[Va] == "function" && (this[Va] = function(qa) {
			return function() {
				return Ia[qa].apply(Ia, arguments)
			}
		}(Va));
		for (var Wa = 0; Wa < pa.length; Wa++) Ia.on(pa[Wa], this.emit.bind(this, pa[Wa]));
		return this._read = function(qa) {
			ca("wrapped _read", qa), ro && (ro = !1, Ia.resume())
		}, this
	}, Object.defineProperty(Ea.prototype, "readableHighWaterMark", {
		enumerable: !1,
		get: function() {
			return this._readableState.highWaterMark
		}
	}), Ea._fromList = Ta;

	function Ta(Ia, Na) {
		if (Na.length === 0) return null;
		var za;
		return Na.objectMode ? za = Na.buffer.shift() : !Ia || Ia >= Na.length ? (Na.decoder ? za = Na.buffer.join("") : Na.buffer.length === 1 ? za = Na.buffer.head.data : za = Na.buffer.concat(Na.length), Na.buffer.clear()) : za = La(Ia, Na.buffer, Na.decoder), za
	}

	function La(Ia, Na, za) {
		var ro;
		return Ia < Na.head.data.length ? (ro = Na.head.data.slice(0, Ia), Na.head.data = Na.head.data.slice(Ia)) : Ia === Na.head.data.length ? ro = Na.shift() : ro = za ? ya(Ia, Na) : Ba(Ia, Na), ro
	}

	function ya(Ia, Na) {
		var za = Na.head,
			ro = 1,
			Va = za.data;
		for (Ia -= Va.length; za = za.next;) {
			var Wa = za.data,
				qa = Ia > Wa.length ? Wa.length : Ia;
			if (qa === Wa.length ? Va += Wa : Va += Wa.slice(0, Ia), Ia -= qa, Ia === 0) {
				qa === Wa.length ? (++ro, za.next ? Na.head = za.next : Na.head = Na.tail = null) : (Na.head = za, za.data = Wa.slice(qa));
				break
			}++ro
		}
		return Na.length -= ro, Va
	}

	function Ba(Ia, Na) {
		var za = ra.allocUnsafe(Ia),
			ro = Na.head,
			Va = 1;
		for (ro.data.copy(za), Ia -= ro.data.length; ro = ro.next;) {
			var Wa = ro.data,
				qa = Ia > Wa.length ? Wa.length : Ia;
			if (Wa.copy(za, za.length - Ia, 0, qa), Ia -= qa, Ia === 0) {
				qa === Wa.length ? (++Va, ro.next ? Na.head = ro.next : Na.head = Na.tail = null) : (Na.head = ro, ro.data = Wa.slice(qa));
				break
			}++Va
		}
		return Na.length -= Va, za
	}

	function io(Ia) {
		var Na = Ia._readableState;
		if (Na.length > 0) throw new Error('"endReadable()" called on non-empty stream');
		Na.endEmitted || (Na.ended = !0, ue.nextTick(oo, Na, Ia))
	}

	function oo(Ia, Na) {
		!Ia.endEmitted && Ia.length === 0 && (Ia.endEmitted = !0, Na.readable = !1, Na.emit("end"))
	}

	function ao(Ia, Na) {
		for (var za = 0, ro = Ia.length; za < ro; za++)
			if (Ia[za] === Na) return za;
		return -1
	}
	return _stream_readable
}
var _stream_transform, hasRequired_stream_transform;

function require_stream_transform() {
	if (hasRequired_stream_transform) return _stream_transform;
	hasRequired_stream_transform = 1, _stream_transform = ta;
	var ue = require_stream_duplex(),
		Yi = Object.create(requireUtil());
	Yi.inherits = requireInherits_browser(), Yi.inherits(ta, ue);

	function ea(ia, aa) {
		var oa = this._transformState;
		oa.transforming = !1;
		var la = oa.writecb;
		if (!la) return this.emit("error", new Error("write callback called multiple times"));
		oa.writechunk = null, oa.writecb = null, aa != null && this.push(aa), la(ia);
		var sa = this._readableState;
		sa.reading = !1, (sa.needReadable || sa.length < sa.highWaterMark) && this._read(sa.highWaterMark)
	}

	function ta(ia) {
		if (!(this instanceof ta)) return new ta(ia);
		ue.call(this, ia), this._transformState = {
			afterTransform: ea.bind(this),
			needTransform: !1,
			transforming: !1,
			writecb: null,
			writechunk: null,
			writeencoding: null
		}, this._readableState.needReadable = !0, this._readableState.sync = !1, ia && (typeof ia.transform == "function" && (this._transform = ia.transform), typeof ia.flush == "function" && (this._flush = ia.flush)), this.on("prefinish", na)
	}

	function na() {
		var ia = this;
		typeof this._flush == "function" ? this._flush(function(aa, oa) {
			ra(ia, aa, oa)
		}) : ra(this, null, null)
	}
	ta.prototype.push = function(ia, aa) {
		return this._transformState.needTransform = !1, ue.prototype.push.call(this, ia, aa)
	}, ta.prototype._transform = function(ia, aa, oa) {
		throw new Error("_transform() is not implemented")
	}, ta.prototype._write = function(ia, aa, oa) {
		var la = this._transformState;
		if (la.writecb = oa, la.writechunk = ia, la.writeencoding = aa, !la.transforming) {
			var sa = this._readableState;
			(la.needTransform || sa.needReadable || sa.length < sa.highWaterMark) && this._read(sa.highWaterMark)
		}
	}, ta.prototype._read = function(ia) {
		var aa = this._transformState;
		aa.writechunk !== null && aa.writecb && !aa.transforming ? (aa.transforming = !0, this._transform(aa.writechunk, aa.writeencoding, aa.afterTransform)) : aa.needTransform = !0
	}, ta.prototype._destroy = function(ia, aa) {
		var oa = this;
		ue.prototype._destroy.call(this, ia, function(la) {
			aa(la), oa.emit("close")
		})
	};

	function ra(ia, aa, oa) {
		if (aa) return ia.emit("error", aa);
		if (oa != null && ia.push(oa), ia._writableState.length) throw new Error("Calling transform done when ws.length != 0");
		if (ia._transformState.transforming) throw new Error("Calling transform done when still transforming");
		return ia.push(null)
	}
	return _stream_transform
}
var _stream_passthrough, hasRequired_stream_passthrough;

function require_stream_passthrough() {
	if (hasRequired_stream_passthrough) return _stream_passthrough;
	hasRequired_stream_passthrough = 1, _stream_passthrough = ea;
	var ue = require_stream_transform(),
		Yi = Object.create(requireUtil());
	Yi.inherits = requireInherits_browser(), Yi.inherits(ea, ue);

	function ea(ta) {
		if (!(this instanceof ea)) return new ea(ta);
		ue.call(this, ta)
	}
	return ea.prototype._transform = function(ta, na, ra) {
		ra(null, ta)
	}, _stream_passthrough
}
var hasRequiredReadableBrowser;

function requireReadableBrowser() {
	return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function(ue, Yi) {
		Yi = ue.exports = require_stream_readable(), Yi.Stream = Yi, Yi.Readable = Yi, Yi.Writable = require_stream_writable(), Yi.Duplex = require_stream_duplex(), Yi.Transform = require_stream_transform(), Yi.PassThrough = require_stream_passthrough()
	}(readableBrowser, readableBrowser.exports)), readableBrowser.exports
}
var sign$2 = {
		exports: {}
	},
	bn$2 = {
		exports: {}
	};
bn$2.exports;
var hasRequiredBn$1;

function requireBn$1() {
	return hasRequiredBn$1 || (hasRequiredBn$1 = 1, function(ue) {
		(function(Yi, ea) {
			function ta(ma, fa) {
				if (!ma) throw new Error(fa || "Assertion failed")
			}

			function na(ma, fa) {
				ma.super_ = fa;
				var ga = function() {};
				ga.prototype = fa.prototype, ma.prototype = new ga, ma.prototype.constructor = ma
			}

			function ra(ma, fa, ga) {
				if (ra.isBN(ma)) return ma;
				this.negative = 0, this.words = null, this.length = 0, this.red = null, ma !== null && ((fa === "le" || fa === "be") && (ga = fa, fa = 10), this._init(ma || 0, fa || 10, ga || "be"))
			}
			typeof Yi == "object" ? Yi.exports = ra : ea.BN = ra, ra.BN = ra, ra.wordSize = 26;
			var ia;
			try {
				typeof window < "u" && typeof window.Buffer < "u" ? ia = window.Buffer : ia = require$$1$2.Buffer
			} catch {}
			ra.isBN = function(fa) {
				return fa instanceof ra ? !0 : fa !== null && typeof fa == "object" && fa.constructor.wordSize === ra.wordSize && Array.isArray(fa.words)
			}, ra.max = function(fa, ga) {
				return fa.cmp(ga) > 0 ? fa : ga
			}, ra.min = function(fa, ga) {
				return fa.cmp(ga) < 0 ? fa : ga
			}, ra.prototype._init = function(fa, ga, wa) {
				if (typeof fa == "number") return this._initNumber(fa, ga, wa);
				if (typeof fa == "object") return this._initArray(fa, ga, wa);
				ga === "hex" && (ga = 16), ta(ga === (ga | 0) && ga >= 2 && ga <= 36), fa = fa.toString().replace(/\s+/g, "");
				var Ma = 0;
				fa[0] === "-" && (Ma++, this.negative = 1), Ma < fa.length && (ga === 16 ? this._parseHex(fa, Ma, wa) : (this._parseBase(fa, ga, Ma), wa === "le" && this._initArray(this.toArray(), ga, wa)))
			}, ra.prototype._initNumber = function(fa, ga, wa) {
				fa < 0 && (this.negative = 1, fa = -fa), fa < 67108864 ? (this.words = [fa & 67108863], this.length = 1) : fa < 4503599627370496 ? (this.words = [fa & 67108863, fa / 67108864 & 67108863], this.length = 2) : (ta(fa < 9007199254740992), this.words = [fa & 67108863, fa / 67108864 & 67108863, 1], this.length = 3), wa === "le" && this._initArray(this.toArray(), ga, wa)
			}, ra.prototype._initArray = function(fa, ga, wa) {
				if (ta(typeof fa.length == "number"), fa.length <= 0) return this.words = [0], this.length = 1, this;
				this.length = Math.ceil(fa.length / 3), this.words = new Array(this.length);
				for (var Ma = 0; Ma < this.length; Ma++) this.words[Ma] = 0;
				var Aa, Ra, Ta = 0;
				if (wa === "be")
					for (Ma = fa.length - 1, Aa = 0; Ma >= 0; Ma -= 3) Ra = fa[Ma] | fa[Ma - 1] << 8 | fa[Ma - 2] << 16, this.words[Aa] |= Ra << Ta & 67108863, this.words[Aa + 1] = Ra >>> 26 - Ta & 67108863, Ta += 24, Ta >= 26 && (Ta -= 26, Aa++);
				else if (wa === "le")
					for (Ma = 0, Aa = 0; Ma < fa.length; Ma += 3) Ra = fa[Ma] | fa[Ma + 1] << 8 | fa[Ma + 2] << 16, this.words[Aa] |= Ra << Ta & 67108863, this.words[Aa + 1] = Ra >>> 26 - Ta & 67108863, Ta += 24, Ta >= 26 && (Ta -= 26, Aa++);
				return this._strip()
			};

			function aa(ma, fa) {
				var ga = ma.charCodeAt(fa);
				if (ga >= 48 && ga <= 57) return ga - 48;
				if (ga >= 65 && ga <= 70) return ga - 55;
				if (ga >= 97 && ga <= 102) return ga - 87;
				ta(!1, "Invalid character in " + ma)
			}

			function oa(ma, fa, ga) {
				var wa = aa(ma, ga);
				return ga - 1 >= fa && (wa |= aa(ma, ga - 1) << 4), wa
			}
			ra.prototype._parseHex = function(fa, ga, wa) {
				this.length = Math.ceil((fa.length - ga) / 6), this.words = new Array(this.length);
				for (var Ma = 0; Ma < this.length; Ma++) this.words[Ma] = 0;
				var Aa = 0,
					Ra = 0,
					Ta;
				if (wa === "be")
					for (Ma = fa.length - 1; Ma >= ga; Ma -= 2) Ta = oa(fa, ga, Ma) << Aa, this.words[Ra] |= Ta & 67108863, Aa >= 18 ? (Aa -= 18, Ra += 1, this.words[Ra] |= Ta >>> 26) : Aa += 8;
				else {
					var La = fa.length - ga;
					for (Ma = La % 2 === 0 ? ga + 1 : ga; Ma < fa.length; Ma += 2) Ta = oa(fa, ga, Ma) << Aa, this.words[Ra] |= Ta & 67108863, Aa >= 18 ? (Aa -= 18, Ra += 1, this.words[Ra] |= Ta >>> 26) : Aa += 8
				}
				this._strip()
			};

			function la(ma, fa, ga, wa) {
				for (var Ma = 0, Aa = 0, Ra = Math.min(ma.length, ga), Ta = fa; Ta < Ra; Ta++) {
					var La = ma.charCodeAt(Ta) - 48;
					Ma *= wa, La >= 49 ? Aa = La - 49 + 10 : La >= 17 ? Aa = La - 17 + 10 : Aa = La, ta(La >= 0 && Aa < wa, "Invalid character"), Ma += Aa
				}
				return Ma
			}
			ra.prototype._parseBase = function(fa, ga, wa) {
				this.words = [0], this.length = 1;
				for (var Ma = 0, Aa = 1; Aa <= 67108863; Aa *= ga) Ma++;
				Ma--, Aa = Aa / ga | 0;
				for (var Ra = fa.length - wa, Ta = Ra % Ma, La = Math.min(Ra, Ra - Ta) + wa, ya = 0, Ba = wa; Ba < La; Ba += Ma) ya = la(fa, Ba, Ba + Ma, ga), this.imuln(Aa), this.words[0] + ya < 67108864 ? this.words[0] += ya : this._iaddn(ya);
				if (Ta !== 0) {
					var io = 1;
					for (ya = la(fa, Ba, fa.length, ga), Ba = 0; Ba < Ta; Ba++) io *= ga;
					this.imuln(io), this.words[0] + ya < 67108864 ? this.words[0] += ya : this._iaddn(ya)
				}
				this._strip()
			}, ra.prototype.copy = function(fa) {
				fa.words = new Array(this.length);
				for (var ga = 0; ga < this.length; ga++) fa.words[ga] = this.words[ga];
				fa.length = this.length, fa.negative = this.negative, fa.red = this.red
			};

			function sa(ma, fa) {
				ma.words = fa.words, ma.length = fa.length, ma.negative = fa.negative, ma.red = fa.red
			}
			if (ra.prototype._move = function(fa) {
					sa(fa, this)
				}, ra.prototype.clone = function() {
					var fa = new ra(null);
					return this.copy(fa), fa
				}, ra.prototype._expand = function(fa) {
					for (; this.length < fa;) this.words[this.length++] = 0;
					return this
				}, ra.prototype._strip = function() {
					for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
					return this._normSign()
				}, ra.prototype._normSign = function() {
					return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
				}, typeof Symbol < "u" && typeof Symbol.for == "function") try {
				ra.prototype[Symbol.for("nodejs.util.inspect.custom")] = ca
			} catch {
				ra.prototype.inspect = ca
			} else ra.prototype.inspect = ca;

			function ca() {
				return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
			}
			var ua = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
				da = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
				ha = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
			ra.prototype.toString = function(fa, ga) {
				fa = fa || 10, ga = ga | 0 || 1;
				var wa;
				if (fa === 16 || fa === "hex") {
					wa = "";
					for (var Ma = 0, Aa = 0, Ra = 0; Ra < this.length; Ra++) {
						var Ta = this.words[Ra],
							La = ((Ta << Ma | Aa) & 16777215).toString(16);
						Aa = Ta >>> 24 - Ma & 16777215, Ma += 2, Ma >= 26 && (Ma -= 26, Ra--), Aa !== 0 || Ra !== this.length - 1 ? wa = ua[6 - La.length] + La + wa : wa = La + wa
					}
					for (Aa !== 0 && (wa = Aa.toString(16) + wa); wa.length % ga !== 0;) wa = "0" + wa;
					return this.negative !== 0 && (wa = "-" + wa), wa
				}
				if (fa === (fa | 0) && fa >= 2 && fa <= 36) {
					var ya = da[fa],
						Ba = ha[fa];
					wa = "";
					var io = this.clone();
					for (io.negative = 0; !io.isZero();) {
						var oo = io.modrn(Ba).toString(fa);
						io = io.idivn(Ba), io.isZero() ? wa = oo + wa : wa = ua[ya - oo.length] + oo + wa
					}
					for (this.isZero() && (wa = "0" + wa); wa.length % ga !== 0;) wa = "0" + wa;
					return this.negative !== 0 && (wa = "-" + wa), wa
				}
				ta(!1, "Base should be between 2 and 36")
			}, ra.prototype.toNumber = function() {
				var fa = this.words[0];
				return this.length === 2 ? fa += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? fa += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && ta(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -fa : fa
			}, ra.prototype.toJSON = function() {
				return this.toString(16, 2)
			}, ia && (ra.prototype.toBuffer = function(fa, ga) {
				return this.toArrayLike(ia, fa, ga)
			}), ra.prototype.toArray = function(fa, ga) {
				return this.toArrayLike(Array, fa, ga)
			};
			var pa = function(fa, ga) {
				return fa.allocUnsafe ? fa.allocUnsafe(ga) : new fa(ga)
			};
			ra.prototype.toArrayLike = function(fa, ga, wa) {
				this._strip();
				var Ma = this.byteLength(),
					Aa = wa || Math.max(1, Ma);
				ta(Ma <= Aa, "byte array longer than desired length"), ta(Aa > 0, "Requested array length <= 0");
				var Ra = pa(fa, Aa),
					Ta = ga === "le" ? "LE" : "BE";
				return this["_toArrayLike" + Ta](Ra, Ma), Ra
			}, ra.prototype._toArrayLikeLE = function(fa, ga) {
				for (var wa = 0, Ma = 0, Aa = 0, Ra = 0; Aa < this.length; Aa++) {
					var Ta = this.words[Aa] << Ra | Ma;
					fa[wa++] = Ta & 255, wa < fa.length && (fa[wa++] = Ta >> 8 & 255), wa < fa.length && (fa[wa++] = Ta >> 16 & 255), Ra === 6 ? (wa < fa.length && (fa[wa++] = Ta >> 24 & 255), Ma = 0, Ra = 0) : (Ma = Ta >>> 24, Ra += 2)
				}
				if (wa < fa.length)
					for (fa[wa++] = Ma; wa < fa.length;) fa[wa++] = 0
			}, ra.prototype._toArrayLikeBE = function(fa, ga) {
				for (var wa = fa.length - 1, Ma = 0, Aa = 0, Ra = 0; Aa < this.length; Aa++) {
					var Ta = this.words[Aa] << Ra | Ma;
					fa[wa--] = Ta & 255, wa >= 0 && (fa[wa--] = Ta >> 8 & 255), wa >= 0 && (fa[wa--] = Ta >> 16 & 255), Ra === 6 ? (wa >= 0 && (fa[wa--] = Ta >> 24 & 255), Ma = 0, Ra = 0) : (Ma = Ta >>> 24, Ra += 2)
				}
				if (wa >= 0)
					for (fa[wa--] = Ma; wa >= 0;) fa[wa--] = 0
			}, Math.clz32 ? ra.prototype._countBits = function(fa) {
				return 32 - Math.clz32(fa)
			} : ra.prototype._countBits = function(fa) {
				var ga = fa,
					wa = 0;
				return ga >= 4096 && (wa += 13, ga >>>= 13), ga >= 64 && (wa += 7, ga >>>= 7), ga >= 8 && (wa += 4, ga >>>= 4), ga >= 2 && (wa += 2, ga >>>= 2), wa + ga
			}, ra.prototype._zeroBits = function(fa) {
				if (fa === 0) return 26;
				var ga = fa,
					wa = 0;
				return ga & 8191 || (wa += 13, ga >>>= 13), ga & 127 || (wa += 7, ga >>>= 7), ga & 15 || (wa += 4, ga >>>= 4), ga & 3 || (wa += 2, ga >>>= 2), ga & 1 || wa++, wa
			}, ra.prototype.bitLength = function() {
				var fa = this.words[this.length - 1],
					ga = this._countBits(fa);
				return (this.length - 1) * 26 + ga
			};

			function va(ma) {
				for (var fa = new Array(ma.bitLength()), ga = 0; ga < fa.length; ga++) {
					var wa = ga / 26 | 0,
						Ma = ga % 26;
					fa[ga] = ma.words[wa] >>> Ma & 1
				}
				return fa
			}
			ra.prototype.zeroBits = function() {
				if (this.isZero()) return 0;
				for (var fa = 0, ga = 0; ga < this.length; ga++) {
					var wa = this._zeroBits(this.words[ga]);
					if (fa += wa, wa !== 26) break
				}
				return fa
			}, ra.prototype.byteLength = function() {
				return Math.ceil(this.bitLength() / 8)
			}, ra.prototype.toTwos = function(fa) {
				return this.negative !== 0 ? this.abs().inotn(fa).iaddn(1) : this.clone()
			}, ra.prototype.fromTwos = function(fa) {
				return this.testn(fa - 1) ? this.notn(fa).iaddn(1).ineg() : this.clone()
			}, ra.prototype.isNeg = function() {
				return this.negative !== 0
			}, ra.prototype.neg = function() {
				return this.clone().ineg()
			}, ra.prototype.ineg = function() {
				return this.isZero() || (this.negative ^= 1), this
			}, ra.prototype.iuor = function(fa) {
				for (; this.length < fa.length;) this.words[this.length++] = 0;
				for (var ga = 0; ga < fa.length; ga++) this.words[ga] = this.words[ga] | fa.words[ga];
				return this._strip()
			}, ra.prototype.ior = function(fa) {
				return ta((this.negative | fa.negative) === 0), this.iuor(fa)
			}, ra.prototype.or = function(fa) {
				return this.length > fa.length ? this.clone().ior(fa) : fa.clone().ior(this)
			}, ra.prototype.uor = function(fa) {
				return this.length > fa.length ? this.clone().iuor(fa) : fa.clone().iuor(this)
			}, ra.prototype.iuand = function(fa) {
				var ga;
				this.length > fa.length ? ga = fa : ga = this;
				for (var wa = 0; wa < ga.length; wa++) this.words[wa] = this.words[wa] & fa.words[wa];
				return this.length = ga.length, this._strip()
			}, ra.prototype.iand = function(fa) {
				return ta((this.negative | fa.negative) === 0), this.iuand(fa)
			}, ra.prototype.and = function(fa) {
				return this.length > fa.length ? this.clone().iand(fa) : fa.clone().iand(this)
			}, ra.prototype.uand = function(fa) {
				return this.length > fa.length ? this.clone().iuand(fa) : fa.clone().iuand(this)
			}, ra.prototype.iuxor = function(fa) {
				var ga, wa;
				this.length > fa.length ? (ga = this, wa = fa) : (ga = fa, wa = this);
				for (var Ma = 0; Ma < wa.length; Ma++) this.words[Ma] = ga.words[Ma] ^ wa.words[Ma];
				if (this !== ga)
					for (; Ma < ga.length; Ma++) this.words[Ma] = ga.words[Ma];
				return this.length = ga.length, this._strip()
			}, ra.prototype.ixor = function(fa) {
				return ta((this.negative | fa.negative) === 0), this.iuxor(fa)
			}, ra.prototype.xor = function(fa) {
				return this.length > fa.length ? this.clone().ixor(fa) : fa.clone().ixor(this)
			}, ra.prototype.uxor = function(fa) {
				return this.length > fa.length ? this.clone().iuxor(fa) : fa.clone().iuxor(this)
			}, ra.prototype.inotn = function(fa) {
				ta(typeof fa == "number" && fa >= 0);
				var ga = Math.ceil(fa / 26) | 0,
					wa = fa % 26;
				this._expand(ga), wa > 0 && ga--;
				for (var Ma = 0; Ma < ga; Ma++) this.words[Ma] = ~this.words[Ma] & 67108863;
				return wa > 0 && (this.words[Ma] = ~this.words[Ma] & 67108863 >> 26 - wa), this._strip()
			}, ra.prototype.notn = function(fa) {
				return this.clone().inotn(fa)
			}, ra.prototype.setn = function(fa, ga) {
				ta(typeof fa == "number" && fa >= 0);
				var wa = fa / 26 | 0,
					Ma = fa % 26;
				return this._expand(wa + 1), ga ? this.words[wa] = this.words[wa] | 1 << Ma : this.words[wa] = this.words[wa] & ~(1 << Ma), this._strip()
			}, ra.prototype.iadd = function(fa) {
				var ga;
				if (this.negative !== 0 && fa.negative === 0) return this.negative = 0, ga = this.isub(fa), this.negative ^= 1, this._normSign();
				if (this.negative === 0 && fa.negative !== 0) return fa.negative = 0, ga = this.isub(fa), fa.negative = 1, ga._normSign();
				var wa, Ma;
				this.length > fa.length ? (wa = this, Ma = fa) : (wa = fa, Ma = this);
				for (var Aa = 0, Ra = 0; Ra < Ma.length; Ra++) ga = (wa.words[Ra] | 0) + (Ma.words[Ra] | 0) + Aa, this.words[Ra] = ga & 67108863, Aa = ga >>> 26;
				for (; Aa !== 0 && Ra < wa.length; Ra++) ga = (wa.words[Ra] | 0) + Aa, this.words[Ra] = ga & 67108863, Aa = ga >>> 26;
				if (this.length = wa.length, Aa !== 0) this.words[this.length] = Aa, this.length++;
				else if (wa !== this)
					for (; Ra < wa.length; Ra++) this.words[Ra] = wa.words[Ra];
				return this
			}, ra.prototype.add = function(fa) {
				var ga;
				return fa.negative !== 0 && this.negative === 0 ? (fa.negative = 0, ga = this.sub(fa), fa.negative ^= 1, ga) : fa.negative === 0 && this.negative !== 0 ? (this.negative = 0, ga = fa.sub(this), this.negative = 1, ga) : this.length > fa.length ? this.clone().iadd(fa) : fa.clone().iadd(this)
			}, ra.prototype.isub = function(fa) {
				if (fa.negative !== 0) {
					fa.negative = 0;
					var ga = this.iadd(fa);
					return fa.negative = 1, ga._normSign()
				} else if (this.negative !== 0) return this.negative = 0, this.iadd(fa), this.negative = 1, this._normSign();
				var wa = this.cmp(fa);
				if (wa === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
				var Ma, Aa;
				wa > 0 ? (Ma = this, Aa = fa) : (Ma = fa, Aa = this);
				for (var Ra = 0, Ta = 0; Ta < Aa.length; Ta++) ga = (Ma.words[Ta] | 0) - (Aa.words[Ta] | 0) + Ra, Ra = ga >> 26, this.words[Ta] = ga & 67108863;
				for (; Ra !== 0 && Ta < Ma.length; Ta++) ga = (Ma.words[Ta] | 0) + Ra, Ra = ga >> 26, this.words[Ta] = ga & 67108863;
				if (Ra === 0 && Ta < Ma.length && Ma !== this)
					for (; Ta < Ma.length; Ta++) this.words[Ta] = Ma.words[Ta];
				return this.length = Math.max(this.length, Ta), Ma !== this && (this.negative = 1), this._strip()
			}, ra.prototype.sub = function(fa) {
				return this.clone().isub(fa)
			};

			function ba(ma, fa, ga) {
				ga.negative = fa.negative ^ ma.negative;
				var wa = ma.length + fa.length | 0;
				ga.length = wa, wa = wa - 1 | 0;
				var Ma = ma.words[0] | 0,
					Aa = fa.words[0] | 0,
					Ra = Ma * Aa,
					Ta = Ra & 67108863,
					La = Ra / 67108864 | 0;
				ga.words[0] = Ta;
				for (var ya = 1; ya < wa; ya++) {
					for (var Ba = La >>> 26, io = La & 67108863, oo = Math.min(ya, fa.length - 1), ao = Math.max(0, ya - ma.length + 1); ao <= oo; ao++) {
						var Ia = ya - ao | 0;
						Ma = ma.words[Ia] | 0, Aa = fa.words[ao] | 0, Ra = Ma * Aa + io, Ba += Ra / 67108864 | 0, io = Ra & 67108863
					}
					ga.words[ya] = io | 0, La = Ba | 0
				}
				return La !== 0 ? ga.words[ya] = La | 0 : ga.length--, ga._strip()
			}
			var Ea = function(fa, ga, wa) {
				var Ma = fa.words,
					Aa = ga.words,
					Ra = wa.words,
					Ta = 0,
					La, ya, Ba, io = Ma[0] | 0,
					oo = io & 8191,
					ao = io >>> 13,
					Ia = Ma[1] | 0,
					Na = Ia & 8191,
					za = Ia >>> 13,
					ro = Ma[2] | 0,
					Va = ro & 8191,
					Wa = ro >>> 13,
					qa = Ma[3] | 0,
					Ka = qa & 8191,
					lo = qa >>> 13,
					yo = Ma[4] | 0,
					fo = yo & 8191,
					vo = yo >>> 13,
					so = Ma[5] | 0,
					Xa = so & 8191,
					to = so >>> 13,
					ho = Ma[6] | 0,
					Eo = ho & 8191,
					wo = ho >>> 13,
					Ao = Ma[7] | 0,
					_o = Ao & 8191,
					Lo = Ao >>> 13,
					Fo = Ma[8] | 0,
					jo = Fo & 8191,
					eo = Fo >>> 13,
					Oa = Ma[9] | 0,
					Da = Oa & 8191,
					Qa = Oa >>> 13,
					uo = Aa[0] | 0,
					bo = uo & 8191,
					So = uo >>> 13,
					Wo = Aa[1] | 0,
					Po = Wo & 8191,
					Ro = Wo >>> 13,
					Ho = Aa[2] | 0,
					Oo = Ho & 8191,
					No = Ho >>> 13,
					ps = Aa[3] | 0,
					Ko = ps & 8191,
					Go = ps >>> 13,
					bs = Aa[4] | 0,
					vs = bs & 8191,
					ls = bs >>> 13,
					Es = Aa[5] | 0,
					ws = Es & 8191,
					as = Es >>> 13,
					go = Aa[6] | 0,
					Ha = go & 8191,
					Fa = go >>> 13,
					Ya = Aa[7] | 0,
					$a = Ya & 8191,
					no = Ya >>> 13,
					Co = Aa[8] | 0,
					co = Co & 8191,
					mo = Co >>> 13,
					xo = Aa[9] | 0,
					ko = xo & 8191,
					$o = xo >>> 13;
				wa.negative = fa.negative ^ ga.negative, wa.length = 19, La = Math.imul(oo, bo), ya = Math.imul(oo, So), ya = ya + Math.imul(ao, bo) | 0, Ba = Math.imul(ao, So);
				var Ss = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Ss >>> 26) | 0, Ss &= 67108863, La = Math.imul(Na, bo), ya = Math.imul(Na, So), ya = ya + Math.imul(za, bo) | 0, Ba = Math.imul(za, So), La = La + Math.imul(oo, Po) | 0, ya = ya + Math.imul(oo, Ro) | 0, ya = ya + Math.imul(ao, Po) | 0, Ba = Ba + Math.imul(ao, Ro) | 0;
				var Xo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Xo >>> 26) | 0, Xo &= 67108863, La = Math.imul(Va, bo), ya = Math.imul(Va, So), ya = ya + Math.imul(Wa, bo) | 0, Ba = Math.imul(Wa, So), La = La + Math.imul(Na, Po) | 0, ya = ya + Math.imul(Na, Ro) | 0, ya = ya + Math.imul(za, Po) | 0, Ba = Ba + Math.imul(za, Ro) | 0, La = La + Math.imul(oo, Oo) | 0, ya = ya + Math.imul(oo, No) | 0, ya = ya + Math.imul(ao, Oo) | 0, Ba = Ba + Math.imul(ao, No) | 0;
				var ms = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (ms >>> 26) | 0, ms &= 67108863, La = Math.imul(Ka, bo), ya = Math.imul(Ka, So), ya = ya + Math.imul(lo, bo) | 0, Ba = Math.imul(lo, So), La = La + Math.imul(Va, Po) | 0, ya = ya + Math.imul(Va, Ro) | 0, ya = ya + Math.imul(Wa, Po) | 0, Ba = Ba + Math.imul(Wa, Ro) | 0, La = La + Math.imul(Na, Oo) | 0, ya = ya + Math.imul(Na, No) | 0, ya = ya + Math.imul(za, Oo) | 0, Ba = Ba + Math.imul(za, No) | 0, La = La + Math.imul(oo, Ko) | 0, ya = ya + Math.imul(oo, Go) | 0, ya = ya + Math.imul(ao, Ko) | 0, Ba = Ba + Math.imul(ao, Go) | 0;
				var gs = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (gs >>> 26) | 0, gs &= 67108863, La = Math.imul(fo, bo), ya = Math.imul(fo, So), ya = ya + Math.imul(vo, bo) | 0, Ba = Math.imul(vo, So), La = La + Math.imul(Ka, Po) | 0, ya = ya + Math.imul(Ka, Ro) | 0, ya = ya + Math.imul(lo, Po) | 0, Ba = Ba + Math.imul(lo, Ro) | 0, La = La + Math.imul(Va, Oo) | 0, ya = ya + Math.imul(Va, No) | 0, ya = ya + Math.imul(Wa, Oo) | 0, Ba = Ba + Math.imul(Wa, No) | 0, La = La + Math.imul(Na, Ko) | 0, ya = ya + Math.imul(Na, Go) | 0, ya = ya + Math.imul(za, Ko) | 0, Ba = Ba + Math.imul(za, Go) | 0, La = La + Math.imul(oo, vs) | 0, ya = ya + Math.imul(oo, ls) | 0, ya = ya + Math.imul(ao, vs) | 0, Ba = Ba + Math.imul(ao, ls) | 0;
				var ys = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (ys >>> 26) | 0, ys &= 67108863, La = Math.imul(Xa, bo), ya = Math.imul(Xa, So), ya = ya + Math.imul(to, bo) | 0, Ba = Math.imul(to, So), La = La + Math.imul(fo, Po) | 0, ya = ya + Math.imul(fo, Ro) | 0, ya = ya + Math.imul(vo, Po) | 0, Ba = Ba + Math.imul(vo, Ro) | 0, La = La + Math.imul(Ka, Oo) | 0, ya = ya + Math.imul(Ka, No) | 0, ya = ya + Math.imul(lo, Oo) | 0, Ba = Ba + Math.imul(lo, No) | 0, La = La + Math.imul(Va, Ko) | 0, ya = ya + Math.imul(Va, Go) | 0, ya = ya + Math.imul(Wa, Ko) | 0, Ba = Ba + Math.imul(Wa, Go) | 0, La = La + Math.imul(Na, vs) | 0, ya = ya + Math.imul(Na, ls) | 0, ya = ya + Math.imul(za, vs) | 0, Ba = Ba + Math.imul(za, ls) | 0, La = La + Math.imul(oo, ws) | 0, ya = ya + Math.imul(oo, as) | 0, ya = ya + Math.imul(ao, ws) | 0, Ba = Ba + Math.imul(ao, as) | 0;
				var Vo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Vo >>> 26) | 0, Vo &= 67108863, La = Math.imul(Eo, bo), ya = Math.imul(Eo, So), ya = ya + Math.imul(wo, bo) | 0, Ba = Math.imul(wo, So), La = La + Math.imul(Xa, Po) | 0, ya = ya + Math.imul(Xa, Ro) | 0, ya = ya + Math.imul(to, Po) | 0, Ba = Ba + Math.imul(to, Ro) | 0, La = La + Math.imul(fo, Oo) | 0, ya = ya + Math.imul(fo, No) | 0, ya = ya + Math.imul(vo, Oo) | 0, Ba = Ba + Math.imul(vo, No) | 0, La = La + Math.imul(Ka, Ko) | 0, ya = ya + Math.imul(Ka, Go) | 0, ya = ya + Math.imul(lo, Ko) | 0, Ba = Ba + Math.imul(lo, Go) | 0, La = La + Math.imul(Va, vs) | 0, ya = ya + Math.imul(Va, ls) | 0, ya = ya + Math.imul(Wa, vs) | 0, Ba = Ba + Math.imul(Wa, ls) | 0, La = La + Math.imul(Na, ws) | 0, ya = ya + Math.imul(Na, as) | 0, ya = ya + Math.imul(za, ws) | 0, Ba = Ba + Math.imul(za, as) | 0, La = La + Math.imul(oo, Ha) | 0, ya = ya + Math.imul(oo, Fa) | 0, ya = ya + Math.imul(ao, Ha) | 0, Ba = Ba + Math.imul(ao, Fa) | 0;
				var cs = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (cs >>> 26) | 0, cs &= 67108863, La = Math.imul(_o, bo), ya = Math.imul(_o, So), ya = ya + Math.imul(Lo, bo) | 0, Ba = Math.imul(Lo, So), La = La + Math.imul(Eo, Po) | 0, ya = ya + Math.imul(Eo, Ro) | 0, ya = ya + Math.imul(wo, Po) | 0, Ba = Ba + Math.imul(wo, Ro) | 0, La = La + Math.imul(Xa, Oo) | 0, ya = ya + Math.imul(Xa, No) | 0, ya = ya + Math.imul(to, Oo) | 0, Ba = Ba + Math.imul(to, No) | 0, La = La + Math.imul(fo, Ko) | 0, ya = ya + Math.imul(fo, Go) | 0, ya = ya + Math.imul(vo, Ko) | 0, Ba = Ba + Math.imul(vo, Go) | 0, La = La + Math.imul(Ka, vs) | 0, ya = ya + Math.imul(Ka, ls) | 0, ya = ya + Math.imul(lo, vs) | 0, Ba = Ba + Math.imul(lo, ls) | 0, La = La + Math.imul(Va, ws) | 0, ya = ya + Math.imul(Va, as) | 0, ya = ya + Math.imul(Wa, ws) | 0, Ba = Ba + Math.imul(Wa, as) | 0, La = La + Math.imul(Na, Ha) | 0, ya = ya + Math.imul(Na, Fa) | 0, ya = ya + Math.imul(za, Ha) | 0, Ba = Ba + Math.imul(za, Fa) | 0, La = La + Math.imul(oo, $a) | 0, ya = ya + Math.imul(oo, no) | 0, ya = ya + Math.imul(ao, $a) | 0, Ba = Ba + Math.imul(ao, no) | 0;
				var Zo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Zo >>> 26) | 0, Zo &= 67108863, La = Math.imul(jo, bo), ya = Math.imul(jo, So), ya = ya + Math.imul(eo, bo) | 0, Ba = Math.imul(eo, So), La = La + Math.imul(_o, Po) | 0, ya = ya + Math.imul(_o, Ro) | 0, ya = ya + Math.imul(Lo, Po) | 0, Ba = Ba + Math.imul(Lo, Ro) | 0, La = La + Math.imul(Eo, Oo) | 0, ya = ya + Math.imul(Eo, No) | 0, ya = ya + Math.imul(wo, Oo) | 0, Ba = Ba + Math.imul(wo, No) | 0, La = La + Math.imul(Xa, Ko) | 0, ya = ya + Math.imul(Xa, Go) | 0, ya = ya + Math.imul(to, Ko) | 0, Ba = Ba + Math.imul(to, Go) | 0, La = La + Math.imul(fo, vs) | 0, ya = ya + Math.imul(fo, ls) | 0, ya = ya + Math.imul(vo, vs) | 0, Ba = Ba + Math.imul(vo, ls) | 0, La = La + Math.imul(Ka, ws) | 0, ya = ya + Math.imul(Ka, as) | 0, ya = ya + Math.imul(lo, ws) | 0, Ba = Ba + Math.imul(lo, as) | 0, La = La + Math.imul(Va, Ha) | 0, ya = ya + Math.imul(Va, Fa) | 0, ya = ya + Math.imul(Wa, Ha) | 0, Ba = Ba + Math.imul(Wa, Fa) | 0, La = La + Math.imul(Na, $a) | 0, ya = ya + Math.imul(Na, no) | 0, ya = ya + Math.imul(za, $a) | 0, Ba = Ba + Math.imul(za, no) | 0, La = La + Math.imul(oo, co) | 0, ya = ya + Math.imul(oo, mo) | 0, ya = ya + Math.imul(ao, co) | 0, Ba = Ba + Math.imul(ao, mo) | 0;
				var us = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (us >>> 26) | 0, us &= 67108863, La = Math.imul(Da, bo), ya = Math.imul(Da, So), ya = ya + Math.imul(Qa, bo) | 0, Ba = Math.imul(Qa, So), La = La + Math.imul(jo, Po) | 0, ya = ya + Math.imul(jo, Ro) | 0, ya = ya + Math.imul(eo, Po) | 0, Ba = Ba + Math.imul(eo, Ro) | 0, La = La + Math.imul(_o, Oo) | 0, ya = ya + Math.imul(_o, No) | 0, ya = ya + Math.imul(Lo, Oo) | 0, Ba = Ba + Math.imul(Lo, No) | 0, La = La + Math.imul(Eo, Ko) | 0, ya = ya + Math.imul(Eo, Go) | 0, ya = ya + Math.imul(wo, Ko) | 0, Ba = Ba + Math.imul(wo, Go) | 0, La = La + Math.imul(Xa, vs) | 0, ya = ya + Math.imul(Xa, ls) | 0, ya = ya + Math.imul(to, vs) | 0, Ba = Ba + Math.imul(to, ls) | 0, La = La + Math.imul(fo, ws) | 0, ya = ya + Math.imul(fo, as) | 0, ya = ya + Math.imul(vo, ws) | 0, Ba = Ba + Math.imul(vo, as) | 0, La = La + Math.imul(Ka, Ha) | 0, ya = ya + Math.imul(Ka, Fa) | 0, ya = ya + Math.imul(lo, Ha) | 0, Ba = Ba + Math.imul(lo, Fa) | 0, La = La + Math.imul(Va, $a) | 0, ya = ya + Math.imul(Va, no) | 0, ya = ya + Math.imul(Wa, $a) | 0, Ba = Ba + Math.imul(Wa, no) | 0, La = La + Math.imul(Na, co) | 0, ya = ya + Math.imul(Na, mo) | 0, ya = ya + Math.imul(za, co) | 0, Ba = Ba + Math.imul(za, mo) | 0, La = La + Math.imul(oo, ko) | 0, ya = ya + Math.imul(oo, $o) | 0, ya = ya + Math.imul(ao, ko) | 0, Ba = Ba + Math.imul(ao, $o) | 0;
				var Jo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Jo >>> 26) | 0, Jo &= 67108863, La = Math.imul(Da, Po), ya = Math.imul(Da, Ro), ya = ya + Math.imul(Qa, Po) | 0, Ba = Math.imul(Qa, Ro), La = La + Math.imul(jo, Oo) | 0, ya = ya + Math.imul(jo, No) | 0, ya = ya + Math.imul(eo, Oo) | 0, Ba = Ba + Math.imul(eo, No) | 0, La = La + Math.imul(_o, Ko) | 0, ya = ya + Math.imul(_o, Go) | 0, ya = ya + Math.imul(Lo, Ko) | 0, Ba = Ba + Math.imul(Lo, Go) | 0, La = La + Math.imul(Eo, vs) | 0, ya = ya + Math.imul(Eo, ls) | 0, ya = ya + Math.imul(wo, vs) | 0, Ba = Ba + Math.imul(wo, ls) | 0, La = La + Math.imul(Xa, ws) | 0, ya = ya + Math.imul(Xa, as) | 0, ya = ya + Math.imul(to, ws) | 0, Ba = Ba + Math.imul(to, as) | 0, La = La + Math.imul(fo, Ha) | 0, ya = ya + Math.imul(fo, Fa) | 0, ya = ya + Math.imul(vo, Ha) | 0, Ba = Ba + Math.imul(vo, Fa) | 0, La = La + Math.imul(Ka, $a) | 0, ya = ya + Math.imul(Ka, no) | 0, ya = ya + Math.imul(lo, $a) | 0, Ba = Ba + Math.imul(lo, no) | 0, La = La + Math.imul(Va, co) | 0, ya = ya + Math.imul(Va, mo) | 0, ya = ya + Math.imul(Wa, co) | 0, Ba = Ba + Math.imul(Wa, mo) | 0, La = La + Math.imul(Na, ko) | 0, ya = ya + Math.imul(Na, $o) | 0, ya = ya + Math.imul(za, ko) | 0, Ba = Ba + Math.imul(za, $o) | 0;
				var hs = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (hs >>> 26) | 0, hs &= 67108863, La = Math.imul(Da, Oo), ya = Math.imul(Da, No), ya = ya + Math.imul(Qa, Oo) | 0, Ba = Math.imul(Qa, No), La = La + Math.imul(jo, Ko) | 0, ya = ya + Math.imul(jo, Go) | 0, ya = ya + Math.imul(eo, Ko) | 0, Ba = Ba + Math.imul(eo, Go) | 0, La = La + Math.imul(_o, vs) | 0, ya = ya + Math.imul(_o, ls) | 0, ya = ya + Math.imul(Lo, vs) | 0, Ba = Ba + Math.imul(Lo, ls) | 0, La = La + Math.imul(Eo, ws) | 0, ya = ya + Math.imul(Eo, as) | 0, ya = ya + Math.imul(wo, ws) | 0, Ba = Ba + Math.imul(wo, as) | 0, La = La + Math.imul(Xa, Ha) | 0, ya = ya + Math.imul(Xa, Fa) | 0, ya = ya + Math.imul(to, Ha) | 0, Ba = Ba + Math.imul(to, Fa) | 0, La = La + Math.imul(fo, $a) | 0, ya = ya + Math.imul(fo, no) | 0, ya = ya + Math.imul(vo, $a) | 0, Ba = Ba + Math.imul(vo, no) | 0, La = La + Math.imul(Ka, co) | 0, ya = ya + Math.imul(Ka, mo) | 0, ya = ya + Math.imul(lo, co) | 0, Ba = Ba + Math.imul(lo, mo) | 0, La = La + Math.imul(Va, ko) | 0, ya = ya + Math.imul(Va, $o) | 0, ya = ya + Math.imul(Wa, ko) | 0, Ba = Ba + Math.imul(Wa, $o) | 0;
				var Qo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Qo >>> 26) | 0, Qo &= 67108863, La = Math.imul(Da, Ko), ya = Math.imul(Da, Go), ya = ya + Math.imul(Qa, Ko) | 0, Ba = Math.imul(Qa, Go), La = La + Math.imul(jo, vs) | 0, ya = ya + Math.imul(jo, ls) | 0, ya = ya + Math.imul(eo, vs) | 0, Ba = Ba + Math.imul(eo, ls) | 0, La = La + Math.imul(_o, ws) | 0, ya = ya + Math.imul(_o, as) | 0, ya = ya + Math.imul(Lo, ws) | 0, Ba = Ba + Math.imul(Lo, as) | 0, La = La + Math.imul(Eo, Ha) | 0, ya = ya + Math.imul(Eo, Fa) | 0, ya = ya + Math.imul(wo, Ha) | 0, Ba = Ba + Math.imul(wo, Fa) | 0, La = La + Math.imul(Xa, $a) | 0, ya = ya + Math.imul(Xa, no) | 0, ya = ya + Math.imul(to, $a) | 0, Ba = Ba + Math.imul(to, no) | 0, La = La + Math.imul(fo, co) | 0, ya = ya + Math.imul(fo, mo) | 0, ya = ya + Math.imul(vo, co) | 0, Ba = Ba + Math.imul(vo, mo) | 0, La = La + Math.imul(Ka, ko) | 0, ya = ya + Math.imul(Ka, $o) | 0, ya = ya + Math.imul(lo, ko) | 0, Ba = Ba + Math.imul(lo, $o) | 0;
				var fs = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (fs >>> 26) | 0, fs &= 67108863, La = Math.imul(Da, vs), ya = Math.imul(Da, ls), ya = ya + Math.imul(Qa, vs) | 0, Ba = Math.imul(Qa, ls), La = La + Math.imul(jo, ws) | 0, ya = ya + Math.imul(jo, as) | 0, ya = ya + Math.imul(eo, ws) | 0, Ba = Ba + Math.imul(eo, as) | 0, La = La + Math.imul(_o, Ha) | 0, ya = ya + Math.imul(_o, Fa) | 0, ya = ya + Math.imul(Lo, Ha) | 0, Ba = Ba + Math.imul(Lo, Fa) | 0, La = La + Math.imul(Eo, $a) | 0, ya = ya + Math.imul(Eo, no) | 0, ya = ya + Math.imul(wo, $a) | 0, Ba = Ba + Math.imul(wo, no) | 0, La = La + Math.imul(Xa, co) | 0, ya = ya + Math.imul(Xa, mo) | 0, ya = ya + Math.imul(to, co) | 0, Ba = Ba + Math.imul(to, mo) | 0, La = La + Math.imul(fo, ko) | 0, ya = ya + Math.imul(fo, $o) | 0, ya = ya + Math.imul(vo, ko) | 0, Ba = Ba + Math.imul(vo, $o) | 0;
				var ds = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (ds >>> 26) | 0, ds &= 67108863, La = Math.imul(Da, ws), ya = Math.imul(Da, as), ya = ya + Math.imul(Qa, ws) | 0, Ba = Math.imul(Qa, as), La = La + Math.imul(jo, Ha) | 0, ya = ya + Math.imul(jo, Fa) | 0, ya = ya + Math.imul(eo, Ha) | 0, Ba = Ba + Math.imul(eo, Fa) | 0, La = La + Math.imul(_o, $a) | 0, ya = ya + Math.imul(_o, no) | 0, ya = ya + Math.imul(Lo, $a) | 0, Ba = Ba + Math.imul(Lo, no) | 0, La = La + Math.imul(Eo, co) | 0, ya = ya + Math.imul(Eo, mo) | 0, ya = ya + Math.imul(wo, co) | 0, Ba = Ba + Math.imul(wo, mo) | 0, La = La + Math.imul(Xa, ko) | 0, ya = ya + Math.imul(Xa, $o) | 0, ya = ya + Math.imul(to, ko) | 0, Ba = Ba + Math.imul(to, $o) | 0;
				var Yo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Yo >>> 26) | 0, Yo &= 67108863, La = Math.imul(Da, Ha), ya = Math.imul(Da, Fa), ya = ya + Math.imul(Qa, Ha) | 0, Ba = Math.imul(Qa, Fa), La = La + Math.imul(jo, $a) | 0, ya = ya + Math.imul(jo, no) | 0, ya = ya + Math.imul(eo, $a) | 0, Ba = Ba + Math.imul(eo, no) | 0, La = La + Math.imul(_o, co) | 0, ya = ya + Math.imul(_o, mo) | 0, ya = ya + Math.imul(Lo, co) | 0, Ba = Ba + Math.imul(Lo, mo) | 0, La = La + Math.imul(Eo, ko) | 0, ya = ya + Math.imul(Eo, $o) | 0, ya = ya + Math.imul(wo, ko) | 0, Ba = Ba + Math.imul(wo, $o) | 0;
				var Bo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Bo >>> 26) | 0, Bo &= 67108863, La = Math.imul(Da, $a), ya = Math.imul(Da, no), ya = ya + Math.imul(Qa, $a) | 0, Ba = Math.imul(Qa, no), La = La + Math.imul(jo, co) | 0, ya = ya + Math.imul(jo, mo) | 0, ya = ya + Math.imul(eo, co) | 0, Ba = Ba + Math.imul(eo, mo) | 0, La = La + Math.imul(_o, ko) | 0, ya = ya + Math.imul(_o, $o) | 0, ya = ya + Math.imul(Lo, ko) | 0, Ba = Ba + Math.imul(Lo, $o) | 0;
				var Mo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Mo >>> 26) | 0, Mo &= 67108863, La = Math.imul(Da, co), ya = Math.imul(Da, mo), ya = ya + Math.imul(Qa, co) | 0, Ba = Math.imul(Qa, mo), La = La + Math.imul(jo, ko) | 0, ya = ya + Math.imul(jo, $o) | 0, ya = ya + Math.imul(eo, ko) | 0, Ba = Ba + Math.imul(eo, $o) | 0;
				var Uo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Uo >>> 26) | 0, Uo &= 67108863, La = Math.imul(Da, ko), ya = Math.imul(Da, $o), ya = ya + Math.imul(Qa, ko) | 0, Ba = Math.imul(Qa, $o);
				var Do = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				return Ta = (Ba + (ya >>> 13) | 0) + (Do >>> 26) | 0, Do &= 67108863, Ra[0] = Ss, Ra[1] = Xo, Ra[2] = ms, Ra[3] = gs, Ra[4] = ys, Ra[5] = Vo, Ra[6] = cs, Ra[7] = Zo, Ra[8] = us, Ra[9] = Jo, Ra[10] = hs, Ra[11] = Qo, Ra[12] = fs, Ra[13] = ds, Ra[14] = Yo, Ra[15] = Bo, Ra[16] = Mo, Ra[17] = Uo, Ra[18] = Do, Ta !== 0 && (Ra[19] = Ta, wa.length++), wa
			};
			Math.imul || (Ea = ba);

			function Sa(ma, fa, ga) {
				ga.negative = fa.negative ^ ma.negative, ga.length = ma.length + fa.length;
				for (var wa = 0, Ma = 0, Aa = 0; Aa < ga.length - 1; Aa++) {
					var Ra = Ma;
					Ma = 0;
					for (var Ta = wa & 67108863, La = Math.min(Aa, fa.length - 1), ya = Math.max(0, Aa - ma.length + 1); ya <= La; ya++) {
						var Ba = Aa - ya,
							io = ma.words[Ba] | 0,
							oo = fa.words[ya] | 0,
							ao = io * oo,
							Ia = ao & 67108863;
						Ra = Ra + (ao / 67108864 | 0) | 0, Ia = Ia + Ta | 0, Ta = Ia & 67108863, Ra = Ra + (Ia >>> 26) | 0, Ma += Ra >>> 26, Ra &= 67108863
					}
					ga.words[Aa] = Ta, wa = Ra, Ra = Ma
				}
				return wa !== 0 ? ga.words[Aa] = wa : ga.length--, ga._strip()
			}

			function Ca(ma, fa, ga) {
				return Sa(ma, fa, ga)
			}
			ra.prototype.mulTo = function(fa, ga) {
				var wa, Ma = this.length + fa.length;
				return this.length === 10 && fa.length === 10 ? wa = Ea(this, fa, ga) : Ma < 63 ? wa = ba(this, fa, ga) : Ma < 1024 ? wa = Sa(this, fa, ga) : wa = Ca(this, fa, ga), wa
			}, ra.prototype.mul = function(fa) {
				var ga = new ra(null);
				return ga.words = new Array(this.length + fa.length), this.mulTo(fa, ga)
			}, ra.prototype.mulf = function(fa) {
				var ga = new ra(null);
				return ga.words = new Array(this.length + fa.length), Ca(this, fa, ga)
			}, ra.prototype.imul = function(fa) {
				return this.clone().mulTo(fa, this)
			}, ra.prototype.imuln = function(fa) {
				var ga = fa < 0;
				ga && (fa = -fa), ta(typeof fa == "number"), ta(fa < 67108864);
				for (var wa = 0, Ma = 0; Ma < this.length; Ma++) {
					var Aa = (this.words[Ma] | 0) * fa,
						Ra = (Aa & 67108863) + (wa & 67108863);
					wa >>= 26, wa += Aa / 67108864 | 0, wa += Ra >>> 26, this.words[Ma] = Ra & 67108863
				}
				return wa !== 0 && (this.words[Ma] = wa, this.length++), ga ? this.ineg() : this
			}, ra.prototype.muln = function(fa) {
				return this.clone().imuln(fa)
			}, ra.prototype.sqr = function() {
				return this.mul(this)
			}, ra.prototype.isqr = function() {
				return this.imul(this.clone())
			}, ra.prototype.pow = function(fa) {
				var ga = va(fa);
				if (ga.length === 0) return new ra(1);
				for (var wa = this, Ma = 0; Ma < ga.length && ga[Ma] === 0; Ma++, wa = wa.sqr());
				if (++Ma < ga.length)
					for (var Aa = wa.sqr(); Ma < ga.length; Ma++, Aa = Aa.sqr()) ga[Ma] !== 0 && (wa = wa.mul(Aa));
				return wa
			}, ra.prototype.iushln = function(fa) {
				ta(typeof fa == "number" && fa >= 0);
				var ga = fa % 26,
					wa = (fa - ga) / 26,
					Ma = 67108863 >>> 26 - ga << 26 - ga,
					Aa;
				if (ga !== 0) {
					var Ra = 0;
					for (Aa = 0; Aa < this.length; Aa++) {
						var Ta = this.words[Aa] & Ma,
							La = (this.words[Aa] | 0) - Ta << ga;
						this.words[Aa] = La | Ra, Ra = Ta >>> 26 - ga
					}
					Ra && (this.words[Aa] = Ra, this.length++)
				}
				if (wa !== 0) {
					for (Aa = this.length - 1; Aa >= 0; Aa--) this.words[Aa + wa] = this.words[Aa];
					for (Aa = 0; Aa < wa; Aa++) this.words[Aa] = 0;
					this.length += wa
				}
				return this._strip()
			}, ra.prototype.ishln = function(fa) {
				return ta(this.negative === 0), this.iushln(fa)
			}, ra.prototype.iushrn = function(fa, ga, wa) {
				ta(typeof fa == "number" && fa >= 0);
				var Ma;
				ga ? Ma = (ga - ga % 26) / 26 : Ma = 0;
				var Aa = fa % 26,
					Ra = Math.min((fa - Aa) / 26, this.length),
					Ta = 67108863 ^ 67108863 >>> Aa << Aa,
					La = wa;
				if (Ma -= Ra, Ma = Math.max(0, Ma), La) {
					for (var ya = 0; ya < Ra; ya++) La.words[ya] = this.words[ya];
					La.length = Ra
				}
				if (Ra !== 0)
					if (this.length > Ra)
						for (this.length -= Ra, ya = 0; ya < this.length; ya++) this.words[ya] = this.words[ya + Ra];
					else this.words[0] = 0, this.length = 1;
				var Ba = 0;
				for (ya = this.length - 1; ya >= 0 && (Ba !== 0 || ya >= Ma); ya--) {
					var io = this.words[ya] | 0;
					this.words[ya] = Ba << 26 - Aa | io >>> Aa, Ba = io & Ta
				}
				return La && Ba !== 0 && (La.words[La.length++] = Ba), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip()
			}, ra.prototype.ishrn = function(fa, ga, wa) {
				return ta(this.negative === 0), this.iushrn(fa, ga, wa)
			}, ra.prototype.shln = function(fa) {
				return this.clone().ishln(fa)
			}, ra.prototype.ushln = function(fa) {
				return this.clone().iushln(fa)
			}, ra.prototype.shrn = function(fa) {
				return this.clone().ishrn(fa)
			}, ra.prototype.ushrn = function(fa) {
				return this.clone().iushrn(fa)
			}, ra.prototype.testn = function(fa) {
				ta(typeof fa == "number" && fa >= 0);
				var ga = fa % 26,
					wa = (fa - ga) / 26,
					Ma = 1 << ga;
				if (this.length <= wa) return !1;
				var Aa = this.words[wa];
				return !!(Aa & Ma)
			}, ra.prototype.imaskn = function(fa) {
				ta(typeof fa == "number" && fa >= 0);
				var ga = fa % 26,
					wa = (fa - ga) / 26;
				if (ta(this.negative === 0, "imaskn works only with positive numbers"), this.length <= wa) return this;
				if (ga !== 0 && wa++, this.length = Math.min(wa, this.length), ga !== 0) {
					var Ma = 67108863 ^ 67108863 >>> ga << ga;
					this.words[this.length - 1] &= Ma
				}
				return this._strip()
			}, ra.prototype.maskn = function(fa) {
				return this.clone().imaskn(fa)
			}, ra.prototype.iaddn = function(fa) {
				return ta(typeof fa == "number"), ta(fa < 67108864), fa < 0 ? this.isubn(-fa) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= fa ? (this.words[0] = fa - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(fa), this.negative = 1, this) : this._iaddn(fa)
			}, ra.prototype._iaddn = function(fa) {
				this.words[0] += fa;
				for (var ga = 0; ga < this.length && this.words[ga] >= 67108864; ga++) this.words[ga] -= 67108864, ga === this.length - 1 ? this.words[ga + 1] = 1 : this.words[ga + 1]++;
				return this.length = Math.max(this.length, ga + 1), this
			}, ra.prototype.isubn = function(fa) {
				if (ta(typeof fa == "number"), ta(fa < 67108864), fa < 0) return this.iaddn(-fa);
				if (this.negative !== 0) return this.negative = 0, this.iaddn(fa), this.negative = 1, this;
				if (this.words[0] -= fa, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
				else
					for (var ga = 0; ga < this.length && this.words[ga] < 0; ga++) this.words[ga] += 67108864, this.words[ga + 1] -= 1;
				return this._strip()
			}, ra.prototype.addn = function(fa) {
				return this.clone().iaddn(fa)
			}, ra.prototype.subn = function(fa) {
				return this.clone().isubn(fa)
			}, ra.prototype.iabs = function() {
				return this.negative = 0, this
			}, ra.prototype.abs = function() {
				return this.clone().iabs()
			}, ra.prototype._ishlnsubmul = function(fa, ga, wa) {
				var Ma = fa.length + wa,
					Aa;
				this._expand(Ma);
				var Ra, Ta = 0;
				for (Aa = 0; Aa < fa.length; Aa++) {
					Ra = (this.words[Aa + wa] | 0) + Ta;
					var La = (fa.words[Aa] | 0) * ga;
					Ra -= La & 67108863, Ta = (Ra >> 26) - (La / 67108864 | 0), this.words[Aa + wa] = Ra & 67108863
				}
				for (; Aa < this.length - wa; Aa++) Ra = (this.words[Aa + wa] | 0) + Ta, Ta = Ra >> 26, this.words[Aa + wa] = Ra & 67108863;
				if (Ta === 0) return this._strip();
				for (ta(Ta === -1), Ta = 0, Aa = 0; Aa < this.length; Aa++) Ra = -(this.words[Aa] | 0) + Ta, Ta = Ra >> 26, this.words[Aa] = Ra & 67108863;
				return this.negative = 1, this._strip()
			}, ra.prototype._wordDiv = function(fa, ga) {
				var wa = this.length - fa.length,
					Ma = this.clone(),
					Aa = fa,
					Ra = Aa.words[Aa.length - 1] | 0,
					Ta = this._countBits(Ra);
				wa = 26 - Ta, wa !== 0 && (Aa = Aa.ushln(wa), Ma.iushln(wa), Ra = Aa.words[Aa.length - 1] | 0);
				var La = Ma.length - Aa.length,
					ya;
				if (ga !== "mod") {
					ya = new ra(null), ya.length = La + 1, ya.words = new Array(ya.length);
					for (var Ba = 0; Ba < ya.length; Ba++) ya.words[Ba] = 0
				}
				var io = Ma.clone()._ishlnsubmul(Aa, 1, La);
				io.negative === 0 && (Ma = io, ya && (ya.words[La] = 1));
				for (var oo = La - 1; oo >= 0; oo--) {
					var ao = (Ma.words[Aa.length + oo] | 0) * 67108864 + (Ma.words[Aa.length + oo - 1] | 0);
					for (ao = Math.min(ao / Ra | 0, 67108863), Ma._ishlnsubmul(Aa, ao, oo); Ma.negative !== 0;) ao--, Ma.negative = 0, Ma._ishlnsubmul(Aa, 1, oo), Ma.isZero() || (Ma.negative ^= 1);
					ya && (ya.words[oo] = ao)
				}
				return ya && ya._strip(), Ma._strip(), ga !== "div" && wa !== 0 && Ma.iushrn(wa), {
					div: ya || null,
					mod: Ma
				}
			}, ra.prototype.divmod = function(fa, ga, wa) {
				if (ta(!fa.isZero()), this.isZero()) return {
					div: new ra(0),
					mod: new ra(0)
				};
				var Ma, Aa, Ra;
				return this.negative !== 0 && fa.negative === 0 ? (Ra = this.neg().divmod(fa, ga), ga !== "mod" && (Ma = Ra.div.neg()), ga !== "div" && (Aa = Ra.mod.neg(), wa && Aa.negative !== 0 && Aa.iadd(fa)), {
					div: Ma,
					mod: Aa
				}) : this.negative === 0 && fa.negative !== 0 ? (Ra = this.divmod(fa.neg(), ga), ga !== "mod" && (Ma = Ra.div.neg()), {
					div: Ma,
					mod: Ra.mod
				}) : this.negative & fa.negative ? (Ra = this.neg().divmod(fa.neg(), ga), ga !== "div" && (Aa = Ra.mod.neg(), wa && Aa.negative !== 0 && Aa.isub(fa)), {
					div: Ra.div,
					mod: Aa
				}) : fa.length > this.length || this.cmp(fa) < 0 ? {
					div: new ra(0),
					mod: this
				} : fa.length === 1 ? ga === "div" ? {
					div: this.divn(fa.words[0]),
					mod: null
				} : ga === "mod" ? {
					div: null,
					mod: new ra(this.modrn(fa.words[0]))
				} : {
					div: this.divn(fa.words[0]),
					mod: new ra(this.modrn(fa.words[0]))
				} : this._wordDiv(fa, ga)
			}, ra.prototype.div = function(fa) {
				return this.divmod(fa, "div", !1).div
			}, ra.prototype.mod = function(fa) {
				return this.divmod(fa, "mod", !1).mod
			}, ra.prototype.umod = function(fa) {
				return this.divmod(fa, "mod", !0).mod
			}, ra.prototype.divRound = function(fa) {
				var ga = this.divmod(fa);
				if (ga.mod.isZero()) return ga.div;
				var wa = ga.div.negative !== 0 ? ga.mod.isub(fa) : ga.mod,
					Ma = fa.ushrn(1),
					Aa = fa.andln(1),
					Ra = wa.cmp(Ma);
				return Ra < 0 || Aa === 1 && Ra === 0 ? ga.div : ga.div.negative !== 0 ? ga.div.isubn(1) : ga.div.iaddn(1)
			}, ra.prototype.modrn = function(fa) {
				var ga = fa < 0;
				ga && (fa = -fa), ta(fa <= 67108863);
				for (var wa = (1 << 26) % fa, Ma = 0, Aa = this.length - 1; Aa >= 0; Aa--) Ma = (wa * Ma + (this.words[Aa] | 0)) % fa;
				return ga ? -Ma : Ma
			}, ra.prototype.modn = function(fa) {
				return this.modrn(fa)
			}, ra.prototype.idivn = function(fa) {
				var ga = fa < 0;
				ga && (fa = -fa), ta(fa <= 67108863);
				for (var wa = 0, Ma = this.length - 1; Ma >= 0; Ma--) {
					var Aa = (this.words[Ma] | 0) + wa * 67108864;
					this.words[Ma] = Aa / fa | 0, wa = Aa % fa
				}
				return this._strip(), ga ? this.ineg() : this
			}, ra.prototype.divn = function(fa) {
				return this.clone().idivn(fa)
			}, ra.prototype.egcd = function(fa) {
				ta(fa.negative === 0), ta(!fa.isZero());
				var ga = this,
					wa = fa.clone();
				ga.negative !== 0 ? ga = ga.umod(fa) : ga = ga.clone();
				for (var Ma = new ra(1), Aa = new ra(0), Ra = new ra(0), Ta = new ra(1), La = 0; ga.isEven() && wa.isEven();) ga.iushrn(1), wa.iushrn(1), ++La;
				for (var ya = wa.clone(), Ba = ga.clone(); !ga.isZero();) {
					for (var io = 0, oo = 1; !(ga.words[0] & oo) && io < 26; ++io, oo <<= 1);
					if (io > 0)
						for (ga.iushrn(io); io-- > 0;)(Ma.isOdd() || Aa.isOdd()) && (Ma.iadd(ya), Aa.isub(Ba)), Ma.iushrn(1), Aa.iushrn(1);
					for (var ao = 0, Ia = 1; !(wa.words[0] & Ia) && ao < 26; ++ao, Ia <<= 1);
					if (ao > 0)
						for (wa.iushrn(ao); ao-- > 0;)(Ra.isOdd() || Ta.isOdd()) && (Ra.iadd(ya), Ta.isub(Ba)), Ra.iushrn(1), Ta.iushrn(1);
					ga.cmp(wa) >= 0 ? (ga.isub(wa), Ma.isub(Ra), Aa.isub(Ta)) : (wa.isub(ga), Ra.isub(Ma), Ta.isub(Aa))
				}
				return {
					a: Ra,
					b: Ta,
					gcd: wa.iushln(La)
				}
			}, ra.prototype._invmp = function(fa) {
				ta(fa.negative === 0), ta(!fa.isZero());
				var ga = this,
					wa = fa.clone();
				ga.negative !== 0 ? ga = ga.umod(fa) : ga = ga.clone();
				for (var Ma = new ra(1), Aa = new ra(0), Ra = wa.clone(); ga.cmpn(1) > 0 && wa.cmpn(1) > 0;) {
					for (var Ta = 0, La = 1; !(ga.words[0] & La) && Ta < 26; ++Ta, La <<= 1);
					if (Ta > 0)
						for (ga.iushrn(Ta); Ta-- > 0;) Ma.isOdd() && Ma.iadd(Ra), Ma.iushrn(1);
					for (var ya = 0, Ba = 1; !(wa.words[0] & Ba) && ya < 26; ++ya, Ba <<= 1);
					if (ya > 0)
						for (wa.iushrn(ya); ya-- > 0;) Aa.isOdd() && Aa.iadd(Ra), Aa.iushrn(1);
					ga.cmp(wa) >= 0 ? (ga.isub(wa), Ma.isub(Aa)) : (wa.isub(ga), Aa.isub(Ma))
				}
				var io;
				return ga.cmpn(1) === 0 ? io = Ma : io = Aa, io.cmpn(0) < 0 && io.iadd(fa), io
			}, ra.prototype.gcd = function(fa) {
				if (this.isZero()) return fa.abs();
				if (fa.isZero()) return this.abs();
				var ga = this.clone(),
					wa = fa.clone();
				ga.negative = 0, wa.negative = 0;
				for (var Ma = 0; ga.isEven() && wa.isEven(); Ma++) ga.iushrn(1), wa.iushrn(1);
				do {
					for (; ga.isEven();) ga.iushrn(1);
					for (; wa.isEven();) wa.iushrn(1);
					var Aa = ga.cmp(wa);
					if (Aa < 0) {
						var Ra = ga;
						ga = wa, wa = Ra
					} else if (Aa === 0 || wa.cmpn(1) === 0) break;
					ga.isub(wa)
				} while (!0);
				return wa.iushln(Ma)
			}, ra.prototype.invm = function(fa) {
				return this.egcd(fa).a.umod(fa)
			}, ra.prototype.isEven = function() {
				return (this.words[0] & 1) === 0
			}, ra.prototype.isOdd = function() {
				return (this.words[0] & 1) === 1
			}, ra.prototype.andln = function(fa) {
				return this.words[0] & fa
			}, ra.prototype.bincn = function(fa) {
				ta(typeof fa == "number");
				var ga = fa % 26,
					wa = (fa - ga) / 26,
					Ma = 1 << ga;
				if (this.length <= wa) return this._expand(wa + 1), this.words[wa] |= Ma, this;
				for (var Aa = Ma, Ra = wa; Aa !== 0 && Ra < this.length; Ra++) {
					var Ta = this.words[Ra] | 0;
					Ta += Aa, Aa = Ta >>> 26, Ta &= 67108863, this.words[Ra] = Ta
				}
				return Aa !== 0 && (this.words[Ra] = Aa, this.length++), this
			}, ra.prototype.isZero = function() {
				return this.length === 1 && this.words[0] === 0
			}, ra.prototype.cmpn = function(fa) {
				var ga = fa < 0;
				if (this.negative !== 0 && !ga) return -1;
				if (this.negative === 0 && ga) return 1;
				this._strip();
				var wa;
				if (this.length > 1) wa = 1;
				else {
					ga && (fa = -fa), ta(fa <= 67108863, "Number is too big");
					var Ma = this.words[0] | 0;
					wa = Ma === fa ? 0 : Ma < fa ? -1 : 1
				}
				return this.negative !== 0 ? -wa | 0 : wa
			}, ra.prototype.cmp = function(fa) {
				if (this.negative !== 0 && fa.negative === 0) return -1;
				if (this.negative === 0 && fa.negative !== 0) return 1;
				var ga = this.ucmp(fa);
				return this.negative !== 0 ? -ga | 0 : ga
			}, ra.prototype.ucmp = function(fa) {
				if (this.length > fa.length) return 1;
				if (this.length < fa.length) return -1;
				for (var ga = 0, wa = this.length - 1; wa >= 0; wa--) {
					var Ma = this.words[wa] | 0,
						Aa = fa.words[wa] | 0;
					if (Ma !== Aa) {
						Ma < Aa ? ga = -1 : Ma > Aa && (ga = 1);
						break
					}
				}
				return ga
			}, ra.prototype.gtn = function(fa) {
				return this.cmpn(fa) === 1
			}, ra.prototype.gt = function(fa) {
				return this.cmp(fa) === 1
			}, ra.prototype.gten = function(fa) {
				return this.cmpn(fa) >= 0
			}, ra.prototype.gte = function(fa) {
				return this.cmp(fa) >= 0
			}, ra.prototype.ltn = function(fa) {
				return this.cmpn(fa) === -1
			}, ra.prototype.lt = function(fa) {
				return this.cmp(fa) === -1
			}, ra.prototype.lten = function(fa) {
				return this.cmpn(fa) <= 0
			}, ra.prototype.lte = function(fa) {
				return this.cmp(fa) <= 0
			}, ra.prototype.eqn = function(fa) {
				return this.cmpn(fa) === 0
			}, ra.prototype.eq = function(fa) {
				return this.cmp(fa) === 0
			}, ra.red = function(fa) {
				return new Ua(fa)
			}, ra.prototype.toRed = function(fa) {
				return ta(!this.red, "Already a number in reduction context"), ta(this.negative === 0, "red works only with positives"), fa.convertTo(this)._forceRed(fa)
			}, ra.prototype.fromRed = function() {
				return ta(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
			}, ra.prototype._forceRed = function(fa) {
				return this.red = fa, this
			}, ra.prototype.forceRed = function(fa) {
				return ta(!this.red, "Already a number in reduction context"), this._forceRed(fa)
			}, ra.prototype.redAdd = function(fa) {
				return ta(this.red, "redAdd works only with red numbers"), this.red.add(this, fa)
			}, ra.prototype.redIAdd = function(fa) {
				return ta(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, fa)
			}, ra.prototype.redSub = function(fa) {
				return ta(this.red, "redSub works only with red numbers"), this.red.sub(this, fa)
			}, ra.prototype.redISub = function(fa) {
				return ta(this.red, "redISub works only with red numbers"), this.red.isub(this, fa)
			}, ra.prototype.redShl = function(fa) {
				return ta(this.red, "redShl works only with red numbers"), this.red.shl(this, fa)
			}, ra.prototype.redMul = function(fa) {
				return ta(this.red, "redMul works only with red numbers"), this.red._verify2(this, fa), this.red.mul(this, fa)
			}, ra.prototype.redIMul = function(fa) {
				return ta(this.red, "redMul works only with red numbers"), this.red._verify2(this, fa), this.red.imul(this, fa)
			}, ra.prototype.redSqr = function() {
				return ta(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
			}, ra.prototype.redISqr = function() {
				return ta(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
			}, ra.prototype.redSqrt = function() {
				return ta(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
			}, ra.prototype.redInvm = function() {
				return ta(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
			}, ra.prototype.redNeg = function() {
				return ta(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
			}, ra.prototype.redPow = function(fa) {
				return ta(this.red && !fa.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, fa)
			};
			var ka = {
				k256: null,
				p224: null,
				p192: null,
				p25519: null
			};

			function Pa(ma, fa) {
				this.name = ma, this.p = new ra(fa, 16), this.n = this.p.bitLength(), this.k = new ra(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
			}
			Pa.prototype._tmp = function() {
				var fa = new ra(null);
				return fa.words = new Array(Math.ceil(this.n / 13)), fa
			}, Pa.prototype.ireduce = function(fa) {
				var ga = fa,
					wa;
				do this.split(ga, this.tmp), ga = this.imulK(ga), ga = ga.iadd(this.tmp), wa = ga.bitLength(); while (wa > this.n);
				var Ma = wa < this.n ? -1 : ga.ucmp(this.p);
				return Ma === 0 ? (ga.words[0] = 0, ga.length = 1) : Ma > 0 ? ga.isub(this.p) : ga.strip !== void 0 ? ga.strip() : ga._strip(), ga
			}, Pa.prototype.split = function(fa, ga) {
				fa.iushrn(this.n, 0, ga)
			}, Pa.prototype.imulK = function(fa) {
				return fa.imul(this.k)
			};

			function ja() {
				Pa.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
			}
			na(ja, Pa), ja.prototype.split = function(fa, ga) {
				for (var wa = 4194303, Ma = Math.min(fa.length, 9), Aa = 0; Aa < Ma; Aa++) ga.words[Aa] = fa.words[Aa];
				if (ga.length = Ma, fa.length <= 9) {
					fa.words[0] = 0, fa.length = 1;
					return
				}
				var Ra = fa.words[9];
				for (ga.words[ga.length++] = Ra & wa, Aa = 10; Aa < fa.length; Aa++) {
					var Ta = fa.words[Aa] | 0;
					fa.words[Aa - 10] = (Ta & wa) << 4 | Ra >>> 22, Ra = Ta
				}
				Ra >>>= 22, fa.words[Aa - 10] = Ra, Ra === 0 && fa.length > 10 ? fa.length -= 10 : fa.length -= 9
			}, ja.prototype.imulK = function(fa) {
				fa.words[fa.length] = 0, fa.words[fa.length + 1] = 0, fa.length += 2;
				for (var ga = 0, wa = 0; wa < fa.length; wa++) {
					var Ma = fa.words[wa] | 0;
					ga += Ma * 977, fa.words[wa] = ga & 67108863, ga = Ma * 64 + (ga / 67108864 | 0)
				}
				return fa.words[fa.length - 1] === 0 && (fa.length--, fa.words[fa.length - 1] === 0 && fa.length--), fa
			};

			function Za() {
				Pa.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
			}
			na(Za, Pa);

			function Ga() {
				Pa.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
			}
			na(Ga, Pa);

			function Ja() {
				Pa.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
			}
			na(Ja, Pa), Ja.prototype.imulK = function(fa) {
				for (var ga = 0, wa = 0; wa < fa.length; wa++) {
					var Ma = (fa.words[wa] | 0) * 19 + ga,
						Aa = Ma & 67108863;
					Ma >>>= 26, fa.words[wa] = Aa, ga = Ma
				}
				return ga !== 0 && (fa.words[fa.length++] = ga), fa
			}, ra._prime = function(fa) {
				if (ka[fa]) return ka[fa];
				var ga;
				if (fa === "k256") ga = new ja;
				else if (fa === "p224") ga = new Za;
				else if (fa === "p192") ga = new Ga;
				else if (fa === "p25519") ga = new Ja;
				else throw new Error("Unknown prime " + fa);
				return ka[fa] = ga, ga
			};

			function Ua(ma) {
				if (typeof ma == "string") {
					var fa = ra._prime(ma);
					this.m = fa.p, this.prime = fa
				} else ta(ma.gtn(1), "modulus must be greater than 1"), this.m = ma, this.prime = null
			}
			Ua.prototype._verify1 = function(fa) {
				ta(fa.negative === 0, "red works only with positives"), ta(fa.red, "red works only with red numbers")
			}, Ua.prototype._verify2 = function(fa, ga) {
				ta((fa.negative | ga.negative) === 0, "red works only with positives"), ta(fa.red && fa.red === ga.red, "red works only with red numbers")
			}, Ua.prototype.imod = function(fa) {
				return this.prime ? this.prime.ireduce(fa)._forceRed(this) : (sa(fa, fa.umod(this.m)._forceRed(this)), fa)
			}, Ua.prototype.neg = function(fa) {
				return fa.isZero() ? fa.clone() : this.m.sub(fa)._forceRed(this)
			}, Ua.prototype.add = function(fa, ga) {
				this._verify2(fa, ga);
				var wa = fa.add(ga);
				return wa.cmp(this.m) >= 0 && wa.isub(this.m), wa._forceRed(this)
			}, Ua.prototype.iadd = function(fa, ga) {
				this._verify2(fa, ga);
				var wa = fa.iadd(ga);
				return wa.cmp(this.m) >= 0 && wa.isub(this.m), wa
			}, Ua.prototype.sub = function(fa, ga) {
				this._verify2(fa, ga);
				var wa = fa.sub(ga);
				return wa.cmpn(0) < 0 && wa.iadd(this.m), wa._forceRed(this)
			}, Ua.prototype.isub = function(fa, ga) {
				this._verify2(fa, ga);
				var wa = fa.isub(ga);
				return wa.cmpn(0) < 0 && wa.iadd(this.m), wa
			}, Ua.prototype.shl = function(fa, ga) {
				return this._verify1(fa), this.imod(fa.ushln(ga))
			}, Ua.prototype.imul = function(fa, ga) {
				return this._verify2(fa, ga), this.imod(fa.imul(ga))
			}, Ua.prototype.mul = function(fa, ga) {
				return this._verify2(fa, ga), this.imod(fa.mul(ga))
			}, Ua.prototype.isqr = function(fa) {
				return this.imul(fa, fa.clone())
			}, Ua.prototype.sqr = function(fa) {
				return this.mul(fa, fa)
			}, Ua.prototype.sqrt = function(fa) {
				if (fa.isZero()) return fa.clone();
				var ga = this.m.andln(3);
				if (ta(ga % 2 === 1), ga === 3) {
					var wa = this.m.add(new ra(1)).iushrn(2);
					return this.pow(fa, wa)
				}
				for (var Ma = this.m.subn(1), Aa = 0; !Ma.isZero() && Ma.andln(1) === 0;) Aa++, Ma.iushrn(1);
				ta(!Ma.isZero());
				var Ra = new ra(1).toRed(this),
					Ta = Ra.redNeg(),
					La = this.m.subn(1).iushrn(1),
					ya = this.m.bitLength();
				for (ya = new ra(2 * ya * ya).toRed(this); this.pow(ya, La).cmp(Ta) !== 0;) ya.redIAdd(Ta);
				for (var Ba = this.pow(ya, Ma), io = this.pow(fa, Ma.addn(1).iushrn(1)), oo = this.pow(fa, Ma), ao = Aa; oo.cmp(Ra) !== 0;) {
					for (var Ia = oo, Na = 0; Ia.cmp(Ra) !== 0; Na++) Ia = Ia.redSqr();
					ta(Na < ao);
					var za = this.pow(Ba, new ra(1).iushln(ao - Na - 1));
					io = io.redMul(za), Ba = za.redSqr(), oo = oo.redMul(Ba), ao = Na
				}
				return io
			}, Ua.prototype.invm = function(fa) {
				var ga = fa._invmp(this.m);
				return ga.negative !== 0 ? (ga.negative = 0, this.imod(ga).redNeg()) : this.imod(ga)
			}, Ua.prototype.pow = function(fa, ga) {
				if (ga.isZero()) return new ra(1).toRed(this);
				if (ga.cmpn(1) === 0) return fa.clone();
				var wa = 4,
					Ma = new Array(1 << wa);
				Ma[0] = new ra(1).toRed(this), Ma[1] = fa;
				for (var Aa = 2; Aa < Ma.length; Aa++) Ma[Aa] = this.mul(Ma[Aa - 1], fa);
				var Ra = Ma[0],
					Ta = 0,
					La = 0,
					ya = ga.bitLength() % 26;
				for (ya === 0 && (ya = 26), Aa = ga.length - 1; Aa >= 0; Aa--) {
					for (var Ba = ga.words[Aa], io = ya - 1; io >= 0; io--) {
						var oo = Ba >> io & 1;
						if (Ra !== Ma[0] && (Ra = this.sqr(Ra)), oo === 0 && Ta === 0) {
							La = 0;
							continue
						}
						Ta <<= 1, Ta |= oo, La++, !(La !== wa && (Aa !== 0 || io !== 0)) && (Ra = this.mul(Ra, Ma[Ta]), La = 0, Ta = 0)
					}
					ya = 26
				}
				return Ra
			}, Ua.prototype.convertTo = function(fa) {
				var ga = fa.umod(this.m);
				return ga === fa ? ga.clone() : ga
			}, Ua.prototype.convertFrom = function(fa) {
				var ga = fa.clone();
				return ga.red = null, ga
			}, ra.mont = function(fa) {
				return new xa(fa)
			};

			function xa(ma) {
				Ua.call(this, ma), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ra(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
			}
			na(xa, Ua), xa.prototype.convertTo = function(fa) {
				return this.imod(fa.ushln(this.shift))
			}, xa.prototype.convertFrom = function(fa) {
				var ga = this.imod(fa.mul(this.rinv));
				return ga.red = null, ga
			}, xa.prototype.imul = function(fa, ga) {
				if (fa.isZero() || ga.isZero()) return fa.words[0] = 0, fa.length = 1, fa;
				var wa = fa.imul(ga),
					Ma = wa.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
					Aa = wa.isub(Ma).iushrn(this.shift),
					Ra = Aa;
				return Aa.cmp(this.m) >= 0 ? Ra = Aa.isub(this.m) : Aa.cmpn(0) < 0 && (Ra = Aa.iadd(this.m)), Ra._forceRed(this)
			}, xa.prototype.mul = function(fa, ga) {
				if (fa.isZero() || ga.isZero()) return new ra(0)._forceRed(this);
				var wa = fa.mul(ga),
					Ma = wa.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
					Aa = wa.isub(Ma).iushrn(this.shift),
					Ra = Aa;
				return Aa.cmp(this.m) >= 0 ? Ra = Aa.isub(this.m) : Aa.cmpn(0) < 0 && (Ra = Aa.iadd(this.m)), Ra._forceRed(this)
			}, xa.prototype.invm = function(fa) {
				var ga = this.imod(fa._invmp(this.m).mul(this.r2));
				return ga._forceRed(this)
			}
		})(ue, commonjsGlobal)
	}(bn$2)), bn$2.exports
}
var browserifyRsa, hasRequiredBrowserifyRsa;

function requireBrowserifyRsa() {
	if (hasRequiredBrowserifyRsa) return browserifyRsa;
	hasRequiredBrowserifyRsa = 1;
	var ue = requireBn$1(),
		Yi = requireBrowser$b();

	function ea(ra) {
		var ia = ta(ra),
			aa = ia.toRed(ue.mont(ra.modulus)).redPow(new ue(ra.publicExponent)).fromRed();
		return {
			blinder: aa,
			unblinder: ia.invm(ra.modulus)
		}
	}

	function ta(ra) {
		var ia = ra.modulus.byteLength(),
			aa;
		do aa = new ue(Yi(ia)); while (aa.cmp(ra.modulus) >= 0 || !aa.umod(ra.prime1) || !aa.umod(ra.prime2));
		return aa
	}

	function na(ra, ia) {
		var aa = ea(ia),
			oa = ia.modulus.byteLength(),
			la = new ue(ra).mul(aa.blinder).umod(ia.modulus),
			sa = la.toRed(ue.mont(ia.prime1)),
			ca = la.toRed(ue.mont(ia.prime2)),
			ua = ia.coefficient,
			da = ia.prime1,
			ha = ia.prime2,
			pa = sa.redPow(ia.exponent1).fromRed(),
			va = ca.redPow(ia.exponent2).fromRed(),
			ba = pa.isub(va).imul(ua).umod(da).imul(ha);
		return va.iadd(ba).imul(aa.unblinder).umod(ia.modulus).toArrayLike(Buffer, "be", oa)
	}
	return na.getr = ta, browserifyRsa = na, browserifyRsa
}
var elliptic = {};
const name = "elliptic",
	version = "6.5.7",
	description = "EC cryptography",
	main = "lib/elliptic.js",
	files = ["lib"],
	scripts = {
		lint: "eslint lib test",
		"lint:fix": "npm run lint -- --fix",
		unit: "istanbul test _mocha --reporter=spec test/index.js",
		test: "npm run lint && npm run unit",
		version: "grunt dist && git add dist/"
	},
	repository = {
		type: "git",
		url: "git@github.com:indutny/elliptic"
	},
	keywords = ["EC", "Elliptic", "curve", "Cryptography"],
	author = "Fedor Indutny <fedor@indutny.com>",
	license = "MIT",
	bugs = {
		url: "https://github.com/indutny/elliptic/issues"
	},
	homepage = "https://github.com/indutny/elliptic",
	devDependencies = {
		brfs: "^2.0.2",
		coveralls: "^3.1.0",
		eslint: "^7.6.0",
		grunt: "^1.2.1",
		"grunt-browserify": "^5.3.0",
		"grunt-cli": "^1.3.2",
		"grunt-contrib-connect": "^3.0.0",
		"grunt-contrib-copy": "^1.0.0",
		"grunt-contrib-uglify": "^5.0.0",
		"grunt-mocha-istanbul": "^5.0.2",
		"grunt-saucelabs": "^9.0.1",
		istanbul: "^0.4.5",
		mocha: "^8.0.1"
	},
	dependencies = {
		"bn.js": "^4.11.9",
		brorand: "^1.1.0",
		"hash.js": "^1.0.0",
		"hmac-drbg": "^1.0.1",
		inherits: "^2.0.4",
		"minimalistic-assert": "^1.0.1",
		"minimalistic-crypto-utils": "^1.0.1"
	},
	require$$0 = {
		name,
		version,
		description,
		main,
		files,
		scripts,
		repository,
		keywords,
		author,
		license,
		bugs,
		homepage,
		devDependencies,
		dependencies
	};
var utils$2 = {},
	utils$1 = {},
	hasRequiredUtils$2;

function requireUtils$2() {
	return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function(ue) {
		var Yi = ue;

		function ea(ra, ia) {
			if (Array.isArray(ra)) return ra.slice();
			if (!ra) return [];
			var aa = [];
			if (typeof ra != "string") {
				for (var oa = 0; oa < ra.length; oa++) aa[oa] = ra[oa] | 0;
				return aa
			}
			if (ia === "hex") {
				ra = ra.replace(/[^a-z0-9]+/ig, ""), ra.length % 2 !== 0 && (ra = "0" + ra);
				for (var oa = 0; oa < ra.length; oa += 2) aa.push(parseInt(ra[oa] + ra[oa + 1], 16))
			} else
				for (var oa = 0; oa < ra.length; oa++) {
					var la = ra.charCodeAt(oa),
						sa = la >> 8,
						ca = la & 255;
					sa ? aa.push(sa, ca) : aa.push(ca)
				}
			return aa
		}
		Yi.toArray = ea;

		function ta(ra) {
			return ra.length === 1 ? "0" + ra : ra
		}
		Yi.zero2 = ta;

		function na(ra) {
			for (var ia = "", aa = 0; aa < ra.length; aa++) ia += ta(ra[aa].toString(16));
			return ia
		}
		Yi.toHex = na, Yi.encode = function(ia, aa) {
			return aa === "hex" ? na(ia) : ia
		}
	}(utils$1)), utils$1
}
var hasRequiredUtils$1;

function requireUtils$1() {
	return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(ue) {
		var Yi = ue,
			ea = requireBn$2(),
			ta = requireMinimalisticAssert(),
			na = requireUtils$2();
		Yi.assert = ta, Yi.toArray = na.toArray, Yi.zero2 = na.zero2, Yi.toHex = na.toHex, Yi.encode = na.encode;

		function ra(sa, ca, ua) {
			var da = new Array(Math.max(sa.bitLength(), ua) + 1),
				ha;
			for (ha = 0; ha < da.length; ha += 1) da[ha] = 0;
			var pa = 1 << ca + 1,
				va = sa.clone();
			for (ha = 0; ha < da.length; ha++) {
				var ba, Ea = va.andln(pa - 1);
				va.isOdd() ? (Ea > (pa >> 1) - 1 ? ba = (pa >> 1) - Ea : ba = Ea, va.isubn(ba)) : ba = 0, da[ha] = ba, va.iushrn(1)
			}
			return da
		}
		Yi.getNAF = ra;

		function ia(sa, ca) {
			var ua = [
				[],
				[]
			];
			sa = sa.clone(), ca = ca.clone();
			for (var da = 0, ha = 0, pa; sa.cmpn(-da) > 0 || ca.cmpn(-ha) > 0;) {
				var va = sa.andln(3) + da & 3,
					ba = ca.andln(3) + ha & 3;
				va === 3 && (va = -1), ba === 3 && (ba = -1);
				var Ea;
				va & 1 ? (pa = sa.andln(7) + da & 7, (pa === 3 || pa === 5) && ba === 2 ? Ea = -va : Ea = va) : Ea = 0, ua[0].push(Ea);
				var Sa;
				ba & 1 ? (pa = ca.andln(7) + ha & 7, (pa === 3 || pa === 5) && va === 2 ? Sa = -ba : Sa = ba) : Sa = 0, ua[1].push(Sa), 2 * da === Ea + 1 && (da = 1 - da), 2 * ha === Sa + 1 && (ha = 1 - ha), sa.iushrn(1), ca.iushrn(1)
			}
			return ua
		}
		Yi.getJSF = ia;

		function aa(sa, ca, ua) {
			var da = "_" + ca;
			sa.prototype[ca] = function() {
				return this[da] !== void 0 ? this[da] : this[da] = ua.call(this)
			}
		}
		Yi.cachedProperty = aa;

		function oa(sa) {
			return typeof sa == "string" ? Yi.toArray(sa, "hex") : sa
		}
		Yi.parseBytes = oa;

		function la(sa) {
			return new ea(sa, "hex", "le")
		}
		Yi.intFromLE = la
	}(utils$2)), utils$2
}
var curve = {},
	base$1, hasRequiredBase$1;

function requireBase$1() {
	if (hasRequiredBase$1) return base$1;
	hasRequiredBase$1 = 1;
	var ue = requireBn$2(),
		Yi = requireUtils$1(),
		ea = Yi.getNAF,
		ta = Yi.getJSF,
		na = Yi.assert;

	function ra(aa, oa) {
		this.type = aa, this.p = new ue(oa.p, 16), this.red = oa.prime ? ue.red(oa.prime) : ue.mont(this.p), this.zero = new ue(0).toRed(this.red), this.one = new ue(1).toRed(this.red), this.two = new ue(2).toRed(this.red), this.n = oa.n && new ue(oa.n, 16), this.g = oa.g && this.pointFromJSON(oa.g, oa.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
		var la = this.n && this.p.div(this.n);
		!la || la.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red))
	}
	base$1 = ra, ra.prototype.point = function() {
		throw new Error("Not implemented")
	}, ra.prototype.validate = function() {
		throw new Error("Not implemented")
	}, ra.prototype._fixedNafMul = function(oa, la) {
		na(oa.precomputed);
		var sa = oa._getDoubles(),
			ca = ea(la, 1, this._bitLength),
			ua = (1 << sa.step + 1) - (sa.step % 2 === 0 ? 2 : 1);
		ua /= 3;
		var da = [],
			ha, pa;
		for (ha = 0; ha < ca.length; ha += sa.step) {
			pa = 0;
			for (var va = ha + sa.step - 1; va >= ha; va--) pa = (pa << 1) + ca[va];
			da.push(pa)
		}
		for (var ba = this.jpoint(null, null, null), Ea = this.jpoint(null, null, null), Sa = ua; Sa > 0; Sa--) {
			for (ha = 0; ha < da.length; ha++) pa = da[ha], pa === Sa ? Ea = Ea.mixedAdd(sa.points[ha]) : pa === -Sa && (Ea = Ea.mixedAdd(sa.points[ha].neg()));
			ba = ba.add(Ea)
		}
		return ba.toP()
	}, ra.prototype._wnafMul = function(oa, la) {
		var sa = 4,
			ca = oa._getNAFPoints(sa);
		sa = ca.wnd;
		for (var ua = ca.points, da = ea(la, sa, this._bitLength), ha = this.jpoint(null, null, null), pa = da.length - 1; pa >= 0; pa--) {
			for (var va = 0; pa >= 0 && da[pa] === 0; pa--) va++;
			if (pa >= 0 && va++, ha = ha.dblp(va), pa < 0) break;
			var ba = da[pa];
			na(ba !== 0), oa.type === "affine" ? ba > 0 ? ha = ha.mixedAdd(ua[ba - 1 >> 1]) : ha = ha.mixedAdd(ua[-ba - 1 >> 1].neg()) : ba > 0 ? ha = ha.add(ua[ba - 1 >> 1]) : ha = ha.add(ua[-ba - 1 >> 1].neg())
		}
		return oa.type === "affine" ? ha.toP() : ha
	}, ra.prototype._wnafMulAdd = function(oa, la, sa, ca, ua) {
		var da = this._wnafT1,
			ha = this._wnafT2,
			pa = this._wnafT3,
			va = 0,
			ba, Ea, Sa;
		for (ba = 0; ba < ca; ba++) {
			Sa = la[ba];
			var Ca = Sa._getNAFPoints(oa);
			da[ba] = Ca.wnd, ha[ba] = Ca.points
		}
		for (ba = ca - 1; ba >= 1; ba -= 2) {
			var ka = ba - 1,
				Pa = ba;
			if (da[ka] !== 1 || da[Pa] !== 1) {
				pa[ka] = ea(sa[ka], da[ka], this._bitLength), pa[Pa] = ea(sa[Pa], da[Pa], this._bitLength), va = Math.max(pa[ka].length, va), va = Math.max(pa[Pa].length, va);
				continue
			}
			var ja = [la[ka], null, null, la[Pa]];
			la[ka].y.cmp(la[Pa].y) === 0 ? (ja[1] = la[ka].add(la[Pa]), ja[2] = la[ka].toJ().mixedAdd(la[Pa].neg())) : la[ka].y.cmp(la[Pa].y.redNeg()) === 0 ? (ja[1] = la[ka].toJ().mixedAdd(la[Pa]), ja[2] = la[ka].add(la[Pa].neg())) : (ja[1] = la[ka].toJ().mixedAdd(la[Pa]), ja[2] = la[ka].toJ().mixedAdd(la[Pa].neg()));
			var Za = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
				Ga = ta(sa[ka], sa[Pa]);
			for (va = Math.max(Ga[0].length, va), pa[ka] = new Array(va), pa[Pa] = new Array(va), Ea = 0; Ea < va; Ea++) {
				var Ja = Ga[0][Ea] | 0,
					Ua = Ga[1][Ea] | 0;
				pa[ka][Ea] = Za[(Ja + 1) * 3 + (Ua + 1)], pa[Pa][Ea] = 0, ha[ka] = ja
			}
		}
		var xa = this.jpoint(null, null, null),
			ma = this._wnafT4;
		for (ba = va; ba >= 0; ba--) {
			for (var fa = 0; ba >= 0;) {
				var ga = !0;
				for (Ea = 0; Ea < ca; Ea++) ma[Ea] = pa[Ea][ba] | 0, ma[Ea] !== 0 && (ga = !1);
				if (!ga) break;
				fa++, ba--
			}
			if (ba >= 0 && fa++, xa = xa.dblp(fa), ba < 0) break;
			for (Ea = 0; Ea < ca; Ea++) {
				var wa = ma[Ea];
				wa !== 0 && (wa > 0 ? Sa = ha[Ea][wa - 1 >> 1] : wa < 0 && (Sa = ha[Ea][-wa - 1 >> 1].neg()), Sa.type === "affine" ? xa = xa.mixedAdd(Sa) : xa = xa.add(Sa))
			}
		}
		for (ba = 0; ba < ca; ba++) ha[ba] = null;
		return ua ? xa : xa.toP()
	};

	function ia(aa, oa) {
		this.curve = aa, this.type = oa, this.precomputed = null
	}
	return ra.BasePoint = ia, ia.prototype.eq = function() {
		throw new Error("Not implemented")
	}, ia.prototype.validate = function() {
		return this.curve.validate(this)
	}, ra.prototype.decodePoint = function(oa, la) {
		oa = Yi.toArray(oa, la);
		var sa = this.p.byteLength();
		if ((oa[0] === 4 || oa[0] === 6 || oa[0] === 7) && oa.length - 1 === 2 * sa) {
			oa[0] === 6 ? na(oa[oa.length - 1] % 2 === 0) : oa[0] === 7 && na(oa[oa.length - 1] % 2 === 1);
			var ca = this.point(oa.slice(1, 1 + sa), oa.slice(1 + sa, 1 + 2 * sa));
			return ca
		} else if ((oa[0] === 2 || oa[0] === 3) && oa.length - 1 === sa) return this.pointFromX(oa.slice(1, 1 + sa), oa[0] === 3);
		throw new Error("Unknown point format")
	}, ia.prototype.encodeCompressed = function(oa) {
		return this.encode(oa, !0)
	}, ia.prototype._encode = function(oa) {
		var la = this.curve.p.byteLength(),
			sa = this.getX().toArray("be", la);
		return oa ? [this.getY().isEven() ? 2 : 3].concat(sa) : [4].concat(sa, this.getY().toArray("be", la))
	}, ia.prototype.encode = function(oa, la) {
		return Yi.encode(this._encode(la), oa)
	}, ia.prototype.precompute = function(oa) {
		if (this.precomputed) return this;
		var la = {
			doubles: null,
			naf: null,
			beta: null
		};
		return la.naf = this._getNAFPoints(8), la.doubles = this._getDoubles(4, oa), la.beta = this._getBeta(), this.precomputed = la, this
	}, ia.prototype._hasDoubles = function(oa) {
		if (!this.precomputed) return !1;
		var la = this.precomputed.doubles;
		return la ? la.points.length >= Math.ceil((oa.bitLength() + 1) / la.step) : !1
	}, ia.prototype._getDoubles = function(oa, la) {
		if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
		for (var sa = [this], ca = this, ua = 0; ua < la; ua += oa) {
			for (var da = 0; da < oa; da++) ca = ca.dbl();
			sa.push(ca)
		}
		return {
			step: oa,
			points: sa
		}
	}, ia.prototype._getNAFPoints = function(oa) {
		if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
		for (var la = [this], sa = (1 << oa) - 1, ca = sa === 1 ? null : this.dbl(), ua = 1; ua < sa; ua++) la[ua] = la[ua - 1].add(ca);
		return {
			wnd: oa,
			points: la
		}
	}, ia.prototype._getBeta = function() {
		return null
	}, ia.prototype.dblp = function(oa) {
		for (var la = this, sa = 0; sa < oa; sa++) la = la.dbl();
		return la
	}, base$1
}
var short, hasRequiredShort;

function requireShort() {
	if (hasRequiredShort) return short;
	hasRequiredShort = 1;
	var ue = requireUtils$1(),
		Yi = requireBn$2(),
		ea = requireInherits_browser(),
		ta = requireBase$1(),
		na = ue.assert;

	function ra(oa) {
		ta.call(this, "short", oa), this.a = new Yi(oa.a, 16).toRed(this.red), this.b = new Yi(oa.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(oa), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4)
	}
	ea(ra, ta), short = ra, ra.prototype._getEndomorphism = function(la) {
		if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
			var sa, ca;
			if (la.beta) sa = new Yi(la.beta, 16).toRed(this.red);
			else {
				var ua = this._getEndoRoots(this.p);
				sa = ua[0].cmp(ua[1]) < 0 ? ua[0] : ua[1], sa = sa.toRed(this.red)
			}
			if (la.lambda) ca = new Yi(la.lambda, 16);
			else {
				var da = this._getEndoRoots(this.n);
				this.g.mul(da[0]).x.cmp(this.g.x.redMul(sa)) === 0 ? ca = da[0] : (ca = da[1], na(this.g.mul(ca).x.cmp(this.g.x.redMul(sa)) === 0))
			}
			var ha;
			return la.basis ? ha = la.basis.map(function(pa) {
				return {
					a: new Yi(pa.a, 16),
					b: new Yi(pa.b, 16)
				}
			}) : ha = this._getEndoBasis(ca), {
				beta: sa,
				lambda: ca,
				basis: ha
			}
		}
	}, ra.prototype._getEndoRoots = function(la) {
		var sa = la === this.p ? this.red : Yi.mont(la),
			ca = new Yi(2).toRed(sa).redInvm(),
			ua = ca.redNeg(),
			da = new Yi(3).toRed(sa).redNeg().redSqrt().redMul(ca),
			ha = ua.redAdd(da).fromRed(),
			pa = ua.redSub(da).fromRed();
		return [ha, pa]
	}, ra.prototype._getEndoBasis = function(la) {
		for (var sa = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), ca = la, ua = this.n.clone(), da = new Yi(1), ha = new Yi(0), pa = new Yi(0), va = new Yi(1), ba, Ea, Sa, Ca, ka, Pa, ja, Za = 0, Ga, Ja; ca.cmpn(0) !== 0;) {
			var Ua = ua.div(ca);
			Ga = ua.sub(Ua.mul(ca)), Ja = pa.sub(Ua.mul(da));
			var xa = va.sub(Ua.mul(ha));
			if (!Sa && Ga.cmp(sa) < 0) ba = ja.neg(), Ea = da, Sa = Ga.neg(), Ca = Ja;
			else if (Sa && ++Za === 2) break;
			ja = Ga, ua = ca, ca = Ga, pa = da, da = Ja, va = ha, ha = xa
		}
		ka = Ga.neg(), Pa = Ja;
		var ma = Sa.sqr().add(Ca.sqr()),
			fa = ka.sqr().add(Pa.sqr());
		return fa.cmp(ma) >= 0 && (ka = ba, Pa = Ea), Sa.negative && (Sa = Sa.neg(), Ca = Ca.neg()), ka.negative && (ka = ka.neg(), Pa = Pa.neg()), [{
			a: Sa,
			b: Ca
		}, {
			a: ka,
			b: Pa
		}]
	}, ra.prototype._endoSplit = function(la) {
		var sa = this.endo.basis,
			ca = sa[0],
			ua = sa[1],
			da = ua.b.mul(la).divRound(this.n),
			ha = ca.b.neg().mul(la).divRound(this.n),
			pa = da.mul(ca.a),
			va = ha.mul(ua.a),
			ba = da.mul(ca.b),
			Ea = ha.mul(ua.b),
			Sa = la.sub(pa).sub(va),
			Ca = ba.add(Ea).neg();
		return {
			k1: Sa,
			k2: Ca
		}
	}, ra.prototype.pointFromX = function(la, sa) {
		la = new Yi(la, 16), la.red || (la = la.toRed(this.red));
		var ca = la.redSqr().redMul(la).redIAdd(la.redMul(this.a)).redIAdd(this.b),
			ua = ca.redSqrt();
		if (ua.redSqr().redSub(ca).cmp(this.zero) !== 0) throw new Error("invalid point");
		var da = ua.fromRed().isOdd();
		return (sa && !da || !sa && da) && (ua = ua.redNeg()), this.point(la, ua)
	}, ra.prototype.validate = function(la) {
		if (la.inf) return !0;
		var sa = la.x,
			ca = la.y,
			ua = this.a.redMul(sa),
			da = sa.redSqr().redMul(sa).redIAdd(ua).redIAdd(this.b);
		return ca.redSqr().redISub(da).cmpn(0) === 0
	}, ra.prototype._endoWnafMulAdd = function(la, sa, ca) {
		for (var ua = this._endoWnafT1, da = this._endoWnafT2, ha = 0; ha < la.length; ha++) {
			var pa = this._endoSplit(sa[ha]),
				va = la[ha],
				ba = va._getBeta();
			pa.k1.negative && (pa.k1.ineg(), va = va.neg(!0)), pa.k2.negative && (pa.k2.ineg(), ba = ba.neg(!0)), ua[ha * 2] = va, ua[ha * 2 + 1] = ba, da[ha * 2] = pa.k1, da[ha * 2 + 1] = pa.k2
		}
		for (var Ea = this._wnafMulAdd(1, ua, da, ha * 2, ca), Sa = 0; Sa < ha * 2; Sa++) ua[Sa] = null, da[Sa] = null;
		return Ea
	};

	function ia(oa, la, sa, ca) {
		ta.BasePoint.call(this, oa, "affine"), la === null && sa === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new Yi(la, 16), this.y = new Yi(sa, 16), ca && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1)
	}
	ea(ia, ta.BasePoint), ra.prototype.point = function(la, sa, ca) {
		return new ia(this, la, sa, ca)
	}, ra.prototype.pointFromJSON = function(la, sa) {
		return ia.fromJSON(this, la, sa)
	}, ia.prototype._getBeta = function() {
		if (this.curve.endo) {
			var la = this.precomputed;
			if (la && la.beta) return la.beta;
			var sa = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
			if (la) {
				var ca = this.curve,
					ua = function(da) {
						return ca.point(da.x.redMul(ca.endo.beta), da.y)
					};
				la.beta = sa, sa.precomputed = {
					beta: null,
					naf: la.naf && {
						wnd: la.naf.wnd,
						points: la.naf.points.map(ua)
					},
					doubles: la.doubles && {
						step: la.doubles.step,
						points: la.doubles.points.map(ua)
					}
				}
			}
			return sa
		}
	}, ia.prototype.toJSON = function() {
		return this.precomputed ? [this.x, this.y, this.precomputed && {
			doubles: this.precomputed.doubles && {
				step: this.precomputed.doubles.step,
				points: this.precomputed.doubles.points.slice(1)
			},
			naf: this.precomputed.naf && {
				wnd: this.precomputed.naf.wnd,
				points: this.precomputed.naf.points.slice(1)
			}
		}] : [this.x, this.y]
	}, ia.fromJSON = function(la, sa, ca) {
		typeof sa == "string" && (sa = JSON.parse(sa));
		var ua = la.point(sa[0], sa[1], ca);
		if (!sa[2]) return ua;

		function da(pa) {
			return la.point(pa[0], pa[1], ca)
		}
		var ha = sa[2];
		return ua.precomputed = {
			beta: null,
			doubles: ha.doubles && {
				step: ha.doubles.step,
				points: [ua].concat(ha.doubles.points.map(da))
			},
			naf: ha.naf && {
				wnd: ha.naf.wnd,
				points: [ua].concat(ha.naf.points.map(da))
			}
		}, ua
	}, ia.prototype.inspect = function() {
		return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
	}, ia.prototype.isInfinity = function() {
		return this.inf
	}, ia.prototype.add = function(la) {
		if (this.inf) return la;
		if (la.inf) return this;
		if (this.eq(la)) return this.dbl();
		if (this.neg().eq(la)) return this.curve.point(null, null);
		if (this.x.cmp(la.x) === 0) return this.curve.point(null, null);
		var sa = this.y.redSub(la.y);
		sa.cmpn(0) !== 0 && (sa = sa.redMul(this.x.redSub(la.x).redInvm()));
		var ca = sa.redSqr().redISub(this.x).redISub(la.x),
			ua = sa.redMul(this.x.redSub(ca)).redISub(this.y);
		return this.curve.point(ca, ua)
	}, ia.prototype.dbl = function() {
		if (this.inf) return this;
		var la = this.y.redAdd(this.y);
		if (la.cmpn(0) === 0) return this.curve.point(null, null);
		var sa = this.curve.a,
			ca = this.x.redSqr(),
			ua = la.redInvm(),
			da = ca.redAdd(ca).redIAdd(ca).redIAdd(sa).redMul(ua),
			ha = da.redSqr().redISub(this.x.redAdd(this.x)),
			pa = da.redMul(this.x.redSub(ha)).redISub(this.y);
		return this.curve.point(ha, pa)
	}, ia.prototype.getX = function() {
		return this.x.fromRed()
	}, ia.prototype.getY = function() {
		return this.y.fromRed()
	}, ia.prototype.mul = function(la) {
		return la = new Yi(la, 16), this.isInfinity() ? this : this._hasDoubles(la) ? this.curve._fixedNafMul(this, la) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [la]) : this.curve._wnafMul(this, la)
	}, ia.prototype.mulAdd = function(la, sa, ca) {
		var ua = [this, sa],
			da = [la, ca];
		return this.curve.endo ? this.curve._endoWnafMulAdd(ua, da) : this.curve._wnafMulAdd(1, ua, da, 2)
	}, ia.prototype.jmulAdd = function(la, sa, ca) {
		var ua = [this, sa],
			da = [la, ca];
		return this.curve.endo ? this.curve._endoWnafMulAdd(ua, da, !0) : this.curve._wnafMulAdd(1, ua, da, 2, !0)
	}, ia.prototype.eq = function(la) {
		return this === la || this.inf === la.inf && (this.inf || this.x.cmp(la.x) === 0 && this.y.cmp(la.y) === 0)
	}, ia.prototype.neg = function(la) {
		if (this.inf) return this;
		var sa = this.curve.point(this.x, this.y.redNeg());
		if (la && this.precomputed) {
			var ca = this.precomputed,
				ua = function(da) {
					return da.neg()
				};
			sa.precomputed = {
				naf: ca.naf && {
					wnd: ca.naf.wnd,
					points: ca.naf.points.map(ua)
				},
				doubles: ca.doubles && {
					step: ca.doubles.step,
					points: ca.doubles.points.map(ua)
				}
			}
		}
		return sa
	}, ia.prototype.toJ = function() {
		if (this.inf) return this.curve.jpoint(null, null, null);
		var la = this.curve.jpoint(this.x, this.y, this.curve.one);
		return la
	};

	function aa(oa, la, sa, ca) {
		ta.BasePoint.call(this, oa, "jacobian"), la === null && sa === null && ca === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new Yi(0)) : (this.x = new Yi(la, 16), this.y = new Yi(sa, 16), this.z = new Yi(ca, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one
	}
	return ea(aa, ta.BasePoint), ra.prototype.jpoint = function(la, sa, ca) {
		return new aa(this, la, sa, ca)
	}, aa.prototype.toP = function() {
		if (this.isInfinity()) return this.curve.point(null, null);
		var la = this.z.redInvm(),
			sa = la.redSqr(),
			ca = this.x.redMul(sa),
			ua = this.y.redMul(sa).redMul(la);
		return this.curve.point(ca, ua)
	}, aa.prototype.neg = function() {
		return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
	}, aa.prototype.add = function(la) {
		if (this.isInfinity()) return la;
		if (la.isInfinity()) return this;
		var sa = la.z.redSqr(),
			ca = this.z.redSqr(),
			ua = this.x.redMul(sa),
			da = la.x.redMul(ca),
			ha = this.y.redMul(sa.redMul(la.z)),
			pa = la.y.redMul(ca.redMul(this.z)),
			va = ua.redSub(da),
			ba = ha.redSub(pa);
		if (va.cmpn(0) === 0) return ba.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
		var Ea = va.redSqr(),
			Sa = Ea.redMul(va),
			Ca = ua.redMul(Ea),
			ka = ba.redSqr().redIAdd(Sa).redISub(Ca).redISub(Ca),
			Pa = ba.redMul(Ca.redISub(ka)).redISub(ha.redMul(Sa)),
			ja = this.z.redMul(la.z).redMul(va);
		return this.curve.jpoint(ka, Pa, ja)
	}, aa.prototype.mixedAdd = function(la) {
		if (this.isInfinity()) return la.toJ();
		if (la.isInfinity()) return this;
		var sa = this.z.redSqr(),
			ca = this.x,
			ua = la.x.redMul(sa),
			da = this.y,
			ha = la.y.redMul(sa).redMul(this.z),
			pa = ca.redSub(ua),
			va = da.redSub(ha);
		if (pa.cmpn(0) === 0) return va.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
		var ba = pa.redSqr(),
			Ea = ba.redMul(pa),
			Sa = ca.redMul(ba),
			Ca = va.redSqr().redIAdd(Ea).redISub(Sa).redISub(Sa),
			ka = va.redMul(Sa.redISub(Ca)).redISub(da.redMul(Ea)),
			Pa = this.z.redMul(pa);
		return this.curve.jpoint(Ca, ka, Pa)
	}, aa.prototype.dblp = function(la) {
		if (la === 0) return this;
		if (this.isInfinity()) return this;
		if (!la) return this.dbl();
		var sa;
		if (this.curve.zeroA || this.curve.threeA) {
			var ca = this;
			for (sa = 0; sa < la; sa++) ca = ca.dbl();
			return ca
		}
		var ua = this.curve.a,
			da = this.curve.tinv,
			ha = this.x,
			pa = this.y,
			va = this.z,
			ba = va.redSqr().redSqr(),
			Ea = pa.redAdd(pa);
		for (sa = 0; sa < la; sa++) {
			var Sa = ha.redSqr(),
				Ca = Ea.redSqr(),
				ka = Ca.redSqr(),
				Pa = Sa.redAdd(Sa).redIAdd(Sa).redIAdd(ua.redMul(ba)),
				ja = ha.redMul(Ca),
				Za = Pa.redSqr().redISub(ja.redAdd(ja)),
				Ga = ja.redISub(Za),
				Ja = Pa.redMul(Ga);
			Ja = Ja.redIAdd(Ja).redISub(ka);
			var Ua = Ea.redMul(va);
			sa + 1 < la && (ba = ba.redMul(ka)), ha = Za, va = Ua, Ea = Ja
		}
		return this.curve.jpoint(ha, Ea.redMul(da), va)
	}, aa.prototype.dbl = function() {
		return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
	}, aa.prototype._zeroDbl = function() {
		var la, sa, ca;
		if (this.zOne) {
			var ua = this.x.redSqr(),
				da = this.y.redSqr(),
				ha = da.redSqr(),
				pa = this.x.redAdd(da).redSqr().redISub(ua).redISub(ha);
			pa = pa.redIAdd(pa);
			var va = ua.redAdd(ua).redIAdd(ua),
				ba = va.redSqr().redISub(pa).redISub(pa),
				Ea = ha.redIAdd(ha);
			Ea = Ea.redIAdd(Ea), Ea = Ea.redIAdd(Ea), la = ba, sa = va.redMul(pa.redISub(ba)).redISub(Ea), ca = this.y.redAdd(this.y)
		} else {
			var Sa = this.x.redSqr(),
				Ca = this.y.redSqr(),
				ka = Ca.redSqr(),
				Pa = this.x.redAdd(Ca).redSqr().redISub(Sa).redISub(ka);
			Pa = Pa.redIAdd(Pa);
			var ja = Sa.redAdd(Sa).redIAdd(Sa),
				Za = ja.redSqr(),
				Ga = ka.redIAdd(ka);
			Ga = Ga.redIAdd(Ga), Ga = Ga.redIAdd(Ga), la = Za.redISub(Pa).redISub(Pa), sa = ja.redMul(Pa.redISub(la)).redISub(Ga), ca = this.y.redMul(this.z), ca = ca.redIAdd(ca)
		}
		return this.curve.jpoint(la, sa, ca)
	}, aa.prototype._threeDbl = function() {
		var la, sa, ca;
		if (this.zOne) {
			var ua = this.x.redSqr(),
				da = this.y.redSqr(),
				ha = da.redSqr(),
				pa = this.x.redAdd(da).redSqr().redISub(ua).redISub(ha);
			pa = pa.redIAdd(pa);
			var va = ua.redAdd(ua).redIAdd(ua).redIAdd(this.curve.a),
				ba = va.redSqr().redISub(pa).redISub(pa);
			la = ba;
			var Ea = ha.redIAdd(ha);
			Ea = Ea.redIAdd(Ea), Ea = Ea.redIAdd(Ea), sa = va.redMul(pa.redISub(ba)).redISub(Ea), ca = this.y.redAdd(this.y)
		} else {
			var Sa = this.z.redSqr(),
				Ca = this.y.redSqr(),
				ka = this.x.redMul(Ca),
				Pa = this.x.redSub(Sa).redMul(this.x.redAdd(Sa));
			Pa = Pa.redAdd(Pa).redIAdd(Pa);
			var ja = ka.redIAdd(ka);
			ja = ja.redIAdd(ja);
			var Za = ja.redAdd(ja);
			la = Pa.redSqr().redISub(Za), ca = this.y.redAdd(this.z).redSqr().redISub(Ca).redISub(Sa);
			var Ga = Ca.redSqr();
			Ga = Ga.redIAdd(Ga), Ga = Ga.redIAdd(Ga), Ga = Ga.redIAdd(Ga), sa = Pa.redMul(ja.redISub(la)).redISub(Ga)
		}
		return this.curve.jpoint(la, sa, ca)
	}, aa.prototype._dbl = function() {
		var la = this.curve.a,
			sa = this.x,
			ca = this.y,
			ua = this.z,
			da = ua.redSqr().redSqr(),
			ha = sa.redSqr(),
			pa = ca.redSqr(),
			va = ha.redAdd(ha).redIAdd(ha).redIAdd(la.redMul(da)),
			ba = sa.redAdd(sa);
		ba = ba.redIAdd(ba);
		var Ea = ba.redMul(pa),
			Sa = va.redSqr().redISub(Ea.redAdd(Ea)),
			Ca = Ea.redISub(Sa),
			ka = pa.redSqr();
		ka = ka.redIAdd(ka), ka = ka.redIAdd(ka), ka = ka.redIAdd(ka);
		var Pa = va.redMul(Ca).redISub(ka),
			ja = ca.redAdd(ca).redMul(ua);
		return this.curve.jpoint(Sa, Pa, ja)
	}, aa.prototype.trpl = function() {
		if (!this.curve.zeroA) return this.dbl().add(this);
		var la = this.x.redSqr(),
			sa = this.y.redSqr(),
			ca = this.z.redSqr(),
			ua = sa.redSqr(),
			da = la.redAdd(la).redIAdd(la),
			ha = da.redSqr(),
			pa = this.x.redAdd(sa).redSqr().redISub(la).redISub(ua);
		pa = pa.redIAdd(pa), pa = pa.redAdd(pa).redIAdd(pa), pa = pa.redISub(ha);
		var va = pa.redSqr(),
			ba = ua.redIAdd(ua);
		ba = ba.redIAdd(ba), ba = ba.redIAdd(ba), ba = ba.redIAdd(ba);
		var Ea = da.redIAdd(pa).redSqr().redISub(ha).redISub(va).redISub(ba),
			Sa = sa.redMul(Ea);
		Sa = Sa.redIAdd(Sa), Sa = Sa.redIAdd(Sa);
		var Ca = this.x.redMul(va).redISub(Sa);
		Ca = Ca.redIAdd(Ca), Ca = Ca.redIAdd(Ca);
		var ka = this.y.redMul(Ea.redMul(ba.redISub(Ea)).redISub(pa.redMul(va)));
		ka = ka.redIAdd(ka), ka = ka.redIAdd(ka), ka = ka.redIAdd(ka);
		var Pa = this.z.redAdd(pa).redSqr().redISub(ca).redISub(va);
		return this.curve.jpoint(Ca, ka, Pa)
	}, aa.prototype.mul = function(la, sa) {
		return la = new Yi(la, sa), this.curve._wnafMul(this, la)
	}, aa.prototype.eq = function(la) {
		if (la.type === "affine") return this.eq(la.toJ());
		if (this === la) return !0;
		var sa = this.z.redSqr(),
			ca = la.z.redSqr();
		if (this.x.redMul(ca).redISub(la.x.redMul(sa)).cmpn(0) !== 0) return !1;
		var ua = sa.redMul(this.z),
			da = ca.redMul(la.z);
		return this.y.redMul(da).redISub(la.y.redMul(ua)).cmpn(0) === 0
	}, aa.prototype.eqXToP = function(la) {
		var sa = this.z.redSqr(),
			ca = la.toRed(this.curve.red).redMul(sa);
		if (this.x.cmp(ca) === 0) return !0;
		for (var ua = la.clone(), da = this.curve.redN.redMul(sa);;) {
			if (ua.iadd(this.curve.n), ua.cmp(this.curve.p) >= 0) return !1;
			if (ca.redIAdd(da), this.x.cmp(ca) === 0) return !0
		}
	}, aa.prototype.inspect = function() {
		return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
	}, aa.prototype.isInfinity = function() {
		return this.z.cmpn(0) === 0
	}, short
}
var mont, hasRequiredMont;

function requireMont() {
	if (hasRequiredMont) return mont;
	hasRequiredMont = 1;
	var ue = requireBn$2(),
		Yi = requireInherits_browser(),
		ea = requireBase$1(),
		ta = requireUtils$1();

	function na(ia) {
		ea.call(this, "mont", ia), this.a = new ue(ia.a, 16).toRed(this.red), this.b = new ue(ia.b, 16).toRed(this.red), this.i4 = new ue(4).toRed(this.red).redInvm(), this.two = new ue(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two))
	}
	Yi(na, ea), mont = na, na.prototype.validate = function(aa) {
		var oa = aa.normalize().x,
			la = oa.redSqr(),
			sa = la.redMul(oa).redAdd(la.redMul(this.a)).redAdd(oa),
			ca = sa.redSqrt();
		return ca.redSqr().cmp(sa) === 0
	};

	function ra(ia, aa, oa) {
		ea.BasePoint.call(this, ia, "projective"), aa === null && oa === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new ue(aa, 16), this.z = new ue(oa, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)))
	}
	return Yi(ra, ea.BasePoint), na.prototype.decodePoint = function(aa, oa) {
		return this.point(ta.toArray(aa, oa), 1)
	}, na.prototype.point = function(aa, oa) {
		return new ra(this, aa, oa)
	}, na.prototype.pointFromJSON = function(aa) {
		return ra.fromJSON(this, aa)
	}, ra.prototype.precompute = function() {}, ra.prototype._encode = function() {
		return this.getX().toArray("be", this.curve.p.byteLength())
	}, ra.fromJSON = function(aa, oa) {
		return new ra(aa, oa[0], oa[1] || aa.one)
	}, ra.prototype.inspect = function() {
		return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
	}, ra.prototype.isInfinity = function() {
		return this.z.cmpn(0) === 0
	}, ra.prototype.dbl = function() {
		var aa = this.x.redAdd(this.z),
			oa = aa.redSqr(),
			la = this.x.redSub(this.z),
			sa = la.redSqr(),
			ca = oa.redSub(sa),
			ua = oa.redMul(sa),
			da = ca.redMul(sa.redAdd(this.curve.a24.redMul(ca)));
		return this.curve.point(ua, da)
	}, ra.prototype.add = function() {
		throw new Error("Not supported on Montgomery curve")
	}, ra.prototype.diffAdd = function(aa, oa) {
		var la = this.x.redAdd(this.z),
			sa = this.x.redSub(this.z),
			ca = aa.x.redAdd(aa.z),
			ua = aa.x.redSub(aa.z),
			da = ua.redMul(la),
			ha = ca.redMul(sa),
			pa = oa.z.redMul(da.redAdd(ha).redSqr()),
			va = oa.x.redMul(da.redISub(ha).redSqr());
		return this.curve.point(pa, va)
	}, ra.prototype.mul = function(aa) {
		for (var oa = aa.clone(), la = this, sa = this.curve.point(null, null), ca = this, ua = []; oa.cmpn(0) !== 0; oa.iushrn(1)) ua.push(oa.andln(1));
		for (var da = ua.length - 1; da >= 0; da--) ua[da] === 0 ? (la = la.diffAdd(sa, ca), sa = sa.dbl()) : (sa = la.diffAdd(sa, ca), la = la.dbl());
		return sa
	}, ra.prototype.mulAdd = function() {
		throw new Error("Not supported on Montgomery curve")
	}, ra.prototype.jumlAdd = function() {
		throw new Error("Not supported on Montgomery curve")
	}, ra.prototype.eq = function(aa) {
		return this.getX().cmp(aa.getX()) === 0
	}, ra.prototype.normalize = function() {
		return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this
	}, ra.prototype.getX = function() {
		return this.normalize(), this.x.fromRed()
	}, mont
}
var edwards, hasRequiredEdwards;

function requireEdwards() {
	if (hasRequiredEdwards) return edwards;
	hasRequiredEdwards = 1;
	var ue = requireUtils$1(),
		Yi = requireBn$2(),
		ea = requireInherits_browser(),
		ta = requireBase$1(),
		na = ue.assert;

	function ra(aa) {
		this.twisted = (aa.a | 0) !== 1, this.mOneA = this.twisted && (aa.a | 0) === -1, this.extended = this.mOneA, ta.call(this, "edwards", aa), this.a = new Yi(aa.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Yi(aa.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Yi(aa.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), na(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (aa.c | 0) === 1
	}
	ea(ra, ta), edwards = ra, ra.prototype._mulA = function(oa) {
		return this.mOneA ? oa.redNeg() : this.a.redMul(oa)
	}, ra.prototype._mulC = function(oa) {
		return this.oneC ? oa : this.c.redMul(oa)
	}, ra.prototype.jpoint = function(oa, la, sa, ca) {
		return this.point(oa, la, sa, ca)
	}, ra.prototype.pointFromX = function(oa, la) {
		oa = new Yi(oa, 16), oa.red || (oa = oa.toRed(this.red));
		var sa = oa.redSqr(),
			ca = this.c2.redSub(this.a.redMul(sa)),
			ua = this.one.redSub(this.c2.redMul(this.d).redMul(sa)),
			da = ca.redMul(ua.redInvm()),
			ha = da.redSqrt();
		if (ha.redSqr().redSub(da).cmp(this.zero) !== 0) throw new Error("invalid point");
		var pa = ha.fromRed().isOdd();
		return (la && !pa || !la && pa) && (ha = ha.redNeg()), this.point(oa, ha)
	}, ra.prototype.pointFromY = function(oa, la) {
		oa = new Yi(oa, 16), oa.red || (oa = oa.toRed(this.red));
		var sa = oa.redSqr(),
			ca = sa.redSub(this.c2),
			ua = sa.redMul(this.d).redMul(this.c2).redSub(this.a),
			da = ca.redMul(ua.redInvm());
		if (da.cmp(this.zero) === 0) {
			if (la) throw new Error("invalid point");
			return this.point(this.zero, oa)
		}
		var ha = da.redSqrt();
		if (ha.redSqr().redSub(da).cmp(this.zero) !== 0) throw new Error("invalid point");
		return ha.fromRed().isOdd() !== la && (ha = ha.redNeg()), this.point(ha, oa)
	}, ra.prototype.validate = function(oa) {
		if (oa.isInfinity()) return !0;
		oa.normalize();
		var la = oa.x.redSqr(),
			sa = oa.y.redSqr(),
			ca = la.redMul(this.a).redAdd(sa),
			ua = this.c2.redMul(this.one.redAdd(this.d.redMul(la).redMul(sa)));
		return ca.cmp(ua) === 0
	};

	function ia(aa, oa, la, sa, ca) {
		ta.BasePoint.call(this, aa, "projective"), oa === null && la === null && sa === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new Yi(oa, 16), this.y = new Yi(la, 16), this.z = sa ? new Yi(sa, 16) : this.curve.one, this.t = ca && new Yi(ca, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))))
	}
	return ea(ia, ta.BasePoint), ra.prototype.pointFromJSON = function(oa) {
		return ia.fromJSON(this, oa)
	}, ra.prototype.point = function(oa, la, sa, ca) {
		return new ia(this, oa, la, sa, ca)
	}, ia.fromJSON = function(oa, la) {
		return new ia(oa, la[0], la[1], la[2])
	}, ia.prototype.inspect = function() {
		return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
	}, ia.prototype.isInfinity = function() {
		return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0)
	}, ia.prototype._extDbl = function() {
		var oa = this.x.redSqr(),
			la = this.y.redSqr(),
			sa = this.z.redSqr();
		sa = sa.redIAdd(sa);
		var ca = this.curve._mulA(oa),
			ua = this.x.redAdd(this.y).redSqr().redISub(oa).redISub(la),
			da = ca.redAdd(la),
			ha = da.redSub(sa),
			pa = ca.redSub(la),
			va = ua.redMul(ha),
			ba = da.redMul(pa),
			Ea = ua.redMul(pa),
			Sa = ha.redMul(da);
		return this.curve.point(va, ba, Sa, Ea)
	}, ia.prototype._projDbl = function() {
		var oa = this.x.redAdd(this.y).redSqr(),
			la = this.x.redSqr(),
			sa = this.y.redSqr(),
			ca, ua, da, ha, pa, va;
		if (this.curve.twisted) {
			ha = this.curve._mulA(la);
			var ba = ha.redAdd(sa);
			this.zOne ? (ca = oa.redSub(la).redSub(sa).redMul(ba.redSub(this.curve.two)), ua = ba.redMul(ha.redSub(sa)), da = ba.redSqr().redSub(ba).redSub(ba)) : (pa = this.z.redSqr(), va = ba.redSub(pa).redISub(pa), ca = oa.redSub(la).redISub(sa).redMul(va), ua = ba.redMul(ha.redSub(sa)), da = ba.redMul(va))
		} else ha = la.redAdd(sa), pa = this.curve._mulC(this.z).redSqr(), va = ha.redSub(pa).redSub(pa), ca = this.curve._mulC(oa.redISub(ha)).redMul(va), ua = this.curve._mulC(ha).redMul(la.redISub(sa)), da = ha.redMul(va);
		return this.curve.point(ca, ua, da)
	}, ia.prototype.dbl = function() {
		return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl()
	}, ia.prototype._extAdd = function(oa) {
		var la = this.y.redSub(this.x).redMul(oa.y.redSub(oa.x)),
			sa = this.y.redAdd(this.x).redMul(oa.y.redAdd(oa.x)),
			ca = this.t.redMul(this.curve.dd).redMul(oa.t),
			ua = this.z.redMul(oa.z.redAdd(oa.z)),
			da = sa.redSub(la),
			ha = ua.redSub(ca),
			pa = ua.redAdd(ca),
			va = sa.redAdd(la),
			ba = da.redMul(ha),
			Ea = pa.redMul(va),
			Sa = da.redMul(va),
			Ca = ha.redMul(pa);
		return this.curve.point(ba, Ea, Ca, Sa)
	}, ia.prototype._projAdd = function(oa) {
		var la = this.z.redMul(oa.z),
			sa = la.redSqr(),
			ca = this.x.redMul(oa.x),
			ua = this.y.redMul(oa.y),
			da = this.curve.d.redMul(ca).redMul(ua),
			ha = sa.redSub(da),
			pa = sa.redAdd(da),
			va = this.x.redAdd(this.y).redMul(oa.x.redAdd(oa.y)).redISub(ca).redISub(ua),
			ba = la.redMul(ha).redMul(va),
			Ea, Sa;
		return this.curve.twisted ? (Ea = la.redMul(pa).redMul(ua.redSub(this.curve._mulA(ca))), Sa = ha.redMul(pa)) : (Ea = la.redMul(pa).redMul(ua.redSub(ca)), Sa = this.curve._mulC(ha).redMul(pa)), this.curve.point(ba, Ea, Sa)
	}, ia.prototype.add = function(oa) {
		return this.isInfinity() ? oa : oa.isInfinity() ? this : this.curve.extended ? this._extAdd(oa) : this._projAdd(oa)
	}, ia.prototype.mul = function(oa) {
		return this._hasDoubles(oa) ? this.curve._fixedNafMul(this, oa) : this.curve._wnafMul(this, oa)
	}, ia.prototype.mulAdd = function(oa, la, sa) {
		return this.curve._wnafMulAdd(1, [this, la], [oa, sa], 2, !1)
	}, ia.prototype.jmulAdd = function(oa, la, sa) {
		return this.curve._wnafMulAdd(1, [this, la], [oa, sa], 2, !0)
	}, ia.prototype.normalize = function() {
		if (this.zOne) return this;
		var oa = this.z.redInvm();
		return this.x = this.x.redMul(oa), this.y = this.y.redMul(oa), this.t && (this.t = this.t.redMul(oa)), this.z = this.curve.one, this.zOne = !0, this
	}, ia.prototype.neg = function() {
		return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg())
	}, ia.prototype.getX = function() {
		return this.normalize(), this.x.fromRed()
	}, ia.prototype.getY = function() {
		return this.normalize(), this.y.fromRed()
	}, ia.prototype.eq = function(oa) {
		return this === oa || this.getX().cmp(oa.getX()) === 0 && this.getY().cmp(oa.getY()) === 0
	}, ia.prototype.eqXToP = function(oa) {
		var la = oa.toRed(this.curve.red).redMul(this.z);
		if (this.x.cmp(la) === 0) return !0;
		for (var sa = oa.clone(), ca = this.curve.redN.redMul(this.z);;) {
			if (sa.iadd(this.curve.n), sa.cmp(this.curve.p) >= 0) return !1;
			if (la.redIAdd(ca), this.x.cmp(la) === 0) return !0
		}
	}, ia.prototype.toP = ia.prototype.normalize, ia.prototype.mixedAdd = ia.prototype.add, edwards
}
var hasRequiredCurve;

function requireCurve() {
	return hasRequiredCurve || (hasRequiredCurve = 1, function(ue) {
		var Yi = ue;
		Yi.base = requireBase$1(), Yi.short = requireShort(), Yi.mont = requireMont(), Yi.edwards = requireEdwards()
	}(curve)), curve
}
var curves = {},
	hash = {},
	utils = {},
	hasRequiredUtils;

function requireUtils() {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	var ue = requireMinimalisticAssert(),
		Yi = requireInherits_browser();
	utils.inherits = Yi;

	function ea(xa, ma) {
		return (xa.charCodeAt(ma) & 64512) !== 55296 || ma < 0 || ma + 1 >= xa.length ? !1 : (xa.charCodeAt(ma + 1) & 64512) === 56320
	}

	function ta(xa, ma) {
		if (Array.isArray(xa)) return xa.slice();
		if (!xa) return [];
		var fa = [];
		if (typeof xa == "string")
			if (ma) {
				if (ma === "hex")
					for (xa = xa.replace(/[^a-z0-9]+/ig, ""), xa.length % 2 !== 0 && (xa = "0" + xa), wa = 0; wa < xa.length; wa += 2) fa.push(parseInt(xa[wa] + xa[wa + 1], 16))
			} else
				for (var ga = 0, wa = 0; wa < xa.length; wa++) {
					var Ma = xa.charCodeAt(wa);
					Ma < 128 ? fa[ga++] = Ma : Ma < 2048 ? (fa[ga++] = Ma >> 6 | 192, fa[ga++] = Ma & 63 | 128) : ea(xa, wa) ? (Ma = 65536 + ((Ma & 1023) << 10) + (xa.charCodeAt(++wa) & 1023), fa[ga++] = Ma >> 18 | 240, fa[ga++] = Ma >> 12 & 63 | 128, fa[ga++] = Ma >> 6 & 63 | 128, fa[ga++] = Ma & 63 | 128) : (fa[ga++] = Ma >> 12 | 224, fa[ga++] = Ma >> 6 & 63 | 128, fa[ga++] = Ma & 63 | 128)
				} else
					for (wa = 0; wa < xa.length; wa++) fa[wa] = xa[wa] | 0;
		return fa
	}
	utils.toArray = ta;

	function na(xa) {
		for (var ma = "", fa = 0; fa < xa.length; fa++) ma += aa(xa[fa].toString(16));
		return ma
	}
	utils.toHex = na;

	function ra(xa) {
		var ma = xa >>> 24 | xa >>> 8 & 65280 | xa << 8 & 16711680 | (xa & 255) << 24;
		return ma >>> 0
	}
	utils.htonl = ra;

	function ia(xa, ma) {
		for (var fa = "", ga = 0; ga < xa.length; ga++) {
			var wa = xa[ga];
			ma === "little" && (wa = ra(wa)), fa += oa(wa.toString(16))
		}
		return fa
	}
	utils.toHex32 = ia;

	function aa(xa) {
		return xa.length === 1 ? "0" + xa : xa
	}
	utils.zero2 = aa;

	function oa(xa) {
		return xa.length === 7 ? "0" + xa : xa.length === 6 ? "00" + xa : xa.length === 5 ? "000" + xa : xa.length === 4 ? "0000" + xa : xa.length === 3 ? "00000" + xa : xa.length === 2 ? "000000" + xa : xa.length === 1 ? "0000000" + xa : xa
	}
	utils.zero8 = oa;

	function la(xa, ma, fa, ga) {
		var wa = fa - ma;
		ue(wa % 4 === 0);
		for (var Ma = new Array(wa / 4), Aa = 0, Ra = ma; Aa < Ma.length; Aa++, Ra += 4) {
			var Ta;
			ga === "big" ? Ta = xa[Ra] << 24 | xa[Ra + 1] << 16 | xa[Ra + 2] << 8 | xa[Ra + 3] : Ta = xa[Ra + 3] << 24 | xa[Ra + 2] << 16 | xa[Ra + 1] << 8 | xa[Ra], Ma[Aa] = Ta >>> 0
		}
		return Ma
	}
	utils.join32 = la;

	function sa(xa, ma) {
		for (var fa = new Array(xa.length * 4), ga = 0, wa = 0; ga < xa.length; ga++, wa += 4) {
			var Ma = xa[ga];
			ma === "big" ? (fa[wa] = Ma >>> 24, fa[wa + 1] = Ma >>> 16 & 255, fa[wa + 2] = Ma >>> 8 & 255, fa[wa + 3] = Ma & 255) : (fa[wa + 3] = Ma >>> 24, fa[wa + 2] = Ma >>> 16 & 255, fa[wa + 1] = Ma >>> 8 & 255, fa[wa] = Ma & 255)
		}
		return fa
	}
	utils.split32 = sa;

	function ca(xa, ma) {
		return xa >>> ma | xa << 32 - ma
	}
	utils.rotr32 = ca;

	function ua(xa, ma) {
		return xa << ma | xa >>> 32 - ma
	}
	utils.rotl32 = ua;

	function da(xa, ma) {
		return xa + ma >>> 0
	}
	utils.sum32 = da;

	function ha(xa, ma, fa) {
		return xa + ma + fa >>> 0
	}
	utils.sum32_3 = ha;

	function pa(xa, ma, fa, ga) {
		return xa + ma + fa + ga >>> 0
	}
	utils.sum32_4 = pa;

	function va(xa, ma, fa, ga, wa) {
		return xa + ma + fa + ga + wa >>> 0
	}
	utils.sum32_5 = va;

	function ba(xa, ma, fa, ga) {
		var wa = xa[ma],
			Ma = xa[ma + 1],
			Aa = ga + Ma >>> 0,
			Ra = (Aa < ga ? 1 : 0) + fa + wa;
		xa[ma] = Ra >>> 0, xa[ma + 1] = Aa
	}
	utils.sum64 = ba;

	function Ea(xa, ma, fa, ga) {
		var wa = ma + ga >>> 0,
			Ma = (wa < ma ? 1 : 0) + xa + fa;
		return Ma >>> 0
	}
	utils.sum64_hi = Ea;

	function Sa(xa, ma, fa, ga) {
		var wa = ma + ga;
		return wa >>> 0
	}
	utils.sum64_lo = Sa;

	function Ca(xa, ma, fa, ga, wa, Ma, Aa, Ra) {
		var Ta = 0,
			La = ma;
		La = La + ga >>> 0, Ta += La < ma ? 1 : 0, La = La + Ma >>> 0, Ta += La < Ma ? 1 : 0, La = La + Ra >>> 0, Ta += La < Ra ? 1 : 0;
		var ya = xa + fa + wa + Aa + Ta;
		return ya >>> 0
	}
	utils.sum64_4_hi = Ca;

	function ka(xa, ma, fa, ga, wa, Ma, Aa, Ra) {
		var Ta = ma + ga + Ma + Ra;
		return Ta >>> 0
	}
	utils.sum64_4_lo = ka;

	function Pa(xa, ma, fa, ga, wa, Ma, Aa, Ra, Ta, La) {
		var ya = 0,
			Ba = ma;
		Ba = Ba + ga >>> 0, ya += Ba < ma ? 1 : 0, Ba = Ba + Ma >>> 0, ya += Ba < Ma ? 1 : 0, Ba = Ba + Ra >>> 0, ya += Ba < Ra ? 1 : 0, Ba = Ba + La >>> 0, ya += Ba < La ? 1 : 0;
		var io = xa + fa + wa + Aa + Ta + ya;
		return io >>> 0
	}
	utils.sum64_5_hi = Pa;

	function ja(xa, ma, fa, ga, wa, Ma, Aa, Ra, Ta, La) {
		var ya = ma + ga + Ma + Ra + La;
		return ya >>> 0
	}
	utils.sum64_5_lo = ja;

	function Za(xa, ma, fa) {
		var ga = ma << 32 - fa | xa >>> fa;
		return ga >>> 0
	}
	utils.rotr64_hi = Za;

	function Ga(xa, ma, fa) {
		var ga = xa << 32 - fa | ma >>> fa;
		return ga >>> 0
	}
	utils.rotr64_lo = Ga;

	function Ja(xa, ma, fa) {
		return xa >>> fa
	}
	utils.shr64_hi = Ja;

	function Ua(xa, ma, fa) {
		var ga = xa << 32 - fa | ma >>> fa;
		return ga >>> 0
	}
	return utils.shr64_lo = Ua, utils
}
var common$1 = {},
	hasRequiredCommon$1;

function requireCommon$1() {
	if (hasRequiredCommon$1) return common$1;
	hasRequiredCommon$1 = 1;
	var ue = requireUtils(),
		Yi = requireMinimalisticAssert();

	function ea() {
		this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32
	}
	return common$1.BlockHash = ea, ea.prototype.update = function(na, ra) {
		if (na = ue.toArray(na, ra), this.pending ? this.pending = this.pending.concat(na) : this.pending = na, this.pendingTotal += na.length, this.pending.length >= this._delta8) {
			na = this.pending;
			var ia = na.length % this._delta8;
			this.pending = na.slice(na.length - ia, na.length), this.pending.length === 0 && (this.pending = null), na = ue.join32(na, 0, na.length - ia, this.endian);
			for (var aa = 0; aa < na.length; aa += this._delta32) this._update(na, aa, aa + this._delta32)
		}
		return this
	}, ea.prototype.digest = function(na) {
		return this.update(this._pad()), Yi(this.pending === null), this._digest(na)
	}, ea.prototype._pad = function() {
		var na = this.pendingTotal,
			ra = this._delta8,
			ia = ra - (na + this.padLength) % ra,
			aa = new Array(ia + this.padLength);
		aa[0] = 128;
		for (var oa = 1; oa < ia; oa++) aa[oa] = 0;
		if (na <<= 3, this.endian === "big") {
			for (var la = 8; la < this.padLength; la++) aa[oa++] = 0;
			aa[oa++] = 0, aa[oa++] = 0, aa[oa++] = 0, aa[oa++] = 0, aa[oa++] = na >>> 24 & 255, aa[oa++] = na >>> 16 & 255, aa[oa++] = na >>> 8 & 255, aa[oa++] = na & 255
		} else
			for (aa[oa++] = na & 255, aa[oa++] = na >>> 8 & 255, aa[oa++] = na >>> 16 & 255, aa[oa++] = na >>> 24 & 255, aa[oa++] = 0, aa[oa++] = 0, aa[oa++] = 0, aa[oa++] = 0, la = 8; la < this.padLength; la++) aa[oa++] = 0;
		return aa
	}, common$1
}
var sha = {},
	common = {},
	hasRequiredCommon;

function requireCommon() {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	var ue = requireUtils(),
		Yi = ue.rotr32;

	function ea(sa, ca, ua, da) {
		if (sa === 0) return ta(ca, ua, da);
		if (sa === 1 || sa === 3) return ra(ca, ua, da);
		if (sa === 2) return na(ca, ua, da)
	}
	common.ft_1 = ea;

	function ta(sa, ca, ua) {
		return sa & ca ^ ~sa & ua
	}
	common.ch32 = ta;

	function na(sa, ca, ua) {
		return sa & ca ^ sa & ua ^ ca & ua
	}
	common.maj32 = na;

	function ra(sa, ca, ua) {
		return sa ^ ca ^ ua
	}
	common.p32 = ra;

	function ia(sa) {
		return Yi(sa, 2) ^ Yi(sa, 13) ^ Yi(sa, 22)
	}
	common.s0_256 = ia;

	function aa(sa) {
		return Yi(sa, 6) ^ Yi(sa, 11) ^ Yi(sa, 25)
	}
	common.s1_256 = aa;

	function oa(sa) {
		return Yi(sa, 7) ^ Yi(sa, 18) ^ sa >>> 3
	}
	common.g0_256 = oa;

	function la(sa) {
		return Yi(sa, 17) ^ Yi(sa, 19) ^ sa >>> 10
	}
	return common.g1_256 = la, common
}
var _1, hasRequired_1;

function require_1() {
	if (hasRequired_1) return _1;
	hasRequired_1 = 1;
	var ue = requireUtils(),
		Yi = requireCommon$1(),
		ea = requireCommon(),
		ta = ue.rotl32,
		na = ue.sum32,
		ra = ue.sum32_5,
		ia = ea.ft_1,
		aa = Yi.BlockHash,
		oa = [1518500249, 1859775393, 2400959708, 3395469782];

	function la() {
		if (!(this instanceof la)) return new la;
		aa.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80)
	}
	return ue.inherits(la, aa), _1 = la, la.blockSize = 512, la.outSize = 160, la.hmacStrength = 80, la.padLength = 64, la.prototype._update = function(ca, ua) {
		for (var da = this.W, ha = 0; ha < 16; ha++) da[ha] = ca[ua + ha];
		for (; ha < da.length; ha++) da[ha] = ta(da[ha - 3] ^ da[ha - 8] ^ da[ha - 14] ^ da[ha - 16], 1);
		var pa = this.h[0],
			va = this.h[1],
			ba = this.h[2],
			Ea = this.h[3],
			Sa = this.h[4];
		for (ha = 0; ha < da.length; ha++) {
			var Ca = ~~(ha / 20),
				ka = ra(ta(pa, 5), ia(Ca, va, ba, Ea), Sa, da[ha], oa[Ca]);
			Sa = Ea, Ea = ba, ba = ta(va, 30), va = pa, pa = ka
		}
		this.h[0] = na(this.h[0], pa), this.h[1] = na(this.h[1], va), this.h[2] = na(this.h[2], ba), this.h[3] = na(this.h[3], Ea), this.h[4] = na(this.h[4], Sa)
	}, la.prototype._digest = function(ca) {
		return ca === "hex" ? ue.toHex32(this.h, "big") : ue.split32(this.h, "big")
	}, _1
}
var _256, hasRequired_256;

function require_256() {
	if (hasRequired_256) return _256;
	hasRequired_256 = 1;
	var ue = requireUtils(),
		Yi = requireCommon$1(),
		ea = requireCommon(),
		ta = requireMinimalisticAssert(),
		na = ue.sum32,
		ra = ue.sum32_4,
		ia = ue.sum32_5,
		aa = ea.ch32,
		oa = ea.maj32,
		la = ea.s0_256,
		sa = ea.s1_256,
		ca = ea.g0_256,
		ua = ea.g1_256,
		da = Yi.BlockHash,
		ha = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];

	function pa() {
		if (!(this instanceof pa)) return new pa;
		da.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = ha, this.W = new Array(64)
	}
	return ue.inherits(pa, da), _256 = pa, pa.blockSize = 512, pa.outSize = 256, pa.hmacStrength = 192, pa.padLength = 64, pa.prototype._update = function(ba, Ea) {
		for (var Sa = this.W, Ca = 0; Ca < 16; Ca++) Sa[Ca] = ba[Ea + Ca];
		for (; Ca < Sa.length; Ca++) Sa[Ca] = ra(ua(Sa[Ca - 2]), Sa[Ca - 7], ca(Sa[Ca - 15]), Sa[Ca - 16]);
		var ka = this.h[0],
			Pa = this.h[1],
			ja = this.h[2],
			Za = this.h[3],
			Ga = this.h[4],
			Ja = this.h[5],
			Ua = this.h[6],
			xa = this.h[7];
		for (ta(this.k.length === Sa.length), Ca = 0; Ca < Sa.length; Ca++) {
			var ma = ia(xa, sa(Ga), aa(Ga, Ja, Ua), this.k[Ca], Sa[Ca]),
				fa = na(la(ka), oa(ka, Pa, ja));
			xa = Ua, Ua = Ja, Ja = Ga, Ga = na(Za, ma), Za = ja, ja = Pa, Pa = ka, ka = na(ma, fa)
		}
		this.h[0] = na(this.h[0], ka), this.h[1] = na(this.h[1], Pa), this.h[2] = na(this.h[2], ja), this.h[3] = na(this.h[3], Za), this.h[4] = na(this.h[4], Ga), this.h[5] = na(this.h[5], Ja), this.h[6] = na(this.h[6], Ua), this.h[7] = na(this.h[7], xa)
	}, pa.prototype._digest = function(ba) {
		return ba === "hex" ? ue.toHex32(this.h, "big") : ue.split32(this.h, "big")
	}, _256
}
var _224, hasRequired_224;

function require_224() {
	if (hasRequired_224) return _224;
	hasRequired_224 = 1;
	var ue = requireUtils(),
		Yi = require_256();

	function ea() {
		if (!(this instanceof ea)) return new ea;
		Yi.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
	}
	return ue.inherits(ea, Yi), _224 = ea, ea.blockSize = 512, ea.outSize = 224, ea.hmacStrength = 192, ea.padLength = 64, ea.prototype._digest = function(na) {
		return na === "hex" ? ue.toHex32(this.h.slice(0, 7), "big") : ue.split32(this.h.slice(0, 7), "big")
	}, _224
}
var _512, hasRequired_512;

function require_512() {
	if (hasRequired_512) return _512;
	hasRequired_512 = 1;
	var ue = requireUtils(),
		Yi = requireCommon$1(),
		ea = requireMinimalisticAssert(),
		ta = ue.rotr64_hi,
		na = ue.rotr64_lo,
		ra = ue.shr64_hi,
		ia = ue.shr64_lo,
		aa = ue.sum64,
		oa = ue.sum64_hi,
		la = ue.sum64_lo,
		sa = ue.sum64_4_hi,
		ca = ue.sum64_4_lo,
		ua = ue.sum64_5_hi,
		da = ue.sum64_5_lo,
		ha = Yi.BlockHash,
		pa = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

	function va() {
		if (!(this instanceof va)) return new va;
		ha.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = pa, this.W = new Array(160)
	}
	ue.inherits(va, ha), _512 = va, va.blockSize = 1024, va.outSize = 512, va.hmacStrength = 192, va.padLength = 128, va.prototype._prepareBlock = function(fa, ga) {
		for (var wa = this.W, Ma = 0; Ma < 32; Ma++) wa[Ma] = fa[ga + Ma];
		for (; Ma < wa.length; Ma += 2) {
			var Aa = Ua(wa[Ma - 4], wa[Ma - 3]),
				Ra = xa(wa[Ma - 4], wa[Ma - 3]),
				Ta = wa[Ma - 14],
				La = wa[Ma - 13],
				ya = Ga(wa[Ma - 30], wa[Ma - 29]),
				Ba = Ja(wa[Ma - 30], wa[Ma - 29]),
				io = wa[Ma - 32],
				oo = wa[Ma - 31];
			wa[Ma] = sa(Aa, Ra, Ta, La, ya, Ba, io, oo), wa[Ma + 1] = ca(Aa, Ra, Ta, La, ya, Ba, io, oo)
		}
	}, va.prototype._update = function(fa, ga) {
		this._prepareBlock(fa, ga);
		var wa = this.W,
			Ma = this.h[0],
			Aa = this.h[1],
			Ra = this.h[2],
			Ta = this.h[3],
			La = this.h[4],
			ya = this.h[5],
			Ba = this.h[6],
			io = this.h[7],
			oo = this.h[8],
			ao = this.h[9],
			Ia = this.h[10],
			Na = this.h[11],
			za = this.h[12],
			ro = this.h[13],
			Va = this.h[14],
			Wa = this.h[15];
		ea(this.k.length === wa.length);
		for (var qa = 0; qa < wa.length; qa += 2) {
			var Ka = Va,
				lo = Wa,
				yo = ja(oo, ao),
				fo = Za(oo, ao),
				vo = ba(oo, ao, Ia, Na, za),
				so = Ea(oo, ao, Ia, Na, za, ro),
				Xa = this.k[qa],
				to = this.k[qa + 1],
				ho = wa[qa],
				Eo = wa[qa + 1],
				wo = ua(Ka, lo, yo, fo, vo, so, Xa, to, ho, Eo),
				Ao = da(Ka, lo, yo, fo, vo, so, Xa, to, ho, Eo);
			Ka = ka(Ma, Aa), lo = Pa(Ma, Aa), yo = Sa(Ma, Aa, Ra, Ta, La), fo = Ca(Ma, Aa, Ra, Ta, La, ya);
			var _o = oa(Ka, lo, yo, fo),
				Lo = la(Ka, lo, yo, fo);
			Va = za, Wa = ro, za = Ia, ro = Na, Ia = oo, Na = ao, oo = oa(Ba, io, wo, Ao), ao = la(io, io, wo, Ao), Ba = La, io = ya, La = Ra, ya = Ta, Ra = Ma, Ta = Aa, Ma = oa(wo, Ao, _o, Lo), Aa = la(wo, Ao, _o, Lo)
		}
		aa(this.h, 0, Ma, Aa), aa(this.h, 2, Ra, Ta), aa(this.h, 4, La, ya), aa(this.h, 6, Ba, io), aa(this.h, 8, oo, ao), aa(this.h, 10, Ia, Na), aa(this.h, 12, za, ro), aa(this.h, 14, Va, Wa)
	}, va.prototype._digest = function(fa) {
		return fa === "hex" ? ue.toHex32(this.h, "big") : ue.split32(this.h, "big")
	};

	function ba(ma, fa, ga, wa, Ma) {
		var Aa = ma & ga ^ ~ma & Ma;
		return Aa < 0 && (Aa += 4294967296), Aa
	}

	function Ea(ma, fa, ga, wa, Ma, Aa) {
		var Ra = fa & wa ^ ~fa & Aa;
		return Ra < 0 && (Ra += 4294967296), Ra
	}

	function Sa(ma, fa, ga, wa, Ma) {
		var Aa = ma & ga ^ ma & Ma ^ ga & Ma;
		return Aa < 0 && (Aa += 4294967296), Aa
	}

	function Ca(ma, fa, ga, wa, Ma, Aa) {
		var Ra = fa & wa ^ fa & Aa ^ wa & Aa;
		return Ra < 0 && (Ra += 4294967296), Ra
	}

	function ka(ma, fa) {
		var ga = ta(ma, fa, 28),
			wa = ta(fa, ma, 2),
			Ma = ta(fa, ma, 7),
			Aa = ga ^ wa ^ Ma;
		return Aa < 0 && (Aa += 4294967296), Aa
	}

	function Pa(ma, fa) {
		var ga = na(ma, fa, 28),
			wa = na(fa, ma, 2),
			Ma = na(fa, ma, 7),
			Aa = ga ^ wa ^ Ma;
		return Aa < 0 && (Aa += 4294967296), Aa
	}

	function ja(ma, fa) {
		var ga = ta(ma, fa, 14),
			wa = ta(ma, fa, 18),
			Ma = ta(fa, ma, 9),
			Aa = ga ^ wa ^ Ma;
		return Aa < 0 && (Aa += 4294967296), Aa
	}

	function Za(ma, fa) {
		var ga = na(ma, fa, 14),
			wa = na(ma, fa, 18),
			Ma = na(fa, ma, 9),
			Aa = ga ^ wa ^ Ma;
		return Aa < 0 && (Aa += 4294967296), Aa
	}

	function Ga(ma, fa) {
		var ga = ta(ma, fa, 1),
			wa = ta(ma, fa, 8),
			Ma = ra(ma, fa, 7),
			Aa = ga ^ wa ^ Ma;
		return Aa < 0 && (Aa += 4294967296), Aa
	}

	function Ja(ma, fa) {
		var ga = na(ma, fa, 1),
			wa = na(ma, fa, 8),
			Ma = ia(ma, fa, 7),
			Aa = ga ^ wa ^ Ma;
		return Aa < 0 && (Aa += 4294967296), Aa
	}

	function Ua(ma, fa) {
		var ga = ta(ma, fa, 19),
			wa = ta(fa, ma, 29),
			Ma = ra(ma, fa, 6),
			Aa = ga ^ wa ^ Ma;
		return Aa < 0 && (Aa += 4294967296), Aa
	}

	function xa(ma, fa) {
		var ga = na(ma, fa, 19),
			wa = na(fa, ma, 29),
			Ma = ia(ma, fa, 6),
			Aa = ga ^ wa ^ Ma;
		return Aa < 0 && (Aa += 4294967296), Aa
	}
	return _512
}
var _384, hasRequired_384;

function require_384() {
	if (hasRequired_384) return _384;
	hasRequired_384 = 1;
	var ue = requireUtils(),
		Yi = require_512();

	function ea() {
		if (!(this instanceof ea)) return new ea;
		Yi.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
	}
	return ue.inherits(ea, Yi), _384 = ea, ea.blockSize = 1024, ea.outSize = 384, ea.hmacStrength = 192, ea.padLength = 128, ea.prototype._digest = function(na) {
		return na === "hex" ? ue.toHex32(this.h.slice(0, 12), "big") : ue.split32(this.h.slice(0, 12), "big")
	}, _384
}
var hasRequiredSha;

function requireSha() {
	return hasRequiredSha || (hasRequiredSha = 1, sha.sha1 = require_1(), sha.sha224 = require_224(), sha.sha256 = require_256(), sha.sha384 = require_384(), sha.sha512 = require_512()), sha
}
var ripemd = {},
	hasRequiredRipemd;

function requireRipemd() {
	if (hasRequiredRipemd) return ripemd;
	hasRequiredRipemd = 1;
	var ue = requireUtils(),
		Yi = requireCommon$1(),
		ea = ue.rotl32,
		ta = ue.sum32,
		na = ue.sum32_3,
		ra = ue.sum32_4,
		ia = Yi.BlockHash;

	function aa() {
		if (!(this instanceof aa)) return new aa;
		ia.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little"
	}
	ue.inherits(aa, ia), ripemd.ripemd160 = aa, aa.blockSize = 512, aa.outSize = 160, aa.hmacStrength = 192, aa.padLength = 64, aa.prototype._update = function(va, ba) {
		for (var Ea = this.h[0], Sa = this.h[1], Ca = this.h[2], ka = this.h[3], Pa = this.h[4], ja = Ea, Za = Sa, Ga = Ca, Ja = ka, Ua = Pa, xa = 0; xa < 80; xa++) {
			var ma = ta(ea(ra(Ea, oa(xa, Sa, Ca, ka), va[ca[xa] + ba], la(xa)), da[xa]), Pa);
			Ea = Pa, Pa = ka, ka = ea(Ca, 10), Ca = Sa, Sa = ma, ma = ta(ea(ra(ja, oa(79 - xa, Za, Ga, Ja), va[ua[xa] + ba], sa(xa)), ha[xa]), Ua), ja = Ua, Ua = Ja, Ja = ea(Ga, 10), Ga = Za, Za = ma
		}
		ma = na(this.h[1], Ca, Ja), this.h[1] = na(this.h[2], ka, Ua), this.h[2] = na(this.h[3], Pa, ja), this.h[3] = na(this.h[4], Ea, Za), this.h[4] = na(this.h[0], Sa, Ga), this.h[0] = ma
	}, aa.prototype._digest = function(va) {
		return va === "hex" ? ue.toHex32(this.h, "little") : ue.split32(this.h, "little")
	};

	function oa(pa, va, ba, Ea) {
		return pa <= 15 ? va ^ ba ^ Ea : pa <= 31 ? va & ba | ~va & Ea : pa <= 47 ? (va | ~ba) ^ Ea : pa <= 63 ? va & Ea | ba & ~Ea : va ^ (ba | ~Ea)
	}

	function la(pa) {
		return pa <= 15 ? 0 : pa <= 31 ? 1518500249 : pa <= 47 ? 1859775393 : pa <= 63 ? 2400959708 : 2840853838
	}

	function sa(pa) {
		return pa <= 15 ? 1352829926 : pa <= 31 ? 1548603684 : pa <= 47 ? 1836072691 : pa <= 63 ? 2053994217 : 0
	}
	var ca = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
		ua = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
		da = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
		ha = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
	return ripemd
}
var hmac, hasRequiredHmac;

function requireHmac() {
	if (hasRequiredHmac) return hmac;
	hasRequiredHmac = 1;
	var ue = requireUtils(),
		Yi = requireMinimalisticAssert();

	function ea(ta, na, ra) {
		if (!(this instanceof ea)) return new ea(ta, na, ra);
		this.Hash = ta, this.blockSize = ta.blockSize / 8, this.outSize = ta.outSize / 8, this.inner = null, this.outer = null, this._init(ue.toArray(na, ra))
	}
	return hmac = ea, ea.prototype._init = function(na) {
		na.length > this.blockSize && (na = new this.Hash().update(na).digest()), Yi(na.length <= this.blockSize);
		for (var ra = na.length; ra < this.blockSize; ra++) na.push(0);
		for (ra = 0; ra < na.length; ra++) na[ra] ^= 54;
		for (this.inner = new this.Hash().update(na), ra = 0; ra < na.length; ra++) na[ra] ^= 106;
		this.outer = new this.Hash().update(na)
	}, ea.prototype.update = function(na, ra) {
		return this.inner.update(na, ra), this
	}, ea.prototype.digest = function(na) {
		return this.outer.update(this.inner.digest()), this.outer.digest(na)
	}, hmac
}
var hasRequiredHash;

function requireHash() {
	return hasRequiredHash || (hasRequiredHash = 1, function(ue) {
		var Yi = ue;
		Yi.utils = requireUtils(), Yi.common = requireCommon$1(), Yi.sha = requireSha(), Yi.ripemd = requireRipemd(), Yi.hmac = requireHmac(), Yi.sha1 = Yi.sha.sha1, Yi.sha256 = Yi.sha.sha256, Yi.sha224 = Yi.sha.sha224, Yi.sha384 = Yi.sha.sha384, Yi.sha512 = Yi.sha.sha512, Yi.ripemd160 = Yi.ripemd.ripemd160
	}(hash)), hash
}
var secp256k1, hasRequiredSecp256k1;

function requireSecp256k1() {
	return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
		doubles: {
			step: 4,
			points: [
				["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"],
				["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"],
				["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"],
				["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"],
				["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"],
				["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"],
				["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"],
				["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"],
				["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"],
				["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"],
				["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"],
				["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"],
				["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"],
				["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"],
				["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"],
				["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"],
				["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"],
				["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"],
				["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"],
				["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"],
				["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"],
				["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"],
				["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"],
				["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"],
				["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"],
				["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"],
				["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"],
				["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"],
				["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"],
				["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"],
				["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"],
				["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"],
				["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"],
				["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"],
				["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"],
				["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"],
				["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"],
				["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"],
				["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"],
				["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"],
				["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"],
				["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"],
				["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"],
				["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"],
				["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"],
				["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"],
				["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"],
				["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"],
				["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"],
				["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"],
				["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"],
				["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"],
				["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"],
				["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"],
				["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"],
				["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"],
				["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"],
				["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"],
				["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"],
				["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"],
				["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"],
				["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"],
				["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"],
				["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"],
				["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]
			]
		},
		naf: {
			wnd: 7,
			points: [
				["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"],
				["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"],
				["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"],
				["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"],
				["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"],
				["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"],
				["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"],
				["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"],
				["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"],
				["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"],
				["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"],
				["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"],
				["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"],
				["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"],
				["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"],
				["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"],
				["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"],
				["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"],
				["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"],
				["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"],
				["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"],
				["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"],
				["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"],
				["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"],
				["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"],
				["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"],
				["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"],
				["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"],
				["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"],
				["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"],
				["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"],
				["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"],
				["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"],
				["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"],
				["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"],
				["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"],
				["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"],
				["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"],
				["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"],
				["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"],
				["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"],
				["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"],
				["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"],
				["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"],
				["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"],
				["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"],
				["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"],
				["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"],
				["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"],
				["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"],
				["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"],
				["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"],
				["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"],
				["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"],
				["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"],
				["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"],
				["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"],
				["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"],
				["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"],
				["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"],
				["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"],
				["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"],
				["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"],
				["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"],
				["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"],
				["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"],
				["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"],
				["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"],
				["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"],
				["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"],
				["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"],
				["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"],
				["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"],
				["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"],
				["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"],
				["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"],
				["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"],
				["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"],
				["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"],
				["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"],
				["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"],
				["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"],
				["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"],
				["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"],
				["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"],
				["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"],
				["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"],
				["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"],
				["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"],
				["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"],
				["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"],
				["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"],
				["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"],
				["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"],
				["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"],
				["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"],
				["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"],
				["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"],
				["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"],
				["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"],
				["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"],
				["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"],
				["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"],
				["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"],
				["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"],
				["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"],
				["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"],
				["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"],
				["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"],
				["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"],
				["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"],
				["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"],
				["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"],
				["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"],
				["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"],
				["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"],
				["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"],
				["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"],
				["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"],
				["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"],
				["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"],
				["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"],
				["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"],
				["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"],
				["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"],
				["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"],
				["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]
			]
		}
	}), secp256k1
}
var hasRequiredCurves;

function requireCurves() {
	return hasRequiredCurves || (hasRequiredCurves = 1, function(ue) {
		var Yi = ue,
			ea = requireHash(),
			ta = requireCurve(),
			na = requireUtils$1(),
			ra = na.assert;

		function ia(la) {
			la.type === "short" ? this.curve = new ta.short(la) : la.type === "edwards" ? this.curve = new ta.edwards(la) : this.curve = new ta.mont(la), this.g = this.curve.g, this.n = this.curve.n, this.hash = la.hash, ra(this.g.validate(), "Invalid curve"), ra(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
		}
		Yi.PresetCurve = ia;

		function aa(la, sa) {
			Object.defineProperty(Yi, la, {
				configurable: !0,
				enumerable: !0,
				get: function() {
					var ca = new ia(sa);
					return Object.defineProperty(Yi, la, {
						configurable: !0,
						enumerable: !0,
						value: ca
					}), ca
				}
			})
		}
		aa("p192", {
			type: "short",
			prime: "p192",
			p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
			a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
			b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
			n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
			hash: ea.sha256,
			gRed: !1,
			g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
		}), aa("p224", {
			type: "short",
			prime: "p224",
			p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
			a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
			b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
			n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
			hash: ea.sha256,
			gRed: !1,
			g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
		}), aa("p256", {
			type: "short",
			prime: null,
			p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
			a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
			b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
			n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
			hash: ea.sha256,
			gRed: !1,
			g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
		}), aa("p384", {
			type: "short",
			prime: null,
			p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
			a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
			b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
			n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
			hash: ea.sha384,
			gRed: !1,
			g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
		}), aa("p521", {
			type: "short",
			prime: null,
			p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
			a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
			b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
			n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
			hash: ea.sha512,
			gRed: !1,
			g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
		}), aa("curve25519", {
			type: "mont",
			prime: "p25519",
			p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
			a: "76d06",
			b: "1",
			n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
			hash: ea.sha256,
			gRed: !1,
			g: ["9"]
		}), aa("ed25519", {
			type: "edwards",
			prime: "p25519",
			p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
			a: "-1",
			c: "1",
			d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
			n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
			hash: ea.sha256,
			gRed: !1,
			g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
		});
		var oa;
		try {
			oa = requireSecp256k1()
		} catch {
			oa = void 0
		}
		aa("secp256k1", {
			type: "short",
			prime: "k256",
			p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
			a: "0",
			b: "7",
			n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
			h: "1",
			hash: ea.sha256,
			beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
			lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
			basis: [{
				a: "3086d221a7d46bcde86c90e49284eb15",
				b: "-e4437ed6010e88286f547fa90abfe4c3"
			}, {
				a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
				b: "3086d221a7d46bcde86c90e49284eb15"
			}],
			gRed: !1,
			g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", oa]
		})
	}(curves)), curves
}
var hmacDrbg, hasRequiredHmacDrbg;

function requireHmacDrbg() {
	if (hasRequiredHmacDrbg) return hmacDrbg;
	hasRequiredHmacDrbg = 1;
	var ue = requireHash(),
		Yi = requireUtils$2(),
		ea = requireMinimalisticAssert();

	function ta(na) {
		if (!(this instanceof ta)) return new ta(na);
		this.hash = na.hash, this.predResist = !!na.predResist, this.outLen = this.hash.outSize, this.minEntropy = na.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
		var ra = Yi.toArray(na.entropy, na.entropyEnc || "hex"),
			ia = Yi.toArray(na.nonce, na.nonceEnc || "hex"),
			aa = Yi.toArray(na.pers, na.persEnc || "hex");
		ea(ra.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(ra, ia, aa)
	}
	return hmacDrbg = ta, ta.prototype._init = function(ra, ia, aa) {
		var oa = ra.concat(ia).concat(aa);
		this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
		for (var la = 0; la < this.V.length; la++) this.K[la] = 0, this.V[la] = 1;
		this._update(oa), this._reseed = 1, this.reseedInterval = 281474976710656
	}, ta.prototype._hmac = function() {
		return new ue.hmac(this.hash, this.K)
	}, ta.prototype._update = function(ra) {
		var ia = this._hmac().update(this.V).update([0]);
		ra && (ia = ia.update(ra)), this.K = ia.digest(), this.V = this._hmac().update(this.V).digest(), ra && (this.K = this._hmac().update(this.V).update([1]).update(ra).digest(), this.V = this._hmac().update(this.V).digest())
	}, ta.prototype.reseed = function(ra, ia, aa, oa) {
		typeof ia != "string" && (oa = aa, aa = ia, ia = null), ra = Yi.toArray(ra, ia), aa = Yi.toArray(aa, oa), ea(ra.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(ra.concat(aa || [])), this._reseed = 1
	}, ta.prototype.generate = function(ra, ia, aa, oa) {
		if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
		typeof ia != "string" && (oa = aa, aa = ia, ia = null), aa && (aa = Yi.toArray(aa, oa || "hex"), this._update(aa));
		for (var la = []; la.length < ra;) this.V = this._hmac().update(this.V).digest(), la = la.concat(this.V);
		var sa = la.slice(0, ra);
		return this._update(aa), this._reseed++, Yi.encode(sa, ia)
	}, hmacDrbg
}
var key$1, hasRequiredKey$1;

function requireKey$1() {
	if (hasRequiredKey$1) return key$1;
	hasRequiredKey$1 = 1;
	var ue = requireBn$2(),
		Yi = requireUtils$1(),
		ea = Yi.assert;

	function ta(na, ra) {
		this.ec = na, this.priv = null, this.pub = null, ra.priv && this._importPrivate(ra.priv, ra.privEnc), ra.pub && this._importPublic(ra.pub, ra.pubEnc)
	}
	return key$1 = ta, ta.fromPublic = function(ra, ia, aa) {
		return ia instanceof ta ? ia : new ta(ra, {
			pub: ia,
			pubEnc: aa
		})
	}, ta.fromPrivate = function(ra, ia, aa) {
		return ia instanceof ta ? ia : new ta(ra, {
			priv: ia,
			privEnc: aa
		})
	}, ta.prototype.validate = function() {
		var ra = this.getPublic();
		return ra.isInfinity() ? {
			result: !1,
			reason: "Invalid public key"
		} : ra.validate() ? ra.mul(this.ec.curve.n).isInfinity() ? {
			result: !0,
			reason: null
		} : {
			result: !1,
			reason: "Public key * N != O"
		} : {
			result: !1,
			reason: "Public key is not a point"
		}
	}, ta.prototype.getPublic = function(ra, ia) {
		return typeof ra == "string" && (ia = ra, ra = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), ia ? this.pub.encode(ia, ra) : this.pub
	}, ta.prototype.getPrivate = function(ra) {
		return ra === "hex" ? this.priv.toString(16, 2) : this.priv
	}, ta.prototype._importPrivate = function(ra, ia) {
		this.priv = new ue(ra, ia || 16), this.priv = this.priv.umod(this.ec.curve.n)
	}, ta.prototype._importPublic = function(ra, ia) {
		if (ra.x || ra.y) {
			this.ec.curve.type === "mont" ? ea(ra.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && ea(ra.x && ra.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(ra.x, ra.y);
			return
		}
		this.pub = this.ec.curve.decodePoint(ra, ia)
	}, ta.prototype.derive = function(ra) {
		return ra.validate() || ea(ra.validate(), "public point not validated"), ra.mul(this.priv).getX()
	}, ta.prototype.sign = function(ra, ia, aa) {
		return this.ec.sign(ra, this, ia, aa)
	}, ta.prototype.verify = function(ra, ia) {
		return this.ec.verify(ra, ia, this)
	}, ta.prototype.inspect = function() {
		return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
	}, key$1
}
var signature$1, hasRequiredSignature$1;

function requireSignature$1() {
	if (hasRequiredSignature$1) return signature$1;
	hasRequiredSignature$1 = 1;
	var ue = requireBn$2(),
		Yi = requireUtils$1(),
		ea = Yi.assert;

	function ta(oa, la) {
		if (oa instanceof ta) return oa;
		this._importDER(oa, la) || (ea(oa.r && oa.s, "Signature without r or s"), this.r = new ue(oa.r, 16), this.s = new ue(oa.s, 16), oa.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = oa.recoveryParam)
	}
	signature$1 = ta;

	function na() {
		this.place = 0
	}

	function ra(oa, la) {
		var sa = oa[la.place++];
		if (!(sa & 128)) return sa;
		var ca = sa & 15;
		if (ca === 0 || ca > 4 || oa[la.place] === 0) return !1;
		for (var ua = 0, da = 0, ha = la.place; da < ca; da++, ha++) ua <<= 8, ua |= oa[ha], ua >>>= 0;
		return ua <= 127 ? !1 : (la.place = ha, ua)
	}

	function ia(oa) {
		for (var la = 0, sa = oa.length - 1; !oa[la] && !(oa[la + 1] & 128) && la < sa;) la++;
		return la === 0 ? oa : oa.slice(la)
	}
	ta.prototype._importDER = function(la, sa) {
		la = Yi.toArray(la, sa);
		var ca = new na;
		if (la[ca.place++] !== 48) return !1;
		var ua = ra(la, ca);
		if (ua === !1 || ua + ca.place !== la.length || la[ca.place++] !== 2) return !1;
		var da = ra(la, ca);
		if (da === !1 || la[ca.place] & 128) return !1;
		var ha = la.slice(ca.place, da + ca.place);
		if (ca.place += da, la[ca.place++] !== 2) return !1;
		var pa = ra(la, ca);
		if (pa === !1 || la.length !== pa + ca.place || la[ca.place] & 128) return !1;
		var va = la.slice(ca.place, pa + ca.place);
		if (ha[0] === 0)
			if (ha[1] & 128) ha = ha.slice(1);
			else return !1;
		if (va[0] === 0)
			if (va[1] & 128) va = va.slice(1);
			else return !1;
		return this.r = new ue(ha), this.s = new ue(va), this.recoveryParam = null, !0
	};

	function aa(oa, la) {
		if (la < 128) {
			oa.push(la);
			return
		}
		var sa = 1 + (Math.log(la) / Math.LN2 >>> 3);
		for (oa.push(sa | 128); --sa;) oa.push(la >>> (sa << 3) & 255);
		oa.push(la)
	}
	return ta.prototype.toDER = function(la) {
		var sa = this.r.toArray(),
			ca = this.s.toArray();
		for (sa[0] & 128 && (sa = [0].concat(sa)), ca[0] & 128 && (ca = [0].concat(ca)), sa = ia(sa), ca = ia(ca); !ca[0] && !(ca[1] & 128);) ca = ca.slice(1);
		var ua = [2];
		aa(ua, sa.length), ua = ua.concat(sa), ua.push(2), aa(ua, ca.length);
		var da = ua.concat(ca),
			ha = [48];
		return aa(ha, da.length), ha = ha.concat(da), Yi.encode(ha, la)
	}, signature$1
}
var ec, hasRequiredEc;

function requireEc() {
	if (hasRequiredEc) return ec;
	hasRequiredEc = 1;
	var ue = requireBn$2(),
		Yi = requireHmacDrbg(),
		ea = requireUtils$1(),
		ta = requireCurves(),
		na = requireBrorand(),
		ra = ea.assert,
		ia = requireKey$1(),
		aa = requireSignature$1();

	function oa(la) {
		if (!(this instanceof oa)) return new oa(la);
		typeof la == "string" && (ra(Object.prototype.hasOwnProperty.call(ta, la), "Unknown curve " + la), la = ta[la]), la instanceof ta.PresetCurve && (la = {
			curve: la
		}), this.curve = la.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = la.curve.g, this.g.precompute(la.curve.n.bitLength() + 1), this.hash = la.hash || la.curve.hash
	}
	return ec = oa, oa.prototype.keyPair = function(sa) {
		return new ia(this, sa)
	}, oa.prototype.keyFromPrivate = function(sa, ca) {
		return ia.fromPrivate(this, sa, ca)
	}, oa.prototype.keyFromPublic = function(sa, ca) {
		return ia.fromPublic(this, sa, ca)
	}, oa.prototype.genKeyPair = function(sa) {
		sa || (sa = {});
		for (var ca = new Yi({
				hash: this.hash,
				pers: sa.pers,
				persEnc: sa.persEnc || "utf8",
				entropy: sa.entropy || na(this.hash.hmacStrength),
				entropyEnc: sa.entropy && sa.entropyEnc || "utf8",
				nonce: this.n.toArray()
			}), ua = this.n.byteLength(), da = this.n.sub(new ue(2));;) {
			var ha = new ue(ca.generate(ua));
			if (!(ha.cmp(da) > 0)) return ha.iaddn(1), this.keyFromPrivate(ha)
		}
	}, oa.prototype._truncateToN = function(sa, ca) {
		var ua = sa.byteLength() * 8 - this.n.bitLength();
		return ua > 0 && (sa = sa.ushrn(ua)), !ca && sa.cmp(this.n) >= 0 ? sa.sub(this.n) : sa
	}, oa.prototype.sign = function(sa, ca, ua, da) {
		typeof ua == "object" && (da = ua, ua = null), da || (da = {}), ca = this.keyFromPrivate(ca, ua), sa = this._truncateToN(new ue(sa, 16));
		for (var ha = this.n.byteLength(), pa = ca.getPrivate().toArray("be", ha), va = sa.toArray("be", ha), ba = new Yi({
				hash: this.hash,
				entropy: pa,
				nonce: va,
				pers: da.pers,
				persEnc: da.persEnc || "utf8"
			}), Ea = this.n.sub(new ue(1)), Sa = 0;; Sa++) {
			var Ca = da.k ? da.k(Sa) : new ue(ba.generate(this.n.byteLength()));
			if (Ca = this._truncateToN(Ca, !0), !(Ca.cmpn(1) <= 0 || Ca.cmp(Ea) >= 0)) {
				var ka = this.g.mul(Ca);
				if (!ka.isInfinity()) {
					var Pa = ka.getX(),
						ja = Pa.umod(this.n);
					if (ja.cmpn(0) !== 0) {
						var Za = Ca.invm(this.n).mul(ja.mul(ca.getPrivate()).iadd(sa));
						if (Za = Za.umod(this.n), Za.cmpn(0) !== 0) {
							var Ga = (ka.getY().isOdd() ? 1 : 0) | (Pa.cmp(ja) !== 0 ? 2 : 0);
							return da.canonical && Za.cmp(this.nh) > 0 && (Za = this.n.sub(Za), Ga ^= 1), new aa({
								r: ja,
								s: Za,
								recoveryParam: Ga
							})
						}
					}
				}
			}
		}
	}, oa.prototype.verify = function(sa, ca, ua, da) {
		sa = this._truncateToN(new ue(sa, 16)), ua = this.keyFromPublic(ua, da), ca = new aa(ca, "hex");
		var ha = ca.r,
			pa = ca.s;
		if (ha.cmpn(1) < 0 || ha.cmp(this.n) >= 0 || pa.cmpn(1) < 0 || pa.cmp(this.n) >= 0) return !1;
		var va = pa.invm(this.n),
			ba = va.mul(sa).umod(this.n),
			Ea = va.mul(ha).umod(this.n),
			Sa;
		return this.curve._maxwellTrick ? (Sa = this.g.jmulAdd(ba, ua.getPublic(), Ea), Sa.isInfinity() ? !1 : Sa.eqXToP(ha)) : (Sa = this.g.mulAdd(ba, ua.getPublic(), Ea), Sa.isInfinity() ? !1 : Sa.getX().umod(this.n).cmp(ha) === 0)
	}, oa.prototype.recoverPubKey = function(la, sa, ca, ua) {
		ra((3 & ca) === ca, "The recovery param is more than two bits"), sa = new aa(sa, ua);
		var da = this.n,
			ha = new ue(la),
			pa = sa.r,
			va = sa.s,
			ba = ca & 1,
			Ea = ca >> 1;
		if (pa.cmp(this.curve.p.umod(this.curve.n)) >= 0 && Ea) throw new Error("Unable to find sencond key candinate");
		Ea ? pa = this.curve.pointFromX(pa.add(this.curve.n), ba) : pa = this.curve.pointFromX(pa, ba);
		var Sa = sa.r.invm(da),
			Ca = da.sub(ha).mul(Sa).umod(da),
			ka = va.mul(Sa).umod(da);
		return this.g.mulAdd(Ca, pa, ka)
	}, oa.prototype.getKeyRecoveryParam = function(la, sa, ca, ua) {
		if (sa = new aa(sa, ua), sa.recoveryParam !== null) return sa.recoveryParam;
		for (var da = 0; da < 4; da++) {
			var ha;
			try {
				ha = this.recoverPubKey(la, sa, da)
			} catch {
				continue
			}
			if (ha.eq(ca)) return da
		}
		throw new Error("Unable to find valid recovery factor")
	}, ec
}
var key, hasRequiredKey;

function requireKey() {
	if (hasRequiredKey) return key;
	hasRequiredKey = 1;
	var ue = requireUtils$1(),
		Yi = ue.assert,
		ea = ue.parseBytes,
		ta = ue.cachedProperty;

	function na(ra, ia) {
		this.eddsa = ra, this._secret = ea(ia.secret), ra.isPoint(ia.pub) ? this._pub = ia.pub : this._pubBytes = ea(ia.pub)
	}
	return na.fromPublic = function(ia, aa) {
		return aa instanceof na ? aa : new na(ia, {
			pub: aa
		})
	}, na.fromSecret = function(ia, aa) {
		return aa instanceof na ? aa : new na(ia, {
			secret: aa
		})
	}, na.prototype.secret = function() {
		return this._secret
	}, ta(na, "pubBytes", function() {
		return this.eddsa.encodePoint(this.pub())
	}), ta(na, "pub", function() {
		return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv())
	}), ta(na, "privBytes", function() {
		var ia = this.eddsa,
			aa = this.hash(),
			oa = ia.encodingLength - 1,
			la = aa.slice(0, ia.encodingLength);
		return la[0] &= 248, la[oa] &= 127, la[oa] |= 64, la
	}), ta(na, "priv", function() {
		return this.eddsa.decodeInt(this.privBytes())
	}), ta(na, "hash", function() {
		return this.eddsa.hash().update(this.secret()).digest()
	}), ta(na, "messagePrefix", function() {
		return this.hash().slice(this.eddsa.encodingLength)
	}), na.prototype.sign = function(ia) {
		return Yi(this._secret, "KeyPair can only verify"), this.eddsa.sign(ia, this)
	}, na.prototype.verify = function(ia, aa) {
		return this.eddsa.verify(ia, aa, this)
	}, na.prototype.getSecret = function(ia) {
		return Yi(this._secret, "KeyPair is public only"), ue.encode(this.secret(), ia)
	}, na.prototype.getPublic = function(ia) {
		return ue.encode(this.pubBytes(), ia)
	}, key = na, key
}
var signature, hasRequiredSignature;

function requireSignature() {
	if (hasRequiredSignature) return signature;
	hasRequiredSignature = 1;
	var ue = requireBn$2(),
		Yi = requireUtils$1(),
		ea = Yi.assert,
		ta = Yi.cachedProperty,
		na = Yi.parseBytes;

	function ra(ia, aa) {
		this.eddsa = ia, typeof aa != "object" && (aa = na(aa)), Array.isArray(aa) && (ea(aa.length === ia.encodingLength * 2, "Signature has invalid size"), aa = {
			R: aa.slice(0, ia.encodingLength),
			S: aa.slice(ia.encodingLength)
		}), ea(aa.R && aa.S, "Signature without R or S"), ia.isPoint(aa.R) && (this._R = aa.R), aa.S instanceof ue && (this._S = aa.S), this._Rencoded = Array.isArray(aa.R) ? aa.R : aa.Rencoded, this._Sencoded = Array.isArray(aa.S) ? aa.S : aa.Sencoded
	}
	return ta(ra, "S", function() {
		return this.eddsa.decodeInt(this.Sencoded())
	}), ta(ra, "R", function() {
		return this.eddsa.decodePoint(this.Rencoded())
	}), ta(ra, "Rencoded", function() {
		return this.eddsa.encodePoint(this.R())
	}), ta(ra, "Sencoded", function() {
		return this.eddsa.encodeInt(this.S())
	}), ra.prototype.toBytes = function() {
		return this.Rencoded().concat(this.Sencoded())
	}, ra.prototype.toHex = function() {
		return Yi.encode(this.toBytes(), "hex").toUpperCase()
	}, signature = ra, signature
}
var eddsa, hasRequiredEddsa;

function requireEddsa() {
	if (hasRequiredEddsa) return eddsa;
	hasRequiredEddsa = 1;
	var ue = requireHash(),
		Yi = requireCurves(),
		ea = requireUtils$1(),
		ta = ea.assert,
		na = ea.parseBytes,
		ra = requireKey(),
		ia = requireSignature();

	function aa(oa) {
		if (ta(oa === "ed25519", "only tested with ed25519 so far"), !(this instanceof aa)) return new aa(oa);
		oa = Yi[oa].curve, this.curve = oa, this.g = oa.g, this.g.precompute(oa.n.bitLength() + 1), this.pointClass = oa.point().constructor, this.encodingLength = Math.ceil(oa.n.bitLength() / 8), this.hash = ue.sha512
	}
	return eddsa = aa, aa.prototype.sign = function(la, sa) {
		la = na(la);
		var ca = this.keyFromSecret(sa),
			ua = this.hashInt(ca.messagePrefix(), la),
			da = this.g.mul(ua),
			ha = this.encodePoint(da),
			pa = this.hashInt(ha, ca.pubBytes(), la).mul(ca.priv()),
			va = ua.add(pa).umod(this.curve.n);
		return this.makeSignature({
			R: da,
			S: va,
			Rencoded: ha
		})
	}, aa.prototype.verify = function(la, sa, ca) {
		if (la = na(la), sa = this.makeSignature(sa), sa.S().gte(sa.eddsa.curve.n) || sa.S().isNeg()) return !1;
		var ua = this.keyFromPublic(ca),
			da = this.hashInt(sa.Rencoded(), ua.pubBytes(), la),
			ha = this.g.mul(sa.S()),
			pa = sa.R().add(ua.pub().mul(da));
		return pa.eq(ha)
	}, aa.prototype.hashInt = function() {
		for (var la = this.hash(), sa = 0; sa < arguments.length; sa++) la.update(arguments[sa]);
		return ea.intFromLE(la.digest()).umod(this.curve.n)
	}, aa.prototype.keyFromPublic = function(la) {
		return ra.fromPublic(this, la)
	}, aa.prototype.keyFromSecret = function(la) {
		return ra.fromSecret(this, la)
	}, aa.prototype.makeSignature = function(la) {
		return la instanceof ia ? la : new ia(this, la)
	}, aa.prototype.encodePoint = function(la) {
		var sa = la.getY().toArray("le", this.encodingLength);
		return sa[this.encodingLength - 1] |= la.getX().isOdd() ? 128 : 0, sa
	}, aa.prototype.decodePoint = function(la) {
		la = ea.parseBytes(la);
		var sa = la.length - 1,
			ca = la.slice(0, sa).concat(la[sa] & -129),
			ua = (la[sa] & 128) !== 0,
			da = ea.intFromLE(ca);
		return this.curve.pointFromY(da, ua)
	}, aa.prototype.encodeInt = function(la) {
		return la.toArray("le", this.encodingLength)
	}, aa.prototype.decodeInt = function(la) {
		return ea.intFromLE(la)
	}, aa.prototype.isPoint = function(la) {
		return la instanceof this.pointClass
	}, eddsa
}
var hasRequiredElliptic;

function requireElliptic() {
	return hasRequiredElliptic || (hasRequiredElliptic = 1, function(ue) {
		var Yi = ue;
		Yi.version = require$$0.version, Yi.utils = requireUtils$1(), Yi.rand = requireBrorand(), Yi.curve = requireCurve(), Yi.curves = requireCurves(), Yi.ec = requireEc(), Yi.eddsa = requireEddsa()
	}(elliptic)), elliptic
}
var bn$1 = {
	exports: {}
};
bn$1.exports;
var hasRequiredBn;

function requireBn() {
	return hasRequiredBn || (hasRequiredBn = 1, function(ue) {
		(function(Yi, ea) {
			function ta(ma, fa) {
				if (!ma) throw new Error(fa || "Assertion failed")
			}

			function na(ma, fa) {
				ma.super_ = fa;
				var ga = function() {};
				ga.prototype = fa.prototype, ma.prototype = new ga, ma.prototype.constructor = ma
			}

			function ra(ma, fa, ga) {
				if (ra.isBN(ma)) return ma;
				this.negative = 0, this.words = null, this.length = 0, this.red = null, ma !== null && ((fa === "le" || fa === "be") && (ga = fa, fa = 10), this._init(ma || 0, fa || 10, ga || "be"))
			}
			typeof Yi == "object" ? Yi.exports = ra : ea.BN = ra, ra.BN = ra, ra.wordSize = 26;
			var ia;
			try {
				typeof window < "u" && typeof window.Buffer < "u" ? ia = window.Buffer : ia = require$$1$2.Buffer
			} catch {}
			ra.isBN = function(fa) {
				return fa instanceof ra ? !0 : fa !== null && typeof fa == "object" && fa.constructor.wordSize === ra.wordSize && Array.isArray(fa.words)
			}, ra.max = function(fa, ga) {
				return fa.cmp(ga) > 0 ? fa : ga
			}, ra.min = function(fa, ga) {
				return fa.cmp(ga) < 0 ? fa : ga
			}, ra.prototype._init = function(fa, ga, wa) {
				if (typeof fa == "number") return this._initNumber(fa, ga, wa);
				if (typeof fa == "object") return this._initArray(fa, ga, wa);
				ga === "hex" && (ga = 16), ta(ga === (ga | 0) && ga >= 2 && ga <= 36), fa = fa.toString().replace(/\s+/g, "");
				var Ma = 0;
				fa[0] === "-" && (Ma++, this.negative = 1), Ma < fa.length && (ga === 16 ? this._parseHex(fa, Ma, wa) : (this._parseBase(fa, ga, Ma), wa === "le" && this._initArray(this.toArray(), ga, wa)))
			}, ra.prototype._initNumber = function(fa, ga, wa) {
				fa < 0 && (this.negative = 1, fa = -fa), fa < 67108864 ? (this.words = [fa & 67108863], this.length = 1) : fa < 4503599627370496 ? (this.words = [fa & 67108863, fa / 67108864 & 67108863], this.length = 2) : (ta(fa < 9007199254740992), this.words = [fa & 67108863, fa / 67108864 & 67108863, 1], this.length = 3), wa === "le" && this._initArray(this.toArray(), ga, wa)
			}, ra.prototype._initArray = function(fa, ga, wa) {
				if (ta(typeof fa.length == "number"), fa.length <= 0) return this.words = [0], this.length = 1, this;
				this.length = Math.ceil(fa.length / 3), this.words = new Array(this.length);
				for (var Ma = 0; Ma < this.length; Ma++) this.words[Ma] = 0;
				var Aa, Ra, Ta = 0;
				if (wa === "be")
					for (Ma = fa.length - 1, Aa = 0; Ma >= 0; Ma -= 3) Ra = fa[Ma] | fa[Ma - 1] << 8 | fa[Ma - 2] << 16, this.words[Aa] |= Ra << Ta & 67108863, this.words[Aa + 1] = Ra >>> 26 - Ta & 67108863, Ta += 24, Ta >= 26 && (Ta -= 26, Aa++);
				else if (wa === "le")
					for (Ma = 0, Aa = 0; Ma < fa.length; Ma += 3) Ra = fa[Ma] | fa[Ma + 1] << 8 | fa[Ma + 2] << 16, this.words[Aa] |= Ra << Ta & 67108863, this.words[Aa + 1] = Ra >>> 26 - Ta & 67108863, Ta += 24, Ta >= 26 && (Ta -= 26, Aa++);
				return this._strip()
			};

			function aa(ma, fa) {
				var ga = ma.charCodeAt(fa);
				if (ga >= 48 && ga <= 57) return ga - 48;
				if (ga >= 65 && ga <= 70) return ga - 55;
				if (ga >= 97 && ga <= 102) return ga - 87;
				ta(!1, "Invalid character in " + ma)
			}

			function oa(ma, fa, ga) {
				var wa = aa(ma, ga);
				return ga - 1 >= fa && (wa |= aa(ma, ga - 1) << 4), wa
			}
			ra.prototype._parseHex = function(fa, ga, wa) {
				this.length = Math.ceil((fa.length - ga) / 6), this.words = new Array(this.length);
				for (var Ma = 0; Ma < this.length; Ma++) this.words[Ma] = 0;
				var Aa = 0,
					Ra = 0,
					Ta;
				if (wa === "be")
					for (Ma = fa.length - 1; Ma >= ga; Ma -= 2) Ta = oa(fa, ga, Ma) << Aa, this.words[Ra] |= Ta & 67108863, Aa >= 18 ? (Aa -= 18, Ra += 1, this.words[Ra] |= Ta >>> 26) : Aa += 8;
				else {
					var La = fa.length - ga;
					for (Ma = La % 2 === 0 ? ga + 1 : ga; Ma < fa.length; Ma += 2) Ta = oa(fa, ga, Ma) << Aa, this.words[Ra] |= Ta & 67108863, Aa >= 18 ? (Aa -= 18, Ra += 1, this.words[Ra] |= Ta >>> 26) : Aa += 8
				}
				this._strip()
			};

			function la(ma, fa, ga, wa) {
				for (var Ma = 0, Aa = 0, Ra = Math.min(ma.length, ga), Ta = fa; Ta < Ra; Ta++) {
					var La = ma.charCodeAt(Ta) - 48;
					Ma *= wa, La >= 49 ? Aa = La - 49 + 10 : La >= 17 ? Aa = La - 17 + 10 : Aa = La, ta(La >= 0 && Aa < wa, "Invalid character"), Ma += Aa
				}
				return Ma
			}
			ra.prototype._parseBase = function(fa, ga, wa) {
				this.words = [0], this.length = 1;
				for (var Ma = 0, Aa = 1; Aa <= 67108863; Aa *= ga) Ma++;
				Ma--, Aa = Aa / ga | 0;
				for (var Ra = fa.length - wa, Ta = Ra % Ma, La = Math.min(Ra, Ra - Ta) + wa, ya = 0, Ba = wa; Ba < La; Ba += Ma) ya = la(fa, Ba, Ba + Ma, ga), this.imuln(Aa), this.words[0] + ya < 67108864 ? this.words[0] += ya : this._iaddn(ya);
				if (Ta !== 0) {
					var io = 1;
					for (ya = la(fa, Ba, fa.length, ga), Ba = 0; Ba < Ta; Ba++) io *= ga;
					this.imuln(io), this.words[0] + ya < 67108864 ? this.words[0] += ya : this._iaddn(ya)
				}
				this._strip()
			}, ra.prototype.copy = function(fa) {
				fa.words = new Array(this.length);
				for (var ga = 0; ga < this.length; ga++) fa.words[ga] = this.words[ga];
				fa.length = this.length, fa.negative = this.negative, fa.red = this.red
			};

			function sa(ma, fa) {
				ma.words = fa.words, ma.length = fa.length, ma.negative = fa.negative, ma.red = fa.red
			}
			if (ra.prototype._move = function(fa) {
					sa(fa, this)
				}, ra.prototype.clone = function() {
					var fa = new ra(null);
					return this.copy(fa), fa
				}, ra.prototype._expand = function(fa) {
					for (; this.length < fa;) this.words[this.length++] = 0;
					return this
				}, ra.prototype._strip = function() {
					for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
					return this._normSign()
				}, ra.prototype._normSign = function() {
					return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
				}, typeof Symbol < "u" && typeof Symbol.for == "function") try {
				ra.prototype[Symbol.for("nodejs.util.inspect.custom")] = ca
			} catch {
				ra.prototype.inspect = ca
			} else ra.prototype.inspect = ca;

			function ca() {
				return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
			}
			var ua = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
				da = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
				ha = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
			ra.prototype.toString = function(fa, ga) {
				fa = fa || 10, ga = ga | 0 || 1;
				var wa;
				if (fa === 16 || fa === "hex") {
					wa = "";
					for (var Ma = 0, Aa = 0, Ra = 0; Ra < this.length; Ra++) {
						var Ta = this.words[Ra],
							La = ((Ta << Ma | Aa) & 16777215).toString(16);
						Aa = Ta >>> 24 - Ma & 16777215, Ma += 2, Ma >= 26 && (Ma -= 26, Ra--), Aa !== 0 || Ra !== this.length - 1 ? wa = ua[6 - La.length] + La + wa : wa = La + wa
					}
					for (Aa !== 0 && (wa = Aa.toString(16) + wa); wa.length % ga !== 0;) wa = "0" + wa;
					return this.negative !== 0 && (wa = "-" + wa), wa
				}
				if (fa === (fa | 0) && fa >= 2 && fa <= 36) {
					var ya = da[fa],
						Ba = ha[fa];
					wa = "";
					var io = this.clone();
					for (io.negative = 0; !io.isZero();) {
						var oo = io.modrn(Ba).toString(fa);
						io = io.idivn(Ba), io.isZero() ? wa = oo + wa : wa = ua[ya - oo.length] + oo + wa
					}
					for (this.isZero() && (wa = "0" + wa); wa.length % ga !== 0;) wa = "0" + wa;
					return this.negative !== 0 && (wa = "-" + wa), wa
				}
				ta(!1, "Base should be between 2 and 36")
			}, ra.prototype.toNumber = function() {
				var fa = this.words[0];
				return this.length === 2 ? fa += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? fa += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && ta(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -fa : fa
			}, ra.prototype.toJSON = function() {
				return this.toString(16, 2)
			}, ia && (ra.prototype.toBuffer = function(fa, ga) {
				return this.toArrayLike(ia, fa, ga)
			}), ra.prototype.toArray = function(fa, ga) {
				return this.toArrayLike(Array, fa, ga)
			};
			var pa = function(fa, ga) {
				return fa.allocUnsafe ? fa.allocUnsafe(ga) : new fa(ga)
			};
			ra.prototype.toArrayLike = function(fa, ga, wa) {
				this._strip();
				var Ma = this.byteLength(),
					Aa = wa || Math.max(1, Ma);
				ta(Ma <= Aa, "byte array longer than desired length"), ta(Aa > 0, "Requested array length <= 0");
				var Ra = pa(fa, Aa),
					Ta = ga === "le" ? "LE" : "BE";
				return this["_toArrayLike" + Ta](Ra, Ma), Ra
			}, ra.prototype._toArrayLikeLE = function(fa, ga) {
				for (var wa = 0, Ma = 0, Aa = 0, Ra = 0; Aa < this.length; Aa++) {
					var Ta = this.words[Aa] << Ra | Ma;
					fa[wa++] = Ta & 255, wa < fa.length && (fa[wa++] = Ta >> 8 & 255), wa < fa.length && (fa[wa++] = Ta >> 16 & 255), Ra === 6 ? (wa < fa.length && (fa[wa++] = Ta >> 24 & 255), Ma = 0, Ra = 0) : (Ma = Ta >>> 24, Ra += 2)
				}
				if (wa < fa.length)
					for (fa[wa++] = Ma; wa < fa.length;) fa[wa++] = 0
			}, ra.prototype._toArrayLikeBE = function(fa, ga) {
				for (var wa = fa.length - 1, Ma = 0, Aa = 0, Ra = 0; Aa < this.length; Aa++) {
					var Ta = this.words[Aa] << Ra | Ma;
					fa[wa--] = Ta & 255, wa >= 0 && (fa[wa--] = Ta >> 8 & 255), wa >= 0 && (fa[wa--] = Ta >> 16 & 255), Ra === 6 ? (wa >= 0 && (fa[wa--] = Ta >> 24 & 255), Ma = 0, Ra = 0) : (Ma = Ta >>> 24, Ra += 2)
				}
				if (wa >= 0)
					for (fa[wa--] = Ma; wa >= 0;) fa[wa--] = 0
			}, Math.clz32 ? ra.prototype._countBits = function(fa) {
				return 32 - Math.clz32(fa)
			} : ra.prototype._countBits = function(fa) {
				var ga = fa,
					wa = 0;
				return ga >= 4096 && (wa += 13, ga >>>= 13), ga >= 64 && (wa += 7, ga >>>= 7), ga >= 8 && (wa += 4, ga >>>= 4), ga >= 2 && (wa += 2, ga >>>= 2), wa + ga
			}, ra.prototype._zeroBits = function(fa) {
				if (fa === 0) return 26;
				var ga = fa,
					wa = 0;
				return ga & 8191 || (wa += 13, ga >>>= 13), ga & 127 || (wa += 7, ga >>>= 7), ga & 15 || (wa += 4, ga >>>= 4), ga & 3 || (wa += 2, ga >>>= 2), ga & 1 || wa++, wa
			}, ra.prototype.bitLength = function() {
				var fa = this.words[this.length - 1],
					ga = this._countBits(fa);
				return (this.length - 1) * 26 + ga
			};

			function va(ma) {
				for (var fa = new Array(ma.bitLength()), ga = 0; ga < fa.length; ga++) {
					var wa = ga / 26 | 0,
						Ma = ga % 26;
					fa[ga] = ma.words[wa] >>> Ma & 1
				}
				return fa
			}
			ra.prototype.zeroBits = function() {
				if (this.isZero()) return 0;
				for (var fa = 0, ga = 0; ga < this.length; ga++) {
					var wa = this._zeroBits(this.words[ga]);
					if (fa += wa, wa !== 26) break
				}
				return fa
			}, ra.prototype.byteLength = function() {
				return Math.ceil(this.bitLength() / 8)
			}, ra.prototype.toTwos = function(fa) {
				return this.negative !== 0 ? this.abs().inotn(fa).iaddn(1) : this.clone()
			}, ra.prototype.fromTwos = function(fa) {
				return this.testn(fa - 1) ? this.notn(fa).iaddn(1).ineg() : this.clone()
			}, ra.prototype.isNeg = function() {
				return this.negative !== 0
			}, ra.prototype.neg = function() {
				return this.clone().ineg()
			}, ra.prototype.ineg = function() {
				return this.isZero() || (this.negative ^= 1), this
			}, ra.prototype.iuor = function(fa) {
				for (; this.length < fa.length;) this.words[this.length++] = 0;
				for (var ga = 0; ga < fa.length; ga++) this.words[ga] = this.words[ga] | fa.words[ga];
				return this._strip()
			}, ra.prototype.ior = function(fa) {
				return ta((this.negative | fa.negative) === 0), this.iuor(fa)
			}, ra.prototype.or = function(fa) {
				return this.length > fa.length ? this.clone().ior(fa) : fa.clone().ior(this)
			}, ra.prototype.uor = function(fa) {
				return this.length > fa.length ? this.clone().iuor(fa) : fa.clone().iuor(this)
			}, ra.prototype.iuand = function(fa) {
				var ga;
				this.length > fa.length ? ga = fa : ga = this;
				for (var wa = 0; wa < ga.length; wa++) this.words[wa] = this.words[wa] & fa.words[wa];
				return this.length = ga.length, this._strip()
			}, ra.prototype.iand = function(fa) {
				return ta((this.negative | fa.negative) === 0), this.iuand(fa)
			}, ra.prototype.and = function(fa) {
				return this.length > fa.length ? this.clone().iand(fa) : fa.clone().iand(this)
			}, ra.prototype.uand = function(fa) {
				return this.length > fa.length ? this.clone().iuand(fa) : fa.clone().iuand(this)
			}, ra.prototype.iuxor = function(fa) {
				var ga, wa;
				this.length > fa.length ? (ga = this, wa = fa) : (ga = fa, wa = this);
				for (var Ma = 0; Ma < wa.length; Ma++) this.words[Ma] = ga.words[Ma] ^ wa.words[Ma];
				if (this !== ga)
					for (; Ma < ga.length; Ma++) this.words[Ma] = ga.words[Ma];
				return this.length = ga.length, this._strip()
			}, ra.prototype.ixor = function(fa) {
				return ta((this.negative | fa.negative) === 0), this.iuxor(fa)
			}, ra.prototype.xor = function(fa) {
				return this.length > fa.length ? this.clone().ixor(fa) : fa.clone().ixor(this)
			}, ra.prototype.uxor = function(fa) {
				return this.length > fa.length ? this.clone().iuxor(fa) : fa.clone().iuxor(this)
			}, ra.prototype.inotn = function(fa) {
				ta(typeof fa == "number" && fa >= 0);
				var ga = Math.ceil(fa / 26) | 0,
					wa = fa % 26;
				this._expand(ga), wa > 0 && ga--;
				for (var Ma = 0; Ma < ga; Ma++) this.words[Ma] = ~this.words[Ma] & 67108863;
				return wa > 0 && (this.words[Ma] = ~this.words[Ma] & 67108863 >> 26 - wa), this._strip()
			}, ra.prototype.notn = function(fa) {
				return this.clone().inotn(fa)
			}, ra.prototype.setn = function(fa, ga) {
				ta(typeof fa == "number" && fa >= 0);
				var wa = fa / 26 | 0,
					Ma = fa % 26;
				return this._expand(wa + 1), ga ? this.words[wa] = this.words[wa] | 1 << Ma : this.words[wa] = this.words[wa] & ~(1 << Ma), this._strip()
			}, ra.prototype.iadd = function(fa) {
				var ga;
				if (this.negative !== 0 && fa.negative === 0) return this.negative = 0, ga = this.isub(fa), this.negative ^= 1, this._normSign();
				if (this.negative === 0 && fa.negative !== 0) return fa.negative = 0, ga = this.isub(fa), fa.negative = 1, ga._normSign();
				var wa, Ma;
				this.length > fa.length ? (wa = this, Ma = fa) : (wa = fa, Ma = this);
				for (var Aa = 0, Ra = 0; Ra < Ma.length; Ra++) ga = (wa.words[Ra] | 0) + (Ma.words[Ra] | 0) + Aa, this.words[Ra] = ga & 67108863, Aa = ga >>> 26;
				for (; Aa !== 0 && Ra < wa.length; Ra++) ga = (wa.words[Ra] | 0) + Aa, this.words[Ra] = ga & 67108863, Aa = ga >>> 26;
				if (this.length = wa.length, Aa !== 0) this.words[this.length] = Aa, this.length++;
				else if (wa !== this)
					for (; Ra < wa.length; Ra++) this.words[Ra] = wa.words[Ra];
				return this
			}, ra.prototype.add = function(fa) {
				var ga;
				return fa.negative !== 0 && this.negative === 0 ? (fa.negative = 0, ga = this.sub(fa), fa.negative ^= 1, ga) : fa.negative === 0 && this.negative !== 0 ? (this.negative = 0, ga = fa.sub(this), this.negative = 1, ga) : this.length > fa.length ? this.clone().iadd(fa) : fa.clone().iadd(this)
			}, ra.prototype.isub = function(fa) {
				if (fa.negative !== 0) {
					fa.negative = 0;
					var ga = this.iadd(fa);
					return fa.negative = 1, ga._normSign()
				} else if (this.negative !== 0) return this.negative = 0, this.iadd(fa), this.negative = 1, this._normSign();
				var wa = this.cmp(fa);
				if (wa === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
				var Ma, Aa;
				wa > 0 ? (Ma = this, Aa = fa) : (Ma = fa, Aa = this);
				for (var Ra = 0, Ta = 0; Ta < Aa.length; Ta++) ga = (Ma.words[Ta] | 0) - (Aa.words[Ta] | 0) + Ra, Ra = ga >> 26, this.words[Ta] = ga & 67108863;
				for (; Ra !== 0 && Ta < Ma.length; Ta++) ga = (Ma.words[Ta] | 0) + Ra, Ra = ga >> 26, this.words[Ta] = ga & 67108863;
				if (Ra === 0 && Ta < Ma.length && Ma !== this)
					for (; Ta < Ma.length; Ta++) this.words[Ta] = Ma.words[Ta];
				return this.length = Math.max(this.length, Ta), Ma !== this && (this.negative = 1), this._strip()
			}, ra.prototype.sub = function(fa) {
				return this.clone().isub(fa)
			};

			function ba(ma, fa, ga) {
				ga.negative = fa.negative ^ ma.negative;
				var wa = ma.length + fa.length | 0;
				ga.length = wa, wa = wa - 1 | 0;
				var Ma = ma.words[0] | 0,
					Aa = fa.words[0] | 0,
					Ra = Ma * Aa,
					Ta = Ra & 67108863,
					La = Ra / 67108864 | 0;
				ga.words[0] = Ta;
				for (var ya = 1; ya < wa; ya++) {
					for (var Ba = La >>> 26, io = La & 67108863, oo = Math.min(ya, fa.length - 1), ao = Math.max(0, ya - ma.length + 1); ao <= oo; ao++) {
						var Ia = ya - ao | 0;
						Ma = ma.words[Ia] | 0, Aa = fa.words[ao] | 0, Ra = Ma * Aa + io, Ba += Ra / 67108864 | 0, io = Ra & 67108863
					}
					ga.words[ya] = io | 0, La = Ba | 0
				}
				return La !== 0 ? ga.words[ya] = La | 0 : ga.length--, ga._strip()
			}
			var Ea = function(fa, ga, wa) {
				var Ma = fa.words,
					Aa = ga.words,
					Ra = wa.words,
					Ta = 0,
					La, ya, Ba, io = Ma[0] | 0,
					oo = io & 8191,
					ao = io >>> 13,
					Ia = Ma[1] | 0,
					Na = Ia & 8191,
					za = Ia >>> 13,
					ro = Ma[2] | 0,
					Va = ro & 8191,
					Wa = ro >>> 13,
					qa = Ma[3] | 0,
					Ka = qa & 8191,
					lo = qa >>> 13,
					yo = Ma[4] | 0,
					fo = yo & 8191,
					vo = yo >>> 13,
					so = Ma[5] | 0,
					Xa = so & 8191,
					to = so >>> 13,
					ho = Ma[6] | 0,
					Eo = ho & 8191,
					wo = ho >>> 13,
					Ao = Ma[7] | 0,
					_o = Ao & 8191,
					Lo = Ao >>> 13,
					Fo = Ma[8] | 0,
					jo = Fo & 8191,
					eo = Fo >>> 13,
					Oa = Ma[9] | 0,
					Da = Oa & 8191,
					Qa = Oa >>> 13,
					uo = Aa[0] | 0,
					bo = uo & 8191,
					So = uo >>> 13,
					Wo = Aa[1] | 0,
					Po = Wo & 8191,
					Ro = Wo >>> 13,
					Ho = Aa[2] | 0,
					Oo = Ho & 8191,
					No = Ho >>> 13,
					ps = Aa[3] | 0,
					Ko = ps & 8191,
					Go = ps >>> 13,
					bs = Aa[4] | 0,
					vs = bs & 8191,
					ls = bs >>> 13,
					Es = Aa[5] | 0,
					ws = Es & 8191,
					as = Es >>> 13,
					go = Aa[6] | 0,
					Ha = go & 8191,
					Fa = go >>> 13,
					Ya = Aa[7] | 0,
					$a = Ya & 8191,
					no = Ya >>> 13,
					Co = Aa[8] | 0,
					co = Co & 8191,
					mo = Co >>> 13,
					xo = Aa[9] | 0,
					ko = xo & 8191,
					$o = xo >>> 13;
				wa.negative = fa.negative ^ ga.negative, wa.length = 19, La = Math.imul(oo, bo), ya = Math.imul(oo, So), ya = ya + Math.imul(ao, bo) | 0, Ba = Math.imul(ao, So);
				var Ss = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Ss >>> 26) | 0, Ss &= 67108863, La = Math.imul(Na, bo), ya = Math.imul(Na, So), ya = ya + Math.imul(za, bo) | 0, Ba = Math.imul(za, So), La = La + Math.imul(oo, Po) | 0, ya = ya + Math.imul(oo, Ro) | 0, ya = ya + Math.imul(ao, Po) | 0, Ba = Ba + Math.imul(ao, Ro) | 0;
				var Xo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Xo >>> 26) | 0, Xo &= 67108863, La = Math.imul(Va, bo), ya = Math.imul(Va, So), ya = ya + Math.imul(Wa, bo) | 0, Ba = Math.imul(Wa, So), La = La + Math.imul(Na, Po) | 0, ya = ya + Math.imul(Na, Ro) | 0, ya = ya + Math.imul(za, Po) | 0, Ba = Ba + Math.imul(za, Ro) | 0, La = La + Math.imul(oo, Oo) | 0, ya = ya + Math.imul(oo, No) | 0, ya = ya + Math.imul(ao, Oo) | 0, Ba = Ba + Math.imul(ao, No) | 0;
				var ms = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (ms >>> 26) | 0, ms &= 67108863, La = Math.imul(Ka, bo), ya = Math.imul(Ka, So), ya = ya + Math.imul(lo, bo) | 0, Ba = Math.imul(lo, So), La = La + Math.imul(Va, Po) | 0, ya = ya + Math.imul(Va, Ro) | 0, ya = ya + Math.imul(Wa, Po) | 0, Ba = Ba + Math.imul(Wa, Ro) | 0, La = La + Math.imul(Na, Oo) | 0, ya = ya + Math.imul(Na, No) | 0, ya = ya + Math.imul(za, Oo) | 0, Ba = Ba + Math.imul(za, No) | 0, La = La + Math.imul(oo, Ko) | 0, ya = ya + Math.imul(oo, Go) | 0, ya = ya + Math.imul(ao, Ko) | 0, Ba = Ba + Math.imul(ao, Go) | 0;
				var gs = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (gs >>> 26) | 0, gs &= 67108863, La = Math.imul(fo, bo), ya = Math.imul(fo, So), ya = ya + Math.imul(vo, bo) | 0, Ba = Math.imul(vo, So), La = La + Math.imul(Ka, Po) | 0, ya = ya + Math.imul(Ka, Ro) | 0, ya = ya + Math.imul(lo, Po) | 0, Ba = Ba + Math.imul(lo, Ro) | 0, La = La + Math.imul(Va, Oo) | 0, ya = ya + Math.imul(Va, No) | 0, ya = ya + Math.imul(Wa, Oo) | 0, Ba = Ba + Math.imul(Wa, No) | 0, La = La + Math.imul(Na, Ko) | 0, ya = ya + Math.imul(Na, Go) | 0, ya = ya + Math.imul(za, Ko) | 0, Ba = Ba + Math.imul(za, Go) | 0, La = La + Math.imul(oo, vs) | 0, ya = ya + Math.imul(oo, ls) | 0, ya = ya + Math.imul(ao, vs) | 0, Ba = Ba + Math.imul(ao, ls) | 0;
				var ys = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (ys >>> 26) | 0, ys &= 67108863, La = Math.imul(Xa, bo), ya = Math.imul(Xa, So), ya = ya + Math.imul(to, bo) | 0, Ba = Math.imul(to, So), La = La + Math.imul(fo, Po) | 0, ya = ya + Math.imul(fo, Ro) | 0, ya = ya + Math.imul(vo, Po) | 0, Ba = Ba + Math.imul(vo, Ro) | 0, La = La + Math.imul(Ka, Oo) | 0, ya = ya + Math.imul(Ka, No) | 0, ya = ya + Math.imul(lo, Oo) | 0, Ba = Ba + Math.imul(lo, No) | 0, La = La + Math.imul(Va, Ko) | 0, ya = ya + Math.imul(Va, Go) | 0, ya = ya + Math.imul(Wa, Ko) | 0, Ba = Ba + Math.imul(Wa, Go) | 0, La = La + Math.imul(Na, vs) | 0, ya = ya + Math.imul(Na, ls) | 0, ya = ya + Math.imul(za, vs) | 0, Ba = Ba + Math.imul(za, ls) | 0, La = La + Math.imul(oo, ws) | 0, ya = ya + Math.imul(oo, as) | 0, ya = ya + Math.imul(ao, ws) | 0, Ba = Ba + Math.imul(ao, as) | 0;
				var Vo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Vo >>> 26) | 0, Vo &= 67108863, La = Math.imul(Eo, bo), ya = Math.imul(Eo, So), ya = ya + Math.imul(wo, bo) | 0, Ba = Math.imul(wo, So), La = La + Math.imul(Xa, Po) | 0, ya = ya + Math.imul(Xa, Ro) | 0, ya = ya + Math.imul(to, Po) | 0, Ba = Ba + Math.imul(to, Ro) | 0, La = La + Math.imul(fo, Oo) | 0, ya = ya + Math.imul(fo, No) | 0, ya = ya + Math.imul(vo, Oo) | 0, Ba = Ba + Math.imul(vo, No) | 0, La = La + Math.imul(Ka, Ko) | 0, ya = ya + Math.imul(Ka, Go) | 0, ya = ya + Math.imul(lo, Ko) | 0, Ba = Ba + Math.imul(lo, Go) | 0, La = La + Math.imul(Va, vs) | 0, ya = ya + Math.imul(Va, ls) | 0, ya = ya + Math.imul(Wa, vs) | 0, Ba = Ba + Math.imul(Wa, ls) | 0, La = La + Math.imul(Na, ws) | 0, ya = ya + Math.imul(Na, as) | 0, ya = ya + Math.imul(za, ws) | 0, Ba = Ba + Math.imul(za, as) | 0, La = La + Math.imul(oo, Ha) | 0, ya = ya + Math.imul(oo, Fa) | 0, ya = ya + Math.imul(ao, Ha) | 0, Ba = Ba + Math.imul(ao, Fa) | 0;
				var cs = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (cs >>> 26) | 0, cs &= 67108863, La = Math.imul(_o, bo), ya = Math.imul(_o, So), ya = ya + Math.imul(Lo, bo) | 0, Ba = Math.imul(Lo, So), La = La + Math.imul(Eo, Po) | 0, ya = ya + Math.imul(Eo, Ro) | 0, ya = ya + Math.imul(wo, Po) | 0, Ba = Ba + Math.imul(wo, Ro) | 0, La = La + Math.imul(Xa, Oo) | 0, ya = ya + Math.imul(Xa, No) | 0, ya = ya + Math.imul(to, Oo) | 0, Ba = Ba + Math.imul(to, No) | 0, La = La + Math.imul(fo, Ko) | 0, ya = ya + Math.imul(fo, Go) | 0, ya = ya + Math.imul(vo, Ko) | 0, Ba = Ba + Math.imul(vo, Go) | 0, La = La + Math.imul(Ka, vs) | 0, ya = ya + Math.imul(Ka, ls) | 0, ya = ya + Math.imul(lo, vs) | 0, Ba = Ba + Math.imul(lo, ls) | 0, La = La + Math.imul(Va, ws) | 0, ya = ya + Math.imul(Va, as) | 0, ya = ya + Math.imul(Wa, ws) | 0, Ba = Ba + Math.imul(Wa, as) | 0, La = La + Math.imul(Na, Ha) | 0, ya = ya + Math.imul(Na, Fa) | 0, ya = ya + Math.imul(za, Ha) | 0, Ba = Ba + Math.imul(za, Fa) | 0, La = La + Math.imul(oo, $a) | 0, ya = ya + Math.imul(oo, no) | 0, ya = ya + Math.imul(ao, $a) | 0, Ba = Ba + Math.imul(ao, no) | 0;
				var Zo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Zo >>> 26) | 0, Zo &= 67108863, La = Math.imul(jo, bo), ya = Math.imul(jo, So), ya = ya + Math.imul(eo, bo) | 0, Ba = Math.imul(eo, So), La = La + Math.imul(_o, Po) | 0, ya = ya + Math.imul(_o, Ro) | 0, ya = ya + Math.imul(Lo, Po) | 0, Ba = Ba + Math.imul(Lo, Ro) | 0, La = La + Math.imul(Eo, Oo) | 0, ya = ya + Math.imul(Eo, No) | 0, ya = ya + Math.imul(wo, Oo) | 0, Ba = Ba + Math.imul(wo, No) | 0, La = La + Math.imul(Xa, Ko) | 0, ya = ya + Math.imul(Xa, Go) | 0, ya = ya + Math.imul(to, Ko) | 0, Ba = Ba + Math.imul(to, Go) | 0, La = La + Math.imul(fo, vs) | 0, ya = ya + Math.imul(fo, ls) | 0, ya = ya + Math.imul(vo, vs) | 0, Ba = Ba + Math.imul(vo, ls) | 0, La = La + Math.imul(Ka, ws) | 0, ya = ya + Math.imul(Ka, as) | 0, ya = ya + Math.imul(lo, ws) | 0, Ba = Ba + Math.imul(lo, as) | 0, La = La + Math.imul(Va, Ha) | 0, ya = ya + Math.imul(Va, Fa) | 0, ya = ya + Math.imul(Wa, Ha) | 0, Ba = Ba + Math.imul(Wa, Fa) | 0, La = La + Math.imul(Na, $a) | 0, ya = ya + Math.imul(Na, no) | 0, ya = ya + Math.imul(za, $a) | 0, Ba = Ba + Math.imul(za, no) | 0, La = La + Math.imul(oo, co) | 0, ya = ya + Math.imul(oo, mo) | 0, ya = ya + Math.imul(ao, co) | 0, Ba = Ba + Math.imul(ao, mo) | 0;
				var us = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (us >>> 26) | 0, us &= 67108863, La = Math.imul(Da, bo), ya = Math.imul(Da, So), ya = ya + Math.imul(Qa, bo) | 0, Ba = Math.imul(Qa, So), La = La + Math.imul(jo, Po) | 0, ya = ya + Math.imul(jo, Ro) | 0, ya = ya + Math.imul(eo, Po) | 0, Ba = Ba + Math.imul(eo, Ro) | 0, La = La + Math.imul(_o, Oo) | 0, ya = ya + Math.imul(_o, No) | 0, ya = ya + Math.imul(Lo, Oo) | 0, Ba = Ba + Math.imul(Lo, No) | 0, La = La + Math.imul(Eo, Ko) | 0, ya = ya + Math.imul(Eo, Go) | 0, ya = ya + Math.imul(wo, Ko) | 0, Ba = Ba + Math.imul(wo, Go) | 0, La = La + Math.imul(Xa, vs) | 0, ya = ya + Math.imul(Xa, ls) | 0, ya = ya + Math.imul(to, vs) | 0, Ba = Ba + Math.imul(to, ls) | 0, La = La + Math.imul(fo, ws) | 0, ya = ya + Math.imul(fo, as) | 0, ya = ya + Math.imul(vo, ws) | 0, Ba = Ba + Math.imul(vo, as) | 0, La = La + Math.imul(Ka, Ha) | 0, ya = ya + Math.imul(Ka, Fa) | 0, ya = ya + Math.imul(lo, Ha) | 0, Ba = Ba + Math.imul(lo, Fa) | 0, La = La + Math.imul(Va, $a) | 0, ya = ya + Math.imul(Va, no) | 0, ya = ya + Math.imul(Wa, $a) | 0, Ba = Ba + Math.imul(Wa, no) | 0, La = La + Math.imul(Na, co) | 0, ya = ya + Math.imul(Na, mo) | 0, ya = ya + Math.imul(za, co) | 0, Ba = Ba + Math.imul(za, mo) | 0, La = La + Math.imul(oo, ko) | 0, ya = ya + Math.imul(oo, $o) | 0, ya = ya + Math.imul(ao, ko) | 0, Ba = Ba + Math.imul(ao, $o) | 0;
				var Jo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Jo >>> 26) | 0, Jo &= 67108863, La = Math.imul(Da, Po), ya = Math.imul(Da, Ro), ya = ya + Math.imul(Qa, Po) | 0, Ba = Math.imul(Qa, Ro), La = La + Math.imul(jo, Oo) | 0, ya = ya + Math.imul(jo, No) | 0, ya = ya + Math.imul(eo, Oo) | 0, Ba = Ba + Math.imul(eo, No) | 0, La = La + Math.imul(_o, Ko) | 0, ya = ya + Math.imul(_o, Go) | 0, ya = ya + Math.imul(Lo, Ko) | 0, Ba = Ba + Math.imul(Lo, Go) | 0, La = La + Math.imul(Eo, vs) | 0, ya = ya + Math.imul(Eo, ls) | 0, ya = ya + Math.imul(wo, vs) | 0, Ba = Ba + Math.imul(wo, ls) | 0, La = La + Math.imul(Xa, ws) | 0, ya = ya + Math.imul(Xa, as) | 0, ya = ya + Math.imul(to, ws) | 0, Ba = Ba + Math.imul(to, as) | 0, La = La + Math.imul(fo, Ha) | 0, ya = ya + Math.imul(fo, Fa) | 0, ya = ya + Math.imul(vo, Ha) | 0, Ba = Ba + Math.imul(vo, Fa) | 0, La = La + Math.imul(Ka, $a) | 0, ya = ya + Math.imul(Ka, no) | 0, ya = ya + Math.imul(lo, $a) | 0, Ba = Ba + Math.imul(lo, no) | 0, La = La + Math.imul(Va, co) | 0, ya = ya + Math.imul(Va, mo) | 0, ya = ya + Math.imul(Wa, co) | 0, Ba = Ba + Math.imul(Wa, mo) | 0, La = La + Math.imul(Na, ko) | 0, ya = ya + Math.imul(Na, $o) | 0, ya = ya + Math.imul(za, ko) | 0, Ba = Ba + Math.imul(za, $o) | 0;
				var hs = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (hs >>> 26) | 0, hs &= 67108863, La = Math.imul(Da, Oo), ya = Math.imul(Da, No), ya = ya + Math.imul(Qa, Oo) | 0, Ba = Math.imul(Qa, No), La = La + Math.imul(jo, Ko) | 0, ya = ya + Math.imul(jo, Go) | 0, ya = ya + Math.imul(eo, Ko) | 0, Ba = Ba + Math.imul(eo, Go) | 0, La = La + Math.imul(_o, vs) | 0, ya = ya + Math.imul(_o, ls) | 0, ya = ya + Math.imul(Lo, vs) | 0, Ba = Ba + Math.imul(Lo, ls) | 0, La = La + Math.imul(Eo, ws) | 0, ya = ya + Math.imul(Eo, as) | 0, ya = ya + Math.imul(wo, ws) | 0, Ba = Ba + Math.imul(wo, as) | 0, La = La + Math.imul(Xa, Ha) | 0, ya = ya + Math.imul(Xa, Fa) | 0, ya = ya + Math.imul(to, Ha) | 0, Ba = Ba + Math.imul(to, Fa) | 0, La = La + Math.imul(fo, $a) | 0, ya = ya + Math.imul(fo, no) | 0, ya = ya + Math.imul(vo, $a) | 0, Ba = Ba + Math.imul(vo, no) | 0, La = La + Math.imul(Ka, co) | 0, ya = ya + Math.imul(Ka, mo) | 0, ya = ya + Math.imul(lo, co) | 0, Ba = Ba + Math.imul(lo, mo) | 0, La = La + Math.imul(Va, ko) | 0, ya = ya + Math.imul(Va, $o) | 0, ya = ya + Math.imul(Wa, ko) | 0, Ba = Ba + Math.imul(Wa, $o) | 0;
				var Qo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Qo >>> 26) | 0, Qo &= 67108863, La = Math.imul(Da, Ko), ya = Math.imul(Da, Go), ya = ya + Math.imul(Qa, Ko) | 0, Ba = Math.imul(Qa, Go), La = La + Math.imul(jo, vs) | 0, ya = ya + Math.imul(jo, ls) | 0, ya = ya + Math.imul(eo, vs) | 0, Ba = Ba + Math.imul(eo, ls) | 0, La = La + Math.imul(_o, ws) | 0, ya = ya + Math.imul(_o, as) | 0, ya = ya + Math.imul(Lo, ws) | 0, Ba = Ba + Math.imul(Lo, as) | 0, La = La + Math.imul(Eo, Ha) | 0, ya = ya + Math.imul(Eo, Fa) | 0, ya = ya + Math.imul(wo, Ha) | 0, Ba = Ba + Math.imul(wo, Fa) | 0, La = La + Math.imul(Xa, $a) | 0, ya = ya + Math.imul(Xa, no) | 0, ya = ya + Math.imul(to, $a) | 0, Ba = Ba + Math.imul(to, no) | 0, La = La + Math.imul(fo, co) | 0, ya = ya + Math.imul(fo, mo) | 0, ya = ya + Math.imul(vo, co) | 0, Ba = Ba + Math.imul(vo, mo) | 0, La = La + Math.imul(Ka, ko) | 0, ya = ya + Math.imul(Ka, $o) | 0, ya = ya + Math.imul(lo, ko) | 0, Ba = Ba + Math.imul(lo, $o) | 0;
				var fs = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (fs >>> 26) | 0, fs &= 67108863, La = Math.imul(Da, vs), ya = Math.imul(Da, ls), ya = ya + Math.imul(Qa, vs) | 0, Ba = Math.imul(Qa, ls), La = La + Math.imul(jo, ws) | 0, ya = ya + Math.imul(jo, as) | 0, ya = ya + Math.imul(eo, ws) | 0, Ba = Ba + Math.imul(eo, as) | 0, La = La + Math.imul(_o, Ha) | 0, ya = ya + Math.imul(_o, Fa) | 0, ya = ya + Math.imul(Lo, Ha) | 0, Ba = Ba + Math.imul(Lo, Fa) | 0, La = La + Math.imul(Eo, $a) | 0, ya = ya + Math.imul(Eo, no) | 0, ya = ya + Math.imul(wo, $a) | 0, Ba = Ba + Math.imul(wo, no) | 0, La = La + Math.imul(Xa, co) | 0, ya = ya + Math.imul(Xa, mo) | 0, ya = ya + Math.imul(to, co) | 0, Ba = Ba + Math.imul(to, mo) | 0, La = La + Math.imul(fo, ko) | 0, ya = ya + Math.imul(fo, $o) | 0, ya = ya + Math.imul(vo, ko) | 0, Ba = Ba + Math.imul(vo, $o) | 0;
				var ds = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (ds >>> 26) | 0, ds &= 67108863, La = Math.imul(Da, ws), ya = Math.imul(Da, as), ya = ya + Math.imul(Qa, ws) | 0, Ba = Math.imul(Qa, as), La = La + Math.imul(jo, Ha) | 0, ya = ya + Math.imul(jo, Fa) | 0, ya = ya + Math.imul(eo, Ha) | 0, Ba = Ba + Math.imul(eo, Fa) | 0, La = La + Math.imul(_o, $a) | 0, ya = ya + Math.imul(_o, no) | 0, ya = ya + Math.imul(Lo, $a) | 0, Ba = Ba + Math.imul(Lo, no) | 0, La = La + Math.imul(Eo, co) | 0, ya = ya + Math.imul(Eo, mo) | 0, ya = ya + Math.imul(wo, co) | 0, Ba = Ba + Math.imul(wo, mo) | 0, La = La + Math.imul(Xa, ko) | 0, ya = ya + Math.imul(Xa, $o) | 0, ya = ya + Math.imul(to, ko) | 0, Ba = Ba + Math.imul(to, $o) | 0;
				var Yo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Yo >>> 26) | 0, Yo &= 67108863, La = Math.imul(Da, Ha), ya = Math.imul(Da, Fa), ya = ya + Math.imul(Qa, Ha) | 0, Ba = Math.imul(Qa, Fa), La = La + Math.imul(jo, $a) | 0, ya = ya + Math.imul(jo, no) | 0, ya = ya + Math.imul(eo, $a) | 0, Ba = Ba + Math.imul(eo, no) | 0, La = La + Math.imul(_o, co) | 0, ya = ya + Math.imul(_o, mo) | 0, ya = ya + Math.imul(Lo, co) | 0, Ba = Ba + Math.imul(Lo, mo) | 0, La = La + Math.imul(Eo, ko) | 0, ya = ya + Math.imul(Eo, $o) | 0, ya = ya + Math.imul(wo, ko) | 0, Ba = Ba + Math.imul(wo, $o) | 0;
				var Bo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Bo >>> 26) | 0, Bo &= 67108863, La = Math.imul(Da, $a), ya = Math.imul(Da, no), ya = ya + Math.imul(Qa, $a) | 0, Ba = Math.imul(Qa, no), La = La + Math.imul(jo, co) | 0, ya = ya + Math.imul(jo, mo) | 0, ya = ya + Math.imul(eo, co) | 0, Ba = Ba + Math.imul(eo, mo) | 0, La = La + Math.imul(_o, ko) | 0, ya = ya + Math.imul(_o, $o) | 0, ya = ya + Math.imul(Lo, ko) | 0, Ba = Ba + Math.imul(Lo, $o) | 0;
				var Mo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Mo >>> 26) | 0, Mo &= 67108863, La = Math.imul(Da, co), ya = Math.imul(Da, mo), ya = ya + Math.imul(Qa, co) | 0, Ba = Math.imul(Qa, mo), La = La + Math.imul(jo, ko) | 0, ya = ya + Math.imul(jo, $o) | 0, ya = ya + Math.imul(eo, ko) | 0, Ba = Ba + Math.imul(eo, $o) | 0;
				var Uo = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				Ta = (Ba + (ya >>> 13) | 0) + (Uo >>> 26) | 0, Uo &= 67108863, La = Math.imul(Da, ko), ya = Math.imul(Da, $o), ya = ya + Math.imul(Qa, ko) | 0, Ba = Math.imul(Qa, $o);
				var Do = (Ta + La | 0) + ((ya & 8191) << 13) | 0;
				return Ta = (Ba + (ya >>> 13) | 0) + (Do >>> 26) | 0, Do &= 67108863, Ra[0] = Ss, Ra[1] = Xo, Ra[2] = ms, Ra[3] = gs, Ra[4] = ys, Ra[5] = Vo, Ra[6] = cs, Ra[7] = Zo, Ra[8] = us, Ra[9] = Jo, Ra[10] = hs, Ra[11] = Qo, Ra[12] = fs, Ra[13] = ds, Ra[14] = Yo, Ra[15] = Bo, Ra[16] = Mo, Ra[17] = Uo, Ra[18] = Do, Ta !== 0 && (Ra[19] = Ta, wa.length++), wa
			};
			Math.imul || (Ea = ba);

			function Sa(ma, fa, ga) {
				ga.negative = fa.negative ^ ma.negative, ga.length = ma.length + fa.length;
				for (var wa = 0, Ma = 0, Aa = 0; Aa < ga.length - 1; Aa++) {
					var Ra = Ma;
					Ma = 0;
					for (var Ta = wa & 67108863, La = Math.min(Aa, fa.length - 1), ya = Math.max(0, Aa - ma.length + 1); ya <= La; ya++) {
						var Ba = Aa - ya,
							io = ma.words[Ba] | 0,
							oo = fa.words[ya] | 0,
							ao = io * oo,
							Ia = ao & 67108863;
						Ra = Ra + (ao / 67108864 | 0) | 0, Ia = Ia + Ta | 0, Ta = Ia & 67108863, Ra = Ra + (Ia >>> 26) | 0, Ma += Ra >>> 26, Ra &= 67108863
					}
					ga.words[Aa] = Ta, wa = Ra, Ra = Ma
				}
				return wa !== 0 ? ga.words[Aa] = wa : ga.length--, ga._strip()
			}

			function Ca(ma, fa, ga) {
				return Sa(ma, fa, ga)
			}
			ra.prototype.mulTo = function(fa, ga) {
				var wa, Ma = this.length + fa.length;
				return this.length === 10 && fa.length === 10 ? wa = Ea(this, fa, ga) : Ma < 63 ? wa = ba(this, fa, ga) : Ma < 1024 ? wa = Sa(this, fa, ga) : wa = Ca(this, fa, ga), wa
			}, ra.prototype.mul = function(fa) {
				var ga = new ra(null);
				return ga.words = new Array(this.length + fa.length), this.mulTo(fa, ga)
			}, ra.prototype.mulf = function(fa) {
				var ga = new ra(null);
				return ga.words = new Array(this.length + fa.length), Ca(this, fa, ga)
			}, ra.prototype.imul = function(fa) {
				return this.clone().mulTo(fa, this)
			}, ra.prototype.imuln = function(fa) {
				var ga = fa < 0;
				ga && (fa = -fa), ta(typeof fa == "number"), ta(fa < 67108864);
				for (var wa = 0, Ma = 0; Ma < this.length; Ma++) {
					var Aa = (this.words[Ma] | 0) * fa,
						Ra = (Aa & 67108863) + (wa & 67108863);
					wa >>= 26, wa += Aa / 67108864 | 0, wa += Ra >>> 26, this.words[Ma] = Ra & 67108863
				}
				return wa !== 0 && (this.words[Ma] = wa, this.length++), ga ? this.ineg() : this
			}, ra.prototype.muln = function(fa) {
				return this.clone().imuln(fa)
			}, ra.prototype.sqr = function() {
				return this.mul(this)
			}, ra.prototype.isqr = function() {
				return this.imul(this.clone())
			}, ra.prototype.pow = function(fa) {
				var ga = va(fa);
				if (ga.length === 0) return new ra(1);
				for (var wa = this, Ma = 0; Ma < ga.length && ga[Ma] === 0; Ma++, wa = wa.sqr());
				if (++Ma < ga.length)
					for (var Aa = wa.sqr(); Ma < ga.length; Ma++, Aa = Aa.sqr()) ga[Ma] !== 0 && (wa = wa.mul(Aa));
				return wa
			}, ra.prototype.iushln = function(fa) {
				ta(typeof fa == "number" && fa >= 0);
				var ga = fa % 26,
					wa = (fa - ga) / 26,
					Ma = 67108863 >>> 26 - ga << 26 - ga,
					Aa;
				if (ga !== 0) {
					var Ra = 0;
					for (Aa = 0; Aa < this.length; Aa++) {
						var Ta = this.words[Aa] & Ma,
							La = (this.words[Aa] | 0) - Ta << ga;
						this.words[Aa] = La | Ra, Ra = Ta >>> 26 - ga
					}
					Ra && (this.words[Aa] = Ra, this.length++)
				}
				if (wa !== 0) {
					for (Aa = this.length - 1; Aa >= 0; Aa--) this.words[Aa + wa] = this.words[Aa];
					for (Aa = 0; Aa < wa; Aa++) this.words[Aa] = 0;
					this.length += wa
				}
				return this._strip()
			}, ra.prototype.ishln = function(fa) {
				return ta(this.negative === 0), this.iushln(fa)
			}, ra.prototype.iushrn = function(fa, ga, wa) {
				ta(typeof fa == "number" && fa >= 0);
				var Ma;
				ga ? Ma = (ga - ga % 26) / 26 : Ma = 0;
				var Aa = fa % 26,
					Ra = Math.min((fa - Aa) / 26, this.length),
					Ta = 67108863 ^ 67108863 >>> Aa << Aa,
					La = wa;
				if (Ma -= Ra, Ma = Math.max(0, Ma), La) {
					for (var ya = 0; ya < Ra; ya++) La.words[ya] = this.words[ya];
					La.length = Ra
				}
				if (Ra !== 0)
					if (this.length > Ra)
						for (this.length -= Ra, ya = 0; ya < this.length; ya++) this.words[ya] = this.words[ya + Ra];
					else this.words[0] = 0, this.length = 1;
				var Ba = 0;
				for (ya = this.length - 1; ya >= 0 && (Ba !== 0 || ya >= Ma); ya--) {
					var io = this.words[ya] | 0;
					this.words[ya] = Ba << 26 - Aa | io >>> Aa, Ba = io & Ta
				}
				return La && Ba !== 0 && (La.words[La.length++] = Ba), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip()
			}, ra.prototype.ishrn = function(fa, ga, wa) {
				return ta(this.negative === 0), this.iushrn(fa, ga, wa)
			}, ra.prototype.shln = function(fa) {
				return this.clone().ishln(fa)
			}, ra.prototype.ushln = function(fa) {
				return this.clone().iushln(fa)
			}, ra.prototype.shrn = function(fa) {
				return this.clone().ishrn(fa)
			}, ra.prototype.ushrn = function(fa) {
				return this.clone().iushrn(fa)
			}, ra.prototype.testn = function(fa) {
				ta(typeof fa == "number" && fa >= 0);
				var ga = fa % 26,
					wa = (fa - ga) / 26,
					Ma = 1 << ga;
				if (this.length <= wa) return !1;
				var Aa = this.words[wa];
				return !!(Aa & Ma)
			}, ra.prototype.imaskn = function(fa) {
				ta(typeof fa == "number" && fa >= 0);
				var ga = fa % 26,
					wa = (fa - ga) / 26;
				if (ta(this.negative === 0, "imaskn works only with positive numbers"), this.length <= wa) return this;
				if (ga !== 0 && wa++, this.length = Math.min(wa, this.length), ga !== 0) {
					var Ma = 67108863 ^ 67108863 >>> ga << ga;
					this.words[this.length - 1] &= Ma
				}
				return this._strip()
			}, ra.prototype.maskn = function(fa) {
				return this.clone().imaskn(fa)
			}, ra.prototype.iaddn = function(fa) {
				return ta(typeof fa == "number"), ta(fa < 67108864), fa < 0 ? this.isubn(-fa) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= fa ? (this.words[0] = fa - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(fa), this.negative = 1, this) : this._iaddn(fa)
			}, ra.prototype._iaddn = function(fa) {
				this.words[0] += fa;
				for (var ga = 0; ga < this.length && this.words[ga] >= 67108864; ga++) this.words[ga] -= 67108864, ga === this.length - 1 ? this.words[ga + 1] = 1 : this.words[ga + 1]++;
				return this.length = Math.max(this.length, ga + 1), this
			}, ra.prototype.isubn = function(fa) {
				if (ta(typeof fa == "number"), ta(fa < 67108864), fa < 0) return this.iaddn(-fa);
				if (this.negative !== 0) return this.negative = 0, this.iaddn(fa), this.negative = 1, this;
				if (this.words[0] -= fa, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
				else
					for (var ga = 0; ga < this.length && this.words[ga] < 0; ga++) this.words[ga] += 67108864, this.words[ga + 1] -= 1;
				return this._strip()
			}, ra.prototype.addn = function(fa) {
				return this.clone().iaddn(fa)
			}, ra.prototype.subn = function(fa) {
				return this.clone().isubn(fa)
			}, ra.prototype.iabs = function() {
				return this.negative = 0, this
			}, ra.prototype.abs = function() {
				return this.clone().iabs()
			}, ra.prototype._ishlnsubmul = function(fa, ga, wa) {
				var Ma = fa.length + wa,
					Aa;
				this._expand(Ma);
				var Ra, Ta = 0;
				for (Aa = 0; Aa < fa.length; Aa++) {
					Ra = (this.words[Aa + wa] | 0) + Ta;
					var La = (fa.words[Aa] | 0) * ga;
					Ra -= La & 67108863, Ta = (Ra >> 26) - (La / 67108864 | 0), this.words[Aa + wa] = Ra & 67108863
				}
				for (; Aa < this.length - wa; Aa++) Ra = (this.words[Aa + wa] | 0) + Ta, Ta = Ra >> 26, this.words[Aa + wa] = Ra & 67108863;
				if (Ta === 0) return this._strip();
				for (ta(Ta === -1), Ta = 0, Aa = 0; Aa < this.length; Aa++) Ra = -(this.words[Aa] | 0) + Ta, Ta = Ra >> 26, this.words[Aa] = Ra & 67108863;
				return this.negative = 1, this._strip()
			}, ra.prototype._wordDiv = function(fa, ga) {
				var wa = this.length - fa.length,
					Ma = this.clone(),
					Aa = fa,
					Ra = Aa.words[Aa.length - 1] | 0,
					Ta = this._countBits(Ra);
				wa = 26 - Ta, wa !== 0 && (Aa = Aa.ushln(wa), Ma.iushln(wa), Ra = Aa.words[Aa.length - 1] | 0);
				var La = Ma.length - Aa.length,
					ya;
				if (ga !== "mod") {
					ya = new ra(null), ya.length = La + 1, ya.words = new Array(ya.length);
					for (var Ba = 0; Ba < ya.length; Ba++) ya.words[Ba] = 0
				}
				var io = Ma.clone()._ishlnsubmul(Aa, 1, La);
				io.negative === 0 && (Ma = io, ya && (ya.words[La] = 1));
				for (var oo = La - 1; oo >= 0; oo--) {
					var ao = (Ma.words[Aa.length + oo] | 0) * 67108864 + (Ma.words[Aa.length + oo - 1] | 0);
					for (ao = Math.min(ao / Ra | 0, 67108863), Ma._ishlnsubmul(Aa, ao, oo); Ma.negative !== 0;) ao--, Ma.negative = 0, Ma._ishlnsubmul(Aa, 1, oo), Ma.isZero() || (Ma.negative ^= 1);
					ya && (ya.words[oo] = ao)
				}
				return ya && ya._strip(), Ma._strip(), ga !== "div" && wa !== 0 && Ma.iushrn(wa), {
					div: ya || null,
					mod: Ma
				}
			}, ra.prototype.divmod = function(fa, ga, wa) {
				if (ta(!fa.isZero()), this.isZero()) return {
					div: new ra(0),
					mod: new ra(0)
				};
				var Ma, Aa, Ra;
				return this.negative !== 0 && fa.negative === 0 ? (Ra = this.neg().divmod(fa, ga), ga !== "mod" && (Ma = Ra.div.neg()), ga !== "div" && (Aa = Ra.mod.neg(), wa && Aa.negative !== 0 && Aa.iadd(fa)), {
					div: Ma,
					mod: Aa
				}) : this.negative === 0 && fa.negative !== 0 ? (Ra = this.divmod(fa.neg(), ga), ga !== "mod" && (Ma = Ra.div.neg()), {
					div: Ma,
					mod: Ra.mod
				}) : this.negative & fa.negative ? (Ra = this.neg().divmod(fa.neg(), ga), ga !== "div" && (Aa = Ra.mod.neg(), wa && Aa.negative !== 0 && Aa.isub(fa)), {
					div: Ra.div,
					mod: Aa
				}) : fa.length > this.length || this.cmp(fa) < 0 ? {
					div: new ra(0),
					mod: this
				} : fa.length === 1 ? ga === "div" ? {
					div: this.divn(fa.words[0]),
					mod: null
				} : ga === "mod" ? {
					div: null,
					mod: new ra(this.modrn(fa.words[0]))
				} : {
					div: this.divn(fa.words[0]),
					mod: new ra(this.modrn(fa.words[0]))
				} : this._wordDiv(fa, ga)
			}, ra.prototype.div = function(fa) {
				return this.divmod(fa, "div", !1).div
			}, ra.prototype.mod = function(fa) {
				return this.divmod(fa, "mod", !1).mod
			}, ra.prototype.umod = function(fa) {
				return this.divmod(fa, "mod", !0).mod
			}, ra.prototype.divRound = function(fa) {
				var ga = this.divmod(fa);
				if (ga.mod.isZero()) return ga.div;
				var wa = ga.div.negative !== 0 ? ga.mod.isub(fa) : ga.mod,
					Ma = fa.ushrn(1),
					Aa = fa.andln(1),
					Ra = wa.cmp(Ma);
				return Ra < 0 || Aa === 1 && Ra === 0 ? ga.div : ga.div.negative !== 0 ? ga.div.isubn(1) : ga.div.iaddn(1)
			}, ra.prototype.modrn = function(fa) {
				var ga = fa < 0;
				ga && (fa = -fa), ta(fa <= 67108863);
				for (var wa = (1 << 26) % fa, Ma = 0, Aa = this.length - 1; Aa >= 0; Aa--) Ma = (wa * Ma + (this.words[Aa] | 0)) % fa;
				return ga ? -Ma : Ma
			}, ra.prototype.modn = function(fa) {
				return this.modrn(fa)
			}, ra.prototype.idivn = function(fa) {
				var ga = fa < 0;
				ga && (fa = -fa), ta(fa <= 67108863);
				for (var wa = 0, Ma = this.length - 1; Ma >= 0; Ma--) {
					var Aa = (this.words[Ma] | 0) + wa * 67108864;
					this.words[Ma] = Aa / fa | 0, wa = Aa % fa
				}
				return this._strip(), ga ? this.ineg() : this
			}, ra.prototype.divn = function(fa) {
				return this.clone().idivn(fa)
			}, ra.prototype.egcd = function(fa) {
				ta(fa.negative === 0), ta(!fa.isZero());
				var ga = this,
					wa = fa.clone();
				ga.negative !== 0 ? ga = ga.umod(fa) : ga = ga.clone();
				for (var Ma = new ra(1), Aa = new ra(0), Ra = new ra(0), Ta = new ra(1), La = 0; ga.isEven() && wa.isEven();) ga.iushrn(1), wa.iushrn(1), ++La;
				for (var ya = wa.clone(), Ba = ga.clone(); !ga.isZero();) {
					for (var io = 0, oo = 1; !(ga.words[0] & oo) && io < 26; ++io, oo <<= 1);
					if (io > 0)
						for (ga.iushrn(io); io-- > 0;)(Ma.isOdd() || Aa.isOdd()) && (Ma.iadd(ya), Aa.isub(Ba)), Ma.iushrn(1), Aa.iushrn(1);
					for (var ao = 0, Ia = 1; !(wa.words[0] & Ia) && ao < 26; ++ao, Ia <<= 1);
					if (ao > 0)
						for (wa.iushrn(ao); ao-- > 0;)(Ra.isOdd() || Ta.isOdd()) && (Ra.iadd(ya), Ta.isub(Ba)), Ra.iushrn(1), Ta.iushrn(1);
					ga.cmp(wa) >= 0 ? (ga.isub(wa), Ma.isub(Ra), Aa.isub(Ta)) : (wa.isub(ga), Ra.isub(Ma), Ta.isub(Aa))
				}
				return {
					a: Ra,
					b: Ta,
					gcd: wa.iushln(La)
				}
			}, ra.prototype._invmp = function(fa) {
				ta(fa.negative === 0), ta(!fa.isZero());
				var ga = this,
					wa = fa.clone();
				ga.negative !== 0 ? ga = ga.umod(fa) : ga = ga.clone();
				for (var Ma = new ra(1), Aa = new ra(0), Ra = wa.clone(); ga.cmpn(1) > 0 && wa.cmpn(1) > 0;) {
					for (var Ta = 0, La = 1; !(ga.words[0] & La) && Ta < 26; ++Ta, La <<= 1);
					if (Ta > 0)
						for (ga.iushrn(Ta); Ta-- > 0;) Ma.isOdd() && Ma.iadd(Ra), Ma.iushrn(1);
					for (var ya = 0, Ba = 1; !(wa.words[0] & Ba) && ya < 26; ++ya, Ba <<= 1);
					if (ya > 0)
						for (wa.iushrn(ya); ya-- > 0;) Aa.isOdd() && Aa.iadd(Ra), Aa.iushrn(1);
					ga.cmp(wa) >= 0 ? (ga.isub(wa), Ma.isub(Aa)) : (wa.isub(ga), Aa.isub(Ma))
				}
				var io;
				return ga.cmpn(1) === 0 ? io = Ma : io = Aa, io.cmpn(0) < 0 && io.iadd(fa), io
			}, ra.prototype.gcd = function(fa) {
				if (this.isZero()) return fa.abs();
				if (fa.isZero()) return this.abs();
				var ga = this.clone(),
					wa = fa.clone();
				ga.negative = 0, wa.negative = 0;
				for (var Ma = 0; ga.isEven() && wa.isEven(); Ma++) ga.iushrn(1), wa.iushrn(1);
				do {
					for (; ga.isEven();) ga.iushrn(1);
					for (; wa.isEven();) wa.iushrn(1);
					var Aa = ga.cmp(wa);
					if (Aa < 0) {
						var Ra = ga;
						ga = wa, wa = Ra
					} else if (Aa === 0 || wa.cmpn(1) === 0) break;
					ga.isub(wa)
				} while (!0);
				return wa.iushln(Ma)
			}, ra.prototype.invm = function(fa) {
				return this.egcd(fa).a.umod(fa)
			}, ra.prototype.isEven = function() {
				return (this.words[0] & 1) === 0
			}, ra.prototype.isOdd = function() {
				return (this.words[0] & 1) === 1
			}, ra.prototype.andln = function(fa) {
				return this.words[0] & fa
			}, ra.prototype.bincn = function(fa) {
				ta(typeof fa == "number");
				var ga = fa % 26,
					wa = (fa - ga) / 26,
					Ma = 1 << ga;
				if (this.length <= wa) return this._expand(wa + 1), this.words[wa] |= Ma, this;
				for (var Aa = Ma, Ra = wa; Aa !== 0 && Ra < this.length; Ra++) {
					var Ta = this.words[Ra] | 0;
					Ta += Aa, Aa = Ta >>> 26, Ta &= 67108863, this.words[Ra] = Ta
				}
				return Aa !== 0 && (this.words[Ra] = Aa, this.length++), this
			}, ra.prototype.isZero = function() {
				return this.length === 1 && this.words[0] === 0
			}, ra.prototype.cmpn = function(fa) {
				var ga = fa < 0;
				if (this.negative !== 0 && !ga) return -1;
				if (this.negative === 0 && ga) return 1;
				this._strip();
				var wa;
				if (this.length > 1) wa = 1;
				else {
					ga && (fa = -fa), ta(fa <= 67108863, "Number is too big");
					var Ma = this.words[0] | 0;
					wa = Ma === fa ? 0 : Ma < fa ? -1 : 1
				}
				return this.negative !== 0 ? -wa | 0 : wa
			}, ra.prototype.cmp = function(fa) {
				if (this.negative !== 0 && fa.negative === 0) return -1;
				if (this.negative === 0 && fa.negative !== 0) return 1;
				var ga = this.ucmp(fa);
				return this.negative !== 0 ? -ga | 0 : ga
			}, ra.prototype.ucmp = function(fa) {
				if (this.length > fa.length) return 1;
				if (this.length < fa.length) return -1;
				for (var ga = 0, wa = this.length - 1; wa >= 0; wa--) {
					var Ma = this.words[wa] | 0,
						Aa = fa.words[wa] | 0;
					if (Ma !== Aa) {
						Ma < Aa ? ga = -1 : Ma > Aa && (ga = 1);
						break
					}
				}
				return ga
			}, ra.prototype.gtn = function(fa) {
				return this.cmpn(fa) === 1
			}, ra.prototype.gt = function(fa) {
				return this.cmp(fa) === 1
			}, ra.prototype.gten = function(fa) {
				return this.cmpn(fa) >= 0
			}, ra.prototype.gte = function(fa) {
				return this.cmp(fa) >= 0
			}, ra.prototype.ltn = function(fa) {
				return this.cmpn(fa) === -1
			}, ra.prototype.lt = function(fa) {
				return this.cmp(fa) === -1
			}, ra.prototype.lten = function(fa) {
				return this.cmpn(fa) <= 0
			}, ra.prototype.lte = function(fa) {
				return this.cmp(fa) <= 0
			}, ra.prototype.eqn = function(fa) {
				return this.cmpn(fa) === 0
			}, ra.prototype.eq = function(fa) {
				return this.cmp(fa) === 0
			}, ra.red = function(fa) {
				return new Ua(fa)
			}, ra.prototype.toRed = function(fa) {
				return ta(!this.red, "Already a number in reduction context"), ta(this.negative === 0, "red works only with positives"), fa.convertTo(this)._forceRed(fa)
			}, ra.prototype.fromRed = function() {
				return ta(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
			}, ra.prototype._forceRed = function(fa) {
				return this.red = fa, this
			}, ra.prototype.forceRed = function(fa) {
				return ta(!this.red, "Already a number in reduction context"), this._forceRed(fa)
			}, ra.prototype.redAdd = function(fa) {
				return ta(this.red, "redAdd works only with red numbers"), this.red.add(this, fa)
			}, ra.prototype.redIAdd = function(fa) {
				return ta(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, fa)
			}, ra.prototype.redSub = function(fa) {
				return ta(this.red, "redSub works only with red numbers"), this.red.sub(this, fa)
			}, ra.prototype.redISub = function(fa) {
				return ta(this.red, "redISub works only with red numbers"), this.red.isub(this, fa)
			}, ra.prototype.redShl = function(fa) {
				return ta(this.red, "redShl works only with red numbers"), this.red.shl(this, fa)
			}, ra.prototype.redMul = function(fa) {
				return ta(this.red, "redMul works only with red numbers"), this.red._verify2(this, fa), this.red.mul(this, fa)
			}, ra.prototype.redIMul = function(fa) {
				return ta(this.red, "redMul works only with red numbers"), this.red._verify2(this, fa), this.red.imul(this, fa)
			}, ra.prototype.redSqr = function() {
				return ta(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
			}, ra.prototype.redISqr = function() {
				return ta(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
			}, ra.prototype.redSqrt = function() {
				return ta(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
			}, ra.prototype.redInvm = function() {
				return ta(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
			}, ra.prototype.redNeg = function() {
				return ta(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
			}, ra.prototype.redPow = function(fa) {
				return ta(this.red && !fa.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, fa)
			};
			var ka = {
				k256: null,
				p224: null,
				p192: null,
				p25519: null
			};

			function Pa(ma, fa) {
				this.name = ma, this.p = new ra(fa, 16), this.n = this.p.bitLength(), this.k = new ra(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
			}
			Pa.prototype._tmp = function() {
				var fa = new ra(null);
				return fa.words = new Array(Math.ceil(this.n / 13)), fa
			}, Pa.prototype.ireduce = function(fa) {
				var ga = fa,
					wa;
				do this.split(ga, this.tmp), ga = this.imulK(ga), ga = ga.iadd(this.tmp), wa = ga.bitLength(); while (wa > this.n);
				var Ma = wa < this.n ? -1 : ga.ucmp(this.p);
				return Ma === 0 ? (ga.words[0] = 0, ga.length = 1) : Ma > 0 ? ga.isub(this.p) : ga.strip !== void 0 ? ga.strip() : ga._strip(), ga
			}, Pa.prototype.split = function(fa, ga) {
				fa.iushrn(this.n, 0, ga)
			}, Pa.prototype.imulK = function(fa) {
				return fa.imul(this.k)
			};

			function ja() {
				Pa.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
			}
			na(ja, Pa), ja.prototype.split = function(fa, ga) {
				for (var wa = 4194303, Ma = Math.min(fa.length, 9), Aa = 0; Aa < Ma; Aa++) ga.words[Aa] = fa.words[Aa];
				if (ga.length = Ma, fa.length <= 9) {
					fa.words[0] = 0, fa.length = 1;
					return
				}
				var Ra = fa.words[9];
				for (ga.words[ga.length++] = Ra & wa, Aa = 10; Aa < fa.length; Aa++) {
					var Ta = fa.words[Aa] | 0;
					fa.words[Aa - 10] = (Ta & wa) << 4 | Ra >>> 22, Ra = Ta
				}
				Ra >>>= 22, fa.words[Aa - 10] = Ra, Ra === 0 && fa.length > 10 ? fa.length -= 10 : fa.length -= 9
			}, ja.prototype.imulK = function(fa) {
				fa.words[fa.length] = 0, fa.words[fa.length + 1] = 0, fa.length += 2;
				for (var ga = 0, wa = 0; wa < fa.length; wa++) {
					var Ma = fa.words[wa] | 0;
					ga += Ma * 977, fa.words[wa] = ga & 67108863, ga = Ma * 64 + (ga / 67108864 | 0)
				}
				return fa.words[fa.length - 1] === 0 && (fa.length--, fa.words[fa.length - 1] === 0 && fa.length--), fa
			};

			function Za() {
				Pa.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
			}
			na(Za, Pa);

			function Ga() {
				Pa.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
			}
			na(Ga, Pa);

			function Ja() {
				Pa.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
			}
			na(Ja, Pa), Ja.prototype.imulK = function(fa) {
				for (var ga = 0, wa = 0; wa < fa.length; wa++) {
					var Ma = (fa.words[wa] | 0) * 19 + ga,
						Aa = Ma & 67108863;
					Ma >>>= 26, fa.words[wa] = Aa, ga = Ma
				}
				return ga !== 0 && (fa.words[fa.length++] = ga), fa
			}, ra._prime = function(fa) {
				if (ka[fa]) return ka[fa];
				var ga;
				if (fa === "k256") ga = new ja;
				else if (fa === "p224") ga = new Za;
				else if (fa === "p192") ga = new Ga;
				else if (fa === "p25519") ga = new Ja;
				else throw new Error("Unknown prime " + fa);
				return ka[fa] = ga, ga
			};

			function Ua(ma) {
				if (typeof ma == "string") {
					var fa = ra._prime(ma);
					this.m = fa.p, this.prime = fa
				} else ta(ma.gtn(1), "modulus must be greater than 1"), this.m = ma, this.prime = null
			}
			Ua.prototype._verify1 = function(fa) {
				ta(fa.negative === 0, "red works only with positives"), ta(fa.red, "red works only with red numbers")
			}, Ua.prototype._verify2 = function(fa, ga) {
				ta((fa.negative | ga.negative) === 0, "red works only with positives"), ta(fa.red && fa.red === ga.red, "red works only with red numbers")
			}, Ua.prototype.imod = function(fa) {
				return this.prime ? this.prime.ireduce(fa)._forceRed(this) : (sa(fa, fa.umod(this.m)._forceRed(this)), fa)
			}, Ua.prototype.neg = function(fa) {
				return fa.isZero() ? fa.clone() : this.m.sub(fa)._forceRed(this)
			}, Ua.prototype.add = function(fa, ga) {
				this._verify2(fa, ga);
				var wa = fa.add(ga);
				return wa.cmp(this.m) >= 0 && wa.isub(this.m), wa._forceRed(this)
			}, Ua.prototype.iadd = function(fa, ga) {
				this._verify2(fa, ga);
				var wa = fa.iadd(ga);
				return wa.cmp(this.m) >= 0 && wa.isub(this.m), wa
			}, Ua.prototype.sub = function(fa, ga) {
				this._verify2(fa, ga);
				var wa = fa.sub(ga);
				return wa.cmpn(0) < 0 && wa.iadd(this.m), wa._forceRed(this)
			}, Ua.prototype.isub = function(fa, ga) {
				this._verify2(fa, ga);
				var wa = fa.isub(ga);
				return wa.cmpn(0) < 0 && wa.iadd(this.m), wa
			}, Ua.prototype.shl = function(fa, ga) {
				return this._verify1(fa), this.imod(fa.ushln(ga))
			}, Ua.prototype.imul = function(fa, ga) {
				return this._verify2(fa, ga), this.imod(fa.imul(ga))
			}, Ua.prototype.mul = function(fa, ga) {
				return this._verify2(fa, ga), this.imod(fa.mul(ga))
			}, Ua.prototype.isqr = function(fa) {
				return this.imul(fa, fa.clone())
			}, Ua.prototype.sqr = function(fa) {
				return this.mul(fa, fa)
			}, Ua.prototype.sqrt = function(fa) {
				if (fa.isZero()) return fa.clone();
				var ga = this.m.andln(3);
				if (ta(ga % 2 === 1), ga === 3) {
					var wa = this.m.add(new ra(1)).iushrn(2);
					return this.pow(fa, wa)
				}
				for (var Ma = this.m.subn(1), Aa = 0; !Ma.isZero() && Ma.andln(1) === 0;) Aa++, Ma.iushrn(1);
				ta(!Ma.isZero());
				var Ra = new ra(1).toRed(this),
					Ta = Ra.redNeg(),
					La = this.m.subn(1).iushrn(1),
					ya = this.m.bitLength();
				for (ya = new ra(2 * ya * ya).toRed(this); this.pow(ya, La).cmp(Ta) !== 0;) ya.redIAdd(Ta);
				for (var Ba = this.pow(ya, Ma), io = this.pow(fa, Ma.addn(1).iushrn(1)), oo = this.pow(fa, Ma), ao = Aa; oo.cmp(Ra) !== 0;) {
					for (var Ia = oo, Na = 0; Ia.cmp(Ra) !== 0; Na++) Ia = Ia.redSqr();
					ta(Na < ao);
					var za = this.pow(Ba, new ra(1).iushln(ao - Na - 1));
					io = io.redMul(za), Ba = za.redSqr(), oo = oo.redMul(Ba), ao = Na
				}
				return io
			}, Ua.prototype.invm = function(fa) {
				var ga = fa._invmp(this.m);
				return ga.negative !== 0 ? (ga.negative = 0, this.imod(ga).redNeg()) : this.imod(ga)
			}, Ua.prototype.pow = function(fa, ga) {
				if (ga.isZero()) return new ra(1).toRed(this);
				if (ga.cmpn(1) === 0) return fa.clone();
				var wa = 4,
					Ma = new Array(1 << wa);
				Ma[0] = new ra(1).toRed(this), Ma[1] = fa;
				for (var Aa = 2; Aa < Ma.length; Aa++) Ma[Aa] = this.mul(Ma[Aa - 1], fa);
				var Ra = Ma[0],
					Ta = 0,
					La = 0,
					ya = ga.bitLength() % 26;
				for (ya === 0 && (ya = 26), Aa = ga.length - 1; Aa >= 0; Aa--) {
					for (var Ba = ga.words[Aa], io = ya - 1; io >= 0; io--) {
						var oo = Ba >> io & 1;
						if (Ra !== Ma[0] && (Ra = this.sqr(Ra)), oo === 0 && Ta === 0) {
							La = 0;
							continue
						}
						Ta <<= 1, Ta |= oo, La++, !(La !== wa && (Aa !== 0 || io !== 0)) && (Ra = this.mul(Ra, Ma[Ta]), La = 0, Ta = 0)
					}
					ya = 26
				}
				return Ra
			}, Ua.prototype.convertTo = function(fa) {
				var ga = fa.umod(this.m);
				return ga === fa ? ga.clone() : ga
			}, Ua.prototype.convertFrom = function(fa) {
				var ga = fa.clone();
				return ga.red = null, ga
			}, ra.mont = function(fa) {
				return new xa(fa)
			};

			function xa(ma) {
				Ua.call(this, ma), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ra(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
			}
			na(xa, Ua), xa.prototype.convertTo = function(fa) {
				return this.imod(fa.ushln(this.shift))
			}, xa.prototype.convertFrom = function(fa) {
				var ga = this.imod(fa.mul(this.rinv));
				return ga.red = null, ga
			}, xa.prototype.imul = function(fa, ga) {
				if (fa.isZero() || ga.isZero()) return fa.words[0] = 0, fa.length = 1, fa;
				var wa = fa.imul(ga),
					Ma = wa.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
					Aa = wa.isub(Ma).iushrn(this.shift),
					Ra = Aa;
				return Aa.cmp(this.m) >= 0 ? Ra = Aa.isub(this.m) : Aa.cmpn(0) < 0 && (Ra = Aa.iadd(this.m)), Ra._forceRed(this)
			}, xa.prototype.mul = function(fa, ga) {
				if (fa.isZero() || ga.isZero()) return new ra(0)._forceRed(this);
				var wa = fa.mul(ga),
					Ma = wa.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
					Aa = wa.isub(Ma).iushrn(this.shift),
					Ra = Aa;
				return Aa.cmp(this.m) >= 0 ? Ra = Aa.isub(this.m) : Aa.cmpn(0) < 0 && (Ra = Aa.iadd(this.m)), Ra._forceRed(this)
			}, xa.prototype.invm = function(fa) {
				var ga = this.imod(fa._invmp(this.m).mul(this.r2));
				return ga._forceRed(this)
			}
		})(ue, commonjsGlobal)
	}(bn$1)), bn$1.exports
}
var asn1$1 = {},
	asn1 = {},
	api = {},
	vmBrowserify = {},
	hasRequiredVmBrowserify;

function requireVmBrowserify() {
	return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
		var indexOf = function(ue, Yi) {
				if (ue.indexOf) return ue.indexOf(Yi);
				for (var ea = 0; ea < ue.length; ea++)
					if (ue[ea] === Yi) return ea;
				return -1
			},
			Object_keys = function(ue) {
				if (Object.keys) return Object.keys(ue);
				var Yi = [];
				for (var ea in ue) Yi.push(ea);
				return Yi
			},
			forEach = function(ue, Yi) {
				if (ue.forEach) return ue.forEach(Yi);
				for (var ea = 0; ea < ue.length; ea++) Yi(ue[ea], ea, ue)
			},
			defineProp = function() {
				try {
					return Object.defineProperty({}, "_", {}),
						function(ue, Yi, ea) {
							Object.defineProperty(ue, Yi, {
								writable: !0,
								enumerable: !1,
								configurable: !0,
								value: ea
							})
						}
				} catch {
					return function(Yi, ea, ta) {
						Yi[ea] = ta
					}
				}
			}(),
			globals = ["Array", "Boolean", "Date", "Error", "EvalError", "Function", "Infinity", "JSON", "Math", "NaN", "Number", "Object", "RangeError", "ReferenceError", "RegExp", "String", "SyntaxError", "TypeError", "URIError", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "undefined", "unescape"];

		function Context() {}
		Context.prototype = {};
		var Script = exports.Script = function(Yi) {
			if (!(this instanceof Script)) return new Script(Yi);
			this.code = Yi
		};
		Script.prototype.runInContext = function(ue) {
			if (!(ue instanceof Context)) throw new TypeError("needs a 'context' argument.");
			var Yi = document.createElement("iframe");
			Yi.style || (Yi.style = {}), Yi.style.display = "none", document.body.appendChild(Yi);
			var ea = Yi.contentWindow,
				ta = ea.eval,
				na = ea.execScript;
			!ta && na && (na.call(ea, "null"), ta = ea.eval), forEach(Object_keys(ue), function(aa) {
				ea[aa] = ue[aa]
			}), forEach(globals, function(aa) {
				ue[aa] && (ea[aa] = ue[aa])
			});
			var ra = Object_keys(ea),
				ia = ta.call(ea, this.code);
			return forEach(Object_keys(ea), function(aa) {
				(aa in ue || indexOf(ra, aa) === -1) && (ue[aa] = ea[aa])
			}), forEach(globals, function(aa) {
				aa in ue || defineProp(ue, aa, ea[aa])
			}), document.body.removeChild(Yi), ia
		}, Script.prototype.runInThisContext = function() {
			return eval(this.code)
		}, Script.prototype.runInNewContext = function(ue) {
			var Yi = Script.createContext(ue),
				ea = this.runInContext(Yi);
			return ue && forEach(Object_keys(Yi), function(ta) {
				ue[ta] = Yi[ta]
			}), ea
		}, forEach(Object_keys(Script.prototype), function(ue) {
			exports[ue] = Script[ue] = function(Yi) {
				var ea = Script(Yi);
				return ea[ue].apply(ea, [].slice.call(arguments, 1))
			}
		}), exports.isContext = function(ue) {
			return ue instanceof Context
		}, exports.createScript = function(ue) {
			return exports.Script(ue)
		}, exports.createContext = Script.createContext = function(ue) {
			var Yi = new Context;
			return typeof ue == "object" && forEach(Object_keys(ue), function(ea) {
				Yi[ea] = ue[ea]
			}), Yi
		}
	}(vmBrowserify)), vmBrowserify
}
var hasRequiredApi;

function requireApi() {
	return hasRequiredApi || (hasRequiredApi = 1, function(ue) {
		var Yi = requireAsn1$1(),
			ea = requireInherits_browser(),
			ta = ue;
		ta.define = function(ia, aa) {
			return new na(ia, aa)
		};

		function na(ra, ia) {
			this.name = ra, this.body = ia, this.decoders = {}, this.encoders = {}
		}
		na.prototype._createNamed = function(ia) {
			var aa;
			try {
				aa = requireVmBrowserify().runInThisContext("(function " + this.name + `(entity) {
  this._initNamed(entity);
})`)
			} catch {
				aa = function(la) {
					this._initNamed(la)
				}
			}
			return ea(aa, ia), aa.prototype._initNamed = function(la) {
				ia.call(this, la)
			}, new aa(this)
		}, na.prototype._getDecoder = function(ia) {
			return ia = ia || "der", this.decoders.hasOwnProperty(ia) || (this.decoders[ia] = this._createNamed(Yi.decoders[ia])), this.decoders[ia]
		}, na.prototype.decode = function(ia, aa, oa) {
			return this._getDecoder(aa).decode(ia, oa)
		}, na.prototype._getEncoder = function(ia) {
			return ia = ia || "der", this.encoders.hasOwnProperty(ia) || (this.encoders[ia] = this._createNamed(Yi.encoders[ia])), this.encoders[ia]
		}, na.prototype.encode = function(ia, aa, oa) {
			return this._getEncoder(aa).encode(ia, oa)
		}
	}(api)), api
}
var base = {},
	reporter = {},
	hasRequiredReporter;

function requireReporter() {
	if (hasRequiredReporter) return reporter;
	hasRequiredReporter = 1;
	var ue = requireInherits_browser();

	function Yi(ta) {
		this._reporterState = {
			obj: null,
			path: [],
			options: ta || {},
			errors: []
		}
	}
	reporter.Reporter = Yi, Yi.prototype.isError = function(na) {
		return na instanceof ea
	}, Yi.prototype.save = function() {
		var na = this._reporterState;
		return {
			obj: na.obj,
			pathLen: na.path.length
		}
	}, Yi.prototype.restore = function(na) {
		var ra = this._reporterState;
		ra.obj = na.obj, ra.path = ra.path.slice(0, na.pathLen)
	}, Yi.prototype.enterKey = function(na) {
		return this._reporterState.path.push(na)
	}, Yi.prototype.exitKey = function(na) {
		var ra = this._reporterState;
		ra.path = ra.path.slice(0, na - 1)
	}, Yi.prototype.leaveKey = function(na, ra, ia) {
		var aa = this._reporterState;
		this.exitKey(na), aa.obj !== null && (aa.obj[ra] = ia)
	}, Yi.prototype.path = function() {
		return this._reporterState.path.join("/")
	}, Yi.prototype.enterObject = function() {
		var na = this._reporterState,
			ra = na.obj;
		return na.obj = {}, ra
	}, Yi.prototype.leaveObject = function(na) {
		var ra = this._reporterState,
			ia = ra.obj;
		return ra.obj = na, ia
	}, Yi.prototype.error = function(na) {
		var ra, ia = this._reporterState,
			aa = na instanceof ea;
		if (aa ? ra = na : ra = new ea(ia.path.map(function(oa) {
				return "[" + JSON.stringify(oa) + "]"
			}).join(""), na.message || na, na.stack), !ia.options.partial) throw ra;
		return aa || ia.errors.push(ra), ra
	}, Yi.prototype.wrapResult = function(na) {
		var ra = this._reporterState;
		return ra.options.partial ? {
			result: this.isError(na) ? null : na,
			errors: ra.errors
		} : na
	};

	function ea(ta, na) {
		this.path = ta, this.rethrow(na)
	}
	return ue(ea, Error), ea.prototype.rethrow = function(na) {
		if (this.message = na + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ea), !this.stack) try {
			throw new Error(this.message)
		} catch (ra) {
			this.stack = ra.stack
		}
		return this
	}, reporter
}
var buffer = {},
	hasRequiredBuffer;

function requireBuffer() {
	if (hasRequiredBuffer) return buffer;
	hasRequiredBuffer = 1;
	var ue = requireInherits_browser(),
		Yi = requireBase().Reporter,
		ea = require$$1$2.Buffer;

	function ta(ra, ia) {
		if (Yi.call(this, ia), !ea.isBuffer(ra)) {
			this.error("Input not Buffer");
			return
		}
		this.base = ra, this.offset = 0, this.length = ra.length
	}
	ue(ta, Yi), buffer.DecoderBuffer = ta, ta.prototype.save = function() {
		return {
			offset: this.offset,
			reporter: Yi.prototype.save.call(this)
		}
	}, ta.prototype.restore = function(ia) {
		var aa = new ta(this.base);
		return aa.offset = ia.offset, aa.length = this.offset, this.offset = ia.offset, Yi.prototype.restore.call(this, ia.reporter), aa
	}, ta.prototype.isEmpty = function() {
		return this.offset === this.length
	}, ta.prototype.readUInt8 = function(ia) {
		return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(ia || "DecoderBuffer overrun")
	}, ta.prototype.skip = function(ia, aa) {
		if (!(this.offset + ia <= this.length)) return this.error(aa || "DecoderBuffer overrun");
		var oa = new ta(this.base);
		return oa._reporterState = this._reporterState, oa.offset = this.offset, oa.length = this.offset + ia, this.offset += ia, oa
	}, ta.prototype.raw = function(ia) {
		return this.base.slice(ia ? ia.offset : this.offset, this.length)
	};

	function na(ra, ia) {
		if (Array.isArray(ra)) this.length = 0, this.value = ra.map(function(aa) {
			return aa instanceof na || (aa = new na(aa, ia)), this.length += aa.length, aa
		}, this);
		else if (typeof ra == "number") {
			if (!(0 <= ra && ra <= 255)) return ia.error("non-byte EncoderBuffer value");
			this.value = ra, this.length = 1
		} else if (typeof ra == "string") this.value = ra, this.length = ea.byteLength(ra);
		else if (ea.isBuffer(ra)) this.value = ra, this.length = ra.length;
		else return ia.error("Unsupported type: " + typeof ra)
	}
	return buffer.EncoderBuffer = na, na.prototype.join = function(ia, aa) {
		return ia || (ia = new ea(this.length)), aa || (aa = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(oa) {
			oa.join(ia, aa), aa += oa.length
		}) : (typeof this.value == "number" ? ia[aa] = this.value : typeof this.value == "string" ? ia.write(this.value, aa) : ea.isBuffer(this.value) && this.value.copy(ia, aa), aa += this.length)), ia
	}, buffer
}
var node, hasRequiredNode;

function requireNode() {
	if (hasRequiredNode) return node;
	hasRequiredNode = 1;
	var ue = requireBase().Reporter,
		Yi = requireBase().EncoderBuffer,
		ea = requireBase().DecoderBuffer,
		ta = requireMinimalisticAssert(),
		na = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"],
		ra = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(na),
		ia = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];

	function aa(la, sa) {
		var ca = {};
		this._baseState = ca, ca.enc = la, ca.parent = sa || null, ca.children = null, ca.tag = null, ca.args = null, ca.reverseArgs = null, ca.choice = null, ca.optional = !1, ca.any = !1, ca.obj = !1, ca.use = null, ca.useDecoder = null, ca.key = null, ca.default = null, ca.explicit = null, ca.implicit = null, ca.contains = null, ca.parent || (ca.children = [], this._wrap())
	}
	node = aa;
	var oa = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
	return aa.prototype.clone = function() {
		var sa = this._baseState,
			ca = {};
		oa.forEach(function(da) {
			ca[da] = sa[da]
		});
		var ua = new this.constructor(ca.parent);
		return ua._baseState = ca, ua
	}, aa.prototype._wrap = function() {
		var sa = this._baseState;
		ra.forEach(function(ca) {
			this[ca] = function() {
				var da = new this.constructor(this);
				return sa.children.push(da), da[ca].apply(da, arguments)
			}
		}, this)
	}, aa.prototype._init = function(sa) {
		var ca = this._baseState;
		ta(ca.parent === null), sa.call(this), ca.children = ca.children.filter(function(ua) {
			return ua._baseState.parent === this
		}, this), ta.equal(ca.children.length, 1, "Root node can have only one child")
	}, aa.prototype._useArgs = function(sa) {
		var ca = this._baseState,
			ua = sa.filter(function(da) {
				return da instanceof this.constructor
			}, this);
		sa = sa.filter(function(da) {
			return !(da instanceof this.constructor)
		}, this), ua.length !== 0 && (ta(ca.children === null), ca.children = ua, ua.forEach(function(da) {
			da._baseState.parent = this
		}, this)), sa.length !== 0 && (ta(ca.args === null), ca.args = sa, ca.reverseArgs = sa.map(function(da) {
			if (typeof da != "object" || da.constructor !== Object) return da;
			var ha = {};
			return Object.keys(da).forEach(function(pa) {
				pa == (pa | 0) && (pa |= 0);
				var va = da[pa];
				ha[va] = pa
			}), ha
		}))
	}, ia.forEach(function(la) {
		aa.prototype[la] = function() {
			var ca = this._baseState;
			throw new Error(la + " not implemented for encoding: " + ca.enc)
		}
	}), na.forEach(function(la) {
		aa.prototype[la] = function() {
			var ca = this._baseState,
				ua = Array.prototype.slice.call(arguments);
			return ta(ca.tag === null), ca.tag = la, this._useArgs(ua), this
		}
	}), aa.prototype.use = function(sa) {
		ta(sa);
		var ca = this._baseState;
		return ta(ca.use === null), ca.use = sa, this
	}, aa.prototype.optional = function() {
		var sa = this._baseState;
		return sa.optional = !0, this
	}, aa.prototype.def = function(sa) {
		var ca = this._baseState;
		return ta(ca.default === null), ca.default = sa, ca.optional = !0, this
	}, aa.prototype.explicit = function(sa) {
		var ca = this._baseState;
		return ta(ca.explicit === null && ca.implicit === null), ca.explicit = sa, this
	}, aa.prototype.implicit = function(sa) {
		var ca = this._baseState;
		return ta(ca.explicit === null && ca.implicit === null), ca.implicit = sa, this
	}, aa.prototype.obj = function() {
		var sa = this._baseState,
			ca = Array.prototype.slice.call(arguments);
		return sa.obj = !0, ca.length !== 0 && this._useArgs(ca), this
	}, aa.prototype.key = function(sa) {
		var ca = this._baseState;
		return ta(ca.key === null), ca.key = sa, this
	}, aa.prototype.any = function() {
		var sa = this._baseState;
		return sa.any = !0, this
	}, aa.prototype.choice = function(sa) {
		var ca = this._baseState;
		return ta(ca.choice === null), ca.choice = sa, this._useArgs(Object.keys(sa).map(function(ua) {
			return sa[ua]
		})), this
	}, aa.prototype.contains = function(sa) {
		var ca = this._baseState;
		return ta(ca.use === null), ca.contains = sa, this
	}, aa.prototype._decode = function(sa, ca) {
		var ua = this._baseState;
		if (ua.parent === null) return sa.wrapResult(ua.children[0]._decode(sa, ca));
		var da = ua.default,
			ha = !0,
			pa = null;
		if (ua.key !== null && (pa = sa.enterKey(ua.key)), ua.optional) {
			var va = null;
			if (ua.explicit !== null ? va = ua.explicit : ua.implicit !== null ? va = ua.implicit : ua.tag !== null && (va = ua.tag), va === null && !ua.any) {
				var ba = sa.save();
				try {
					ua.choice === null ? this._decodeGeneric(ua.tag, sa, ca) : this._decodeChoice(sa, ca), ha = !0
				} catch {
					ha = !1
				}
				sa.restore(ba)
			} else if (ha = this._peekTag(sa, va, ua.any), sa.isError(ha)) return ha
		}
		var Ea;
		if (ua.obj && ha && (Ea = sa.enterObject()), ha) {
			if (ua.explicit !== null) {
				var Sa = this._decodeTag(sa, ua.explicit);
				if (sa.isError(Sa)) return Sa;
				sa = Sa
			}
			var Ca = sa.offset;
			if (ua.use === null && ua.choice === null) {
				if (ua.any) var ba = sa.save();
				var ka = this._decodeTag(sa, ua.implicit !== null ? ua.implicit : ua.tag, ua.any);
				if (sa.isError(ka)) return ka;
				ua.any ? da = sa.raw(ba) : sa = ka
			}
			if (ca && ca.track && ua.tag !== null && ca.track(sa.path(), Ca, sa.length, "tagged"), ca && ca.track && ua.tag !== null && ca.track(sa.path(), sa.offset, sa.length, "content"), ua.any ? da = da : ua.choice === null ? da = this._decodeGeneric(ua.tag, sa, ca) : da = this._decodeChoice(sa, ca), sa.isError(da)) return da;
			if (!ua.any && ua.choice === null && ua.children !== null && ua.children.forEach(function(Za) {
					Za._decode(sa, ca)
				}), ua.contains && (ua.tag === "octstr" || ua.tag === "bitstr")) {
				var Pa = new ea(da);
				da = this._getUse(ua.contains, sa._reporterState.obj)._decode(Pa, ca)
			}
		}
		return ua.obj && ha && (da = sa.leaveObject(Ea)), ua.key !== null && (da !== null || ha === !0) ? sa.leaveKey(pa, ua.key, da) : pa !== null && sa.exitKey(pa), da
	}, aa.prototype._decodeGeneric = function(sa, ca, ua) {
		var da = this._baseState;
		return sa === "seq" || sa === "set" ? null : sa === "seqof" || sa === "setof" ? this._decodeList(ca, sa, da.args[0], ua) : /str$/.test(sa) ? this._decodeStr(ca, sa, ua) : sa === "objid" && da.args ? this._decodeObjid(ca, da.args[0], da.args[1], ua) : sa === "objid" ? this._decodeObjid(ca, null, null, ua) : sa === "gentime" || sa === "utctime" ? this._decodeTime(ca, sa, ua) : sa === "null_" ? this._decodeNull(ca, ua) : sa === "bool" ? this._decodeBool(ca, ua) : sa === "objDesc" ? this._decodeStr(ca, sa, ua) : sa === "int" || sa === "enum" ? this._decodeInt(ca, da.args && da.args[0], ua) : da.use !== null ? this._getUse(da.use, ca._reporterState.obj)._decode(ca, ua) : ca.error("unknown tag: " + sa)
	}, aa.prototype._getUse = function(sa, ca) {
		var ua = this._baseState;
		return ua.useDecoder = this._use(sa, ca), ta(ua.useDecoder._baseState.parent === null), ua.useDecoder = ua.useDecoder._baseState.children[0], ua.implicit !== ua.useDecoder._baseState.implicit && (ua.useDecoder = ua.useDecoder.clone(), ua.useDecoder._baseState.implicit = ua.implicit), ua.useDecoder
	}, aa.prototype._decodeChoice = function(sa, ca) {
		var ua = this._baseState,
			da = null,
			ha = !1;
		return Object.keys(ua.choice).some(function(pa) {
			var va = sa.save(),
				ba = ua.choice[pa];
			try {
				var Ea = ba._decode(sa, ca);
				if (sa.isError(Ea)) return !1;
				da = {
					type: pa,
					value: Ea
				}, ha = !0
			} catch {
				return sa.restore(va), !1
			}
			return !0
		}, this), ha ? da : sa.error("Choice not matched")
	}, aa.prototype._createEncoderBuffer = function(sa) {
		return new Yi(sa, this.reporter)
	}, aa.prototype._encode = function(sa, ca, ua) {
		var da = this._baseState;
		if (!(da.default !== null && da.default === sa)) {
			var ha = this._encodeValue(sa, ca, ua);
			if (ha !== void 0 && !this._skipDefault(ha, ca, ua)) return ha
		}
	}, aa.prototype._encodeValue = function(sa, ca, ua) {
		var da = this._baseState;
		if (da.parent === null) return da.children[0]._encode(sa, ca || new ue);
		var ba = null;
		if (this.reporter = ca, da.optional && sa === void 0)
			if (da.default !== null) sa = da.default;
			else return;
		var ha = null,
			pa = !1;
		if (da.any) ba = this._createEncoderBuffer(sa);
		else if (da.choice) ba = this._encodeChoice(sa, ca);
		else if (da.contains) ha = this._getUse(da.contains, ua)._encode(sa, ca), pa = !0;
		else if (da.children) ha = da.children.map(function(Ca) {
			if (Ca._baseState.tag === "null_") return Ca._encode(null, ca, sa);
			if (Ca._baseState.key === null) return ca.error("Child should have a key");
			var ka = ca.enterKey(Ca._baseState.key);
			if (typeof sa != "object") return ca.error("Child expected, but input is not object");
			var Pa = Ca._encode(sa[Ca._baseState.key], ca, sa);
			return ca.leaveKey(ka), Pa
		}, this).filter(function(Ca) {
			return Ca
		}), ha = this._createEncoderBuffer(ha);
		else if (da.tag === "seqof" || da.tag === "setof") {
			if (!(da.args && da.args.length === 1)) return ca.error("Too many args for : " + da.tag);
			if (!Array.isArray(sa)) return ca.error("seqof/setof, but data is not Array");
			var va = this.clone();
			va._baseState.implicit = null, ha = this._createEncoderBuffer(sa.map(function(Ca) {
				var ka = this._baseState;
				return this._getUse(ka.args[0], sa)._encode(Ca, ca)
			}, va))
		} else da.use !== null ? ba = this._getUse(da.use, ua)._encode(sa, ca) : (ha = this._encodePrimitive(da.tag, sa), pa = !0);
		var ba;
		if (!da.any && da.choice === null) {
			var Ea = da.implicit !== null ? da.implicit : da.tag,
				Sa = da.implicit === null ? "universal" : "context";
			Ea === null ? da.use === null && ca.error("Tag could be omitted only for .use()") : da.use === null && (ba = this._encodeComposite(Ea, pa, Sa, ha))
		}
		return da.explicit !== null && (ba = this._encodeComposite(da.explicit, !1, "context", ba)), ba
	}, aa.prototype._encodeChoice = function(sa, ca) {
		var ua = this._baseState,
			da = ua.choice[sa.type];
		return da || ta(!1, sa.type + " not found in " + JSON.stringify(Object.keys(ua.choice))), da._encode(sa.value, ca)
	}, aa.prototype._encodePrimitive = function(sa, ca) {
		var ua = this._baseState;
		if (/str$/.test(sa)) return this._encodeStr(ca, sa);
		if (sa === "objid" && ua.args) return this._encodeObjid(ca, ua.reverseArgs[0], ua.args[1]);
		if (sa === "objid") return this._encodeObjid(ca, null, null);
		if (sa === "gentime" || sa === "utctime") return this._encodeTime(ca, sa);
		if (sa === "null_") return this._encodeNull();
		if (sa === "int" || sa === "enum") return this._encodeInt(ca, ua.args && ua.reverseArgs[0]);
		if (sa === "bool") return this._encodeBool(ca);
		if (sa === "objDesc") return this._encodeStr(ca, sa);
		throw new Error("Unsupported tag: " + sa)
	}, aa.prototype._isNumstr = function(sa) {
		return /^[0-9 ]*$/.test(sa)
	}, aa.prototype._isPrintstr = function(sa) {
		return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(sa)
	}, node
}
var hasRequiredBase;

function requireBase() {
	return hasRequiredBase || (hasRequiredBase = 1, function(ue) {
		var Yi = ue;
		Yi.Reporter = requireReporter().Reporter, Yi.DecoderBuffer = requireBuffer().DecoderBuffer, Yi.EncoderBuffer = requireBuffer().EncoderBuffer, Yi.Node = requireNode()
	}(base)), base
}
var constants = {},
	der = {},
	hasRequiredDer$2;

function requireDer$2() {
	return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(ue) {
		var Yi = requireConstants();
		ue.tagClass = {
			0: "universal",
			1: "application",
			2: "context",
			3: "private"
		}, ue.tagClassByName = Yi._reverse(ue.tagClass), ue.tag = {
			0: "end",
			1: "bool",
			2: "int",
			3: "bitstr",
			4: "octstr",
			5: "null_",
			6: "objid",
			7: "objDesc",
			8: "external",
			9: "real",
			10: "enum",
			11: "embed",
			12: "utf8str",
			13: "relativeOid",
			16: "seq",
			17: "set",
			18: "numstr",
			19: "printstr",
			20: "t61str",
			21: "videostr",
			22: "ia5str",
			23: "utctime",
			24: "gentime",
			25: "graphstr",
			26: "iso646str",
			27: "genstr",
			28: "unistr",
			29: "charstr",
			30: "bmpstr"
		}, ue.tagByName = Yi._reverse(ue.tag)
	}(der)), der
}
var hasRequiredConstants;

function requireConstants() {
	return hasRequiredConstants || (hasRequiredConstants = 1, function(ue) {
		var Yi = ue;
		Yi._reverse = function(ta) {
			var na = {};
			return Object.keys(ta).forEach(function(ra) {
				(ra | 0) == ra && (ra = ra | 0);
				var ia = ta[ra];
				na[ia] = ra
			}), na
		}, Yi.der = requireDer$2()
	}(constants)), constants
}
var decoders = {},
	der_1$1, hasRequiredDer$1;

function requireDer$1() {
	if (hasRequiredDer$1) return der_1$1;
	hasRequiredDer$1 = 1;
	var ue = requireInherits_browser(),
		Yi = requireAsn1$1(),
		ea = Yi.base,
		ta = Yi.bignum,
		na = Yi.constants.der;

	function ra(la) {
		this.enc = "der", this.name = la.name, this.entity = la, this.tree = new ia, this.tree._init(la.body)
	}
	der_1$1 = ra, ra.prototype.decode = function(sa, ca) {
		return sa instanceof ea.DecoderBuffer || (sa = new ea.DecoderBuffer(sa, ca)), this.tree._decode(sa, ca)
	};

	function ia(la) {
		ea.Node.call(this, "der", la)
	}
	ue(ia, ea.Node), ia.prototype._peekTag = function(sa, ca, ua) {
		if (sa.isEmpty()) return !1;
		var da = sa.save(),
			ha = aa(sa, 'Failed to peek tag: "' + ca + '"');
		return sa.isError(ha) ? ha : (sa.restore(da), ha.tag === ca || ha.tagStr === ca || ha.tagStr + "of" === ca || ua)
	}, ia.prototype._decodeTag = function(sa, ca, ua) {
		var da = aa(sa, 'Failed to decode tag of "' + ca + '"');
		if (sa.isError(da)) return da;
		var ha = oa(sa, da.primitive, 'Failed to get length of "' + ca + '"');
		if (sa.isError(ha)) return ha;
		if (!ua && da.tag !== ca && da.tagStr !== ca && da.tagStr + "of" !== ca) return sa.error('Failed to match tag: "' + ca + '"');
		if (da.primitive || ha !== null) return sa.skip(ha, 'Failed to match body of: "' + ca + '"');
		var pa = sa.save(),
			va = this._skipUntilEnd(sa, 'Failed to skip indefinite length body: "' + this.tag + '"');
		return sa.isError(va) ? va : (ha = sa.offset - pa.offset, sa.restore(pa), sa.skip(ha, 'Failed to match body of: "' + ca + '"'))
	}, ia.prototype._skipUntilEnd = function(sa, ca) {
		for (;;) {
			var ua = aa(sa, ca);
			if (sa.isError(ua)) return ua;
			var da = oa(sa, ua.primitive, ca);
			if (sa.isError(da)) return da;
			var ha;
			if (ua.primitive || da !== null ? ha = sa.skip(da) : ha = this._skipUntilEnd(sa, ca), sa.isError(ha)) return ha;
			if (ua.tagStr === "end") break
		}
	}, ia.prototype._decodeList = function(sa, ca, ua, da) {
		for (var ha = []; !sa.isEmpty();) {
			var pa = this._peekTag(sa, "end");
			if (sa.isError(pa)) return pa;
			var va = ua.decode(sa, "der", da);
			if (sa.isError(va) && pa) break;
			ha.push(va)
		}
		return ha
	}, ia.prototype._decodeStr = function(sa, ca) {
		if (ca === "bitstr") {
			var ua = sa.readUInt8();
			return sa.isError(ua) ? ua : {
				unused: ua,
				data: sa.raw()
			}
		} else if (ca === "bmpstr") {
			var da = sa.raw();
			if (da.length % 2 === 1) return sa.error("Decoding of string type: bmpstr length mismatch");
			for (var ha = "", pa = 0; pa < da.length / 2; pa++) ha += String.fromCharCode(da.readUInt16BE(pa * 2));
			return ha
		} else if (ca === "numstr") {
			var va = sa.raw().toString("ascii");
			return this._isNumstr(va) ? va : sa.error("Decoding of string type: numstr unsupported characters")
		} else {
			if (ca === "octstr") return sa.raw();
			if (ca === "objDesc") return sa.raw();
			if (ca === "printstr") {
				var ba = sa.raw().toString("ascii");
				return this._isPrintstr(ba) ? ba : sa.error("Decoding of string type: printstr unsupported characters")
			} else return /str$/.test(ca) ? sa.raw().toString() : sa.error("Decoding of string type: " + ca + " unsupported")
		}
	}, ia.prototype._decodeObjid = function(sa, ca, ua) {
		for (var da, ha = [], pa = 0; !sa.isEmpty();) {
			var va = sa.readUInt8();
			pa <<= 7, pa |= va & 127, va & 128 || (ha.push(pa), pa = 0)
		}
		va & 128 && ha.push(pa);
		var ba = ha[0] / 40 | 0,
			Ea = ha[0] % 40;
		if (ua ? da = ha : da = [ba, Ea].concat(ha.slice(1)), ca) {
			var Sa = ca[da.join(" ")];
			Sa === void 0 && (Sa = ca[da.join(".")]), Sa !== void 0 && (da = Sa)
		}
		return da
	}, ia.prototype._decodeTime = function(sa, ca) {
		var ua = sa.raw().toString();
		if (ca === "gentime") var da = ua.slice(0, 4) | 0,
			ha = ua.slice(4, 6) | 0,
			pa = ua.slice(6, 8) | 0,
			va = ua.slice(8, 10) | 0,
			ba = ua.slice(10, 12) | 0,
			Ea = ua.slice(12, 14) | 0;
		else if (ca === "utctime") {
			var da = ua.slice(0, 2) | 0,
				ha = ua.slice(2, 4) | 0,
				pa = ua.slice(4, 6) | 0,
				va = ua.slice(6, 8) | 0,
				ba = ua.slice(8, 10) | 0,
				Ea = ua.slice(10, 12) | 0;
			da < 70 ? da = 2e3 + da : da = 1900 + da
		} else return sa.error("Decoding " + ca + " time is not supported yet");
		return Date.UTC(da, ha - 1, pa, va, ba, Ea, 0)
	}, ia.prototype._decodeNull = function(sa) {
		return null
	}, ia.prototype._decodeBool = function(sa) {
		var ca = sa.readUInt8();
		return sa.isError(ca) ? ca : ca !== 0
	}, ia.prototype._decodeInt = function(sa, ca) {
		var ua = sa.raw(),
			da = new ta(ua);
		return ca && (da = ca[da.toString(10)] || da), da
	}, ia.prototype._use = function(sa, ca) {
		return typeof sa == "function" && (sa = sa(ca)), sa._getDecoder("der").tree
	};

	function aa(la, sa) {
		var ca = la.readUInt8(sa);
		if (la.isError(ca)) return ca;
		var ua = na.tagClass[ca >> 6],
			da = (ca & 32) === 0;
		if ((ca & 31) === 31) {
			var ha = ca;
			for (ca = 0;
				(ha & 128) === 128;) {
				if (ha = la.readUInt8(sa), la.isError(ha)) return ha;
				ca <<= 7, ca |= ha & 127
			}
		} else ca &= 31;
		var pa = na.tag[ca];
		return {
			cls: ua,
			primitive: da,
			tag: ca,
			tagStr: pa
		}
	}

	function oa(la, sa, ca) {
		var ua = la.readUInt8(ca);
		if (la.isError(ua)) return ua;
		if (!sa && ua === 128) return null;
		if (!(ua & 128)) return ua;
		var da = ua & 127;
		if (da > 4) return la.error("length octect is too long");
		ua = 0;
		for (var ha = 0; ha < da; ha++) {
			ua <<= 8;
			var pa = la.readUInt8(ca);
			if (la.isError(pa)) return pa;
			ua |= pa
		}
		return ua
	}
	return der_1$1
}
var pem$1, hasRequiredPem$1;

function requirePem$1() {
	if (hasRequiredPem$1) return pem$1;
	hasRequiredPem$1 = 1;
	var ue = requireInherits_browser(),
		Yi = require$$1$2.Buffer,
		ea = requireDer$1();

	function ta(na) {
		ea.call(this, na), this.enc = "pem"
	}
	return ue(ta, ea), pem$1 = ta, ta.prototype.decode = function(ra, ia) {
		for (var aa = ra.toString().split(/[\r\n]+/g), oa = ia.label.toUpperCase(), la = /^-----(BEGIN|END) ([^-]+)-----$/, sa = -1, ca = -1, ua = 0; ua < aa.length; ua++) {
			var da = aa[ua].match(la);
			if (da !== null && da[2] === oa)
				if (sa === -1) {
					if (da[1] !== "BEGIN") break;
					sa = ua
				} else {
					if (da[1] !== "END") break;
					ca = ua;
					break
				}
		}
		if (sa === -1 || ca === -1) throw new Error("PEM section not found for: " + oa);
		var ha = aa.slice(sa + 1, ca).join("");
		ha.replace(/[^a-z0-9\+\/=]+/gi, "");
		var pa = new Yi(ha, "base64");
		return ea.prototype.decode.call(this, pa, ia)
	}, pem$1
}
var hasRequiredDecoders;

function requireDecoders() {
	return hasRequiredDecoders || (hasRequiredDecoders = 1, function(ue) {
		var Yi = ue;
		Yi.der = requireDer$1(), Yi.pem = requirePem$1()
	}(decoders)), decoders
}
var encoders = {},
	der_1, hasRequiredDer;

function requireDer() {
	if (hasRequiredDer) return der_1;
	hasRequiredDer = 1;
	var ue = requireInherits_browser(),
		Yi = require$$1$2.Buffer,
		ea = requireAsn1$1(),
		ta = ea.base,
		na = ea.constants.der;

	function ra(la) {
		this.enc = "der", this.name = la.name, this.entity = la, this.tree = new ia, this.tree._init(la.body)
	}
	der_1 = ra, ra.prototype.encode = function(sa, ca) {
		return this.tree._encode(sa, ca).join()
	};

	function ia(la) {
		ta.Node.call(this, "der", la)
	}
	ue(ia, ta.Node), ia.prototype._encodeComposite = function(sa, ca, ua, da) {
		var ha = oa(sa, ca, ua, this.reporter);
		if (da.length < 128) {
			var ba = new Yi(2);
			return ba[0] = ha, ba[1] = da.length, this._createEncoderBuffer([ba, da])
		}
		for (var pa = 1, va = da.length; va >= 256; va >>= 8) pa++;
		var ba = new Yi(2 + pa);
		ba[0] = ha, ba[1] = 128 | pa;
		for (var va = 1 + pa, Ea = da.length; Ea > 0; va--, Ea >>= 8) ba[va] = Ea & 255;
		return this._createEncoderBuffer([ba, da])
	}, ia.prototype._encodeStr = function(sa, ca) {
		if (ca === "bitstr") return this._createEncoderBuffer([sa.unused | 0, sa.data]);
		if (ca === "bmpstr") {
			for (var ua = new Yi(sa.length * 2), da = 0; da < sa.length; da++) ua.writeUInt16BE(sa.charCodeAt(da), da * 2);
			return this._createEncoderBuffer(ua)
		} else return ca === "numstr" ? this._isNumstr(sa) ? this._createEncoderBuffer(sa) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : ca === "printstr" ? this._isPrintstr(sa) ? this._createEncoderBuffer(sa) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(ca) ? this._createEncoderBuffer(sa) : ca === "objDesc" ? this._createEncoderBuffer(sa) : this.reporter.error("Encoding of string type: " + ca + " unsupported")
	}, ia.prototype._encodeObjid = function(sa, ca, ua) {
		if (typeof sa == "string") {
			if (!ca) return this.reporter.error("string objid given, but no values map found");
			if (!ca.hasOwnProperty(sa)) return this.reporter.error("objid not found in values map");
			sa = ca[sa].split(/[\s\.]+/g);
			for (var da = 0; da < sa.length; da++) sa[da] |= 0
		} else if (Array.isArray(sa)) {
			sa = sa.slice();
			for (var da = 0; da < sa.length; da++) sa[da] |= 0
		}
		if (!Array.isArray(sa)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(sa));
		if (!ua) {
			if (sa[1] >= 40) return this.reporter.error("Second objid identifier OOB");
			sa.splice(0, 2, sa[0] * 40 + sa[1])
		}
		for (var ha = 0, da = 0; da < sa.length; da++) {
			var pa = sa[da];
			for (ha++; pa >= 128; pa >>= 7) ha++
		}
		for (var va = new Yi(ha), ba = va.length - 1, da = sa.length - 1; da >= 0; da--) {
			var pa = sa[da];
			for (va[ba--] = pa & 127;
				(pa >>= 7) > 0;) va[ba--] = 128 | pa & 127
		}
		return this._createEncoderBuffer(va)
	};

	function aa(la) {
		return la < 10 ? "0" + la : la
	}
	ia.prototype._encodeTime = function(sa, ca) {
		var ua, da = new Date(sa);
		return ca === "gentime" ? ua = [aa(da.getFullYear()), aa(da.getUTCMonth() + 1), aa(da.getUTCDate()), aa(da.getUTCHours()), aa(da.getUTCMinutes()), aa(da.getUTCSeconds()), "Z"].join("") : ca === "utctime" ? ua = [aa(da.getFullYear() % 100), aa(da.getUTCMonth() + 1), aa(da.getUTCDate()), aa(da.getUTCHours()), aa(da.getUTCMinutes()), aa(da.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + ca + " time is not supported yet"), this._encodeStr(ua, "octstr")
	}, ia.prototype._encodeNull = function() {
		return this._createEncoderBuffer("")
	}, ia.prototype._encodeInt = function(sa, ca) {
		if (typeof sa == "string") {
			if (!ca) return this.reporter.error("String int or enum given, but no values map");
			if (!ca.hasOwnProperty(sa)) return this.reporter.error("Values map doesn't contain: " + JSON.stringify(sa));
			sa = ca[sa]
		}
		if (typeof sa != "number" && !Yi.isBuffer(sa)) {
			var ua = sa.toArray();
			!sa.sign && ua[0] & 128 && ua.unshift(0), sa = new Yi(ua)
		}
		if (Yi.isBuffer(sa)) {
			var da = sa.length;
			sa.length === 0 && da++;
			var pa = new Yi(da);
			return sa.copy(pa), sa.length === 0 && (pa[0] = 0), this._createEncoderBuffer(pa)
		}
		if (sa < 128) return this._createEncoderBuffer(sa);
		if (sa < 256) return this._createEncoderBuffer([0, sa]);
		for (var da = 1, ha = sa; ha >= 256; ha >>= 8) da++;
		for (var pa = new Array(da), ha = pa.length - 1; ha >= 0; ha--) pa[ha] = sa & 255, sa >>= 8;
		return pa[0] & 128 && pa.unshift(0), this._createEncoderBuffer(new Yi(pa))
	}, ia.prototype._encodeBool = function(sa) {
		return this._createEncoderBuffer(sa ? 255 : 0)
	}, ia.prototype._use = function(sa, ca) {
		return typeof sa == "function" && (sa = sa(ca)), sa._getEncoder("der").tree
	}, ia.prototype._skipDefault = function(sa, ca, ua) {
		var da = this._baseState,
			ha;
		if (da.default === null) return !1;
		var pa = sa.join();
		if (da.defaultBuffer === void 0 && (da.defaultBuffer = this._encodeValue(da.default, ca, ua).join()), pa.length !== da.defaultBuffer.length) return !1;
		for (ha = 0; ha < pa.length; ha++)
			if (pa[ha] !== da.defaultBuffer[ha]) return !1;
		return !0
	};

	function oa(la, sa, ca, ua) {
		var da;
		if (la === "seqof" ? la = "seq" : la === "setof" && (la = "set"), na.tagByName.hasOwnProperty(la)) da = na.tagByName[la];
		else if (typeof la == "number" && (la | 0) === la) da = la;
		else return ua.error("Unknown tag: " + la);
		return da >= 31 ? ua.error("Multi-octet tag encoding unsupported") : (sa || (da |= 32), da |= na.tagClassByName[ca || "universal"] << 6, da)
	}
	return der_1
}
var pem, hasRequiredPem;

function requirePem() {
	if (hasRequiredPem) return pem;
	hasRequiredPem = 1;
	var ue = requireInherits_browser(),
		Yi = requireDer();

	function ea(ta) {
		Yi.call(this, ta), this.enc = "pem"
	}
	return ue(ea, Yi), pem = ea, ea.prototype.encode = function(na, ra) {
		for (var ia = Yi.prototype.encode.call(this, na), aa = ia.toString("base64"), oa = ["-----BEGIN " + ra.label + "-----"], la = 0; la < aa.length; la += 64) oa.push(aa.slice(la, la + 64));
		return oa.push("-----END " + ra.label + "-----"), oa.join(`
`)
	}, pem
}
var hasRequiredEncoders;

function requireEncoders() {
	return hasRequiredEncoders || (hasRequiredEncoders = 1, function(ue) {
		var Yi = ue;
		Yi.der = requireDer(), Yi.pem = requirePem()
	}(encoders)), encoders
}
var hasRequiredAsn1$1;

function requireAsn1$1() {
	return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(ue) {
		var Yi = ue;
		Yi.bignum = requireBn$2(), Yi.define = requireApi().define, Yi.base = requireBase(), Yi.constants = requireConstants(), Yi.decoders = requireDecoders(), Yi.encoders = requireEncoders()
	}(asn1)), asn1
}
var certificate, hasRequiredCertificate;

function requireCertificate() {
	if (hasRequiredCertificate) return certificate;
	hasRequiredCertificate = 1;
	var ue = requireAsn1$1(),
		Yi = ue.define("Time", function() {
			this.choice({
				utcTime: this.utctime(),
				generalTime: this.gentime()
			})
		}),
		ea = ue.define("AttributeTypeValue", function() {
			this.seq().obj(this.key("type").objid(), this.key("value").any())
		}),
		ta = ue.define("AlgorithmIdentifier", function() {
			this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional())
		}),
		na = ue.define("SubjectPublicKeyInfo", function() {
			this.seq().obj(this.key("algorithm").use(ta), this.key("subjectPublicKey").bitstr())
		}),
		ra = ue.define("RelativeDistinguishedName", function() {
			this.setof(ea)
		}),
		ia = ue.define("RDNSequence", function() {
			this.seqof(ra)
		}),
		aa = ue.define("Name", function() {
			this.choice({
				rdnSequence: this.use(ia)
			})
		}),
		oa = ue.define("Validity", function() {
			this.seq().obj(this.key("notBefore").use(Yi), this.key("notAfter").use(Yi))
		}),
		la = ue.define("Extension", function() {
			this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr())
		}),
		sa = ue.define("TBSCertificate", function() {
			this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(ta), this.key("issuer").use(aa), this.key("validity").use(oa), this.key("subject").use(aa), this.key("subjectPublicKeyInfo").use(na), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(la).optional())
		}),
		ca = ue.define("X509Certificate", function() {
			this.seq().obj(this.key("tbsCertificate").use(sa), this.key("signatureAlgorithm").use(ta), this.key("signatureValue").bitstr())
		});
	return certificate = ca, certificate
}
var hasRequiredAsn1;

function requireAsn1() {
	if (hasRequiredAsn1) return asn1$1;
	hasRequiredAsn1 = 1;
	var ue = requireAsn1$1();
	asn1$1.certificate = requireCertificate();
	var Yi = ue.define("RSAPrivateKey", function() {
		this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int())
	});
	asn1$1.RSAPrivateKey = Yi;
	var ea = ue.define("RSAPublicKey", function() {
		this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int())
	});
	asn1$1.RSAPublicKey = ea;
	var ta = ue.define("AlgorithmIdentifier", function() {
			this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional())
		}),
		na = ue.define("SubjectPublicKeyInfo", function() {
			this.seq().obj(this.key("algorithm").use(ta), this.key("subjectPublicKey").bitstr())
		});
	asn1$1.PublicKey = na;
	var ra = ue.define("PrivateKeyInfo", function() {
		this.seq().obj(this.key("version").int(), this.key("algorithm").use(ta), this.key("subjectPrivateKey").octstr())
	});
	asn1$1.PrivateKey = ra;
	var ia = ue.define("EncryptedPrivateKeyInfo", function() {
		this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr())
	});
	asn1$1.EncryptedPrivateKey = ia;
	var aa = ue.define("DSAPrivateKey", function() {
		this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int())
	});
	asn1$1.DSAPrivateKey = aa, asn1$1.DSAparam = ue.define("DSAparam", function() {
		this.int()
	});
	var oa = ue.define("ECParameters", function() {
			this.choice({
				namedCurve: this.objid()
			})
		}),
		la = ue.define("ECPrivateKey", function() {
			this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(oa), this.key("publicKey").optional().explicit(1).bitstr())
		});
	return asn1$1.ECPrivateKey = la, asn1$1.signature = ue.define("signature", function() {
		this.seq().obj(this.key("r").int(), this.key("s").int())
	}), asn1$1
}
const require$$1 = {
	"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
	"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
	"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
	"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
	"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
	"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
	"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
	"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
	"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
	"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
	"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
	"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;

function requireFixProc() {
	if (hasRequiredFixProc) return fixProc;
	hasRequiredFixProc = 1;
	var ue = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m,
		Yi = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m,
		ea = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m,
		ta = requireEvp_bytestokey(),
		na = requireBrowser$6(),
		ra = requireSafeBuffer$1().Buffer;
	return fixProc = function(ia, aa) {
		var oa = ia.toString(),
			la = oa.match(ue),
			sa;
		if (la) {
			var ua = "aes" + la[1],
				da = ra.from(la[2], "hex"),
				ha = ra.from(la[3].replace(/[\r\n]/g, ""), "base64"),
				pa = ta(aa, da.slice(0, 8), parseInt(la[1], 10)).key,
				va = [],
				ba = na.createDecipheriv(ua, pa, da);
			va.push(ba.update(ha)), va.push(ba.final()), sa = ra.concat(va)
		} else {
			var ca = oa.match(ea);
			sa = ra.from(ca[2].replace(/[\r\n]/g, ""), "base64")
		}
		var Ea = oa.match(Yi)[1];
		return {
			tag: Ea,
			data: sa
		}
	}, fixProc
}
var parseAsn1, hasRequiredParseAsn1;

function requireParseAsn1() {
	if (hasRequiredParseAsn1) return parseAsn1;
	hasRequiredParseAsn1 = 1;
	var ue = requireAsn1(),
		Yi = require$$1,
		ea = requireFixProc(),
		ta = requireBrowser$6(),
		na = requireBrowser$7(),
		ra = requireSafeBuffer$1().Buffer;

	function ia(oa, la) {
		var sa = oa.algorithm.decrypt.kde.kdeparams.salt,
			ca = parseInt(oa.algorithm.decrypt.kde.kdeparams.iters.toString(), 10),
			ua = Yi[oa.algorithm.decrypt.cipher.algo.join(".")],
			da = oa.algorithm.decrypt.cipher.iv,
			ha = oa.subjectPrivateKey,
			pa = parseInt(ua.split("-")[1], 10) / 8,
			va = na.pbkdf2Sync(la, sa, ca, pa, "sha1"),
			ba = ta.createDecipheriv(ua, va, da),
			Ea = [];
		return Ea.push(ba.update(ha)), Ea.push(ba.final()), ra.concat(Ea)
	}

	function aa(oa) {
		var la;
		typeof oa == "object" && !ra.isBuffer(oa) && (la = oa.passphrase, oa = oa.key), typeof oa == "string" && (oa = ra.from(oa));
		var sa = ea(oa, la),
			ca = sa.tag,
			ua = sa.data,
			da, ha;
		switch (ca) {
			case "CERTIFICATE":
				ha = ue.certificate.decode(ua, "der").tbsCertificate.subjectPublicKeyInfo;
			case "PUBLIC KEY":
				switch (ha || (ha = ue.PublicKey.decode(ua, "der")), da = ha.algorithm.algorithm.join("."), da) {
					case "1.2.840.113549.1.1.1":
						return ue.RSAPublicKey.decode(ha.subjectPublicKey.data, "der");
					case "1.2.840.10045.2.1":
						return ha.subjectPrivateKey = ha.subjectPublicKey, {
							type: "ec",
							data: ha
						};
					case "1.2.840.10040.4.1":
						return ha.algorithm.params.pub_key = ue.DSAparam.decode(ha.subjectPublicKey.data, "der"), {
							type: "dsa",
							data: ha.algorithm.params
						};
					default:
						throw new Error("unknown key id " + da)
				}
			case "ENCRYPTED PRIVATE KEY":
				ua = ue.EncryptedPrivateKey.decode(ua, "der"), ua = ia(ua, la);
			case "PRIVATE KEY":
				switch (ha = ue.PrivateKey.decode(ua, "der"), da = ha.algorithm.algorithm.join("."), da) {
					case "1.2.840.113549.1.1.1":
						return ue.RSAPrivateKey.decode(ha.subjectPrivateKey, "der");
					case "1.2.840.10045.2.1":
						return {
							curve: ha.algorithm.curve, privateKey: ue.ECPrivateKey.decode(ha.subjectPrivateKey, "der").privateKey
						};
					case "1.2.840.10040.4.1":
						return ha.algorithm.params.priv_key = ue.DSAparam.decode(ha.subjectPrivateKey, "der"), {
							type: "dsa",
							params: ha.algorithm.params
						};
					default:
						throw new Error("unknown key id " + da)
				}
			case "RSA PUBLIC KEY":
				return ue.RSAPublicKey.decode(ua, "der");
			case "RSA PRIVATE KEY":
				return ue.RSAPrivateKey.decode(ua, "der");
			case "DSA PRIVATE KEY":
				return {
					type: "dsa", params: ue.DSAPrivateKey.decode(ua, "der")
				};
			case "EC PRIVATE KEY":
				return ua = ue.ECPrivateKey.decode(ua, "der"), {
					curve: ua.parameters.value,
					privateKey: ua.privateKey
				};
			default:
				throw new Error("unknown key type " + ca)
		}
	}
	return aa.signature = ue.signature, parseAsn1 = aa, parseAsn1
}
const require$$4 = {
	"1.3.132.0.10": "secp256k1",
	"1.3.132.0.33": "p224",
	"1.2.840.10045.3.1.1": "p192",
	"1.2.840.10045.3.1.7": "p256",
	"1.3.132.0.34": "p384",
	"1.3.132.0.35": "p521"
};
var hasRequiredSign;

function requireSign() {
	if (hasRequiredSign) return sign$2.exports;
	hasRequiredSign = 1;
	var ue = requireSafeBuffer$1().Buffer,
		Yi = requireBrowser$8(),
		ea = requireBrowserifyRsa(),
		ta = requireElliptic().ec,
		na = requireBn(),
		ra = requireParseAsn1(),
		ia = require$$4,
		aa = 1;

	function oa(ba, Ea, Sa, Ca, ka) {
		var Pa = ra(Ea);
		if (Pa.curve) {
			if (Ca !== "ecdsa" && Ca !== "ecdsa/rsa") throw new Error("wrong private key type");
			return la(ba, Pa)
		} else if (Pa.type === "dsa") {
			if (Ca !== "dsa") throw new Error("wrong private key type");
			return sa(ba, Pa, Sa)
		}
		if (Ca !== "rsa" && Ca !== "ecdsa/rsa") throw new Error("wrong private key type");
		if (Ea.padding !== void 0 && Ea.padding !== aa) throw new Error("illegal or unsupported padding mode");
		ba = ue.concat([ka, ba]);
		for (var ja = Pa.modulus.byteLength(), Za = [0, 1]; ba.length + Za.length + 1 < ja;) Za.push(255);
		Za.push(0);
		for (var Ga = -1; ++Ga < ba.length;) Za.push(ba[Ga]);
		var Ja = ea(Za, Pa);
		return Ja
	}

	function la(ba, Ea) {
		var Sa = ia[Ea.curve.join(".")];
		if (!Sa) throw new Error("unknown curve " + Ea.curve.join("."));
		var Ca = new ta(Sa),
			ka = Ca.keyFromPrivate(Ea.privateKey),
			Pa = ka.sign(ba);
		return ue.from(Pa.toDER())
	}

	function sa(ba, Ea, Sa) {
		for (var Ca = Ea.params.priv_key, ka = Ea.params.p, Pa = Ea.params.q, ja = Ea.params.g, Za = new na(0), Ga, Ja = da(ba, Pa).mod(Pa), Ua = !1, xa = ua(Ca, Pa, ba, Sa); Ua === !1;) Ga = pa(Pa, xa, Sa), Za = va(ja, Ga, ka, Pa), Ua = Ga.invm(Pa).imul(Ja.add(Ca.mul(Za))).mod(Pa), Ua.cmpn(0) === 0 && (Ua = !1, Za = new na(0));
		return ca(Za, Ua)
	}

	function ca(ba, Ea) {
		ba = ba.toArray(), Ea = Ea.toArray(), ba[0] & 128 && (ba = [0].concat(ba)), Ea[0] & 128 && (Ea = [0].concat(Ea));
		var Sa = ba.length + Ea.length + 4,
			Ca = [48, Sa, 2, ba.length];
		return Ca = Ca.concat(ba, [2, Ea.length], Ea), ue.from(Ca)
	}

	function ua(ba, Ea, Sa, Ca) {
		if (ba = ue.from(ba.toArray()), ba.length < Ea.byteLength()) {
			var ka = ue.alloc(Ea.byteLength() - ba.length);
			ba = ue.concat([ka, ba])
		}
		var Pa = Sa.length,
			ja = ha(Sa, Ea),
			Za = ue.alloc(Pa);
		Za.fill(1);
		var Ga = ue.alloc(Pa);
		return Ga = Yi(Ca, Ga).update(Za).update(ue.from([0])).update(ba).update(ja).digest(), Za = Yi(Ca, Ga).update(Za).digest(), Ga = Yi(Ca, Ga).update(Za).update(ue.from([1])).update(ba).update(ja).digest(), Za = Yi(Ca, Ga).update(Za).digest(), {
			k: Ga,
			v: Za
		}
	}

	function da(ba, Ea) {
		var Sa = new na(ba),
			Ca = (ba.length << 3) - Ea.bitLength();
		return Ca > 0 && Sa.ishrn(Ca), Sa
	}

	function ha(ba, Ea) {
		ba = da(ba, Ea), ba = ba.mod(Ea);
		var Sa = ue.from(ba.toArray());
		if (Sa.length < Ea.byteLength()) {
			var Ca = ue.alloc(Ea.byteLength() - Sa.length);
			Sa = ue.concat([Ca, Sa])
		}
		return Sa
	}

	function pa(ba, Ea, Sa) {
		var Ca, ka;
		do {
			for (Ca = ue.alloc(0); Ca.length * 8 < ba.bitLength();) Ea.v = Yi(Sa, Ea.k).update(Ea.v).digest(), Ca = ue.concat([Ca, Ea.v]);
			ka = da(Ca, ba), Ea.k = Yi(Sa, Ea.k).update(Ea.v).update(ue.from([0])).digest(), Ea.v = Yi(Sa, Ea.k).update(Ea.v).digest()
		} while (ka.cmp(ba) !== -1);
		return ka
	}

	function va(ba, Ea, Sa, Ca) {
		return ba.toRed(na.mont(Sa)).redPow(Ea).fromRed().mod(Ca)
	}
	return sign$2.exports = oa, sign$2.exports.getKey = ua, sign$2.exports.makeKey = pa, sign$2.exports
}
var verify_1, hasRequiredVerify;

function requireVerify() {
	if (hasRequiredVerify) return verify_1;
	hasRequiredVerify = 1;
	var ue = requireSafeBuffer$1().Buffer,
		Yi = requireBn(),
		ea = requireElliptic().ec,
		ta = requireParseAsn1(),
		na = require$$4;

	function ra(la, sa, ca, ua, da) {
		var ha = ta(ca);
		if (ha.type === "ec") {
			if (ua !== "ecdsa" && ua !== "ecdsa/rsa") throw new Error("wrong public key type");
			return ia(la, sa, ha)
		} else if (ha.type === "dsa") {
			if (ua !== "dsa") throw new Error("wrong public key type");
			return aa(la, sa, ha)
		}
		if (ua !== "rsa" && ua !== "ecdsa/rsa") throw new Error("wrong public key type");
		sa = ue.concat([da, sa]);
		for (var pa = ha.modulus.byteLength(), va = [1], ba = 0; sa.length + va.length + 2 < pa;) va.push(255), ba += 1;
		va.push(0);
		for (var Ea = -1; ++Ea < sa.length;) va.push(sa[Ea]);
		va = ue.from(va);
		var Sa = Yi.mont(ha.modulus);
		la = new Yi(la).toRed(Sa), la = la.redPow(new Yi(ha.publicExponent)), la = ue.from(la.fromRed().toArray());
		var Ca = ba < 8 ? 1 : 0;
		for (pa = Math.min(la.length, va.length), la.length !== va.length && (Ca = 1), Ea = -1; ++Ea < pa;) Ca |= la[Ea] ^ va[Ea];
		return Ca === 0
	}

	function ia(la, sa, ca) {
		var ua = na[ca.data.algorithm.curve.join(".")];
		if (!ua) throw new Error("unknown curve " + ca.data.algorithm.curve.join("."));
		var da = new ea(ua),
			ha = ca.data.subjectPrivateKey.data;
		return da.verify(sa, la, ha)
	}

	function aa(la, sa, ca) {
		var ua = ca.data.p,
			da = ca.data.q,
			ha = ca.data.g,
			pa = ca.data.pub_key,
			va = ta.signature.decode(la, "der"),
			ba = va.s,
			Ea = va.r;
		oa(ba, da), oa(Ea, da);
		var Sa = Yi.mont(ua),
			Ca = ba.invm(da),
			ka = ha.toRed(Sa).redPow(new Yi(sa).mul(Ca).mod(da)).fromRed().mul(pa.toRed(Sa).redPow(Ea.mul(Ca).mod(da)).fromRed()).mod(ua).mod(da);
		return ka.cmp(Ea) === 0
	}

	function oa(la, sa) {
		if (la.cmpn(0) <= 0) throw new Error("invalid sig");
		if (la.cmp(sa) >= 0) throw new Error("invalid sig")
	}
	return verify_1 = ra, verify_1
}
var browser$3, hasRequiredBrowser$3;

function requireBrowser$3() {
	if (hasRequiredBrowser$3) return browser$3;
	hasRequiredBrowser$3 = 1;
	var ue = requireSafeBuffer$1().Buffer,
		Yi = requireBrowser$9(),
		ea = requireReadableBrowser(),
		ta = requireInherits_browser(),
		na = requireSign(),
		ra = requireVerify(),
		ia = require$$6;
	Object.keys(ia).forEach(function(ca) {
		ia[ca].id = ue.from(ia[ca].id, "hex"), ia[ca.toLowerCase()] = ia[ca]
	});

	function aa(ca) {
		ea.Writable.call(this);
		var ua = ia[ca];
		if (!ua) throw new Error("Unknown message digest");
		this._hashType = ua.hash, this._hash = Yi(ua.hash), this._tag = ua.id, this._signType = ua.sign
	}
	ta(aa, ea.Writable), aa.prototype._write = function(ua, da, ha) {
		this._hash.update(ua), ha()
	}, aa.prototype.update = function(ua, da) {
		return this._hash.update(typeof ua == "string" ? ue.from(ua, da) : ua), this
	}, aa.prototype.sign = function(ua, da) {
		this.end();
		var ha = this._hash.digest(),
			pa = na(ha, ua, this._hashType, this._signType, this._tag);
		return da ? pa.toString(da) : pa
	};

	function oa(ca) {
		ea.Writable.call(this);
		var ua = ia[ca];
		if (!ua) throw new Error("Unknown message digest");
		this._hash = Yi(ua.hash), this._tag = ua.id, this._signType = ua.sign
	}
	ta(oa, ea.Writable), oa.prototype._write = function(ua, da, ha) {
		this._hash.update(ua), ha()
	}, oa.prototype.update = function(ua, da) {
		return this._hash.update(typeof ua == "string" ? ue.from(ua, da) : ua), this
	}, oa.prototype.verify = function(ua, da, ha) {
		var pa = typeof da == "string" ? ue.from(da, ha) : da;
		this.end();
		var va = this._hash.digest();
		return ra(pa, va, ua, this._signType, this._tag)
	};

	function la(ca) {
		return new aa(ca)
	}

	function sa(ca) {
		return new oa(ca)
	}
	return browser$3 = {
		Sign: la,
		Verify: sa,
		createSign: la,
		createVerify: sa
	}, browser$3
}
var browser$2, hasRequiredBrowser$2;

function requireBrowser$2() {
	if (hasRequiredBrowser$2) return browser$2;
	hasRequiredBrowser$2 = 1;
	var ue = requireElliptic(),
		Yi = requireBn$2();
	browser$2 = function(ia) {
		return new ta(ia)
	};
	var ea = {
		secp256k1: {
			name: "secp256k1",
			byteLength: 32
		},
		secp224r1: {
			name: "p224",
			byteLength: 28
		},
		prime256v1: {
			name: "p256",
			byteLength: 32
		},
		prime192v1: {
			name: "p192",
			byteLength: 24
		},
		ed25519: {
			name: "ed25519",
			byteLength: 32
		},
		secp384r1: {
			name: "p384",
			byteLength: 48
		},
		secp521r1: {
			name: "p521",
			byteLength: 66
		}
	};
	ea.p224 = ea.secp224r1, ea.p256 = ea.secp256r1 = ea.prime256v1, ea.p192 = ea.secp192r1 = ea.prime192v1, ea.p384 = ea.secp384r1, ea.p521 = ea.secp521r1;

	function ta(ra) {
		this.curveType = ea[ra], this.curveType || (this.curveType = {
			name: ra
		}), this.curve = new ue.ec(this.curveType.name), this.keys = void 0
	}
	ta.prototype.generateKeys = function(ra, ia) {
		return this.keys = this.curve.genKeyPair(), this.getPublicKey(ra, ia)
	}, ta.prototype.computeSecret = function(ra, ia, aa) {
		ia = ia || "utf8", Buffer.isBuffer(ra) || (ra = new Buffer(ra, ia));
		var oa = this.curve.keyFromPublic(ra).getPublic(),
			la = oa.mul(this.keys.getPrivate()).getX();
		return na(la, aa, this.curveType.byteLength)
	}, ta.prototype.getPublicKey = function(ra, ia) {
		var aa = this.keys.getPublic(ia === "compressed", !0);
		return ia === "hybrid" && (aa[aa.length - 1] % 2 ? aa[0] = 7 : aa[0] = 6), na(aa, ra)
	}, ta.prototype.getPrivateKey = function(ra) {
		return na(this.keys.getPrivate(), ra)
	}, ta.prototype.setPublicKey = function(ra, ia) {
		return ia = ia || "utf8", Buffer.isBuffer(ra) || (ra = new Buffer(ra, ia)), this.keys._importPublic(ra), this
	}, ta.prototype.setPrivateKey = function(ra, ia) {
		ia = ia || "utf8", Buffer.isBuffer(ra) || (ra = new Buffer(ra, ia));
		var aa = new Yi(ra);
		return aa = aa.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(aa), this
	};

	function na(ra, ia, aa) {
		Array.isArray(ra) || (ra = ra.toArray());
		var oa = new Buffer(ra);
		if (aa && oa.length < aa) {
			var la = new Buffer(aa - oa.length);
			la.fill(0), oa = Buffer.concat([la, oa])
		}
		return ia ? oa.toString(ia) : oa
	}
	return browser$2
}
var browser$1 = {},
	mgf, hasRequiredMgf;

function requireMgf() {
	if (hasRequiredMgf) return mgf;
	hasRequiredMgf = 1;
	var ue = requireBrowser$9(),
		Yi = requireSafeBuffer$1().Buffer;
	mgf = function(ta, na) {
		for (var ra = Yi.alloc(0), ia = 0, aa; ra.length < na;) aa = ea(ia++), ra = Yi.concat([ra, ue("sha1").update(ta).update(aa).digest()]);
		return ra.slice(0, na)
	};

	function ea(ta) {
		var na = Yi.allocUnsafe(4);
		return na.writeUInt32BE(ta, 0), na
	}
	return mgf
}
var xor, hasRequiredXor;

function requireXor() {
	return hasRequiredXor || (hasRequiredXor = 1, xor = function(Yi, ea) {
		for (var ta = Yi.length, na = -1; ++na < ta;) Yi[na] ^= ea[na];
		return Yi
	}), xor
}
var withPublic_1, hasRequiredWithPublic;

function requireWithPublic() {
	if (hasRequiredWithPublic) return withPublic_1;
	hasRequiredWithPublic = 1;
	var ue = requireBn$2(),
		Yi = requireSafeBuffer$1().Buffer;

	function ea(ta, na) {
		return Yi.from(ta.toRed(ue.mont(na.modulus)).redPow(new ue(na.publicExponent)).fromRed().toArray())
	}
	return withPublic_1 = ea, withPublic_1
}
var publicEncrypt, hasRequiredPublicEncrypt;

function requirePublicEncrypt() {
	if (hasRequiredPublicEncrypt) return publicEncrypt;
	hasRequiredPublicEncrypt = 1;
	var ue = requireParseAsn1(),
		Yi = requireBrowser$b(),
		ea = requireBrowser$9(),
		ta = requireMgf(),
		na = requireXor(),
		ra = requireBn$2(),
		ia = requireWithPublic(),
		aa = requireBrowserifyRsa(),
		oa = requireSafeBuffer$1().Buffer;
	publicEncrypt = function(da, ha, pa) {
		var va;
		da.padding ? va = da.padding : pa ? va = 1 : va = 4;
		var ba = ue(da),
			Ea;
		if (va === 4) Ea = la(ba, ha);
		else if (va === 1) Ea = sa(ba, ha, pa);
		else if (va === 3) {
			if (Ea = new ra(ha), Ea.cmp(ba.modulus) >= 0) throw new Error("data too long for modulus")
		} else throw new Error("unknown padding");
		return pa ? aa(Ea, ba) : ia(Ea, ba)
	};

	function la(ua, da) {
		var ha = ua.modulus.byteLength(),
			pa = da.length,
			va = ea("sha1").update(oa.alloc(0)).digest(),
			ba = va.length,
			Ea = 2 * ba;
		if (pa > ha - Ea - 2) throw new Error("message too long");
		var Sa = oa.alloc(ha - pa - Ea - 2),
			Ca = ha - ba - 1,
			ka = Yi(ba),
			Pa = na(oa.concat([va, Sa, oa.alloc(1, 1), da], Ca), ta(ka, Ca)),
			ja = na(ka, ta(Pa, ba));
		return new ra(oa.concat([oa.alloc(1), ja, Pa], ha))
	}

	function sa(ua, da, ha) {
		var pa = da.length,
			va = ua.modulus.byteLength();
		if (pa > va - 11) throw new Error("message too long");
		var ba;
		return ha ? ba = oa.alloc(va - pa - 3, 255) : ba = ca(va - pa - 3), new ra(oa.concat([oa.from([0, ha ? 1 : 2]), ba, oa.alloc(1), da], va))
	}

	function ca(ua) {
		for (var da = oa.allocUnsafe(ua), ha = 0, pa = Yi(ua * 2), va = 0, ba; ha < ua;) va === pa.length && (pa = Yi(ua * 2), va = 0), ba = pa[va++], ba && (da[ha++] = ba);
		return da
	}
	return publicEncrypt
}
var privateDecrypt, hasRequiredPrivateDecrypt;

function requirePrivateDecrypt() {
	if (hasRequiredPrivateDecrypt) return privateDecrypt;
	hasRequiredPrivateDecrypt = 1;
	var ue = requireParseAsn1(),
		Yi = requireMgf(),
		ea = requireXor(),
		ta = requireBn$2(),
		na = requireBrowserifyRsa(),
		ra = requireBrowser$9(),
		ia = requireWithPublic(),
		aa = requireSafeBuffer$1().Buffer;
	privateDecrypt = function(ua, da, ha) {
		var pa;
		ua.padding ? pa = ua.padding : ha ? pa = 1 : pa = 4;
		var va = ue(ua),
			ba = va.modulus.byteLength();
		if (da.length > ba || new ta(da).cmp(va.modulus) >= 0) throw new Error("decryption error");
		var Ea;
		ha ? Ea = ia(new ta(da), va) : Ea = na(da, va);
		var Sa = aa.alloc(ba - Ea.length);
		if (Ea = aa.concat([Sa, Ea], ba), pa === 4) return oa(va, Ea);
		if (pa === 1) return la(va, Ea, ha);
		if (pa === 3) return Ea;
		throw new Error("unknown padding")
	};

	function oa(ca, ua) {
		var da = ca.modulus.byteLength(),
			ha = ra("sha1").update(aa.alloc(0)).digest(),
			pa = ha.length;
		if (ua[0] !== 0) throw new Error("decryption error");
		var va = ua.slice(1, pa + 1),
			ba = ua.slice(pa + 1),
			Ea = ea(va, Yi(ba, pa)),
			Sa = ea(ba, Yi(Ea, da - pa - 1));
		if (sa(ha, Sa.slice(0, pa))) throw new Error("decryption error");
		for (var Ca = pa; Sa[Ca] === 0;) Ca++;
		if (Sa[Ca++] !== 1) throw new Error("decryption error");
		return Sa.slice(Ca)
	}

	function la(ca, ua, da) {
		for (var ha = ua.slice(0, 2), pa = 2, va = 0; ua[pa++] !== 0;)
			if (pa >= ua.length) {
				va++;
				break
			} var ba = ua.slice(2, pa - 1);
		if ((ha.toString("hex") !== "0002" && !da || ha.toString("hex") !== "0001" && da) && va++, ba.length < 8 && va++, va) throw new Error("decryption error");
		return ua.slice(pa)
	}

	function sa(ca, ua) {
		ca = aa.from(ca), ua = aa.from(ua);
		var da = 0,
			ha = ca.length;
		ca.length !== ua.length && (da++, ha = Math.min(ca.length, ua.length));
		for (var pa = -1; ++pa < ha;) da += ca[pa] ^ ua[pa];
		return da
	}
	return privateDecrypt
}
var hasRequiredBrowser$1;

function requireBrowser$1() {
	return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(ue) {
		ue.publicEncrypt = requirePublicEncrypt(), ue.privateDecrypt = requirePrivateDecrypt(), ue.privateEncrypt = function(ea, ta) {
			return ue.publicEncrypt(ea, ta, !0)
		}, ue.publicDecrypt = function(ea, ta) {
			return ue.privateDecrypt(ea, ta, !0)
		}
	}(browser$1)), browser$1
}
var browser = {},
	hasRequiredBrowser;

function requireBrowser() {
	if (hasRequiredBrowser) return browser;
	hasRequiredBrowser = 1;

	function ue() {
		throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`)
	}
	var Yi = requireSafeBuffer$1();
	requireBrowser$b();
	var ea = Yi.Buffer,
		ta = Yi.kMaxLength,
		na = commonjsGlobal.crypto || commonjsGlobal.msCrypto,
		ra = Math.pow(2, 32) - 1;

	function ia(ca, ua) {
		if (typeof ca != "number" || ca !== ca) throw new TypeError("offset must be a number");
		if (ca > ra || ca < 0) throw new TypeError("offset must be a uint32");
		if (ca > ta || ca > ua) throw new RangeError("offset out of range")
	}

	function aa(ca, ua, da) {
		if (typeof ca != "number" || ca !== ca) throw new TypeError("size must be a number");
		if (ca > ra || ca < 0) throw new TypeError("size must be a uint32");
		if (ca + ua > da || ca > ta) throw new RangeError("buffer too small")
	}
	na && na.getRandomValues ? (exports.randomFill = oa, exports.randomFillSync = sa) : (browser.randomFill = ue, browser.randomFillSync = ue);

	function oa(ca, ua, da, ha) {
		if (!ea.isBuffer(ca) && !(ca instanceof globalThis.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
		if (typeof ua == "function") ha = ua, ua = 0, da = ca.length;
		else if (typeof da == "function") ha = da, da = ca.length - ua;
		else if (typeof ha != "function") throw new TypeError('"cb" argument must be a function');
		return ia(ua, ca.length), aa(da, ua, ca.length), la(ca, ua, da, ha)
	}

	function la(ca, ua, da, ha) {
		{
			var pa = ca.buffer,
				va = new Uint8Array(pa, ua, da);
			if (na.getRandomValues(va), ha) {
				process$1.nextTick(function() {
					ha(null, ca)
				});
				return
			}
			return ca
		}
	}

	function sa(ca, ua, da) {
		if (typeof ua > "u" && (ua = 0), !ea.isBuffer(ca) && !(ca instanceof globalThis.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
		return ia(ua, ca.length), da === void 0 && (da = ca.length - ua), aa(da, ua, ca.length), la(ca, ua, da)
	}
	return browser
}
var hasRequiredCryptoBrowserify;

function requireCryptoBrowserify() {
	if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
	hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
	var ue = requireAlgos(),
		Yi = Object.keys(ue),
		ea = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(Yi);
	cryptoBrowserify.getHashes = function() {
		return ea
	};
	var ta = requireBrowser$7();
	cryptoBrowserify.pbkdf2 = ta.pbkdf2, cryptoBrowserify.pbkdf2Sync = ta.pbkdf2Sync;
	var na = requireBrowser$5();
	cryptoBrowserify.Cipher = na.Cipher, cryptoBrowserify.createCipher = na.createCipher, cryptoBrowserify.Cipheriv = na.Cipheriv, cryptoBrowserify.createCipheriv = na.createCipheriv, cryptoBrowserify.Decipher = na.Decipher, cryptoBrowserify.createDecipher = na.createDecipher, cryptoBrowserify.Decipheriv = na.Decipheriv, cryptoBrowserify.createDecipheriv = na.createDecipheriv, cryptoBrowserify.getCiphers = na.getCiphers, cryptoBrowserify.listCiphers = na.listCiphers;
	var ra = requireBrowser$4();
	cryptoBrowserify.DiffieHellmanGroup = ra.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = ra.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = ra.getDiffieHellman, cryptoBrowserify.createDiffieHellman = ra.createDiffieHellman, cryptoBrowserify.DiffieHellman = ra.DiffieHellman;
	var ia = requireBrowser$3();
	cryptoBrowserify.createSign = ia.createSign, cryptoBrowserify.Sign = ia.Sign, cryptoBrowserify.createVerify = ia.createVerify, cryptoBrowserify.Verify = ia.Verify, cryptoBrowserify.createECDH = requireBrowser$2();
	var aa = requireBrowser$1();
	cryptoBrowserify.publicEncrypt = aa.publicEncrypt, cryptoBrowserify.privateEncrypt = aa.privateEncrypt, cryptoBrowserify.publicDecrypt = aa.publicDecrypt, cryptoBrowserify.privateDecrypt = aa.privateDecrypt;
	var oa = requireBrowser();
	return cryptoBrowserify.randomFill = oa.randomFill, cryptoBrowserify.randomFillSync = oa.randomFillSync, cryptoBrowserify.createCredentials = function() {
		throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`))
	}, cryptoBrowserify.constants = {
		DH_CHECK_P_NOT_SAFE_PRIME: 2,
		DH_CHECK_P_NOT_PRIME: 1,
		DH_UNABLE_TO_CHECK_GENERATOR: 4,
		DH_NOT_SUITABLE_GENERATOR: 8,
		NPN_ENABLED: 1,
		ALPN_ENABLED: 1,
		RSA_PKCS1_PADDING: 1,
		RSA_SSLV23_PADDING: 2,
		RSA_NO_PADDING: 3,
		RSA_PKCS1_OAEP_PADDING: 4,
		RSA_X931_PADDING: 5,
		RSA_PKCS1_PSS_PADDING: 6,
		POINT_CONVERSION_COMPRESSED: 2,
		POINT_CONVERSION_UNCOMPRESSED: 4,
		POINT_CONVERSION_HYBRID: 6
	}, cryptoBrowserify
}(function(ue) {
	(function(Yi) {
		var ea = function(Ha) {
				var Fa, Ya = new Float64Array(16);
				if (Ha)
					for (Fa = 0; Fa < Ha.length; Fa++) Ya[Fa] = Ha[Fa];
				return Ya
			},
			ta = function() {
				throw new Error("no PRNG")
			},
			na = new Uint8Array(16),
			ra = new Uint8Array(32);
		ra[0] = 9;
		var ia = ea(),
			aa = ea([1]),
			oa = ea([56129, 1]),
			la = ea([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]),
			sa = ea([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]),
			ca = ea([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]),
			ua = ea([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]),
			da = ea([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);

		function ha(Ha, Fa, Ya, $a) {
			Ha[Fa] = Ya >> 24 & 255, Ha[Fa + 1] = Ya >> 16 & 255, Ha[Fa + 2] = Ya >> 8 & 255, Ha[Fa + 3] = Ya & 255, Ha[Fa + 4] = $a >> 24 & 255, Ha[Fa + 5] = $a >> 16 & 255, Ha[Fa + 6] = $a >> 8 & 255, Ha[Fa + 7] = $a & 255
		}

		function pa(Ha, Fa, Ya, $a, no) {
			var Co, co = 0;
			for (Co = 0; Co < no; Co++) co |= Ha[Fa + Co] ^ Ya[$a + Co];
			return (1 & co - 1 >>> 8) - 1
		}

		function va(Ha, Fa, Ya, $a) {
			return pa(Ha, Fa, Ya, $a, 16)
		}

		function ba(Ha, Fa, Ya, $a) {
			return pa(Ha, Fa, Ya, $a, 32)
		}

		function Ea(Ha, Fa, Ya, $a) {
			for (var no = $a[0] & 255 | ($a[1] & 255) << 8 | ($a[2] & 255) << 16 | ($a[3] & 255) << 24, Co = Ya[0] & 255 | (Ya[1] & 255) << 8 | (Ya[2] & 255) << 16 | (Ya[3] & 255) << 24, co = Ya[4] & 255 | (Ya[5] & 255) << 8 | (Ya[6] & 255) << 16 | (Ya[7] & 255) << 24, mo = Ya[8] & 255 | (Ya[9] & 255) << 8 | (Ya[10] & 255) << 16 | (Ya[11] & 255) << 24, xo = Ya[12] & 255 | (Ya[13] & 255) << 8 | (Ya[14] & 255) << 16 | (Ya[15] & 255) << 24, ko = $a[4] & 255 | ($a[5] & 255) << 8 | ($a[6] & 255) << 16 | ($a[7] & 255) << 24, $o = Fa[0] & 255 | (Fa[1] & 255) << 8 | (Fa[2] & 255) << 16 | (Fa[3] & 255) << 24, Ss = Fa[4] & 255 | (Fa[5] & 255) << 8 | (Fa[6] & 255) << 16 | (Fa[7] & 255) << 24, Xo = Fa[8] & 255 | (Fa[9] & 255) << 8 | (Fa[10] & 255) << 16 | (Fa[11] & 255) << 24, ms = Fa[12] & 255 | (Fa[13] & 255) << 8 | (Fa[14] & 255) << 16 | (Fa[15] & 255) << 24, gs = $a[8] & 255 | ($a[9] & 255) << 8 | ($a[10] & 255) << 16 | ($a[11] & 255) << 24, ys = Ya[16] & 255 | (Ya[17] & 255) << 8 | (Ya[18] & 255) << 16 | (Ya[19] & 255) << 24, Vo = Ya[20] & 255 | (Ya[21] & 255) << 8 | (Ya[22] & 255) << 16 | (Ya[23] & 255) << 24, cs = Ya[24] & 255 | (Ya[25] & 255) << 8 | (Ya[26] & 255) << 16 | (Ya[27] & 255) << 24, Zo = Ya[28] & 255 | (Ya[29] & 255) << 8 | (Ya[30] & 255) << 16 | (Ya[31] & 255) << 24, us = $a[12] & 255 | ($a[13] & 255) << 8 | ($a[14] & 255) << 16 | ($a[15] & 255) << 24, Jo = no, hs = Co, Qo = co, fs = mo, ds = xo, Yo = ko, Bo = $o, Mo = Ss, Uo = Xo, Do = ms, qo = gs, zo = ys, _s = Vo, Ts = cs, Ls = Zo, Cs = us, To, xs = 0; xs < 20; xs += 2) To = Jo + _s | 0, ds ^= To << 7 | To >>> 25, To = ds + Jo | 0, Uo ^= To << 9 | To >>> 23, To = Uo + ds | 0, _s ^= To << 13 | To >>> 19, To = _s + Uo | 0, Jo ^= To << 18 | To >>> 14, To = Yo + hs | 0, Do ^= To << 7 | To >>> 25, To = Do + Yo | 0, Ts ^= To << 9 | To >>> 23, To = Ts + Do | 0, hs ^= To << 13 | To >>> 19, To = hs + Ts | 0, Yo ^= To << 18 | To >>> 14, To = qo + Bo | 0, Ls ^= To << 7 | To >>> 25, To = Ls + qo | 0, Qo ^= To << 9 | To >>> 23, To = Qo + Ls | 0, Bo ^= To << 13 | To >>> 19, To = Bo + Qo | 0, qo ^= To << 18 | To >>> 14, To = Cs + zo | 0, fs ^= To << 7 | To >>> 25, To = fs + Cs | 0, Mo ^= To << 9 | To >>> 23, To = Mo + fs | 0, zo ^= To << 13 | To >>> 19, To = zo + Mo | 0, Cs ^= To << 18 | To >>> 14, To = Jo + fs | 0, hs ^= To << 7 | To >>> 25, To = hs + Jo | 0, Qo ^= To << 9 | To >>> 23, To = Qo + hs | 0, fs ^= To << 13 | To >>> 19, To = fs + Qo | 0, Jo ^= To << 18 | To >>> 14, To = Yo + ds | 0, Bo ^= To << 7 | To >>> 25, To = Bo + Yo | 0, Mo ^= To << 9 | To >>> 23, To = Mo + Bo | 0, ds ^= To << 13 | To >>> 19, To = ds + Mo | 0, Yo ^= To << 18 | To >>> 14, To = qo + Do | 0, zo ^= To << 7 | To >>> 25, To = zo + qo | 0, Uo ^= To << 9 | To >>> 23, To = Uo + zo | 0, Do ^= To << 13 | To >>> 19, To = Do + Uo | 0, qo ^= To << 18 | To >>> 14, To = Cs + Ls | 0, _s ^= To << 7 | To >>> 25, To = _s + Cs | 0, Ts ^= To << 9 | To >>> 23, To = Ts + _s | 0, Ls ^= To << 13 | To >>> 19, To = Ls + Ts | 0, Cs ^= To << 18 | To >>> 14;
			Jo = Jo + no | 0, hs = hs + Co | 0, Qo = Qo + co | 0, fs = fs + mo | 0, ds = ds + xo | 0, Yo = Yo + ko | 0, Bo = Bo + $o | 0, Mo = Mo + Ss | 0, Uo = Uo + Xo | 0, Do = Do + ms | 0, qo = qo + gs | 0, zo = zo + ys | 0, _s = _s + Vo | 0, Ts = Ts + cs | 0, Ls = Ls + Zo | 0, Cs = Cs + us | 0, Ha[0] = Jo >>> 0 & 255, Ha[1] = Jo >>> 8 & 255, Ha[2] = Jo >>> 16 & 255, Ha[3] = Jo >>> 24 & 255, Ha[4] = hs >>> 0 & 255, Ha[5] = hs >>> 8 & 255, Ha[6] = hs >>> 16 & 255, Ha[7] = hs >>> 24 & 255, Ha[8] = Qo >>> 0 & 255, Ha[9] = Qo >>> 8 & 255, Ha[10] = Qo >>> 16 & 255, Ha[11] = Qo >>> 24 & 255, Ha[12] = fs >>> 0 & 255, Ha[13] = fs >>> 8 & 255, Ha[14] = fs >>> 16 & 255, Ha[15] = fs >>> 24 & 255, Ha[16] = ds >>> 0 & 255, Ha[17] = ds >>> 8 & 255, Ha[18] = ds >>> 16 & 255, Ha[19] = ds >>> 24 & 255, Ha[20] = Yo >>> 0 & 255, Ha[21] = Yo >>> 8 & 255, Ha[22] = Yo >>> 16 & 255, Ha[23] = Yo >>> 24 & 255, Ha[24] = Bo >>> 0 & 255, Ha[25] = Bo >>> 8 & 255, Ha[26] = Bo >>> 16 & 255, Ha[27] = Bo >>> 24 & 255, Ha[28] = Mo >>> 0 & 255, Ha[29] = Mo >>> 8 & 255, Ha[30] = Mo >>> 16 & 255, Ha[31] = Mo >>> 24 & 255, Ha[32] = Uo >>> 0 & 255, Ha[33] = Uo >>> 8 & 255, Ha[34] = Uo >>> 16 & 255, Ha[35] = Uo >>> 24 & 255, Ha[36] = Do >>> 0 & 255, Ha[37] = Do >>> 8 & 255, Ha[38] = Do >>> 16 & 255, Ha[39] = Do >>> 24 & 255, Ha[40] = qo >>> 0 & 255, Ha[41] = qo >>> 8 & 255, Ha[42] = qo >>> 16 & 255, Ha[43] = qo >>> 24 & 255, Ha[44] = zo >>> 0 & 255, Ha[45] = zo >>> 8 & 255, Ha[46] = zo >>> 16 & 255, Ha[47] = zo >>> 24 & 255, Ha[48] = _s >>> 0 & 255, Ha[49] = _s >>> 8 & 255, Ha[50] = _s >>> 16 & 255, Ha[51] = _s >>> 24 & 255, Ha[52] = Ts >>> 0 & 255, Ha[53] = Ts >>> 8 & 255, Ha[54] = Ts >>> 16 & 255, Ha[55] = Ts >>> 24 & 255, Ha[56] = Ls >>> 0 & 255, Ha[57] = Ls >>> 8 & 255, Ha[58] = Ls >>> 16 & 255, Ha[59] = Ls >>> 24 & 255, Ha[60] = Cs >>> 0 & 255, Ha[61] = Cs >>> 8 & 255, Ha[62] = Cs >>> 16 & 255, Ha[63] = Cs >>> 24 & 255
		}

		function Sa(Ha, Fa, Ya, $a) {
			for (var no = $a[0] & 255 | ($a[1] & 255) << 8 | ($a[2] & 255) << 16 | ($a[3] & 255) << 24, Co = Ya[0] & 255 | (Ya[1] & 255) << 8 | (Ya[2] & 255) << 16 | (Ya[3] & 255) << 24, co = Ya[4] & 255 | (Ya[5] & 255) << 8 | (Ya[6] & 255) << 16 | (Ya[7] & 255) << 24, mo = Ya[8] & 255 | (Ya[9] & 255) << 8 | (Ya[10] & 255) << 16 | (Ya[11] & 255) << 24, xo = Ya[12] & 255 | (Ya[13] & 255) << 8 | (Ya[14] & 255) << 16 | (Ya[15] & 255) << 24, ko = $a[4] & 255 | ($a[5] & 255) << 8 | ($a[6] & 255) << 16 | ($a[7] & 255) << 24, $o = Fa[0] & 255 | (Fa[1] & 255) << 8 | (Fa[2] & 255) << 16 | (Fa[3] & 255) << 24, Ss = Fa[4] & 255 | (Fa[5] & 255) << 8 | (Fa[6] & 255) << 16 | (Fa[7] & 255) << 24, Xo = Fa[8] & 255 | (Fa[9] & 255) << 8 | (Fa[10] & 255) << 16 | (Fa[11] & 255) << 24, ms = Fa[12] & 255 | (Fa[13] & 255) << 8 | (Fa[14] & 255) << 16 | (Fa[15] & 255) << 24, gs = $a[8] & 255 | ($a[9] & 255) << 8 | ($a[10] & 255) << 16 | ($a[11] & 255) << 24, ys = Ya[16] & 255 | (Ya[17] & 255) << 8 | (Ya[18] & 255) << 16 | (Ya[19] & 255) << 24, Vo = Ya[20] & 255 | (Ya[21] & 255) << 8 | (Ya[22] & 255) << 16 | (Ya[23] & 255) << 24, cs = Ya[24] & 255 | (Ya[25] & 255) << 8 | (Ya[26] & 255) << 16 | (Ya[27] & 255) << 24, Zo = Ya[28] & 255 | (Ya[29] & 255) << 8 | (Ya[30] & 255) << 16 | (Ya[31] & 255) << 24, us = $a[12] & 255 | ($a[13] & 255) << 8 | ($a[14] & 255) << 16 | ($a[15] & 255) << 24, Jo = no, hs = Co, Qo = co, fs = mo, ds = xo, Yo = ko, Bo = $o, Mo = Ss, Uo = Xo, Do = ms, qo = gs, zo = ys, _s = Vo, Ts = cs, Ls = Zo, Cs = us, To, xs = 0; xs < 20; xs += 2) To = Jo + _s | 0, ds ^= To << 7 | To >>> 25, To = ds + Jo | 0, Uo ^= To << 9 | To >>> 23, To = Uo + ds | 0, _s ^= To << 13 | To >>> 19, To = _s + Uo | 0, Jo ^= To << 18 | To >>> 14, To = Yo + hs | 0, Do ^= To << 7 | To >>> 25, To = Do + Yo | 0, Ts ^= To << 9 | To >>> 23, To = Ts + Do | 0, hs ^= To << 13 | To >>> 19, To = hs + Ts | 0, Yo ^= To << 18 | To >>> 14, To = qo + Bo | 0, Ls ^= To << 7 | To >>> 25, To = Ls + qo | 0, Qo ^= To << 9 | To >>> 23, To = Qo + Ls | 0, Bo ^= To << 13 | To >>> 19, To = Bo + Qo | 0, qo ^= To << 18 | To >>> 14, To = Cs + zo | 0, fs ^= To << 7 | To >>> 25, To = fs + Cs | 0, Mo ^= To << 9 | To >>> 23, To = Mo + fs | 0, zo ^= To << 13 | To >>> 19, To = zo + Mo | 0, Cs ^= To << 18 | To >>> 14, To = Jo + fs | 0, hs ^= To << 7 | To >>> 25, To = hs + Jo | 0, Qo ^= To << 9 | To >>> 23, To = Qo + hs | 0, fs ^= To << 13 | To >>> 19, To = fs + Qo | 0, Jo ^= To << 18 | To >>> 14, To = Yo + ds | 0, Bo ^= To << 7 | To >>> 25, To = Bo + Yo | 0, Mo ^= To << 9 | To >>> 23, To = Mo + Bo | 0, ds ^= To << 13 | To >>> 19, To = ds + Mo | 0, Yo ^= To << 18 | To >>> 14, To = qo + Do | 0, zo ^= To << 7 | To >>> 25, To = zo + qo | 0, Uo ^= To << 9 | To >>> 23, To = Uo + zo | 0, Do ^= To << 13 | To >>> 19, To = Do + Uo | 0, qo ^= To << 18 | To >>> 14, To = Cs + Ls | 0, _s ^= To << 7 | To >>> 25, To = _s + Cs | 0, Ts ^= To << 9 | To >>> 23, To = Ts + _s | 0, Ls ^= To << 13 | To >>> 19, To = Ls + Ts | 0, Cs ^= To << 18 | To >>> 14;
			Ha[0] = Jo >>> 0 & 255, Ha[1] = Jo >>> 8 & 255, Ha[2] = Jo >>> 16 & 255, Ha[3] = Jo >>> 24 & 255, Ha[4] = Yo >>> 0 & 255, Ha[5] = Yo >>> 8 & 255, Ha[6] = Yo >>> 16 & 255, Ha[7] = Yo >>> 24 & 255, Ha[8] = qo >>> 0 & 255, Ha[9] = qo >>> 8 & 255, Ha[10] = qo >>> 16 & 255, Ha[11] = qo >>> 24 & 255, Ha[12] = Cs >>> 0 & 255, Ha[13] = Cs >>> 8 & 255, Ha[14] = Cs >>> 16 & 255, Ha[15] = Cs >>> 24 & 255, Ha[16] = Bo >>> 0 & 255, Ha[17] = Bo >>> 8 & 255, Ha[18] = Bo >>> 16 & 255, Ha[19] = Bo >>> 24 & 255, Ha[20] = Mo >>> 0 & 255, Ha[21] = Mo >>> 8 & 255, Ha[22] = Mo >>> 16 & 255, Ha[23] = Mo >>> 24 & 255, Ha[24] = Uo >>> 0 & 255, Ha[25] = Uo >>> 8 & 255, Ha[26] = Uo >>> 16 & 255, Ha[27] = Uo >>> 24 & 255, Ha[28] = Do >>> 0 & 255, Ha[29] = Do >>> 8 & 255, Ha[30] = Do >>> 16 & 255, Ha[31] = Do >>> 24 & 255
		}

		function Ca(Ha, Fa, Ya, $a) {
			Ea(Ha, Fa, Ya, $a)
		}

		function ka(Ha, Fa, Ya, $a) {
			Sa(Ha, Fa, Ya, $a)
		}
		var Pa = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);

		function ja(Ha, Fa, Ya, $a, no, Co, co) {
			var mo = new Uint8Array(16),
				xo = new Uint8Array(64),
				ko, $o;
			for ($o = 0; $o < 16; $o++) mo[$o] = 0;
			for ($o = 0; $o < 8; $o++) mo[$o] = Co[$o];
			for (; no >= 64;) {
				for (Ca(xo, mo, co, Pa), $o = 0; $o < 64; $o++) Ha[Fa + $o] = Ya[$a + $o] ^ xo[$o];
				for (ko = 1, $o = 8; $o < 16; $o++) ko = ko + (mo[$o] & 255) | 0, mo[$o] = ko & 255, ko >>>= 8;
				no -= 64, Fa += 64, $a += 64
			}
			if (no > 0)
				for (Ca(xo, mo, co, Pa), $o = 0; $o < no; $o++) Ha[Fa + $o] = Ya[$a + $o] ^ xo[$o];
			return 0
		}

		function Za(Ha, Fa, Ya, $a, no) {
			var Co = new Uint8Array(16),
				co = new Uint8Array(64),
				mo, xo;
			for (xo = 0; xo < 16; xo++) Co[xo] = 0;
			for (xo = 0; xo < 8; xo++) Co[xo] = $a[xo];
			for (; Ya >= 64;) {
				for (Ca(co, Co, no, Pa), xo = 0; xo < 64; xo++) Ha[Fa + xo] = co[xo];
				for (mo = 1, xo = 8; xo < 16; xo++) mo = mo + (Co[xo] & 255) | 0, Co[xo] = mo & 255, mo >>>= 8;
				Ya -= 64, Fa += 64
			}
			if (Ya > 0)
				for (Ca(co, Co, no, Pa), xo = 0; xo < Ya; xo++) Ha[Fa + xo] = co[xo];
			return 0
		}

		function Ga(Ha, Fa, Ya, $a, no) {
			var Co = new Uint8Array(32);
			ka(Co, $a, no, Pa);
			for (var co = new Uint8Array(8), mo = 0; mo < 8; mo++) co[mo] = $a[mo + 16];
			return Za(Ha, Fa, Ya, co, Co)
		}

		function Ja(Ha, Fa, Ya, $a, no, Co, co) {
			var mo = new Uint8Array(32);
			ka(mo, Co, co, Pa);
			for (var xo = new Uint8Array(8), ko = 0; ko < 8; ko++) xo[ko] = Co[ko + 16];
			return ja(Ha, Fa, Ya, $a, no, xo, mo)
		}
		var Ua = function(Ha) {
			this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
			var Fa, Ya, $a, no, Co, co, mo, xo;
			Fa = Ha[0] & 255 | (Ha[1] & 255) << 8, this.r[0] = Fa & 8191, Ya = Ha[2] & 255 | (Ha[3] & 255) << 8, this.r[1] = (Fa >>> 13 | Ya << 3) & 8191, $a = Ha[4] & 255 | (Ha[5] & 255) << 8, this.r[2] = (Ya >>> 10 | $a << 6) & 7939, no = Ha[6] & 255 | (Ha[7] & 255) << 8, this.r[3] = ($a >>> 7 | no << 9) & 8191, Co = Ha[8] & 255 | (Ha[9] & 255) << 8, this.r[4] = (no >>> 4 | Co << 12) & 255, this.r[5] = Co >>> 1 & 8190, co = Ha[10] & 255 | (Ha[11] & 255) << 8, this.r[6] = (Co >>> 14 | co << 2) & 8191, mo = Ha[12] & 255 | (Ha[13] & 255) << 8, this.r[7] = (co >>> 11 | mo << 5) & 8065, xo = Ha[14] & 255 | (Ha[15] & 255) << 8, this.r[8] = (mo >>> 8 | xo << 8) & 8191, this.r[9] = xo >>> 5 & 127, this.pad[0] = Ha[16] & 255 | (Ha[17] & 255) << 8, this.pad[1] = Ha[18] & 255 | (Ha[19] & 255) << 8, this.pad[2] = Ha[20] & 255 | (Ha[21] & 255) << 8, this.pad[3] = Ha[22] & 255 | (Ha[23] & 255) << 8, this.pad[4] = Ha[24] & 255 | (Ha[25] & 255) << 8, this.pad[5] = Ha[26] & 255 | (Ha[27] & 255) << 8, this.pad[6] = Ha[28] & 255 | (Ha[29] & 255) << 8, this.pad[7] = Ha[30] & 255 | (Ha[31] & 255) << 8
		};
		Ua.prototype.blocks = function(Ha, Fa, Ya) {
			for (var $a = this.fin ? 0 : 2048, no, Co, co, mo, xo, ko, $o, Ss, Xo, ms, gs, ys, Vo, cs, Zo, us, Jo, hs, Qo, fs = this.h[0], ds = this.h[1], Yo = this.h[2], Bo = this.h[3], Mo = this.h[4], Uo = this.h[5], Do = this.h[6], qo = this.h[7], zo = this.h[8], _s = this.h[9], Ts = this.r[0], Ls = this.r[1], Cs = this.r[2], To = this.r[3], xs = this.r[4], Rs = this.r[5], ks = this.r[6], Ms = this.r[7], As = this.r[8], Is = this.r[9]; Ya >= 16;) no = Ha[Fa + 0] & 255 | (Ha[Fa + 1] & 255) << 8, fs += no & 8191, Co = Ha[Fa + 2] & 255 | (Ha[Fa + 3] & 255) << 8, ds += (no >>> 13 | Co << 3) & 8191, co = Ha[Fa + 4] & 255 | (Ha[Fa + 5] & 255) << 8, Yo += (Co >>> 10 | co << 6) & 8191, mo = Ha[Fa + 6] & 255 | (Ha[Fa + 7] & 255) << 8, Bo += (co >>> 7 | mo << 9) & 8191, xo = Ha[Fa + 8] & 255 | (Ha[Fa + 9] & 255) << 8, Mo += (mo >>> 4 | xo << 12) & 8191, Uo += xo >>> 1 & 8191, ko = Ha[Fa + 10] & 255 | (Ha[Fa + 11] & 255) << 8, Do += (xo >>> 14 | ko << 2) & 8191, $o = Ha[Fa + 12] & 255 | (Ha[Fa + 13] & 255) << 8, qo += (ko >>> 11 | $o << 5) & 8191, Ss = Ha[Fa + 14] & 255 | (Ha[Fa + 15] & 255) << 8, zo += ($o >>> 8 | Ss << 8) & 8191, _s += Ss >>> 5 | $a, Xo = 0, ms = Xo, ms += fs * Ts, ms += ds * (5 * Is), ms += Yo * (5 * As), ms += Bo * (5 * Ms), ms += Mo * (5 * ks), Xo = ms >>> 13, ms &= 8191, ms += Uo * (5 * Rs), ms += Do * (5 * xs), ms += qo * (5 * To), ms += zo * (5 * Cs), ms += _s * (5 * Ls), Xo += ms >>> 13, ms &= 8191, gs = Xo, gs += fs * Ls, gs += ds * Ts, gs += Yo * (5 * Is), gs += Bo * (5 * As), gs += Mo * (5 * Ms), Xo = gs >>> 13, gs &= 8191, gs += Uo * (5 * ks), gs += Do * (5 * Rs), gs += qo * (5 * xs), gs += zo * (5 * To), gs += _s * (5 * Cs), Xo += gs >>> 13, gs &= 8191, ys = Xo, ys += fs * Cs, ys += ds * Ls, ys += Yo * Ts, ys += Bo * (5 * Is), ys += Mo * (5 * As), Xo = ys >>> 13, ys &= 8191, ys += Uo * (5 * Ms), ys += Do * (5 * ks), ys += qo * (5 * Rs), ys += zo * (5 * xs), ys += _s * (5 * To), Xo += ys >>> 13, ys &= 8191, Vo = Xo, Vo += fs * To, Vo += ds * Cs, Vo += Yo * Ls, Vo += Bo * Ts, Vo += Mo * (5 * Is), Xo = Vo >>> 13, Vo &= 8191, Vo += Uo * (5 * As), Vo += Do * (5 * Ms), Vo += qo * (5 * ks), Vo += zo * (5 * Rs), Vo += _s * (5 * xs), Xo += Vo >>> 13, Vo &= 8191, cs = Xo, cs += fs * xs, cs += ds * To, cs += Yo * Cs, cs += Bo * Ls, cs += Mo * Ts, Xo = cs >>> 13, cs &= 8191, cs += Uo * (5 * Is), cs += Do * (5 * As), cs += qo * (5 * Ms), cs += zo * (5 * ks), cs += _s * (5 * Rs), Xo += cs >>> 13, cs &= 8191, Zo = Xo, Zo += fs * Rs, Zo += ds * xs, Zo += Yo * To, Zo += Bo * Cs, Zo += Mo * Ls, Xo = Zo >>> 13, Zo &= 8191, Zo += Uo * Ts, Zo += Do * (5 * Is), Zo += qo * (5 * As), Zo += zo * (5 * Ms), Zo += _s * (5 * ks), Xo += Zo >>> 13, Zo &= 8191, us = Xo, us += fs * ks, us += ds * Rs, us += Yo * xs, us += Bo * To, us += Mo * Cs, Xo = us >>> 13, us &= 8191, us += Uo * Ls, us += Do * Ts, us += qo * (5 * Is), us += zo * (5 * As), us += _s * (5 * Ms), Xo += us >>> 13, us &= 8191, Jo = Xo, Jo += fs * Ms, Jo += ds * ks, Jo += Yo * Rs, Jo += Bo * xs, Jo += Mo * To, Xo = Jo >>> 13, Jo &= 8191, Jo += Uo * Cs, Jo += Do * Ls, Jo += qo * Ts, Jo += zo * (5 * Is), Jo += _s * (5 * As), Xo += Jo >>> 13, Jo &= 8191, hs = Xo, hs += fs * As, hs += ds * Ms, hs += Yo * ks, hs += Bo * Rs, hs += Mo * xs, Xo = hs >>> 13, hs &= 8191, hs += Uo * To, hs += Do * Cs, hs += qo * Ls, hs += zo * Ts, hs += _s * (5 * Is), Xo += hs >>> 13, hs &= 8191, Qo = Xo, Qo += fs * Is, Qo += ds * As, Qo += Yo * Ms, Qo += Bo * ks, Qo += Mo * Rs, Xo = Qo >>> 13, Qo &= 8191, Qo += Uo * xs, Qo += Do * To, Qo += qo * Cs, Qo += zo * Ls, Qo += _s * Ts, Xo += Qo >>> 13, Qo &= 8191, Xo = (Xo << 2) + Xo | 0, Xo = Xo + ms | 0, ms = Xo & 8191, Xo = Xo >>> 13, gs += Xo, fs = ms, ds = gs, Yo = ys, Bo = Vo, Mo = cs, Uo = Zo, Do = us, qo = Jo, zo = hs, _s = Qo, Fa += 16, Ya -= 16;
			this.h[0] = fs, this.h[1] = ds, this.h[2] = Yo, this.h[3] = Bo, this.h[4] = Mo, this.h[5] = Uo, this.h[6] = Do, this.h[7] = qo, this.h[8] = zo, this.h[9] = _s
		}, Ua.prototype.finish = function(Ha, Fa) {
			var Ya = new Uint16Array(10),
				$a, no, Co, co;
			if (this.leftover) {
				for (co = this.leftover, this.buffer[co++] = 1; co < 16; co++) this.buffer[co] = 0;
				this.fin = 1, this.blocks(this.buffer, 0, 16)
			}
			for ($a = this.h[1] >>> 13, this.h[1] &= 8191, co = 2; co < 10; co++) this.h[co] += $a, $a = this.h[co] >>> 13, this.h[co] &= 8191;
			for (this.h[0] += $a * 5, $a = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += $a, $a = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += $a, Ya[0] = this.h[0] + 5, $a = Ya[0] >>> 13, Ya[0] &= 8191, co = 1; co < 10; co++) Ya[co] = this.h[co] + $a, $a = Ya[co] >>> 13, Ya[co] &= 8191;
			for (Ya[9] -= 8192, no = ($a ^ 1) - 1, co = 0; co < 10; co++) Ya[co] &= no;
			for (no = ~no, co = 0; co < 10; co++) this.h[co] = this.h[co] & no | Ya[co];
			for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, Co = this.h[0] + this.pad[0], this.h[0] = Co & 65535, co = 1; co < 8; co++) Co = (this.h[co] + this.pad[co] | 0) + (Co >>> 16) | 0, this.h[co] = Co & 65535;
			Ha[Fa + 0] = this.h[0] >>> 0 & 255, Ha[Fa + 1] = this.h[0] >>> 8 & 255, Ha[Fa + 2] = this.h[1] >>> 0 & 255, Ha[Fa + 3] = this.h[1] >>> 8 & 255, Ha[Fa + 4] = this.h[2] >>> 0 & 255, Ha[Fa + 5] = this.h[2] >>> 8 & 255, Ha[Fa + 6] = this.h[3] >>> 0 & 255, Ha[Fa + 7] = this.h[3] >>> 8 & 255, Ha[Fa + 8] = this.h[4] >>> 0 & 255, Ha[Fa + 9] = this.h[4] >>> 8 & 255, Ha[Fa + 10] = this.h[5] >>> 0 & 255, Ha[Fa + 11] = this.h[5] >>> 8 & 255, Ha[Fa + 12] = this.h[6] >>> 0 & 255, Ha[Fa + 13] = this.h[6] >>> 8 & 255, Ha[Fa + 14] = this.h[7] >>> 0 & 255, Ha[Fa + 15] = this.h[7] >>> 8 & 255
		}, Ua.prototype.update = function(Ha, Fa, Ya) {
			var $a, no;
			if (this.leftover) {
				for (no = 16 - this.leftover, no > Ya && (no = Ya), $a = 0; $a < no; $a++) this.buffer[this.leftover + $a] = Ha[Fa + $a];
				if (Ya -= no, Fa += no, this.leftover += no, this.leftover < 16) return;
				this.blocks(this.buffer, 0, 16), this.leftover = 0
			}
			if (Ya >= 16 && (no = Ya - Ya % 16, this.blocks(Ha, Fa, no), Fa += no, Ya -= no), Ya) {
				for ($a = 0; $a < Ya; $a++) this.buffer[this.leftover + $a] = Ha[Fa + $a];
				this.leftover += Ya
			}
		};

		function xa(Ha, Fa, Ya, $a, no, Co) {
			var co = new Ua(Co);
			return co.update(Ya, $a, no), co.finish(Ha, Fa), 0
		}

		function ma(Ha, Fa, Ya, $a, no, Co) {
			var co = new Uint8Array(16);
			return xa(co, 0, Ya, $a, no, Co), va(Ha, Fa, co, 0)
		}

		function fa(Ha, Fa, Ya, $a, no) {
			var Co;
			if (Ya < 32) return -1;
			for (Ja(Ha, 0, Fa, 0, Ya, $a, no), xa(Ha, 16, Ha, 32, Ya - 32, Ha), Co = 0; Co < 16; Co++) Ha[Co] = 0;
			return 0
		}

		function ga(Ha, Fa, Ya, $a, no) {
			var Co, co = new Uint8Array(32);
			if (Ya < 32 || (Ga(co, 0, 32, $a, no), ma(Fa, 16, Fa, 32, Ya - 32, co) !== 0)) return -1;
			for (Ja(Ha, 0, Fa, 0, Ya, $a, no), Co = 0; Co < 32; Co++) Ha[Co] = 0;
			return 0
		}

		function wa(Ha, Fa) {
			var Ya;
			for (Ya = 0; Ya < 16; Ya++) Ha[Ya] = Fa[Ya] | 0
		}

		function Ma(Ha) {
			var Fa, Ya, $a = 1;
			for (Fa = 0; Fa < 16; Fa++) Ya = Ha[Fa] + $a + 65535, $a = Math.floor(Ya / 65536), Ha[Fa] = Ya - $a * 65536;
			Ha[0] += $a - 1 + 37 * ($a - 1)
		}

		function Aa(Ha, Fa, Ya) {
			for (var $a, no = ~(Ya - 1), Co = 0; Co < 16; Co++) $a = no & (Ha[Co] ^ Fa[Co]), Ha[Co] ^= $a, Fa[Co] ^= $a
		}

		function Ra(Ha, Fa) {
			var Ya, $a, no, Co = ea(),
				co = ea();
			for (Ya = 0; Ya < 16; Ya++) co[Ya] = Fa[Ya];
			for (Ma(co), Ma(co), Ma(co), $a = 0; $a < 2; $a++) {
				for (Co[0] = co[0] - 65517, Ya = 1; Ya < 15; Ya++) Co[Ya] = co[Ya] - 65535 - (Co[Ya - 1] >> 16 & 1), Co[Ya - 1] &= 65535;
				Co[15] = co[15] - 32767 - (Co[14] >> 16 & 1), no = Co[15] >> 16 & 1, Co[14] &= 65535, Aa(co, Co, 1 - no)
			}
			for (Ya = 0; Ya < 16; Ya++) Ha[2 * Ya] = co[Ya] & 255, Ha[2 * Ya + 1] = co[Ya] >> 8
		}

		function Ta(Ha, Fa) {
			var Ya = new Uint8Array(32),
				$a = new Uint8Array(32);
			return Ra(Ya, Ha), Ra($a, Fa), ba(Ya, 0, $a, 0)
		}

		function La(Ha) {
			var Fa = new Uint8Array(32);
			return Ra(Fa, Ha), Fa[0] & 1
		}

		function ya(Ha, Fa) {
			var Ya;
			for (Ya = 0; Ya < 16; Ya++) Ha[Ya] = Fa[2 * Ya] + (Fa[2 * Ya + 1] << 8);
			Ha[15] &= 32767
		}

		function Ba(Ha, Fa, Ya) {
			for (var $a = 0; $a < 16; $a++) Ha[$a] = Fa[$a] + Ya[$a]
		}

		function io(Ha, Fa, Ya) {
			for (var $a = 0; $a < 16; $a++) Ha[$a] = Fa[$a] - Ya[$a]
		}

		function oo(Ha, Fa, Ya) {
			var $a, no, Co = 0,
				co = 0,
				mo = 0,
				xo = 0,
				ko = 0,
				$o = 0,
				Ss = 0,
				Xo = 0,
				ms = 0,
				gs = 0,
				ys = 0,
				Vo = 0,
				cs = 0,
				Zo = 0,
				us = 0,
				Jo = 0,
				hs = 0,
				Qo = 0,
				fs = 0,
				ds = 0,
				Yo = 0,
				Bo = 0,
				Mo = 0,
				Uo = 0,
				Do = 0,
				qo = 0,
				zo = 0,
				_s = 0,
				Ts = 0,
				Ls = 0,
				Cs = 0,
				To = Ya[0],
				xs = Ya[1],
				Rs = Ya[2],
				ks = Ya[3],
				Ms = Ya[4],
				As = Ya[5],
				Is = Ya[6],
				Ns = Ya[7],
				Bs = Ya[8],
				Os = Ya[9],
				$s = Ya[10],
				Ps = Ya[11],
				Ds = Ya[12],
				Hs = Ya[13],
				Us = Ya[14],
				Fs = Ya[15];
			$a = Fa[0], Co += $a * To, co += $a * xs, mo += $a * Rs, xo += $a * ks, ko += $a * Ms, $o += $a * As, Ss += $a * Is, Xo += $a * Ns, ms += $a * Bs, gs += $a * Os, ys += $a * $s, Vo += $a * Ps, cs += $a * Ds, Zo += $a * Hs, us += $a * Us, Jo += $a * Fs, $a = Fa[1], co += $a * To, mo += $a * xs, xo += $a * Rs, ko += $a * ks, $o += $a * Ms, Ss += $a * As, Xo += $a * Is, ms += $a * Ns, gs += $a * Bs, ys += $a * Os, Vo += $a * $s, cs += $a * Ps, Zo += $a * Ds, us += $a * Hs, Jo += $a * Us, hs += $a * Fs, $a = Fa[2], mo += $a * To, xo += $a * xs, ko += $a * Rs, $o += $a * ks, Ss += $a * Ms, Xo += $a * As, ms += $a * Is, gs += $a * Ns, ys += $a * Bs, Vo += $a * Os, cs += $a * $s, Zo += $a * Ps, us += $a * Ds, Jo += $a * Hs, hs += $a * Us, Qo += $a * Fs, $a = Fa[3], xo += $a * To, ko += $a * xs, $o += $a * Rs, Ss += $a * ks, Xo += $a * Ms, ms += $a * As, gs += $a * Is, ys += $a * Ns, Vo += $a * Bs, cs += $a * Os, Zo += $a * $s, us += $a * Ps, Jo += $a * Ds, hs += $a * Hs, Qo += $a * Us, fs += $a * Fs, $a = Fa[4], ko += $a * To, $o += $a * xs, Ss += $a * Rs, Xo += $a * ks, ms += $a * Ms, gs += $a * As, ys += $a * Is, Vo += $a * Ns, cs += $a * Bs, Zo += $a * Os, us += $a * $s, Jo += $a * Ps, hs += $a * Ds, Qo += $a * Hs, fs += $a * Us, ds += $a * Fs, $a = Fa[5], $o += $a * To, Ss += $a * xs, Xo += $a * Rs, ms += $a * ks, gs += $a * Ms, ys += $a * As, Vo += $a * Is, cs += $a * Ns, Zo += $a * Bs, us += $a * Os, Jo += $a * $s, hs += $a * Ps, Qo += $a * Ds, fs += $a * Hs, ds += $a * Us, Yo += $a * Fs, $a = Fa[6], Ss += $a * To, Xo += $a * xs, ms += $a * Rs, gs += $a * ks, ys += $a * Ms, Vo += $a * As, cs += $a * Is, Zo += $a * Ns, us += $a * Bs, Jo += $a * Os, hs += $a * $s, Qo += $a * Ps, fs += $a * Ds, ds += $a * Hs, Yo += $a * Us, Bo += $a * Fs, $a = Fa[7], Xo += $a * To, ms += $a * xs, gs += $a * Rs, ys += $a * ks, Vo += $a * Ms, cs += $a * As, Zo += $a * Is, us += $a * Ns, Jo += $a * Bs, hs += $a * Os, Qo += $a * $s, fs += $a * Ps, ds += $a * Ds, Yo += $a * Hs, Bo += $a * Us, Mo += $a * Fs, $a = Fa[8], ms += $a * To, gs += $a * xs, ys += $a * Rs, Vo += $a * ks, cs += $a * Ms, Zo += $a * As, us += $a * Is, Jo += $a * Ns, hs += $a * Bs, Qo += $a * Os, fs += $a * $s, ds += $a * Ps, Yo += $a * Ds, Bo += $a * Hs, Mo += $a * Us, Uo += $a * Fs, $a = Fa[9], gs += $a * To, ys += $a * xs, Vo += $a * Rs, cs += $a * ks, Zo += $a * Ms, us += $a * As, Jo += $a * Is, hs += $a * Ns, Qo += $a * Bs, fs += $a * Os, ds += $a * $s, Yo += $a * Ps, Bo += $a * Ds, Mo += $a * Hs, Uo += $a * Us, Do += $a * Fs, $a = Fa[10], ys += $a * To, Vo += $a * xs, cs += $a * Rs, Zo += $a * ks, us += $a * Ms, Jo += $a * As, hs += $a * Is, Qo += $a * Ns, fs += $a * Bs, ds += $a * Os, Yo += $a * $s, Bo += $a * Ps, Mo += $a * Ds, Uo += $a * Hs, Do += $a * Us, qo += $a * Fs, $a = Fa[11], Vo += $a * To, cs += $a * xs, Zo += $a * Rs, us += $a * ks, Jo += $a * Ms, hs += $a * As, Qo += $a * Is, fs += $a * Ns, ds += $a * Bs, Yo += $a * Os, Bo += $a * $s, Mo += $a * Ps, Uo += $a * Ds, Do += $a * Hs, qo += $a * Us, zo += $a * Fs, $a = Fa[12], cs += $a * To, Zo += $a * xs, us += $a * Rs, Jo += $a * ks, hs += $a * Ms, Qo += $a * As, fs += $a * Is, ds += $a * Ns, Yo += $a * Bs, Bo += $a * Os, Mo += $a * $s, Uo += $a * Ps, Do += $a * Ds, qo += $a * Hs, zo += $a * Us, _s += $a * Fs, $a = Fa[13], Zo += $a * To, us += $a * xs, Jo += $a * Rs, hs += $a * ks, Qo += $a * Ms, fs += $a * As, ds += $a * Is, Yo += $a * Ns, Bo += $a * Bs, Mo += $a * Os, Uo += $a * $s, Do += $a * Ps, qo += $a * Ds, zo += $a * Hs, _s += $a * Us, Ts += $a * Fs, $a = Fa[14], us += $a * To, Jo += $a * xs, hs += $a * Rs, Qo += $a * ks, fs += $a * Ms, ds += $a * As, Yo += $a * Is, Bo += $a * Ns, Mo += $a * Bs, Uo += $a * Os, Do += $a * $s, qo += $a * Ps, zo += $a * Ds, _s += $a * Hs, Ts += $a * Us, Ls += $a * Fs, $a = Fa[15], Jo += $a * To, hs += $a * xs, Qo += $a * Rs, fs += $a * ks, ds += $a * Ms, Yo += $a * As, Bo += $a * Is, Mo += $a * Ns, Uo += $a * Bs, Do += $a * Os, qo += $a * $s, zo += $a * Ps, _s += $a * Ds, Ts += $a * Hs, Ls += $a * Us, Cs += $a * Fs, Co += 38 * hs, co += 38 * Qo, mo += 38 * fs, xo += 38 * ds, ko += 38 * Yo, $o += 38 * Bo, Ss += 38 * Mo, Xo += 38 * Uo, ms += 38 * Do, gs += 38 * qo, ys += 38 * zo, Vo += 38 * _s, cs += 38 * Ts, Zo += 38 * Ls, us += 38 * Cs, no = 1, $a = Co + no + 65535, no = Math.floor($a / 65536), Co = $a - no * 65536, $a = co + no + 65535, no = Math.floor($a / 65536), co = $a - no * 65536, $a = mo + no + 65535, no = Math.floor($a / 65536), mo = $a - no * 65536, $a = xo + no + 65535, no = Math.floor($a / 65536), xo = $a - no * 65536, $a = ko + no + 65535, no = Math.floor($a / 65536), ko = $a - no * 65536, $a = $o + no + 65535, no = Math.floor($a / 65536), $o = $a - no * 65536, $a = Ss + no + 65535, no = Math.floor($a / 65536), Ss = $a - no * 65536, $a = Xo + no + 65535, no = Math.floor($a / 65536), Xo = $a - no * 65536, $a = ms + no + 65535, no = Math.floor($a / 65536), ms = $a - no * 65536, $a = gs + no + 65535, no = Math.floor($a / 65536), gs = $a - no * 65536, $a = ys + no + 65535, no = Math.floor($a / 65536), ys = $a - no * 65536, $a = Vo + no + 65535, no = Math.floor($a / 65536), Vo = $a - no * 65536, $a = cs + no + 65535, no = Math.floor($a / 65536), cs = $a - no * 65536, $a = Zo + no + 65535, no = Math.floor($a / 65536), Zo = $a - no * 65536, $a = us + no + 65535, no = Math.floor($a / 65536), us = $a - no * 65536, $a = Jo + no + 65535, no = Math.floor($a / 65536), Jo = $a - no * 65536, Co += no - 1 + 37 * (no - 1), no = 1, $a = Co + no + 65535, no = Math.floor($a / 65536), Co = $a - no * 65536, $a = co + no + 65535, no = Math.floor($a / 65536), co = $a - no * 65536, $a = mo + no + 65535, no = Math.floor($a / 65536), mo = $a - no * 65536, $a = xo + no + 65535, no = Math.floor($a / 65536), xo = $a - no * 65536, $a = ko + no + 65535, no = Math.floor($a / 65536), ko = $a - no * 65536, $a = $o + no + 65535, no = Math.floor($a / 65536), $o = $a - no * 65536, $a = Ss + no + 65535, no = Math.floor($a / 65536), Ss = $a - no * 65536, $a = Xo + no + 65535, no = Math.floor($a / 65536), Xo = $a - no * 65536, $a = ms + no + 65535, no = Math.floor($a / 65536), ms = $a - no * 65536, $a = gs + no + 65535, no = Math.floor($a / 65536), gs = $a - no * 65536, $a = ys + no + 65535, no = Math.floor($a / 65536), ys = $a - no * 65536, $a = Vo + no + 65535, no = Math.floor($a / 65536), Vo = $a - no * 65536, $a = cs + no + 65535, no = Math.floor($a / 65536), cs = $a - no * 65536, $a = Zo + no + 65535, no = Math.floor($a / 65536), Zo = $a - no * 65536, $a = us + no + 65535, no = Math.floor($a / 65536), us = $a - no * 65536, $a = Jo + no + 65535, no = Math.floor($a / 65536), Jo = $a - no * 65536, Co += no - 1 + 37 * (no - 1), Ha[0] = Co, Ha[1] = co, Ha[2] = mo, Ha[3] = xo, Ha[4] = ko, Ha[5] = $o, Ha[6] = Ss, Ha[7] = Xo, Ha[8] = ms, Ha[9] = gs, Ha[10] = ys, Ha[11] = Vo, Ha[12] = cs, Ha[13] = Zo, Ha[14] = us, Ha[15] = Jo
		}

		function ao(Ha, Fa) {
			oo(Ha, Fa, Fa)
		}

		function Ia(Ha, Fa) {
			var Ya = ea(),
				$a;
			for ($a = 0; $a < 16; $a++) Ya[$a] = Fa[$a];
			for ($a = 253; $a >= 0; $a--) ao(Ya, Ya), $a !== 2 && $a !== 4 && oo(Ya, Ya, Fa);
			for ($a = 0; $a < 16; $a++) Ha[$a] = Ya[$a]
		}

		function Na(Ha, Fa) {
			var Ya = ea(),
				$a;
			for ($a = 0; $a < 16; $a++) Ya[$a] = Fa[$a];
			for ($a = 250; $a >= 0; $a--) ao(Ya, Ya), $a !== 1 && oo(Ya, Ya, Fa);
			for ($a = 0; $a < 16; $a++) Ha[$a] = Ya[$a]
		}

		function za(Ha, Fa, Ya) {
			var $a = new Uint8Array(32),
				no = new Float64Array(80),
				Co, co, mo = ea(),
				xo = ea(),
				ko = ea(),
				$o = ea(),
				Ss = ea(),
				Xo = ea();
			for (co = 0; co < 31; co++) $a[co] = Fa[co];
			for ($a[31] = Fa[31] & 127 | 64, $a[0] &= 248, ya(no, Ya), co = 0; co < 16; co++) xo[co] = no[co], $o[co] = mo[co] = ko[co] = 0;
			for (mo[0] = $o[0] = 1, co = 254; co >= 0; --co) Co = $a[co >>> 3] >>> (co & 7) & 1, Aa(mo, xo, Co), Aa(ko, $o, Co), Ba(Ss, mo, ko), io(mo, mo, ko), Ba(ko, xo, $o), io(xo, xo, $o), ao($o, Ss), ao(Xo, mo), oo(mo, ko, mo), oo(ko, xo, Ss), Ba(Ss, mo, ko), io(mo, mo, ko), ao(xo, mo), io(ko, $o, Xo), oo(mo, ko, oa), Ba(mo, mo, $o), oo(ko, ko, mo), oo(mo, $o, Xo), oo($o, xo, no), ao(xo, Ss), Aa(mo, xo, Co), Aa(ko, $o, Co);
			for (co = 0; co < 16; co++) no[co + 16] = mo[co], no[co + 32] = ko[co], no[co + 48] = xo[co], no[co + 64] = $o[co];
			var ms = no.subarray(32),
				gs = no.subarray(16);
			return Ia(ms, ms), oo(gs, gs, ms), Ra(Ha, gs), 0
		}

		function ro(Ha, Fa) {
			return za(Ha, Fa, ra)
		}

		function Va(Ha, Fa) {
			return ta(Fa, 32), ro(Ha, Fa)
		}

		function Wa(Ha, Fa, Ya) {
			var $a = new Uint8Array(32);
			return za($a, Ya, Fa), ka(Ha, na, $a, Pa)
		}
		var qa = fa,
			Ka = ga;

		function lo(Ha, Fa, Ya, $a, no, Co) {
			var co = new Uint8Array(32);
			return Wa(co, no, Co), qa(Ha, Fa, Ya, $a, co)
		}

		function yo(Ha, Fa, Ya, $a, no, Co) {
			var co = new Uint8Array(32);
			return Wa(co, no, Co), Ka(Ha, Fa, Ya, $a, co)
		}
		var fo = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

		function vo(Ha, Fa, Ya, $a) {
			for (var no = new Int32Array(16), Co = new Int32Array(16), co, mo, xo, ko, $o, Ss, Xo, ms, gs, ys, Vo, cs, Zo, us, Jo, hs, Qo, fs, ds, Yo, Bo, Mo, Uo, Do, qo, zo, _s = Ha[0], Ts = Ha[1], Ls = Ha[2], Cs = Ha[3], To = Ha[4], xs = Ha[5], Rs = Ha[6], ks = Ha[7], Ms = Fa[0], As = Fa[1], Is = Fa[2], Ns = Fa[3], Bs = Fa[4], Os = Fa[5], $s = Fa[6], Ps = Fa[7], Ds = 0; $a >= 128;) {
				for (ds = 0; ds < 16; ds++) Yo = 8 * ds + Ds, no[ds] = Ya[Yo + 0] << 24 | Ya[Yo + 1] << 16 | Ya[Yo + 2] << 8 | Ya[Yo + 3], Co[ds] = Ya[Yo + 4] << 24 | Ya[Yo + 5] << 16 | Ya[Yo + 6] << 8 | Ya[Yo + 7];
				for (ds = 0; ds < 80; ds++)
					if (co = _s, mo = Ts, xo = Ls, ko = Cs, $o = To, Ss = xs, Xo = Rs, ms = ks, gs = Ms, ys = As, Vo = Is, cs = Ns, Zo = Bs, us = Os, Jo = $s, hs = Ps, Bo = ks, Mo = Ps, Uo = Mo & 65535, Do = Mo >>> 16, qo = Bo & 65535, zo = Bo >>> 16, Bo = (To >>> 14 | Bs << 18) ^ (To >>> 18 | Bs << 14) ^ (Bs >>> 9 | To << 23), Mo = (Bs >>> 14 | To << 18) ^ (Bs >>> 18 | To << 14) ^ (To >>> 9 | Bs << 23), Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Bo = To & xs ^ ~To & Rs, Mo = Bs & Os ^ ~Bs & $s, Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Bo = fo[ds * 2], Mo = fo[ds * 2 + 1], Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Bo = no[ds % 16], Mo = Co[ds % 16], Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Do += Uo >>> 16, qo += Do >>> 16, zo += qo >>> 16, Qo = qo & 65535 | zo << 16, fs = Uo & 65535 | Do << 16, Bo = Qo, Mo = fs, Uo = Mo & 65535, Do = Mo >>> 16, qo = Bo & 65535, zo = Bo >>> 16, Bo = (_s >>> 28 | Ms << 4) ^ (Ms >>> 2 | _s << 30) ^ (Ms >>> 7 | _s << 25), Mo = (Ms >>> 28 | _s << 4) ^ (_s >>> 2 | Ms << 30) ^ (_s >>> 7 | Ms << 25), Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Bo = _s & Ts ^ _s & Ls ^ Ts & Ls, Mo = Ms & As ^ Ms & Is ^ As & Is, Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Do += Uo >>> 16, qo += Do >>> 16, zo += qo >>> 16, ms = qo & 65535 | zo << 16, hs = Uo & 65535 | Do << 16, Bo = ko, Mo = cs, Uo = Mo & 65535, Do = Mo >>> 16, qo = Bo & 65535, zo = Bo >>> 16, Bo = Qo, Mo = fs, Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Do += Uo >>> 16, qo += Do >>> 16, zo += qo >>> 16, ko = qo & 65535 | zo << 16, cs = Uo & 65535 | Do << 16, Ts = co, Ls = mo, Cs = xo, To = ko, xs = $o, Rs = Ss, ks = Xo, _s = ms, As = gs, Is = ys, Ns = Vo, Bs = cs, Os = Zo, $s = us, Ps = Jo, Ms = hs, ds % 16 === 15)
						for (Yo = 0; Yo < 16; Yo++) Bo = no[Yo], Mo = Co[Yo], Uo = Mo & 65535, Do = Mo >>> 16, qo = Bo & 65535, zo = Bo >>> 16, Bo = no[(Yo + 9) % 16], Mo = Co[(Yo + 9) % 16], Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Qo = no[(Yo + 1) % 16], fs = Co[(Yo + 1) % 16], Bo = (Qo >>> 1 | fs << 31) ^ (Qo >>> 8 | fs << 24) ^ Qo >>> 7, Mo = (fs >>> 1 | Qo << 31) ^ (fs >>> 8 | Qo << 24) ^ (fs >>> 7 | Qo << 25), Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Qo = no[(Yo + 14) % 16], fs = Co[(Yo + 14) % 16], Bo = (Qo >>> 19 | fs << 13) ^ (fs >>> 29 | Qo << 3) ^ Qo >>> 6, Mo = (fs >>> 19 | Qo << 13) ^ (Qo >>> 29 | fs << 3) ^ (fs >>> 6 | Qo << 26), Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Do += Uo >>> 16, qo += Do >>> 16, zo += qo >>> 16, no[Yo] = qo & 65535 | zo << 16, Co[Yo] = Uo & 65535 | Do << 16;
				Bo = _s, Mo = Ms, Uo = Mo & 65535, Do = Mo >>> 16, qo = Bo & 65535, zo = Bo >>> 16, Bo = Ha[0], Mo = Fa[0], Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Do += Uo >>> 16, qo += Do >>> 16, zo += qo >>> 16, Ha[0] = _s = qo & 65535 | zo << 16, Fa[0] = Ms = Uo & 65535 | Do << 16, Bo = Ts, Mo = As, Uo = Mo & 65535, Do = Mo >>> 16, qo = Bo & 65535, zo = Bo >>> 16, Bo = Ha[1], Mo = Fa[1], Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Do += Uo >>> 16, qo += Do >>> 16, zo += qo >>> 16, Ha[1] = Ts = qo & 65535 | zo << 16, Fa[1] = As = Uo & 65535 | Do << 16, Bo = Ls, Mo = Is, Uo = Mo & 65535, Do = Mo >>> 16, qo = Bo & 65535, zo = Bo >>> 16, Bo = Ha[2], Mo = Fa[2], Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Do += Uo >>> 16, qo += Do >>> 16, zo += qo >>> 16, Ha[2] = Ls = qo & 65535 | zo << 16, Fa[2] = Is = Uo & 65535 | Do << 16, Bo = Cs, Mo = Ns, Uo = Mo & 65535, Do = Mo >>> 16, qo = Bo & 65535, zo = Bo >>> 16, Bo = Ha[3], Mo = Fa[3], Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Do += Uo >>> 16, qo += Do >>> 16, zo += qo >>> 16, Ha[3] = Cs = qo & 65535 | zo << 16, Fa[3] = Ns = Uo & 65535 | Do << 16, Bo = To, Mo = Bs, Uo = Mo & 65535, Do = Mo >>> 16, qo = Bo & 65535, zo = Bo >>> 16, Bo = Ha[4], Mo = Fa[4], Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Do += Uo >>> 16, qo += Do >>> 16, zo += qo >>> 16, Ha[4] = To = qo & 65535 | zo << 16, Fa[4] = Bs = Uo & 65535 | Do << 16, Bo = xs, Mo = Os, Uo = Mo & 65535, Do = Mo >>> 16, qo = Bo & 65535, zo = Bo >>> 16, Bo = Ha[5], Mo = Fa[5], Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Do += Uo >>> 16, qo += Do >>> 16, zo += qo >>> 16, Ha[5] = xs = qo & 65535 | zo << 16, Fa[5] = Os = Uo & 65535 | Do << 16, Bo = Rs, Mo = $s, Uo = Mo & 65535, Do = Mo >>> 16, qo = Bo & 65535, zo = Bo >>> 16, Bo = Ha[6], Mo = Fa[6], Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Do += Uo >>> 16, qo += Do >>> 16, zo += qo >>> 16, Ha[6] = Rs = qo & 65535 | zo << 16, Fa[6] = $s = Uo & 65535 | Do << 16, Bo = ks, Mo = Ps, Uo = Mo & 65535, Do = Mo >>> 16, qo = Bo & 65535, zo = Bo >>> 16, Bo = Ha[7], Mo = Fa[7], Uo += Mo & 65535, Do += Mo >>> 16, qo += Bo & 65535, zo += Bo >>> 16, Do += Uo >>> 16, qo += Do >>> 16, zo += qo >>> 16, Ha[7] = ks = qo & 65535 | zo << 16, Fa[7] = Ps = Uo & 65535 | Do << 16, Ds += 128, $a -= 128
			}
			return $a
		}

		function so(Ha, Fa, Ya) {
			var $a = new Int32Array(8),
				no = new Int32Array(8),
				Co = new Uint8Array(256),
				co, mo = Ya;
			for ($a[0] = 1779033703, $a[1] = 3144134277, $a[2] = 1013904242, $a[3] = 2773480762, $a[4] = 1359893119, $a[5] = 2600822924, $a[6] = 528734635, $a[7] = 1541459225, no[0] = 4089235720, no[1] = 2227873595, no[2] = 4271175723, no[3] = 1595750129, no[4] = 2917565137, no[5] = 725511199, no[6] = 4215389547, no[7] = 327033209, vo($a, no, Fa, Ya), Ya %= 128, co = 0; co < Ya; co++) Co[co] = Fa[mo - Ya + co];
			for (Co[Ya] = 128, Ya = 256 - 128 * (Ya < 112 ? 1 : 0), Co[Ya - 9] = 0, ha(Co, Ya - 8, mo / 536870912 | 0, mo << 3), vo($a, no, Co, Ya), co = 0; co < 8; co++) ha(Ha, 8 * co, $a[co], no[co]);
			return 0
		}

		function Xa(Ha, Fa) {
			var Ya = ea(),
				$a = ea(),
				no = ea(),
				Co = ea(),
				co = ea(),
				mo = ea(),
				xo = ea(),
				ko = ea(),
				$o = ea();
			io(Ya, Ha[1], Ha[0]), io($o, Fa[1], Fa[0]), oo(Ya, Ya, $o), Ba($a, Ha[0], Ha[1]), Ba($o, Fa[0], Fa[1]), oo($a, $a, $o), oo(no, Ha[3], Fa[3]), oo(no, no, sa), oo(Co, Ha[2], Fa[2]), Ba(Co, Co, Co), io(co, $a, Ya), io(mo, Co, no), Ba(xo, Co, no), Ba(ko, $a, Ya), oo(Ha[0], co, mo), oo(Ha[1], ko, xo), oo(Ha[2], xo, mo), oo(Ha[3], co, ko)
		}

		function to(Ha, Fa, Ya) {
			var $a;
			for ($a = 0; $a < 4; $a++) Aa(Ha[$a], Fa[$a], Ya)
		}

		function ho(Ha, Fa) {
			var Ya = ea(),
				$a = ea(),
				no = ea();
			Ia(no, Fa[2]), oo(Ya, Fa[0], no), oo($a, Fa[1], no), Ra(Ha, $a), Ha[31] ^= La(Ya) << 7
		}

		function Eo(Ha, Fa, Ya) {
			var $a, no;
			for (wa(Ha[0], ia), wa(Ha[1], aa), wa(Ha[2], aa), wa(Ha[3], ia), no = 255; no >= 0; --no) $a = Ya[no / 8 | 0] >> (no & 7) & 1, to(Ha, Fa, $a), Xa(Fa, Ha), Xa(Ha, Ha), to(Ha, Fa, $a)
		}

		function wo(Ha, Fa) {
			var Ya = [ea(), ea(), ea(), ea()];
			wa(Ya[0], ca), wa(Ya[1], ua), wa(Ya[2], aa), oo(Ya[3], ca, ua), Eo(Ha, Ya, Fa)
		}

		function Ao(Ha, Fa, Ya) {
			var $a = new Uint8Array(64),
				no = [ea(), ea(), ea(), ea()],
				Co;
			for (Ya || ta(Fa, 32), so($a, Fa, 32), $a[0] &= 248, $a[31] &= 127, $a[31] |= 64, wo(no, $a), ho(Ha, no), Co = 0; Co < 32; Co++) Fa[Co + 32] = Ha[Co];
			return 0
		}
		var _o = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);

		function Lo(Ha, Fa) {
			var Ya, $a, no, Co;
			for ($a = 63; $a >= 32; --$a) {
				for (Ya = 0, no = $a - 32, Co = $a - 12; no < Co; ++no) Fa[no] += Ya - 16 * Fa[$a] * _o[no - ($a - 32)], Ya = Math.floor((Fa[no] + 128) / 256), Fa[no] -= Ya * 256;
				Fa[no] += Ya, Fa[$a] = 0
			}
			for (Ya = 0, no = 0; no < 32; no++) Fa[no] += Ya - (Fa[31] >> 4) * _o[no], Ya = Fa[no] >> 8, Fa[no] &= 255;
			for (no = 0; no < 32; no++) Fa[no] -= Ya * _o[no];
			for ($a = 0; $a < 32; $a++) Fa[$a + 1] += Fa[$a] >> 8, Ha[$a] = Fa[$a] & 255
		}

		function Fo(Ha) {
			var Fa = new Float64Array(64),
				Ya;
			for (Ya = 0; Ya < 64; Ya++) Fa[Ya] = Ha[Ya];
			for (Ya = 0; Ya < 64; Ya++) Ha[Ya] = 0;
			Lo(Ha, Fa)
		}

		function jo(Ha, Fa, Ya, $a) {
			var no = new Uint8Array(64),
				Co = new Uint8Array(64),
				co = new Uint8Array(64),
				mo, xo, ko = new Float64Array(64),
				$o = [ea(), ea(), ea(), ea()];
			so(no, $a, 32), no[0] &= 248, no[31] &= 127, no[31] |= 64;
			var Ss = Ya + 64;
			for (mo = 0; mo < Ya; mo++) Ha[64 + mo] = Fa[mo];
			for (mo = 0; mo < 32; mo++) Ha[32 + mo] = no[32 + mo];
			for (so(co, Ha.subarray(32), Ya + 32), Fo(co), wo($o, co), ho(Ha, $o), mo = 32; mo < 64; mo++) Ha[mo] = $a[mo];
			for (so(Co, Ha, Ya + 64), Fo(Co), mo = 0; mo < 64; mo++) ko[mo] = 0;
			for (mo = 0; mo < 32; mo++) ko[mo] = co[mo];
			for (mo = 0; mo < 32; mo++)
				for (xo = 0; xo < 32; xo++) ko[mo + xo] += Co[mo] * no[xo];
			return Lo(Ha.subarray(32), ko), Ss
		}

		function eo(Ha, Fa) {
			var Ya = ea(),
				$a = ea(),
				no = ea(),
				Co = ea(),
				co = ea(),
				mo = ea(),
				xo = ea();
			return wa(Ha[2], aa), ya(Ha[1], Fa), ao(no, Ha[1]), oo(Co, no, la), io(no, no, Ha[2]), Ba(Co, Ha[2], Co), ao(co, Co), ao(mo, co), oo(xo, mo, co), oo(Ya, xo, no), oo(Ya, Ya, Co), Na(Ya, Ya), oo(Ya, Ya, no), oo(Ya, Ya, Co), oo(Ya, Ya, Co), oo(Ha[0], Ya, Co), ao($a, Ha[0]), oo($a, $a, Co), Ta($a, no) && oo(Ha[0], Ha[0], da), ao($a, Ha[0]), oo($a, $a, Co), Ta($a, no) ? -1 : (La(Ha[0]) === Fa[31] >> 7 && io(Ha[0], ia, Ha[0]), oo(Ha[3], Ha[0], Ha[1]), 0)
		}

		function Oa(Ha, Fa, Ya, $a) {
			var no, Co = new Uint8Array(32),
				co = new Uint8Array(64),
				mo = [ea(), ea(), ea(), ea()],
				xo = [ea(), ea(), ea(), ea()];
			if (Ya < 64 || eo(xo, $a)) return -1;
			for (no = 0; no < Ya; no++) Ha[no] = Fa[no];
			for (no = 0; no < 32; no++) Ha[no + 32] = $a[no];
			if (so(co, Ha, Ya), Fo(co), Eo(mo, xo, co), wo(xo, Fa.subarray(32)), Xa(mo, xo), ho(Co, mo), Ya -= 64, ba(Fa, 0, Co, 0)) {
				for (no = 0; no < Ya; no++) Ha[no] = 0;
				return -1
			}
			for (no = 0; no < Ya; no++) Ha[no] = Fa[no + 64];
			return Ya
		}
		var Da = 32,
			Qa = 24,
			uo = 32,
			bo = 16,
			So = 32,
			Wo = 32,
			Po = 32,
			Ro = 32,
			Ho = 32,
			Oo = Qa,
			No = uo,
			ps = bo,
			Ko = 64,
			Go = 32,
			bs = 64,
			vs = 32,
			ls = 64;
		Yi.lowlevel = {
			crypto_core_hsalsa20: ka,
			crypto_stream_xor: Ja,
			crypto_stream: Ga,
			crypto_stream_salsa20_xor: ja,
			crypto_stream_salsa20: Za,
			crypto_onetimeauth: xa,
			crypto_onetimeauth_verify: ma,
			crypto_verify_16: va,
			crypto_verify_32: ba,
			crypto_secretbox: fa,
			crypto_secretbox_open: ga,
			crypto_scalarmult: za,
			crypto_scalarmult_base: ro,
			crypto_box_beforenm: Wa,
			crypto_box_afternm: qa,
			crypto_box: lo,
			crypto_box_open: yo,
			crypto_box_keypair: Va,
			crypto_hash: so,
			crypto_sign: jo,
			crypto_sign_keypair: Ao,
			crypto_sign_open: Oa,
			crypto_secretbox_KEYBYTES: Da,
			crypto_secretbox_NONCEBYTES: Qa,
			crypto_secretbox_ZEROBYTES: uo,
			crypto_secretbox_BOXZEROBYTES: bo,
			crypto_scalarmult_BYTES: So,
			crypto_scalarmult_SCALARBYTES: Wo,
			crypto_box_PUBLICKEYBYTES: Po,
			crypto_box_SECRETKEYBYTES: Ro,
			crypto_box_BEFORENMBYTES: Ho,
			crypto_box_NONCEBYTES: Oo,
			crypto_box_ZEROBYTES: No,
			crypto_box_BOXZEROBYTES: ps,
			crypto_sign_BYTES: Ko,
			crypto_sign_PUBLICKEYBYTES: Go,
			crypto_sign_SECRETKEYBYTES: bs,
			crypto_sign_SEEDBYTES: vs,
			crypto_hash_BYTES: ls,
			gf: ea,
			D: la,
			L: _o,
			pack25519: Ra,
			unpack25519: ya,
			M: oo,
			A: Ba,
			S: ao,
			Z: io,
			pow2523: Na,
			add: Xa,
			set25519: wa,
			modL: Lo,
			scalarmult: Eo,
			scalarbase: wo
		};

		function Es(Ha, Fa) {
			if (Ha.length !== Da) throw new Error("bad key size");
			if (Fa.length !== Qa) throw new Error("bad nonce size")
		}

		function ws(Ha, Fa) {
			if (Ha.length !== Po) throw new Error("bad public key size");
			if (Fa.length !== Ro) throw new Error("bad secret key size")
		}

		function as() {
			for (var Ha = 0; Ha < arguments.length; Ha++)
				if (!(arguments[Ha] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array")
		}

		function go(Ha) {
			for (var Fa = 0; Fa < Ha.length; Fa++) Ha[Fa] = 0
		}
		Yi.randomBytes = function(Ha) {
				var Fa = new Uint8Array(Ha);
				return ta(Fa, Ha), Fa
			}, Yi.secretbox = function(Ha, Fa, Ya) {
				as(Ha, Fa, Ya), Es(Ya, Fa);
				for (var $a = new Uint8Array(uo + Ha.length), no = new Uint8Array($a.length), Co = 0; Co < Ha.length; Co++) $a[Co + uo] = Ha[Co];
				return fa(no, $a, $a.length, Fa, Ya), no.subarray(bo)
			}, Yi.secretbox.open = function(Ha, Fa, Ya) {
				as(Ha, Fa, Ya), Es(Ya, Fa);
				for (var $a = new Uint8Array(bo + Ha.length), no = new Uint8Array($a.length), Co = 0; Co < Ha.length; Co++) $a[Co + bo] = Ha[Co];
				return $a.length < 32 || ga(no, $a, $a.length, Fa, Ya) !== 0 ? null : no.subarray(uo)
			}, Yi.secretbox.keyLength = Da, Yi.secretbox.nonceLength = Qa, Yi.secretbox.overheadLength = bo, Yi.scalarMult = function(Ha, Fa) {
				if (as(Ha, Fa), Ha.length !== Wo) throw new Error("bad n size");
				if (Fa.length !== So) throw new Error("bad p size");
				var Ya = new Uint8Array(So);
				return za(Ya, Ha, Fa), Ya
			}, Yi.scalarMult.base = function(Ha) {
				if (as(Ha), Ha.length !== Wo) throw new Error("bad n size");
				var Fa = new Uint8Array(So);
				return ro(Fa, Ha), Fa
			}, Yi.scalarMult.scalarLength = Wo, Yi.scalarMult.groupElementLength = So, Yi.box = function(Ha, Fa, Ya, $a) {
				var no = Yi.box.before(Ya, $a);
				return Yi.secretbox(Ha, Fa, no)
			}, Yi.box.before = function(Ha, Fa) {
				as(Ha, Fa), ws(Ha, Fa);
				var Ya = new Uint8Array(Ho);
				return Wa(Ya, Ha, Fa), Ya
			}, Yi.box.after = Yi.secretbox, Yi.box.open = function(Ha, Fa, Ya, $a) {
				var no = Yi.box.before(Ya, $a);
				return Yi.secretbox.open(Ha, Fa, no)
			}, Yi.box.open.after = Yi.secretbox.open, Yi.box.keyPair = function() {
				var Ha = new Uint8Array(Po),
					Fa = new Uint8Array(Ro);
				return Va(Ha, Fa), {
					publicKey: Ha,
					secretKey: Fa
				}
			}, Yi.box.keyPair.fromSecretKey = function(Ha) {
				if (as(Ha), Ha.length !== Ro) throw new Error("bad secret key size");
				var Fa = new Uint8Array(Po);
				return ro(Fa, Ha), {
					publicKey: Fa,
					secretKey: new Uint8Array(Ha)
				}
			}, Yi.box.publicKeyLength = Po, Yi.box.secretKeyLength = Ro, Yi.box.sharedKeyLength = Ho, Yi.box.nonceLength = Oo, Yi.box.overheadLength = Yi.secretbox.overheadLength, Yi.sign = function(Ha, Fa) {
				if (as(Ha, Fa), Fa.length !== bs) throw new Error("bad secret key size");
				var Ya = new Uint8Array(Ko + Ha.length);
				return jo(Ya, Ha, Ha.length, Fa), Ya
			}, Yi.sign.open = function(Ha, Fa) {
				if (as(Ha, Fa), Fa.length !== Go) throw new Error("bad public key size");
				var Ya = new Uint8Array(Ha.length),
					$a = Oa(Ya, Ha, Ha.length, Fa);
				if ($a < 0) return null;
				for (var no = new Uint8Array($a), Co = 0; Co < no.length; Co++) no[Co] = Ya[Co];
				return no
			}, Yi.sign.detached = function(Ha, Fa) {
				for (var Ya = Yi.sign(Ha, Fa), $a = new Uint8Array(Ko), no = 0; no < $a.length; no++) $a[no] = Ya[no];
				return $a
			}, Yi.sign.detached.verify = function(Ha, Fa, Ya) {
				if (as(Ha, Fa, Ya), Fa.length !== Ko) throw new Error("bad signature size");
				if (Ya.length !== Go) throw new Error("bad public key size");
				var $a = new Uint8Array(Ko + Ha.length),
					no = new Uint8Array(Ko + Ha.length),
					Co;
				for (Co = 0; Co < Ko; Co++) $a[Co] = Fa[Co];
				for (Co = 0; Co < Ha.length; Co++) $a[Co + Ko] = Ha[Co];
				return Oa(no, $a, $a.length, Ya) >= 0
			}, Yi.sign.keyPair = function() {
				var Ha = new Uint8Array(Go),
					Fa = new Uint8Array(bs);
				return Ao(Ha, Fa), {
					publicKey: Ha,
					secretKey: Fa
				}
			}, Yi.sign.keyPair.fromSecretKey = function(Ha) {
				if (as(Ha), Ha.length !== bs) throw new Error("bad secret key size");
				for (var Fa = new Uint8Array(Go), Ya = 0; Ya < Fa.length; Ya++) Fa[Ya] = Ha[32 + Ya];
				return {
					publicKey: Fa,
					secretKey: new Uint8Array(Ha)
				}
			}, Yi.sign.keyPair.fromSeed = function(Ha) {
				if (as(Ha), Ha.length !== vs) throw new Error("bad seed size");
				for (var Fa = new Uint8Array(Go), Ya = new Uint8Array(bs), $a = 0; $a < 32; $a++) Ya[$a] = Ha[$a];
				return Ao(Fa, Ya, !0), {
					publicKey: Fa,
					secretKey: Ya
				}
			}, Yi.sign.publicKeyLength = Go, Yi.sign.secretKeyLength = bs, Yi.sign.seedLength = vs, Yi.sign.signatureLength = Ko, Yi.hash = function(Ha) {
				as(Ha);
				var Fa = new Uint8Array(ls);
				return so(Fa, Ha, Ha.length), Fa
			}, Yi.hash.hashLength = ls, Yi.verify = function(Ha, Fa) {
				return as(Ha, Fa), Ha.length === 0 || Fa.length === 0 || Ha.length !== Fa.length ? !1 : pa(Ha, 0, Fa, 0, Ha.length) === 0
			}, Yi.setPRNG = function(Ha) {
				ta = Ha
			},
			function() {
				var Ha = typeof self < "u" ? self.crypto || self.msCrypto : null;
				if (Ha && Ha.getRandomValues) {
					var Fa = 65536;
					Yi.setPRNG(function(Ya, $a) {
						var no, Co = new Uint8Array($a);
						for (no = 0; no < $a; no += Fa) Ha.getRandomValues(Co.subarray(no, no + Math.min($a - no, Fa)));
						for (no = 0; no < $a; no++) Ya[no] = Co[no];
						go(Co)
					})
				} else typeof commonjsRequire < "u" && (Ha = requireCryptoBrowserify(), Ha && Ha.randomBytes && Yi.setPRNG(function(Ya, $a) {
					var no, Co = Ha.randomBytes($a);
					for (no = 0; no < $a; no++) Ya[no] = Co[no];
					go(Co)
				}))
			}()
	})(ue.exports ? ue.exports : self.nacl = self.nacl || {})
})(naclFast);
var naclFastExports = naclFast.exports;
const nacl$1 = getDefaultExportFromCjs$1(naclFastExports);
var binary = {};
Object.defineProperty(binary, "__esModule", {
	value: !0
});
binary.bitsToBytes = binary.bytesToBits = binary.lpad = void 0;

function lpad(ue, Yi, ea) {
	for (; ue.length < ea;) ue = Yi + ue;
	return ue
}
binary.lpad = lpad;

function bytesToBits(ue) {
	let Yi = "";
	for (let ea = 0; ea < ue.length; ea++) {
		let ta = ue.at(ea);
		Yi += lpad(ta.toString(2), "0", 8)
	}
	return Yi
}
binary.bytesToBits = bytesToBits;

function bitsToBytes(ue) {
	if (ue.length % 8 !== 0) throw Error("Uneven bits");
	let Yi = [];
	for (; ue.length > 0;) Yi.push(parseInt(ue.slice(0, 8), 2)), ue = ue.slice(8);
	return Buffer.from(Yi)
}
binary.bitsToBytes = bitsToBytes;
var wordlist = {};
Object.defineProperty(wordlist, "__esModule", {
	value: !0
});
wordlist.wordlist = void 0;
const EN = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"];
wordlist.wordlist = EN;
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(ue) {
	return ue && ue.__esModule ? ue : {
		default: ue
	}
};
Object.defineProperty(mnemonic, "__esModule", {
	value: !0
});
mnemonic.mnemonicFromRandomSeed = mnemonic.mnemonicIndexesToBytes = mnemonic.bytesToMnemonics = mnemonic.bytesToMnemonicIndexes = mnemonic.mnemonicNew = mnemonic.mnemonicValidate = mnemonic.mnemonicToHDSeed = mnemonic.mnemonicToWalletKey = mnemonic.mnemonicToPrivateKey = mnemonic.mnemonicToSeed = mnemonic.mnemonicToEntropy = void 0;
const tweetnacl_1$1 = __importDefault$1(naclFastExports),
	getSecureRandom_1 = getSecureRandom,
	hmac_sha512_1$3 = hmac_sha512$1,
	pbkdf2_sha512_1 = pbkdf2_sha512$1,
	binary_1 = binary,
	wordlist_1 = wordlist,
	PBKDF_ITERATIONS = 1e5;
async function isPasswordNeeded(ue) {
	const Yi = await mnemonicToEntropy(ue);
	return await isPasswordSeed(Yi) && !await isBasicSeed(Yi)
}

function normalizeMnemonic(ue) {
	return ue.map(Yi => Yi.toLowerCase().trim())
}
async function isBasicSeed(ue) {
	return (await (0, pbkdf2_sha512_1.pbkdf2_sha512)(ue, "TON seed version", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64))[0] == 0
}
async function isPasswordSeed(ue) {
	return (await (0, pbkdf2_sha512_1.pbkdf2_sha512)(ue, "TON fast seed version", 1, 64))[0] == 1
}
async function mnemonicToEntropy(ue, Yi) {
	return await (0, hmac_sha512_1$3.hmac_sha512)(ue.join(" "), Yi && Yi.length > 0 ? Yi : "")
}
mnemonic.mnemonicToEntropy = mnemonicToEntropy;
async function mnemonicToSeed(ue, Yi, ea) {
	const ta = await mnemonicToEntropy(ue, ea);
	return await (0, pbkdf2_sha512_1.pbkdf2_sha512)(ta, Yi, PBKDF_ITERATIONS, 64)
}
mnemonic.mnemonicToSeed = mnemonicToSeed;
async function mnemonicToPrivateKey(ue, Yi) {
	ue = normalizeMnemonic(ue);
	const ea = await mnemonicToSeed(ue, "TON default seed", Yi);
	let ta = tweetnacl_1$1.default.sign.keyPair.fromSeed(ea.slice(0, 32));
	return {
		publicKey: Buffer.from(ta.publicKey),
		secretKey: Buffer.from(ta.secretKey)
	}
}
mnemonic.mnemonicToPrivateKey = mnemonicToPrivateKey;
async function mnemonicToWalletKey(ue, Yi) {
	let ta = (await mnemonicToPrivateKey(ue, Yi)).secretKey.slice(0, 32);
	const na = tweetnacl_1$1.default.sign.keyPair.fromSeed(ta);
	return {
		publicKey: Buffer.from(na.publicKey),
		secretKey: Buffer.from(na.secretKey)
	}
}
mnemonic.mnemonicToWalletKey = mnemonicToWalletKey;
async function mnemonicToHDSeed(ue, Yi) {
	return ue = normalizeMnemonic(ue), await mnemonicToSeed(ue, "TON HD Keys seed", Yi)
}
mnemonic.mnemonicToHDSeed = mnemonicToHDSeed;
async function mnemonicValidate(ue, Yi) {
	ue = normalizeMnemonic(ue);
	for (let ea of ue)
		if (wordlist_1.wordlist.indexOf(ea) < 0) return !1;
	return Yi && Yi.length > 0 && !await isPasswordNeeded(ue) ? !1 : await isBasicSeed(await mnemonicToEntropy(ue, Yi))
}
mnemonic.mnemonicValidate = mnemonicValidate;
async function mnemonicNew(ue = 24, Yi) {
	let ea = [];
	for (;;) {
		ea = [];
		for (let ta = 0; ta < ue; ta++) {
			let na = await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);
			ea.push(wordlist_1.wordlist[na])
		}
		if (!(Yi && Yi.length > 0 && !await isPasswordNeeded(ea)) && await isBasicSeed(await mnemonicToEntropy(ea, Yi))) break
	}
	return ea
}
mnemonic.mnemonicNew = mnemonicNew;

function bytesToMnemonicIndexes(ue, Yi) {
	let ea = (0, binary_1.bytesToBits)(ue),
		ta = [];
	for (let na = 0; na < Yi; na++) {
		let ra = ea.slice(na * 11, na * 11 + 11);
		ta.push(parseInt(ra, 2))
	}
	return ta
}
mnemonic.bytesToMnemonicIndexes = bytesToMnemonicIndexes;

function bytesToMnemonics(ue, Yi) {
	let ea = bytesToMnemonicIndexes(ue, Yi),
		ta = [];
	for (let na of ea) ta.push(wordlist_1.wordlist[na]);
	return ta
}
mnemonic.bytesToMnemonics = bytesToMnemonics;

function mnemonicIndexesToBytes(ue) {
	let Yi = "";
	for (let ea of ue) {
		if (!Number.isSafeInteger(ea) || ea < 0 || ea >= 2028) throw Error("Invalid input");
		Yi += (0, binary_1.lpad)(ea.toString(2), "0", 11)
	}
	for (; Yi.length % 8 !== 0;) Yi = Yi + "0";
	return (0, binary_1.bitsToBytes)(Yi)
}
mnemonic.mnemonicIndexesToBytes = mnemonicIndexesToBytes;
async function mnemonicFromRandomSeed(ue, Yi = 24, ea) {
	const ta = Math.ceil(Yi * 11 / 8);
	let na = ue;
	for (;;) {
		let ra = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(na, "TON mnemonic seed", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), ta),
			ia = bytesToMnemonics(ra, Yi);
		if (await mnemonicValidate(ia, ea)) return ia;
		na = ra
	}
}
mnemonic.mnemonicFromRandomSeed = mnemonicFromRandomSeed;
var nacl = {},
	__importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(ue) {
		return ue && ue.__esModule ? ue : {
			default: ue
		}
	};
Object.defineProperty(nacl, "__esModule", {
	value: !0
});
nacl.openBox = nacl.sealBox = nacl.signVerify = nacl.sign = nacl.keyPairFromSeed = nacl.keyPairFromSecretKey = void 0;
const tweetnacl_1 = __importDefault(naclFastExports);

function keyPairFromSecretKey(ue) {
	let Yi = tweetnacl_1.default.sign.keyPair.fromSecretKey(new Uint8Array(ue));
	return {
		publicKey: Buffer.from(Yi.publicKey),
		secretKey: Buffer.from(Yi.secretKey)
	}
}
nacl.keyPairFromSecretKey = keyPairFromSecretKey;

function keyPairFromSeed(ue) {
	let Yi = tweetnacl_1.default.sign.keyPair.fromSeed(new Uint8Array(ue));
	return {
		publicKey: Buffer.from(Yi.publicKey),
		secretKey: Buffer.from(Yi.secretKey)
	}
}
nacl.keyPairFromSeed = keyPairFromSeed;

function sign$1(ue, Yi) {
	return Buffer.from(tweetnacl_1.default.sign.detached(new Uint8Array(ue), new Uint8Array(Yi)))
}
nacl.sign = sign$1;

function signVerify(ue, Yi, ea) {
	return tweetnacl_1.default.sign.detached.verify(new Uint8Array(ue), new Uint8Array(Yi), new Uint8Array(ea))
}
nacl.signVerify = signVerify;

function sealBox(ue, Yi, ea) {
	return Buffer.from(tweetnacl_1.default.secretbox(ue, Yi, ea))
}
nacl.sealBox = sealBox;

function openBox(ue, Yi, ea) {
	let ta = tweetnacl_1.default.secretbox.open(ue, Yi, ea);
	return ta ? Buffer.from(ta) : null
}
nacl.openBox = openBox;
var ed25519 = {};
Object.defineProperty(ed25519, "__esModule", {
	value: !0
});
ed25519.deriveEd25519Path = ed25519.deriveED25519HardenedKey = ed25519.getED25519MasterKeyFromSeed = void 0;
const hmac_sha512_1$2 = hmac_sha512$1,
	ED25519_CURVE = "ed25519 seed",
	HARDENED_OFFSET$1 = 2147483648;
async function getED25519MasterKeyFromSeed(ue) {
	const Yi = await (0, hmac_sha512_1$2.hmac_sha512)(ED25519_CURVE, ue),
		ea = Yi.slice(0, 32),
		ta = Yi.slice(32);
	return {
		key: ea,
		chainCode: ta
	}
}
ed25519.getED25519MasterKeyFromSeed = getED25519MasterKeyFromSeed;
async function deriveED25519HardenedKey(ue, Yi) {
	if (Yi >= HARDENED_OFFSET$1) throw Error("Key index must be less than offset");
	const ea = Buffer.alloc(4);
	ea.writeUInt32BE(Yi + HARDENED_OFFSET$1, 0);
	const ta = Buffer.concat([Buffer.alloc(1, 0), ue.key, ea]),
		na = await (0, hmac_sha512_1$2.hmac_sha512)(ue.chainCode, ta),
		ra = na.slice(0, 32),
		ia = na.slice(32);
	return {
		key: ra,
		chainCode: ia
	}
}
ed25519.deriveED25519HardenedKey = deriveED25519HardenedKey;
async function deriveEd25519Path(ue, Yi) {
	let ea = await getED25519MasterKeyFromSeed(ue),
		ta = [...Yi];
	for (; ta.length > 0;) {
		let na = ta[0];
		ta = ta.slice(1), ea = await deriveED25519HardenedKey(ea, na)
	}
	return ea.key
}
ed25519.deriveEd25519Path = deriveEd25519Path;
var symmetric = {};
Object.defineProperty(symmetric, "__esModule", {
	value: !0
});
symmetric.deriveSymmetricPath = symmetric.deriveSymmetricHardenedKey = symmetric.getSymmetricMasterKeyFromSeed = void 0;
const hmac_sha512_1$1 = hmac_sha512$1,
	SYMMETRIC_SEED = "Symmetric key seed";
async function getSymmetricMasterKeyFromSeed(ue) {
	const Yi = await (0, hmac_sha512_1$1.hmac_sha512)(SYMMETRIC_SEED, ue),
		ea = Yi.slice(32),
		ta = Yi.slice(0, 32);
	return {
		key: ea,
		chainCode: ta
	}
}
symmetric.getSymmetricMasterKeyFromSeed = getSymmetricMasterKeyFromSeed;
async function deriveSymmetricHardenedKey(ue, Yi) {
	const ea = Buffer.concat([Buffer.alloc(1, 0), Buffer.from(Yi)]),
		ta = await (0, hmac_sha512_1$1.hmac_sha512)(ue.chainCode, ea),
		na = ta.slice(32),
		ra = ta.slice(0, 32);
	return {
		key: na,
		chainCode: ra
	}
}
symmetric.deriveSymmetricHardenedKey = deriveSymmetricHardenedKey;
async function deriveSymmetricPath(ue, Yi) {
	let ea = await getSymmetricMasterKeyFromSeed(ue),
		ta = [...Yi];
	for (; ta.length > 0;) {
		let na = ta[0];
		ta = ta.slice(1), ea = await deriveSymmetricHardenedKey(ea, na)
	}
	return ea.key
}
symmetric.deriveSymmetricPath = deriveSymmetricPath;
var mnemonics = {};
Object.defineProperty(mnemonics, "__esModule", {
	value: !0
});
mnemonics.deriveMnemonicsPath = mnemonics.deriveMnemonicHardenedKey = mnemonics.getMnemonicsMasterKeyFromSeed = void 0;
const mnemonic_1 = mnemonic,
	hmac_sha512_1 = hmac_sha512$1,
	HARDENED_OFFSET = 2147483648,
	MNEMONICS_SEED = "TON Mnemonics HD seed";
async function getMnemonicsMasterKeyFromSeed(ue) {
	const Yi = await (0, hmac_sha512_1.hmac_sha512)(MNEMONICS_SEED, ue),
		ea = Yi.slice(0, 32),
		ta = Yi.slice(32);
	return {
		key: ea,
		chainCode: ta
	}
}
mnemonics.getMnemonicsMasterKeyFromSeed = getMnemonicsMasterKeyFromSeed;
async function deriveMnemonicHardenedKey(ue, Yi) {
	if (Yi >= HARDENED_OFFSET) throw Error("Key index must be less than offset");
	const ea = Buffer.alloc(4);
	ea.writeUInt32BE(Yi + HARDENED_OFFSET, 0);
	const ta = Buffer.concat([Buffer.alloc(1, 0), ue.key, ea]),
		na = await (0, hmac_sha512_1.hmac_sha512)(ue.chainCode, ta),
		ra = na.slice(0, 32),
		ia = na.slice(32);
	return {
		key: ra,
		chainCode: ia
	}
}
mnemonics.deriveMnemonicHardenedKey = deriveMnemonicHardenedKey;
async function deriveMnemonicsPath(ue, Yi, ea = 24, ta) {
	let na = await getMnemonicsMasterKeyFromSeed(ue),
		ra = [...Yi];
	for (; ra.length > 0;) {
		let ia = ra[0];
		ra = ra.slice(1), na = await deriveMnemonicHardenedKey(na, ia)
	}
	return await (0, mnemonic_1.mnemonicFromRandomSeed)(na.key, ea, ta)
}
mnemonics.deriveMnemonicsPath = deriveMnemonicsPath;
var hasRequiredDist;

function requireDist() {
	return hasRequiredDist || (hasRequiredDist = 1, function(ue) {
		Object.defineProperty(ue, "__esModule", {
			value: !0
		}), ue.getMnemonicsMasterKeyFromSeed = ue.deriveMnemonicHardenedKey = ue.deriveMnemonicsPath = ue.deriveSymmetricPath = ue.deriveSymmetricHardenedKey = ue.getSymmetricMasterKeyFromSeed = ue.deriveEd25519Path = ue.deriveED25519HardenedKey = ue.getED25519MasterKeyFromSeed = ue.signVerify = ue.sign = ue.keyPairFromSecretKey = ue.keyPairFromSeed = ue.openBox = ue.sealBox = ue.mnemonicWordList = ue.mnemonicToHDSeed = ue.mnemonicToSeed = ue.mnemonicToWalletKey = ue.mnemonicToPrivateKey = ue.mnemonicValidate = ue.mnemonicNew = ue.newSecurePassphrase = ue.newSecureWords = ue.getSecureRandomNumber = ue.getSecureRandomWords = ue.getSecureRandomBytes = ue.hmac_sha512 = ue.pbkdf2_sha512 = ue.sha512_sync = ue.sha512 = ue.sha256_sync = ue.sha256 = void 0;
		var Yi = sha256$5;
		Object.defineProperty(ue, "sha256", {
			enumerable: !0,
			get: function() {
				return Yi.sha256
			}
		}), Object.defineProperty(ue, "sha256_sync", {
			enumerable: !0,
			get: function() {
				return Yi.sha256_sync
			}
		});
		var ea = sha512$3;
		Object.defineProperty(ue, "sha512", {
			enumerable: !0,
			get: function() {
				return ea.sha512
			}
		}), Object.defineProperty(ue, "sha512_sync", {
			enumerable: !0,
			get: function() {
				return ea.sha512_sync
			}
		});
		var ta = pbkdf2_sha512$1;
		Object.defineProperty(ue, "pbkdf2_sha512", {
			enumerable: !0,
			get: function() {
				return ta.pbkdf2_sha512
			}
		});
		var na = hmac_sha512$1;
		Object.defineProperty(ue, "hmac_sha512", {
			enumerable: !0,
			get: function() {
				return na.hmac_sha512
			}
		});
		var ra = getSecureRandom;
		Object.defineProperty(ue, "getSecureRandomBytes", {
			enumerable: !0,
			get: function() {
				return ra.getSecureRandomBytes
			}
		}), Object.defineProperty(ue, "getSecureRandomWords", {
			enumerable: !0,
			get: function() {
				return ra.getSecureRandomWords
			}
		}), Object.defineProperty(ue, "getSecureRandomNumber", {
			enumerable: !0,
			get: function() {
				return ra.getSecureRandomNumber
			}
		});
		var ia = newSecureWords$1;
		Object.defineProperty(ue, "newSecureWords", {
			enumerable: !0,
			get: function() {
				return ia.newSecureWords
			}
		});
		var aa = requireNewSecurePassphrase();
		Object.defineProperty(ue, "newSecurePassphrase", {
			enumerable: !0,
			get: function() {
				return aa.newSecurePassphrase
			}
		});
		var oa = mnemonic;
		Object.defineProperty(ue, "mnemonicNew", {
			enumerable: !0,
			get: function() {
				return oa.mnemonicNew
			}
		}), Object.defineProperty(ue, "mnemonicValidate", {
			enumerable: !0,
			get: function() {
				return oa.mnemonicValidate
			}
		}), Object.defineProperty(ue, "mnemonicToPrivateKey", {
			enumerable: !0,
			get: function() {
				return oa.mnemonicToPrivateKey
			}
		}), Object.defineProperty(ue, "mnemonicToWalletKey", {
			enumerable: !0,
			get: function() {
				return oa.mnemonicToWalletKey
			}
		}), Object.defineProperty(ue, "mnemonicToSeed", {
			enumerable: !0,
			get: function() {
				return oa.mnemonicToSeed
			}
		}), Object.defineProperty(ue, "mnemonicToHDSeed", {
			enumerable: !0,
			get: function() {
				return oa.mnemonicToHDSeed
			}
		});
		var la = wordlist;
		Object.defineProperty(ue, "mnemonicWordList", {
			enumerable: !0,
			get: function() {
				return la.wordlist
			}
		});
		var sa = nacl;
		Object.defineProperty(ue, "sealBox", {
			enumerable: !0,
			get: function() {
				return sa.sealBox
			}
		}), Object.defineProperty(ue, "openBox", {
			enumerable: !0,
			get: function() {
				return sa.openBox
			}
		});
		var ca = nacl;
		Object.defineProperty(ue, "keyPairFromSeed", {
			enumerable: !0,
			get: function() {
				return ca.keyPairFromSeed
			}
		}), Object.defineProperty(ue, "keyPairFromSecretKey", {
			enumerable: !0,
			get: function() {
				return ca.keyPairFromSecretKey
			}
		}), Object.defineProperty(ue, "sign", {
			enumerable: !0,
			get: function() {
				return ca.sign
			}
		}), Object.defineProperty(ue, "signVerify", {
			enumerable: !0,
			get: function() {
				return ca.signVerify
			}
		});
		var ua = ed25519;
		Object.defineProperty(ue, "getED25519MasterKeyFromSeed", {
			enumerable: !0,
			get: function() {
				return ua.getED25519MasterKeyFromSeed
			}
		}), Object.defineProperty(ue, "deriveED25519HardenedKey", {
			enumerable: !0,
			get: function() {
				return ua.deriveED25519HardenedKey
			}
		}), Object.defineProperty(ue, "deriveEd25519Path", {
			enumerable: !0,
			get: function() {
				return ua.deriveEd25519Path
			}
		});
		var da = symmetric;
		Object.defineProperty(ue, "getSymmetricMasterKeyFromSeed", {
			enumerable: !0,
			get: function() {
				return da.getSymmetricMasterKeyFromSeed
			}
		}), Object.defineProperty(ue, "deriveSymmetricHardenedKey", {
			enumerable: !0,
			get: function() {
				return da.deriveSymmetricHardenedKey
			}
		}), Object.defineProperty(ue, "deriveSymmetricPath", {
			enumerable: !0,
			get: function() {
				return da.deriveSymmetricPath
			}
		});
		var ha = mnemonics;
		Object.defineProperty(ue, "deriveMnemonicsPath", {
			enumerable: !0,
			get: function() {
				return ha.deriveMnemonicsPath
			}
		}), Object.defineProperty(ue, "deriveMnemonicHardenedKey", {
			enumerable: !0,
			get: function() {
				return ha.deriveMnemonicHardenedKey
			}
		}), Object.defineProperty(ue, "getMnemonicsMasterKeyFromSeed", {
			enumerable: !0,
			get: function() {
				return ha.getMnemonicsMasterKeyFromSeed
			}
		})
	}(dist)), dist
}
var hasRequiredWonderCalculator;

function requireWonderCalculator() {
	if (hasRequiredWonderCalculator) return wonderCalculator;
	hasRequiredWonderCalculator = 1, Object.defineProperty(wonderCalculator, "__esModule", {
		value: !0
	}), wonderCalculator.wonderCalculator = void 0;
	const ue = requireBitString(),
		Yi = CellType$1,
		ea = LevelMask$1,
		ta = exoticPruned$1,
		na = requireExoticMerkleProof(),
		ra = descriptor,
		ia = requireDist(),
		aa = exoticMerkleUpdate$1,
		oa = exoticLibrary$1;

	function la(sa, ca, ua) {
		let da, ha = null;
		if (sa === Yi.CellType.Ordinary) {
			let Pa = 0;
			for (let ja of ua) Pa = Pa | ja.mask.value;
			da = new ea.LevelMask(Pa)
		} else if (sa === Yi.CellType.PrunedBranch) ha = (0, ta.exoticPruned)(ca, ua), da = new ea.LevelMask(ha.mask);
		else if (sa === Yi.CellType.MerkleProof)(0, na.exoticMerkleProof)(ca, ua), da = new ea.LevelMask(ua[0].mask.value >> 1);
		else if (sa === Yi.CellType.MerkleUpdate)(0, aa.exoticMerkleUpdate)(ca, ua), da = new ea.LevelMask((ua[0].mask.value | ua[1].mask.value) >> 1);
		else if (sa === Yi.CellType.Library)(0, oa.exoticLibrary)(ca, ua), da = new ea.LevelMask;
		else throw new Error("Unsupported exotic type");
		let pa = [],
			va = [],
			ba = sa === Yi.CellType.PrunedBranch ? 1 : da.hashCount,
			Sa = da.hashCount - ba;
		for (let Pa = 0, ja = 0; Pa <= da.level; Pa++) {
			if (!da.isSignificant(Pa)) continue;
			if (ja < Sa) {
				ja++;
				continue
			}
			let Za;
			if (ja === Sa) {
				if (!(Pa === 0 || sa === Yi.CellType.PrunedBranch)) throw Error("Invalid");
				Za = ca
			} else {
				if (!(Pa !== 0 && sa !== Yi.CellType.PrunedBranch)) throw Error("Invalid: " + Pa + ", " + sa);
				Za = new ue.BitString(va[ja - Sa - 1], 0, 256)
			}
			let Ga = 0;
			for (let ma of ua) {
				let fa;
				sa == Yi.CellType.MerkleProof || sa == Yi.CellType.MerkleUpdate ? fa = ma.depth(Pa + 1) : fa = ma.depth(Pa), Ga = Math.max(Ga, fa)
			}
			ua.length > 0 && Ga++;
			let Ja = (0, ra.getRepr)(ca, Za, ua, Pa, da.apply(Pa).value, sa),
				Ua = (0, ia.sha256_sync)(Ja),
				xa = ja - Sa;
			pa[xa] = Ga, va[xa] = Ua, ja++
		}
		let Ca = [],
			ka = [];
		if (ha)
			for (let Pa = 0; Pa < 4; Pa++) {
				const {
					hashIndex: ja
				} = da.apply(Pa), {
					hashIndex: Za
				} = da;
				ja !== Za ? (Ca.push(ha.pruned[ja].hash), ka.push(ha.pruned[ja].depth)) : (Ca.push(va[0]), ka.push(pa[0]))
			} else
				for (let Pa = 0; Pa < 4; Pa++) Ca.push(va[da.apply(Pa).hashIndex]), ka.push(pa[da.apply(Pa).hashIndex]);
		return {
			mask: da,
			hashes: Ca,
			depths: ka
		}
	}
	return wonderCalculator.wonderCalculator = la, wonderCalculator
}
var serialization = {},
	topologicalSort$1 = {};
Object.defineProperty(topologicalSort$1, "__esModule", {
	value: !0
});
topologicalSort$1.topologicalSort = void 0;

function topologicalSort(ue) {
	let Yi = [ue],
		ea = new Map,
		ta = new Set,
		na = [];
	for (; Yi.length > 0;) {
		const la = [...Yi];
		Yi = [];
		for (let sa of la) {
			const ca = sa.hash().toString("hex");
			if (!ea.has(ca)) {
				ta.add(ca), ea.set(ca, {
					cell: sa,
					refs: sa.refs.map(ua => ua.hash().toString("hex"))
				});
				for (let ua of sa.refs) Yi.push(ua)
			}
		}
	}
	let ra = new Set;

	function ia(la) {
		if (!ta.has(la)) return;
		if (ra.has(la)) throw Error("Not a DAG");
		ra.add(la);
		let sa = ea.get(la).refs;
		for (let ca = sa.length - 1; ca >= 0; ca--) ia(sa[ca]);
		na.push(la), ra.delete(la), ta.delete(la)
	}
	for (; ta.size > 0;) {
		const la = Array.from(ta)[0];
		ia(la)
	}
	let aa = new Map;
	for (let la = 0; la < na.length; la++) aa.set(na[na.length - la - 1], la);
	let oa = [];
	for (let la = na.length - 1; la >= 0; la--) {
		let sa = na[la];
		const ca = ea.get(sa);
		oa.push({
			cell: ca.cell,
			refs: ca.refs.map(ua => aa.get(ua))
		})
	}
	return oa
}
topologicalSort$1.topologicalSort = topologicalSort;
var bitsForNumber$1 = {};
Object.defineProperty(bitsForNumber$1, "__esModule", {
	value: !0
});
bitsForNumber$1.bitsForNumber = void 0;

function bitsForNumber(ue, Yi) {
	let ea = BigInt(ue);
	if (Yi === "int") return ea === 0n || ea === -1n ? 1 : (ea > 0 ? ea : -ea).toString(2).length + 1;
	if (Yi === "uint") {
		if (ea < 0) throw Error(`value is negative. Got ${ue}`);
		return ea.toString(2).length
	} else throw Error(`invalid mode. Got ${Yi}`)
}
bitsForNumber$1.bitsForNumber = bitsForNumber;
var crc32c$1 = {};
Object.defineProperty(crc32c$1, "__esModule", {
	value: !0
});
crc32c$1.crc32c = void 0;
const POLY = 2197175160;

function crc32c(ue) {
	let Yi = -1;
	for (let ta = 0; ta < ue.length; ta++) Yi ^= ue[ta], Yi = Yi & 1 ? Yi >>> 1 ^ POLY : Yi >>> 1, Yi = Yi & 1 ? Yi >>> 1 ^ POLY : Yi >>> 1, Yi = Yi & 1 ? Yi >>> 1 ^ POLY : Yi >>> 1, Yi = Yi & 1 ? Yi >>> 1 ^ POLY : Yi >>> 1, Yi = Yi & 1 ? Yi >>> 1 ^ POLY : Yi >>> 1, Yi = Yi & 1 ? Yi >>> 1 ^ POLY : Yi >>> 1, Yi = Yi & 1 ? Yi >>> 1 ^ POLY : Yi >>> 1, Yi = Yi & 1 ? Yi >>> 1 ^ POLY : Yi >>> 1;
	Yi = Yi ^ 4294967295;
	let ea = Buffer.alloc(4);
	return ea.writeInt32LE(Yi), ea
}
crc32c$1.crc32c = crc32c;
var hasRequiredSerialization;

function requireSerialization() {
	if (hasRequiredSerialization) return serialization;
	hasRequiredSerialization = 1, Object.defineProperty(serialization, "__esModule", {
		value: !0
	}), serialization.serializeBoc = serialization.deserializeBoc = serialization.parseBoc = void 0;
	const ue = BitReader$1,
		Yi = requireBitString(),
		ea = requireCell(),
		ta = topologicalSort$1,
		na = bitsForNumber$1,
		ra = requireBitBuilder(),
		ia = descriptor,
		aa = requirePaddedBits(),
		oa = crc32c$1;

	function la(ba) {
		return sa(ba & 7)
	}

	function sa(ba) {
		let Ea = 0;
		for (let Sa = 0; Sa < 3; Sa++) Ea += ba & 1, ba = ba >> 1;
		return Ea + 1
	}

	function ca(ba, Ea) {
		const Sa = ba.loadUint(8),
			Ca = Sa % 8,
			ka = !!(Sa & 8),
			Pa = ba.loadUint(8),
			ja = Math.ceil(Pa / 2),
			Za = !!(Pa % 2),
			Ga = Sa >> 5,
			Ja = (Sa & 16) != 0,
			xa = Ja ? la(Ga) * 32 : 0,
			ma = Ja ? la(Ga) * 2 : 0;
		ba.skip(xa * 8), ba.skip(ma * 8);
		let fa = Yi.BitString.EMPTY;
		ja > 0 && (Za ? fa = ba.loadPaddedBits(ja * 8) : fa = ba.loadBits(ja * 8));
		let ga = [];
		for (let wa = 0; wa < Ca; wa++) ga.push(ba.loadUint(Ea * 8));
		return {
			bits: fa,
			refs: ga,
			exotic: ka
		}
	}

	function ua(ba, Ea) {
		return 2 + Math.ceil(ba.bits.length / 8) + ba.refs.length * Ea
	}

	function da(ba) {
		let Ea = new ue.BitReader(new Yi.BitString(ba, 0, ba.length * 8)),
			Sa = Ea.loadUint(32);
		if (Sa === 1761568243) {
			let Ca = Ea.loadUint(8),
				ka = Ea.loadUint(8),
				Pa = Ea.loadUint(Ca * 8),
				ja = Ea.loadUint(Ca * 8),
				Za = Ea.loadUint(Ca * 8),
				Ga = Ea.loadUint(ka * 8),
				Ja = Ea.loadBuffer(Pa * ka),
				Ua = Ea.loadBuffer(Ga);
			return {
				size: Ca,
				offBytes: ka,
				cells: Pa,
				roots: ja,
				absent: Za,
				totalCellSize: Ga,
				index: Ja,
				cellData: Ua,
				root: [0]
			}
		} else if (Sa === 2898503464) {
			let Ca = Ea.loadUint(8),
				ka = Ea.loadUint(8),
				Pa = Ea.loadUint(Ca * 8),
				ja = Ea.loadUint(Ca * 8),
				Za = Ea.loadUint(Ca * 8),
				Ga = Ea.loadUint(ka * 8),
				Ja = Ea.loadBuffer(Pa * ka),
				Ua = Ea.loadBuffer(Ga),
				xa = Ea.loadBuffer(4);
			if (!(0, oa.crc32c)(ba.subarray(0, ba.length - 4)).equals(xa)) throw Error("Invalid CRC32C");
			return {
				size: Ca,
				offBytes: ka,
				cells: Pa,
				roots: ja,
				absent: Za,
				totalCellSize: Ga,
				index: Ja,
				cellData: Ua,
				root: [0]
			}
		} else if (Sa === 3052313714) {
			let Ca = Ea.loadUint(1),
				ka = Ea.loadUint(1);
			Ea.loadUint(1), Ea.loadUint(2);
			let Pa = Ea.loadUint(3),
				ja = Ea.loadUint(8),
				Za = Ea.loadUint(Pa * 8),
				Ga = Ea.loadUint(Pa * 8),
				Ja = Ea.loadUint(Pa * 8),
				Ua = Ea.loadUint(ja * 8),
				xa = [];
			for (let ga = 0; ga < Ga; ga++) xa.push(Ea.loadUint(Pa * 8));
			let ma = null;
			Ca && (ma = Ea.loadBuffer(Za * ja));
			let fa = Ea.loadBuffer(Ua);
			if (ka) {
				let ga = Ea.loadBuffer(4);
				if (!(0, oa.crc32c)(ba.subarray(0, ba.length - 4)).equals(ga)) throw Error("Invalid CRC32C")
			}
			return {
				size: Pa,
				offBytes: ja,
				cells: Za,
				roots: Ga,
				absent: Ja,
				totalCellSize: Ua,
				index: ma,
				cellData: fa,
				root: xa
			}
		} else throw Error("Invalid magic")
	}
	serialization.parseBoc = da;

	function ha(ba) {
		let Ea = da(ba),
			Sa = new ue.BitReader(new Yi.BitString(Ea.cellData, 0, Ea.cellData.length * 8)),
			Ca = [];
		for (let Pa = 0; Pa < Ea.cells; Pa++) {
			let ja = ca(Sa, Ea.size);
			Ca.push({
				...ja,
				result: null
			})
		}
		for (let Pa = Ca.length - 1; Pa >= 0; Pa--) {
			if (Ca[Pa].result) throw Error("Impossible");
			let ja = [];
			for (let Za of Ca[Pa].refs) {
				if (!Ca[Za].result) throw Error("Invalid BOC file");
				ja.push(Ca[Za].result)
			}
			Ca[Pa].result = new ea.Cell({
				bits: Ca[Pa].bits,
				refs: ja,
				exotic: Ca[Pa].exotic
			})
		}
		let ka = [];
		for (let Pa = 0; Pa < Ea.root.length; Pa++) ka.push(Ca[Ea.root[Pa]].result);
		return ka
	}
	serialization.deserializeBoc = ha;

	function pa(ba, Ea, Sa, Ca) {
		let ka = (0, ia.getRefsDescriptor)(ba.refs, ba.mask.value, ba.type),
			Pa = (0, ia.getBitsDescriptor)(ba.bits);
		Ca.writeUint(ka, 8), Ca.writeUint(Pa, 8), Ca.writeBuffer((0, aa.bitsToPaddedBuffer)(ba.bits));
		for (let ja of Ea) Ca.writeUint(ja, Sa * 8)
	}

	function va(ba, Ea) {
		let Sa = (0, ta.topologicalSort)(ba),
			Ca = Sa.length,
			ka = Ea.idx,
			Pa = Ea.crc32,
			ja = !1,
			Za = 0,
			Ga = Math.max(Math.ceil((0, na.bitsForNumber)(Ca, "uint") / 8), 1),
			Ja = 0,
			Ua = [];
		for (let wa of Sa) {
			let Ma = ua(wa.cell, Ga);
			Ja += Ma, Ua.push(Ja)
		}
		let xa = Math.max(Math.ceil((0, na.bitsForNumber)(Ja, "uint") / 8), 1),
			ma = (6 + 3 * Ga + xa + 1 * Ga + (ka ? Ca * xa : 0) + Ja + (Pa ? 4 : 0)) * 8,
			fa = new ra.BitBuilder(ma);
		if (fa.writeUint(3052313714, 32), fa.writeBit(ka), fa.writeBit(Pa), fa.writeBit(ja), fa.writeUint(Za, 2), fa.writeUint(Ga, 3), fa.writeUint(xa, 8), fa.writeUint(Ca, Ga * 8), fa.writeUint(1, Ga * 8), fa.writeUint(0, Ga * 8), fa.writeUint(Ja, xa * 8), fa.writeUint(0, Ga * 8), ka)
			for (let wa = 0; wa < Ca; wa++) fa.writeUint(Ua[wa], xa * 8);
		for (let wa = 0; wa < Ca; wa++) pa(Sa[wa].cell, Sa[wa].refs, Ga, fa);
		if (Pa) {
			let wa = (0, oa.crc32c)(fa.buffer());
			fa.writeBuffer(wa)
		}
		let ga = fa.buffer();
		if (ga.length !== ma / 8) throw Error("Internal error");
		return ga
	}
	return serialization.serializeBoc = va, serialization
}
var hasRequiredCell;

function requireCell() {
	if (hasRequiredCell) return Cell;
	hasRequiredCell = 1;
	var ue = commonjsGlobal && commonjsGlobal.__importDefault || function(ua) {
			return ua && ua.__esModule ? ua : {
				default: ua
			}
		},
		Yi;
	Object.defineProperty(Cell, "__esModule", {
		value: !0
	}), Cell.Cell = void 0;
	const ea = ue(symbol_inspect),
		ta = requireBitString(),
		na = CellType$1,
		ra = requireSlice(),
		ia = requireResolveExotic(),
		aa = requireWonderCalculator(),
		oa = requireSerialization(),
		la = BitReader$1,
		sa = requireBuilder();
	let ca = class Xs {
		static fromBoc(da) {
			return (0, oa.deserializeBoc)(da)
		}
		static fromBase64(da) {
			let ha = Xs.fromBoc(Buffer.from(da, "base64"));
			if (ha.length !== 1) throw new Error("Deserialized more than one cell");
			return ha[0]
		}
		constructor(da) {
			this._hashes = [], this._depths = [], this.beginParse = (Ca = !1) => {
				if (this.isExotic && !Ca) throw new Error("Exotic cells cannot be parsed");
				return new ra.Slice(new la.BitReader(this.bits), this.refs)
			}, this.hash = (Ca = 3) => this._hashes[Math.min(this._hashes.length - 1, Ca)], this.depth = (Ca = 3) => this._depths[Math.min(this._depths.length - 1, Ca)], this.level = () => this.mask.level, this.equals = Ca => this.hash().equals(Ca.hash()), this[Yi] = () => this.toString();
			let ha = ta.BitString.EMPTY;
			da && da.bits && (ha = da.bits);
			let pa = [];
			da && da.refs && (pa = [...da.refs]);
			let va, ba, Ea, Sa = na.CellType.Ordinary;
			if (da && da.exotic) {
				let Ca = (0, ia.resolveExotic)(ha, pa),
					ka = (0, aa.wonderCalculator)(Ca.type, ha, pa);
				Ea = ka.mask, ba = ka.depths, va = ka.hashes, Sa = Ca.type
			} else {
				if (pa.length > 4) throw new Error("Invalid number of references");
				if (ha.length > 1023) throw new Error(`Bits overflow: ${ha.length} > 1023`);
				let Ca = (0, aa.wonderCalculator)(na.CellType.Ordinary, ha, pa);
				Ea = Ca.mask, ba = Ca.depths, va = Ca.hashes, Sa = na.CellType.Ordinary
			}
			this.type = Sa, this.bits = ha, this.refs = pa, this.mask = Ea, this._depths = ba, this._hashes = va, Object.freeze(this), Object.freeze(this.refs), Object.freeze(this.bits), Object.freeze(this.mask), Object.freeze(this._depths), Object.freeze(this._hashes)
		}
		get isExotic() {
			return this.type !== na.CellType.Ordinary
		}
		toBoc(da) {
			let ha = da && da.idx !== null && da.idx !== void 0 ? da.idx : !1,
				pa = da && da.crc32 !== null && da.crc32 !== void 0 ? da.crc32 : !0;
			return (0, oa.serializeBoc)(this, {
				idx: ha,
				crc32: pa
			})
		}
		toString(da) {
			let ha = da || "",
				pa = "x";
			this.isExotic && (this.type === na.CellType.MerkleProof ? pa = "p" : this.type === na.CellType.MerkleUpdate ? pa = "u" : this.type === na.CellType.PrunedBranch && (pa = "p"));
			let va = ha + (this.isExotic ? pa : "x") + "{" + this.bits.toString() + "}";
			for (let ba in this.refs) {
				const Ea = this.refs[ba];
				va += `
` + Ea.toString(ha + " ")
			}
			return va
		}
		asSlice() {
			return this.beginParse()
		}
		asBuilder() {
			return (0, sa.beginCell)().storeSlice(this.asSlice())
		}
	};
	return Cell.Cell = ca, Yi = ea.default, ca.EMPTY = new ca, Cell
}
var hasRequiredBuilder;

function requireBuilder() {
	if (hasRequiredBuilder) return Builder;
	hasRequiredBuilder = 1, Object.defineProperty(Builder, "__esModule", {
		value: !0
	}), Builder.Builder = Builder.beginCell = void 0;
	const ue = requireBitBuilder(),
		Yi = requireCell(),
		ea = requireStrings();

	function ta() {
		return new na
	}
	Builder.beginCell = ta;
	let na = class Qs {
		constructor() {
			this._bits = new ue.BitBuilder, this._refs = []
		}
		get bits() {
			return this._bits.length
		}
		get refs() {
			return this._refs.length
		}
		get availableBits() {
			return 1023 - this.bits
		}
		get availableRefs() {
			return 4 - this.refs
		}
		storeBit(ia) {
			return this._bits.writeBit(ia), this
		}
		storeBits(ia) {
			return this._bits.writeBits(ia), this
		}
		storeBuffer(ia, aa) {
			if (aa != null && ia.length !== aa) throw Error(`Buffer length ${ia.length} is not equal to ${aa}`);
			return this._bits.writeBuffer(ia), this
		}
		storeMaybeBuffer(ia, aa) {
			return ia !== null ? (this.storeBit(1), this.storeBuffer(ia, aa)) : this.storeBit(0), this
		}
		storeUint(ia, aa) {
			return this._bits.writeUint(ia, aa), this
		}
		storeMaybeUint(ia, aa) {
			return ia != null ? (this.storeBit(1), this.storeUint(ia, aa)) : this.storeBit(0), this
		}
		storeInt(ia, aa) {
			return this._bits.writeInt(ia, aa), this
		}
		storeMaybeInt(ia, aa) {
			return ia != null ? (this.storeBit(1), this.storeInt(ia, aa)) : this.storeBit(0), this
		}
		storeVarUint(ia, aa) {
			return this._bits.writeVarUint(ia, aa), this
		}
		storeMaybeVarUint(ia, aa) {
			return ia != null ? (this.storeBit(1), this.storeVarUint(ia, aa)) : this.storeBit(0), this
		}
		storeVarInt(ia, aa) {
			return this._bits.writeVarInt(ia, aa), this
		}
		storeMaybeVarInt(ia, aa) {
			return ia != null ? (this.storeBit(1), this.storeVarInt(ia, aa)) : this.storeBit(0), this
		}
		storeCoins(ia) {
			return this._bits.writeCoins(ia), this
		}
		storeMaybeCoins(ia) {
			return ia != null ? (this.storeBit(1), this.storeCoins(ia)) : this.storeBit(0), this
		}
		storeAddress(ia) {
			return this._bits.writeAddress(ia), this
		}
		storeRef(ia) {
			if (this._refs.length >= 4) throw new Error("Too many references");
			if (ia instanceof Yi.Cell) this._refs.push(ia);
			else if (ia instanceof Qs) this._refs.push(ia.endCell());
			else throw new Error("Invalid argument");
			return this
		}
		storeMaybeRef(ia) {
			return ia ? (this.storeBit(1), this.storeRef(ia)) : this.storeBit(0), this
		}
		storeSlice(ia) {
			let aa = ia.clone();
			for (aa.remainingBits > 0 && this.storeBits(aa.loadBits(aa.remainingBits)); aa.remainingRefs > 0;) this.storeRef(aa.loadRef());
			return this
		}
		storeMaybeSlice(ia) {
			return ia ? (this.storeBit(1), this.storeSlice(ia)) : this.storeBit(0), this
		}
		storeBuilder(ia) {
			return this.storeSlice(ia.endCell().beginParse())
		}
		storeMaybeBuilder(ia) {
			return ia ? (this.storeBit(1), this.storeBuilder(ia)) : this.storeBit(0), this
		}
		storeWritable(ia) {
			return typeof ia == "object" ? ia.writeTo(this) : ia(this), this
		}
		storeMaybeWritable(ia) {
			return ia ? (this.storeBit(1), this.storeWritable(ia)) : this.storeBit(0), this
		}
		store(ia) {
			return this.storeWritable(ia), this
		}
		storeStringTail(ia) {
			return (0, ea.writeString)(ia, this), this
		}
		storeMaybeStringTail(ia) {
			return ia != null ? (this.storeBit(1), (0, ea.writeString)(ia, this)) : this.storeBit(0), this
		}
		storeStringRefTail(ia) {
			return this.storeRef(ta().storeStringTail(ia)), this
		}
		storeMaybeStringRefTail(ia) {
			return ia != null ? (this.storeBit(1), this.storeStringRefTail(ia)) : this.storeBit(0), this
		}
		storeDict(ia, aa, oa) {
			return ia ? ia.store(this, aa, oa) : this.storeBit(0), this
		}
		storeDictDirect(ia, aa, oa) {
			return ia.storeDirect(this, aa, oa), this
		}
		endCell(ia) {
			return new Yi.Cell({
				bits: this._bits.build(),
				refs: this._refs,
				exotic: ia == null ? void 0 : ia.exotic
			})
		}
		asCell() {
			return this.endCell()
		}
		asSlice() {
			return this.endCell().beginParse()
		}
	};
	return Builder.Builder = na, Builder
}
var StateInit = {},
	SimpleLibrary = {};
Object.defineProperty(SimpleLibrary, "__esModule", {
	value: !0
});
SimpleLibrary.SimpleLibraryValue = SimpleLibrary.storeSimpleLibrary = SimpleLibrary.loadSimpleLibrary = void 0;

function loadSimpleLibrary(ue) {
	return {
		public: ue.loadBit(),
		root: ue.loadRef()
	}
}
SimpleLibrary.loadSimpleLibrary = loadSimpleLibrary;

function storeSimpleLibrary(ue) {
	return Yi => {
		Yi.storeBit(ue.public), Yi.storeRef(ue.root)
	}
}
SimpleLibrary.storeSimpleLibrary = storeSimpleLibrary;
SimpleLibrary.SimpleLibraryValue = {
	serialize(ue, Yi) {
		storeSimpleLibrary(ue)(Yi)
	},
	parse(ue) {
		return loadSimpleLibrary(ue)
	}
};
var TickTock = {};
Object.defineProperty(TickTock, "__esModule", {
	value: !0
});
TickTock.storeTickTock = TickTock.loadTickTock = void 0;

function loadTickTock(ue) {
	return {
		tick: ue.loadBit(),
		tock: ue.loadBit()
	}
}
TickTock.loadTickTock = loadTickTock;

function storeTickTock(ue) {
	return Yi => {
		Yi.storeBit(ue.tick), Yi.storeBit(ue.tock)
	}
}
TickTock.storeTickTock = storeTickTock;
Object.defineProperty(StateInit, "__esModule", {
	value: !0
});
StateInit.storeStateInit = StateInit.loadStateInit = void 0;
const Dictionary_1$2 = requireDictionary(),
	SimpleLibrary_1 = SimpleLibrary,
	TickTock_1 = TickTock;

function loadStateInit(ue) {
	let Yi;
	ue.loadBit() && (Yi = ue.loadUint(5));
	let ea;
	ue.loadBit() && (ea = (0, TickTock_1.loadTickTock)(ue));
	let ta = ue.loadMaybeRef(),
		na = ue.loadMaybeRef(),
		ra = ue.loadDict(Dictionary_1$2.Dictionary.Keys.BigUint(256), SimpleLibrary_1.SimpleLibraryValue);
	return ra.size === 0 && (ra = void 0), {
		splitDepth: Yi,
		special: ea,
		code: ta,
		data: na,
		libraries: ra
	}
}
StateInit.loadStateInit = loadStateInit;

function storeStateInit(ue) {
	return Yi => {
		ue.splitDepth !== null && ue.splitDepth !== void 0 ? (Yi.storeBit(!0), Yi.storeUint(ue.splitDepth, 5)) : Yi.storeBit(!1), ue.special !== null && ue.special !== void 0 ? (Yi.storeBit(!0), Yi.store((0, TickTock_1.storeTickTock)(ue.special))) : Yi.storeBit(!1), Yi.storeMaybeRef(ue.code), Yi.storeMaybeRef(ue.data), Yi.storeDict(ue.libraries)
	}
}
StateInit.storeStateInit = storeStateInit;
Object.defineProperty(contractAddress$1, "__esModule", {
	value: !0
});
contractAddress$1.contractAddress = void 0;
const Builder_1$8 = requireBuilder(),
	StateInit_1$3 = StateInit,
	Address_1$2 = Address$1;

function contractAddress(ue, Yi) {
	let ea = (0, Builder_1$8.beginCell)().store((0, StateInit_1$3.storeStateInit)(Yi)).endCell().hash();
	return new Address_1$2.Address(ue, ea)
}
contractAddress$1.contractAddress = contractAddress;
var tuple = {};
Object.defineProperty(tuple, "__esModule", {
	value: !0
});
tuple.parseTuple = tuple.serializeTuple = void 0;
const Builder_1$7 = requireBuilder(),
	INT64_MIN = BigInt("-9223372036854775808"),
	INT64_MAX = BigInt("9223372036854775807");

function serializeTupleItem(ue, Yi) {
	if (ue.type === "null") Yi.storeUint(0, 8);
	else if (ue.type === "int") ue.value <= INT64_MAX && ue.value >= INT64_MIN ? (Yi.storeUint(1, 8), Yi.storeInt(ue.value, 64)) : (Yi.storeUint(256, 15), Yi.storeInt(ue.value, 257));
	else if (ue.type === "nan") Yi.storeInt(767, 16);
	else if (ue.type === "cell") Yi.storeUint(3, 8), Yi.storeRef(ue.cell);
	else if (ue.type === "slice") Yi.storeUint(4, 8), Yi.storeUint(0, 10), Yi.storeUint(ue.cell.bits.length, 10), Yi.storeUint(0, 3), Yi.storeUint(ue.cell.refs.length, 3), Yi.storeRef(ue.cell);
	else if (ue.type === "builder") Yi.storeUint(5, 8), Yi.storeRef(ue.cell);
	else if (ue.type === "tuple") {
		let ea = null,
			ta = null;
		for (let na = 0; na < ue.items.length; na++) {
			let ra = ea;
			ea = ta, ta = ra, na > 1 && (ea = (0, Builder_1$7.beginCell)().storeRef(ta).storeRef(ea).endCell());
			let ia = (0, Builder_1$7.beginCell)();
			serializeTupleItem(ue.items[na], ia), ta = ia.endCell()
		}
		Yi.storeUint(7, 8), Yi.storeUint(ue.items.length, 16), ea && Yi.storeRef(ea), ta && Yi.storeRef(ta)
	} else throw Error("Invalid value")
}

function parseStackItem(ue) {
	let Yi = ue.loadUint(8);
	if (Yi === 0) return {
		type: "null"
	};
	if (Yi === 1) return {
		type: "int",
		value: ue.loadIntBig(64)
	};
	if (Yi === 2) return ue.loadUint(7) === 0 ? {
		type: "int",
		value: ue.loadIntBig(257)
	} : (ue.loadBit(), {
		type: "nan"
	});
	if (Yi === 3) return {
		type: "cell",
		cell: ue.loadRef()
	};
	if (Yi === 4) {
		let ea = ue.loadUint(10),
			ta = ue.loadUint(10),
			na = ue.loadUint(3),
			ra = ue.loadUint(3),
			ia = ue.loadRef().beginParse();
		ia.skip(ea);
		let aa = ia.loadBits(ta - ea),
			oa = (0, Builder_1$7.beginCell)().storeBits(aa);
		if (na < ra) {
			for (let la = 0; la < na; la++) ia.loadRef();
			for (let la = 0; la < ra - na; la++) oa.storeRef(ia.loadRef())
		}
		return {
			type: "slice",
			cell: oa.endCell()
		}
	} else {
		if (Yi === 5) return {
			type: "builder",
			cell: ue.loadRef()
		};
		if (Yi === 7) {
			let ea = ue.loadUint(16),
				ta = [];
			if (ea > 1) {
				let na = ue.loadRef().beginParse(),
					ra = ue.loadRef().beginParse();
				ta.unshift(parseStackItem(ra));
				for (let ia = 0; ia < ea - 2; ia++) {
					let aa = na;
					na = aa.loadRef().beginParse(), ra = aa.loadRef().beginParse(), ta.unshift(parseStackItem(ra))
				}
				ta.unshift(parseStackItem(na))
			} else ea === 1 && ta.push(parseStackItem(ue.loadRef().beginParse()));
			return {
				type: "tuple",
				items: ta
			}
		} else throw Error("Unsupported stack item")
	}
}

function serializeTupleTail(ue, Yi) {
	if (ue.length > 0) {
		let ea = (0, Builder_1$7.beginCell)();
		serializeTupleTail(ue.slice(0, ue.length - 1), ea), Yi.storeRef(ea.endCell()), serializeTupleItem(ue[ue.length - 1], Yi)
	}
}

function serializeTuple(ue) {
	let Yi = (0, Builder_1$7.beginCell)();
	Yi.storeUint(ue.length, 24);
	let ea = [...ue];
	return serializeTupleTail(ea, Yi), Yi.endCell()
}
tuple.serializeTuple = serializeTuple;

function parseTuple(ue) {
	let Yi = [],
		ea = ue.beginParse(),
		ta = ea.loadUint(24);
	for (let na = 0; na < ta; na++) {
		let ra = ea.loadRef();
		Yi.unshift(parseStackItem(ea)), ea = ra.beginParse()
	}
	return Yi
}
tuple.parseTuple = parseTuple;
var reader = {};
Object.defineProperty(reader, "__esModule", {
	value: !0
});
reader.TupleReader = void 0;
class TupleReader {
	constructor(Yi) {
		this.items = [...Yi]
	}
	get remaining() {
		return this.items.length
	}
	peek() {
		if (this.items.length === 0) throw Error("EOF");
		return this.items[0]
	}
	pop() {
		if (this.items.length === 0) throw Error("EOF");
		let Yi = this.items[0];
		return this.items.splice(0, 1), Yi
	}
	skip(Yi = 1) {
		for (let ea = 0; ea < Yi; ea++) this.pop();
		return this
	}
	readBigNumber() {
		let Yi = this.pop();
		if (Yi.type !== "int") throw Error("Not a number");
		return Yi.value
	}
	readBigNumberOpt() {
		let Yi = this.pop();
		if (Yi.type === "null") return null;
		if (Yi.type !== "int") throw Error("Not a number");
		return Yi.value
	}
	readNumber() {
		return Number(this.readBigNumber())
	}
	readNumberOpt() {
		let Yi = this.readBigNumberOpt();
		return Yi !== null ? Number(Yi) : null
	}
	readBoolean() {
		return this.readNumber() !== 0
	}
	readBooleanOpt() {
		let Yi = this.readNumberOpt();
		return Yi !== null ? Yi !== 0 : null
	}
	readAddress() {
		let Yi = this.readCell().beginParse().loadAddress();
		if (Yi !== null) return Yi;
		throw Error("Not an address")
	}
	readAddressOpt() {
		let Yi = this.readCellOpt();
		return Yi !== null ? Yi.beginParse().loadMaybeAddress() : null
	}
	readCell() {
		let Yi = this.pop();
		if (Yi.type !== "cell" && Yi.type !== "slice" && Yi.type !== "builder") throw Error("Not a cell: " + Yi.type);
		return Yi.cell
	}
	readCellOpt() {
		let Yi = this.pop();
		if (Yi.type === "null") return null;
		if (Yi.type !== "cell" && Yi.type !== "slice" && Yi.type !== "builder") throw Error("Not a cell");
		return Yi.cell
	}
	readTuple() {
		let Yi = this.pop();
		if (Yi.type !== "tuple") throw Error("Not a tuple");
		return new TupleReader(Yi.items)
	}
	readTupleOpt() {
		let Yi = this.pop();
		if (Yi.type === "null") return null;
		if (Yi.type !== "tuple") throw Error("Not a tuple");
		return new TupleReader(Yi.items)
	}
	static readLispList(Yi) {
		const ea = [];
		let ta = Yi;
		for (; ta !== null;) {
			var na = ta.pop();
			if (ta.items.length === 0 || ta.items[0].type !== "tuple" && ta.items[0].type !== "null") throw Error("Lisp list consists only from (any, tuple) elements and ends with null");
			ta = ta.readTupleOpt(), ea.push(na)
		}
		return ea
	}
	readLispListDirect() {
		return this.items.length === 1 && this.items[0].type === "null" ? [] : TupleReader.readLispList(this)
	}
	readLispList() {
		return TupleReader.readLispList(this.readTupleOpt())
	}
	readBuffer() {
		let Yi = this.readCell().beginParse();
		if (Yi.remainingRefs !== 0 || Yi.remainingBits % 8 !== 0) throw Error("Not a buffer");
		return Yi.loadBuffer(Yi.remainingBits / 8)
	}
	readBufferOpt() {
		if (this.peek().type === "null") return null;
		let ea = this.readCell().beginParse();
		if (ea.remainingRefs !== 0 || ea.remainingBits % 8 !== 0) throw Error("Not a buffer");
		return ea.loadBuffer(ea.remainingBits / 8)
	}
	readString() {
		return this.readCell().beginParse().loadStringTail()
	}
	readStringOpt() {
		return this.peek().type === "null" ? null : this.readCell().beginParse().loadStringTail()
	}
}
reader.TupleReader = TupleReader;
var builder = {};
Object.defineProperty(builder, "__esModule", {
	value: !0
});
builder.TupleBuilder = void 0;
const Builder_1$6 = requireBuilder(),
	Cell_1$2 = requireCell(),
	Slice_1 = requireSlice();
class TupleBuilder {
	constructor() {
		this._tuple = []
	}
	writeNumber(Yi) {
		Yi == null ? this._tuple.push({
			type: "null"
		}) : this._tuple.push({
			type: "int",
			value: BigInt(Yi)
		})
	}
	writeBoolean(Yi) {
		Yi == null ? this._tuple.push({
			type: "null"
		}) : this._tuple.push({
			type: "int",
			value: Yi ? -1n : 0n
		})
	}
	writeBuffer(Yi) {
		Yi == null ? this._tuple.push({
			type: "null"
		}) : this._tuple.push({
			type: "slice",
			cell: (0, Builder_1$6.beginCell)().storeBuffer(Yi).endCell()
		})
	}
	writeString(Yi) {
		Yi == null ? this._tuple.push({
			type: "null"
		}) : this._tuple.push({
			type: "slice",
			cell: (0, Builder_1$6.beginCell)().storeStringTail(Yi).endCell()
		})
	}
	writeCell(Yi) {
		Yi == null ? this._tuple.push({
			type: "null"
		}) : Yi instanceof Cell_1$2.Cell ? this._tuple.push({
			type: "cell",
			cell: Yi
		}) : Yi instanceof Slice_1.Slice && this._tuple.push({
			type: "cell",
			cell: Yi.asCell()
		})
	}
	writeSlice(Yi) {
		Yi == null ? this._tuple.push({
			type: "null"
		}) : Yi instanceof Cell_1$2.Cell ? this._tuple.push({
			type: "slice",
			cell: Yi
		}) : Yi instanceof Slice_1.Slice && this._tuple.push({
			type: "slice",
			cell: Yi.asCell()
		})
	}
	writeBuilder(Yi) {
		Yi == null ? this._tuple.push({
			type: "null"
		}) : Yi instanceof Cell_1$2.Cell ? this._tuple.push({
			type: "builder",
			cell: Yi
		}) : Yi instanceof Slice_1.Slice && this._tuple.push({
			type: "builder",
			cell: Yi.asCell()
		})
	}
	writeTuple(Yi) {
		Yi == null ? this._tuple.push({
			type: "null"
		}) : this._tuple.push({
			type: "tuple",
			items: Yi
		})
	}
	writeAddress(Yi) {
		Yi == null ? this._tuple.push({
			type: "null"
		}) : this._tuple.push({
			type: "slice",
			cell: (0, Builder_1$6.beginCell)().storeAddress(Yi).endCell()
		})
	}
	build() {
		return [...this._tuple]
	}
}
builder.TupleBuilder = TupleBuilder;
var _export = {},
	_helpers = {},
	convert = {};
Object.defineProperty(convert, "__esModule", {
	value: !0
});
convert.fromNano = convert.toNano = void 0;

function toNano(ue) {
	if (typeof ue == "bigint") return ue * 1000000000n;
	{
		if (typeof ue == "number") {
			if (!Number.isFinite(ue)) throw Error("Invalid number");
			if (Math.log10(ue) <= 6) ue = ue.toLocaleString("en", {
				minimumFractionDigits: 9,
				useGrouping: !1
			});
			else if (ue - Math.trunc(ue) === 0) ue = ue.toLocaleString("en", {
				maximumFractionDigits: 0,
				useGrouping: !1
			});
			else throw Error("Not enough precision for a number value. Use string value instead")
		}
		let Yi = !1;
		for (; ue.startsWith("-");) Yi = !Yi, ue = ue.slice(1);
		if (ue === ".") throw Error("Invalid number");
		let ea = ue.split(".");
		if (ea.length > 2) throw Error("Invalid number");
		let ta = ea[0],
			na = ea[1];
		if (ta || (ta = "0"), na || (na = "0"), na.length > 9) throw Error("Invalid number");
		for (; na.length < 9;) na += "0";
		let ra = BigInt(ta) * 1000000000n + BigInt(na);
		return Yi && (ra = -ra), ra
	}
}
convert.toNano = toNano;

function fromNano(ue) {
	let Yi = BigInt(ue),
		ea = !1;
	Yi < 0 && (ea = !0, Yi = -Yi);
	let na = (Yi % 1000000000n).toString();
	for (; na.length < 9;) na = "0" + na;
	na = na.match(/^([0-9]*[1-9]|0)(0*)/)[1];
	let aa = `${(Yi/1000000000n).toString()}${na==="0"?"":`.${na}`}`;
	return ea && (aa = "-" + aa), aa
}
convert.fromNano = fromNano;
Object.defineProperty(_helpers, "__esModule", {
	value: !0
});
_helpers.comment = _helpers.external = _helpers.internal = void 0;
const Address_1$1 = Address$1,
	Cell_1$1 = requireCell(),
	Builder_1$5 = requireBuilder(),
	convert_1 = convert;

function internal(ue) {
	let Yi = !0;
	ue.bounce !== null && ue.bounce !== void 0 && (Yi = ue.bounce);
	let ea;
	if (typeof ue.to == "string") ea = Address_1$1.Address.parse(ue.to);
	else if (Address_1$1.Address.isAddress(ue.to)) ea = ue.to;
	else throw new Error(`Invalid address ${ue.to}`);
	let ta;
	typeof ue.value == "string" ? ta = (0, convert_1.toNano)(ue.value) : ta = ue.value;
	let na = Cell_1$1.Cell.EMPTY;
	return typeof ue.body == "string" ? na = (0, Builder_1$5.beginCell)().storeUint(0, 32).storeStringTail(ue.body).endCell() : ue.body && (na = ue.body), {
		info: {
			type: "internal",
			dest: ea,
			value: {
				coins: ta
			},
			bounce: Yi,
			ihrDisabled: !0,
			bounced: !1,
			ihrFee: 0n,
			forwardFee: 0n,
			createdAt: 0,
			createdLt: 0n
		},
		init: ue.init ?? void 0,
		body: na
	}
}
_helpers.internal = internal;

function external$1(ue) {
	let Yi;
	if (typeof ue.to == "string") Yi = Address_1$1.Address.parse(ue.to);
	else if (Address_1$1.Address.isAddress(ue.to)) Yi = ue.to;
	else throw new Error(`Invalid address ${ue.to}`);
	return {
		info: {
			type: "external-in",
			dest: Yi,
			importFee: 0n
		},
		init: ue.init ?? void 0,
		body: ue.body || Cell_1$1.Cell.EMPTY
	}
}
_helpers.external = external$1;

function comment(ue) {
	return (0, Builder_1$5.beginCell)().storeUint(0, 32).storeStringTail(ue).endCell()
}
_helpers.comment = comment;
var Account = {},
	AccountStorage = {},
	AccountState = {};
Object.defineProperty(AccountState, "__esModule", {
	value: !0
});
AccountState.storeAccountState = AccountState.loadAccountState = void 0;
const StateInit_1$2 = StateInit;

function loadAccountState(ue) {
	return ue.loadBit() ? {
		type: "active",
		state: (0, StateInit_1$2.loadStateInit)(ue)
	} : ue.loadBit() ? {
		type: "frozen",
		stateHash: ue.loadUintBig(256)
	} : {
		type: "uninit"
	}
}
AccountState.loadAccountState = loadAccountState;

function storeAccountState(ue) {
	return Yi => {
		ue.type === "active" ? (Yi.storeBit(!0), Yi.store((0, StateInit_1$2.storeStateInit)(ue.state))) : ue.type === "frozen" ? (Yi.storeBit(!1), Yi.storeBit(!0), Yi.storeUint(ue.stateHash, 256)) : ue.type === "uninit" && (Yi.storeBit(!1), Yi.storeBit(!1))
	}
}
AccountState.storeAccountState = storeAccountState;
var CurrencyCollection = {};
Object.defineProperty(CurrencyCollection, "__esModule", {
	value: !0
});
CurrencyCollection.storeCurrencyCollection = CurrencyCollection.loadCurrencyCollection = void 0;
const Dictionary_1$1 = requireDictionary();

function loadCurrencyCollection(ue) {
	const Yi = ue.loadCoins(),
		ea = ue.loadDict(Dictionary_1$1.Dictionary.Keys.Uint(32), Dictionary_1$1.Dictionary.Values.BigVarUint(5));
	return ea.size === 0 ? {
		coins: Yi
	} : {
		other: ea,
		coins: Yi
	}
}
CurrencyCollection.loadCurrencyCollection = loadCurrencyCollection;

function storeCurrencyCollection(ue) {
	return Yi => {
		Yi.storeCoins(ue.coins), ue.other ? Yi.storeDict(ue.other) : Yi.storeBit(0)
	}
}
CurrencyCollection.storeCurrencyCollection = storeCurrencyCollection;
Object.defineProperty(AccountStorage, "__esModule", {
	value: !0
});
AccountStorage.storeAccountStorage = AccountStorage.loadAccountStorage = void 0;
const AccountState_1 = AccountState,
	CurrencyCollection_1$6 = CurrencyCollection;

function loadAccountStorage(ue) {
	return {
		lastTransLt: ue.loadUintBig(64),
		balance: (0, CurrencyCollection_1$6.loadCurrencyCollection)(ue),
		state: (0, AccountState_1.loadAccountState)(ue)
	}
}
AccountStorage.loadAccountStorage = loadAccountStorage;

function storeAccountStorage(ue) {
	return Yi => {
		Yi.storeUint(ue.lastTransLt, 64), Yi.store((0, CurrencyCollection_1$6.storeCurrencyCollection)(ue.balance)), Yi.store((0, AccountState_1.storeAccountState)(ue.state))
	}
}
AccountStorage.storeAccountStorage = storeAccountStorage;
var StorageInto = {},
	StorageUsed = {};
Object.defineProperty(StorageUsed, "__esModule", {
	value: !0
});
StorageUsed.storeStorageUsed = StorageUsed.loadStorageUsed = void 0;

function loadStorageUsed(ue) {
	return {
		cells: ue.loadVarUintBig(3),
		bits: ue.loadVarUintBig(3),
		publicCells: ue.loadVarUintBig(3)
	}
}
StorageUsed.loadStorageUsed = loadStorageUsed;

function storeStorageUsed(ue) {
	return Yi => {
		Yi.storeVarUint(ue.cells, 3), Yi.storeVarUint(ue.bits, 3), Yi.storeVarUint(ue.publicCells, 3)
	}
}
StorageUsed.storeStorageUsed = storeStorageUsed;
Object.defineProperty(StorageInto, "__esModule", {
	value: !0
});
StorageInto.storeStorageInfo = StorageInto.loadStorageInfo = void 0;
const StorageUsed_1 = StorageUsed;

function loadStorageInfo(ue) {
	return {
		used: (0, StorageUsed_1.loadStorageUsed)(ue),
		lastPaid: ue.loadUint(32),
		duePayment: ue.loadMaybeCoins()
	}
}
StorageInto.loadStorageInfo = loadStorageInfo;

function storeStorageInfo(ue) {
	return Yi => {
		Yi.store((0, StorageUsed_1.storeStorageUsed)(ue.used)), Yi.storeUint(ue.lastPaid, 32), Yi.storeMaybeCoins(ue.duePayment)
	}
}
StorageInto.storeStorageInfo = storeStorageInfo;
Object.defineProperty(Account, "__esModule", {
	value: !0
});
Account.storeAccount = Account.loadAccount = void 0;
const AccountStorage_1 = AccountStorage,
	StorageInto_1 = StorageInto;

function loadAccount(ue) {
	return {
		addr: ue.loadAddress(),
		storageStats: (0, StorageInto_1.loadStorageInfo)(ue),
		storage: (0, AccountStorage_1.loadAccountStorage)(ue)
	}
}
Account.loadAccount = loadAccount;

function storeAccount(ue) {
	return Yi => {
		Yi.storeAddress(ue.addr), Yi.store((0, StorageInto_1.storeStorageInfo)(ue.storageStats)), Yi.store((0, AccountStorage_1.storeAccountStorage)(ue.storage))
	}
}
Account.storeAccount = storeAccount;
var AccountStatus = {};
Object.defineProperty(AccountStatus, "__esModule", {
	value: !0
});
AccountStatus.storeAccountStatus = AccountStatus.loadAccountStatus = void 0;

function loadAccountStatus(ue) {
	const Yi = ue.loadUint(2);
	if (Yi === 0) return "uninitialized";
	if (Yi === 1) return "frozen";
	if (Yi === 2) return "active";
	if (Yi === 3) return "non-existing";
	throw Error("Invalid data")
}
AccountStatus.loadAccountStatus = loadAccountStatus;

function storeAccountStatus(ue) {
	return Yi => {
		if (ue === "uninitialized") Yi.storeUint(0, 2);
		else if (ue === "frozen") Yi.storeUint(1, 2);
		else if (ue === "active") Yi.storeUint(2, 2);
		else if (ue === "non-existing") Yi.storeUint(3, 2);
		else throw Error("Invalid data");
		return Yi
	}
}
AccountStatus.storeAccountStatus = storeAccountStatus;
var AccountStatusChange = {};
Object.defineProperty(AccountStatusChange, "__esModule", {
	value: !0
});
AccountStatusChange.storeAccountStatusChange = AccountStatusChange.loadAccountStatusChange = void 0;

function loadAccountStatusChange(ue) {
	return ue.loadBit() ? ue.loadBit() ? "deleted" : "frozen" : "unchanged"
}
AccountStatusChange.loadAccountStatusChange = loadAccountStatusChange;

function storeAccountStatusChange(ue) {
	return Yi => {
		if (ue == "unchanged") Yi.storeBit(0);
		else if (ue === "frozen") Yi.storeBit(1), Yi.storeBit(0);
		else if (ue === "deleted") Yi.storeBit(1), Yi.storeBit(1);
		else throw Error("Invalid account status change")
	}
}
AccountStatusChange.storeAccountStatusChange = storeAccountStatusChange;
var OutList = {},
	MessageRelaxed = {},
	CommonMessageInfoRelaxed = {};
Object.defineProperty(CommonMessageInfoRelaxed, "__esModule", {
	value: !0
});
CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = void 0;
const CurrencyCollection_1$5 = CurrencyCollection;

function loadCommonMessageInfoRelaxed(ue) {
	if (!ue.loadBit()) {
		const ra = ue.loadBit(),
			ia = ue.loadBit(),
			aa = ue.loadBit(),
			oa = ue.loadMaybeAddress(),
			la = ue.loadAddress(),
			sa = (0, CurrencyCollection_1$5.loadCurrencyCollection)(ue),
			ca = ue.loadCoins(),
			ua = ue.loadCoins(),
			da = ue.loadUintBig(64),
			ha = ue.loadUint(32);
		return {
			type: "internal",
			ihrDisabled: ra,
			bounce: ia,
			bounced: aa,
			src: oa,
			dest: la,
			value: sa,
			ihrFee: ca,
			forwardFee: ua,
			createdLt: da,
			createdAt: ha
		}
	}
	if (!ue.loadBit()) throw Error("External In message is not possible for CommonMessageInfoRelaxed");
	const Yi = ue.loadMaybeAddress(),
		ea = ue.loadMaybeExternalAddress(),
		ta = ue.loadUintBig(64),
		na = ue.loadUint(32);
	return {
		type: "external-out",
		src: Yi,
		dest: ea,
		createdLt: ta,
		createdAt: na
	}
}
CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = loadCommonMessageInfoRelaxed;

function storeCommonMessageInfoRelaxed(ue) {
	return Yi => {
		if (ue.type === "internal") Yi.storeBit(0), Yi.storeBit(ue.ihrDisabled), Yi.storeBit(ue.bounce), Yi.storeBit(ue.bounced), Yi.storeAddress(ue.src), Yi.storeAddress(ue.dest), Yi.store((0, CurrencyCollection_1$5.storeCurrencyCollection)(ue.value)), Yi.storeCoins(ue.ihrFee), Yi.storeCoins(ue.forwardFee), Yi.storeUint(ue.createdLt, 64), Yi.storeUint(ue.createdAt, 32);
		else if (ue.type === "external-out") Yi.storeBit(1), Yi.storeBit(1), Yi.storeAddress(ue.src), Yi.storeAddress(ue.dest), Yi.storeUint(ue.createdLt, 64), Yi.storeUint(ue.createdAt, 32);
		else throw new Error("Unknown CommonMessageInfo type")
	}
}
CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = storeCommonMessageInfoRelaxed;
Object.defineProperty(MessageRelaxed, "__esModule", {
	value: !0
});
MessageRelaxed.storeMessageRelaxed = MessageRelaxed.loadMessageRelaxed = void 0;
const Builder_1$4 = requireBuilder(),
	CommonMessageInfoRelaxed_1 = CommonMessageInfoRelaxed,
	StateInit_1$1 = StateInit;

function loadMessageRelaxed(ue) {
	const Yi = (0, CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed)(ue);
	let ea = null;
	ue.loadBit() && (ue.loadBit() ? ea = (0, StateInit_1$1.loadStateInit)(ue.loadRef().beginParse()) : ea = (0, StateInit_1$1.loadStateInit)(ue));
	const ta = ue.loadBit() ? ue.loadRef() : ue.asCell();
	return {
		info: Yi,
		init: ea,
		body: ta
	}
}
MessageRelaxed.loadMessageRelaxed = loadMessageRelaxed;

function storeMessageRelaxed(ue, Yi) {
	return ea => {
		if (ea.store((0, CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed)(ue.info)), ue.init) {
			ea.storeBit(!0);
			let na = (0, Builder_1$4.beginCell)().store((0, StateInit_1$1.storeStateInit)(ue.init)),
				ra = !1;
			Yi && Yi.forceRef ? ra = !0 : ea.availableBits - 2 >= na.bits ? ra = !1 : ra = !0, ra ? (ea.storeBit(!0), ea.storeRef(na)) : (ea.storeBit(!1), ea.storeBuilder(na))
		} else ea.storeBit(!1);
		let ta = !1;
		Yi && Yi.forceRef ? ta = !0 : ea.availableBits - 1 >= ue.body.bits.length && ea.refs + ue.body.refs.length <= 4 && !ue.body.isExotic ? ta = !1 : ta = !0, ta ? (ea.storeBit(!0), ea.storeRef(ue.body)) : (ea.storeBit(!1), ea.storeBuilder(ue.body.asBuilder()))
	}
}
MessageRelaxed.storeMessageRelaxed = storeMessageRelaxed;
var LibRef = {};
Object.defineProperty(LibRef, "__esModule", {
	value: !0
});
LibRef.storeLibRef = LibRef.loadLibRef = void 0;

function loadLibRef(ue) {
	return ue.loadUint(1) === 0 ? {
		type: "hash",
		libHash: ue.loadBuffer(32)
	} : {
		type: "ref",
		library: ue.loadRef()
	}
}
LibRef.loadLibRef = loadLibRef;

function storeLibRef(ue) {
	return Yi => {
		ue.type === "hash" ? (Yi.storeUint(0, 1), Yi.storeBuffer(ue.libHash)) : (Yi.storeUint(1, 1), Yi.storeRef(ue.library))
	}
}
LibRef.storeLibRef = storeLibRef;
Object.defineProperty(OutList, "__esModule", {
	value: !0
});
OutList.loadOutList = OutList.storeOutList = OutList.loadOutAction = OutList.storeOutAction = void 0;
const MessageRelaxed_1 = MessageRelaxed,
	Builder_1$3 = requireBuilder(),
	CurrencyCollection_1$4 = CurrencyCollection,
	LibRef_1 = LibRef;

function storeOutAction(ue) {
	switch (ue.type) {
		case "sendMsg":
			return storeOutActionSendMsg(ue);
		case "setCode":
			return storeOutActionSetCode(ue);
		case "reserve":
			return storeOutActionReserve(ue);
		case "changeLibrary":
			return storeOutActionChangeLibrary(ue);
		default:
			throw new Error(`Unknown action type ${ue.type}`)
	}
}
OutList.storeOutAction = storeOutAction;
const outActionSendMsgTag = 247711853;

function storeOutActionSendMsg(ue) {
	return Yi => {
		Yi.storeUint(outActionSendMsgTag, 32).storeUint(ue.mode, 8).storeRef((0, Builder_1$3.beginCell)().store((0, MessageRelaxed_1.storeMessageRelaxed)(ue.outMsg)).endCell())
	}
}
const outActionSetCodeTag = 2907562126;

function storeOutActionSetCode(ue) {
	return Yi => {
		Yi.storeUint(outActionSetCodeTag, 32).storeRef(ue.newCode)
	}
}
const outActionReserveTag = 921090057;

function storeOutActionReserve(ue) {
	return Yi => {
		Yi.storeUint(outActionReserveTag, 32).storeUint(ue.mode, 8).store((0, CurrencyCollection_1$4.storeCurrencyCollection)(ue.currency))
	}
}
const outActionChangeLibraryTag = 653925844;

function storeOutActionChangeLibrary(ue) {
	return Yi => {
		Yi.storeUint(outActionChangeLibraryTag, 32).storeUint(ue.mode, 7).store((0, LibRef_1.storeLibRef)(ue.libRef))
	}
}

function loadOutAction(ue) {
	const Yi = ue.loadUint(32);
	if (Yi === outActionSendMsgTag) {
		const ea = ue.loadUint(8),
			ta = (0, MessageRelaxed_1.loadMessageRelaxed)(ue.loadRef().beginParse());
		return {
			type: "sendMsg",
			mode: ea,
			outMsg: ta
		}
	}
	if (Yi === outActionSetCodeTag) return {
		type: "setCode",
		newCode: ue.loadRef()
	};
	if (Yi === outActionReserveTag) {
		const ea = ue.loadUint(8),
			ta = (0, CurrencyCollection_1$4.loadCurrencyCollection)(ue);
		return {
			type: "reserve",
			mode: ea,
			currency: ta
		}
	}
	if (Yi === outActionChangeLibraryTag) {
		const ea = ue.loadUint(7),
			ta = (0, LibRef_1.loadLibRef)(ue);
		return {
			type: "changeLibrary",
			mode: ea,
			libRef: ta
		}
	}
	throw new Error(`Unknown out action tag 0x${Yi.toString(16)}`)
}
OutList.loadOutAction = loadOutAction;

function storeOutList(ue) {
	const Yi = ue.reduce((ea, ta) => (0, Builder_1$3.beginCell)().storeRef(ea).store(storeOutAction(ta)).endCell(), (0, Builder_1$3.beginCell)().endCell());
	return ea => {
		ea.storeSlice(Yi.beginParse())
	}
}
OutList.storeOutList = storeOutList;

function loadOutList(ue) {
	const Yi = [];
	for (; ue.remainingRefs;) {
		const ea = ue.loadRef();
		Yi.push(loadOutAction(ue)), ue = ea.beginParse()
	}
	return Yi.reverse()
}
OutList.loadOutList = loadOutList;
var CommonMessageInfo = {};
Object.defineProperty(CommonMessageInfo, "__esModule", {
	value: !0
});
CommonMessageInfo.storeCommonMessageInfo = CommonMessageInfo.loadCommonMessageInfo = void 0;
const CurrencyCollection_1$3 = CurrencyCollection;

function loadCommonMessageInfo(ue) {
	if (!ue.loadBit()) {
		const ra = ue.loadBit(),
			ia = ue.loadBit(),
			aa = ue.loadBit(),
			oa = ue.loadAddress(),
			la = ue.loadAddress(),
			sa = (0, CurrencyCollection_1$3.loadCurrencyCollection)(ue),
			ca = ue.loadCoins(),
			ua = ue.loadCoins(),
			da = ue.loadUintBig(64),
			ha = ue.loadUint(32);
		return {
			type: "internal",
			ihrDisabled: ra,
			bounce: ia,
			bounced: aa,
			src: oa,
			dest: la,
			value: sa,
			ihrFee: ca,
			forwardFee: ua,
			createdLt: da,
			createdAt: ha
		}
	}
	if (!ue.loadBit()) {
		const ra = ue.loadMaybeExternalAddress(),
			ia = ue.loadAddress(),
			aa = ue.loadCoins();
		return {
			type: "external-in",
			src: ra,
			dest: ia,
			importFee: aa
		}
	}
	const Yi = ue.loadAddress(),
		ea = ue.loadMaybeExternalAddress(),
		ta = ue.loadUintBig(64),
		na = ue.loadUint(32);
	return {
		type: "external-out",
		src: Yi,
		dest: ea,
		createdLt: ta,
		createdAt: na
	}
}
CommonMessageInfo.loadCommonMessageInfo = loadCommonMessageInfo;

function storeCommonMessageInfo(ue) {
	return Yi => {
		if (ue.type === "internal") Yi.storeBit(0), Yi.storeBit(ue.ihrDisabled), Yi.storeBit(ue.bounce), Yi.storeBit(ue.bounced), Yi.storeAddress(ue.src), Yi.storeAddress(ue.dest), Yi.store((0, CurrencyCollection_1$3.storeCurrencyCollection)(ue.value)), Yi.storeCoins(ue.ihrFee), Yi.storeCoins(ue.forwardFee), Yi.storeUint(ue.createdLt, 64), Yi.storeUint(ue.createdAt, 32);
		else if (ue.type === "external-in") Yi.storeBit(1), Yi.storeBit(0), Yi.storeAddress(ue.src), Yi.storeAddress(ue.dest), Yi.storeCoins(ue.importFee);
		else if (ue.type === "external-out") Yi.storeBit(1), Yi.storeBit(1), Yi.storeAddress(ue.src), Yi.storeAddress(ue.dest), Yi.storeUint(ue.createdLt, 64), Yi.storeUint(ue.createdAt, 32);
		else throw new Error("Unknown CommonMessageInfo type")
	}
}
CommonMessageInfo.storeCommonMessageInfo = storeCommonMessageInfo;
var ComputeSkipReason = {};
Object.defineProperty(ComputeSkipReason, "__esModule", {
	value: !0
});
ComputeSkipReason.storeComputeSkipReason = ComputeSkipReason.loadComputeSkipReason = void 0;

function loadComputeSkipReason(ue) {
	let Yi = ue.loadUint(2);
	if (Yi === 0) return "no-state";
	if (Yi === 1) return "bad-state";
	if (Yi === 2) return "no-gas";
	throw new Error(`Unknown ComputeSkipReason: ${Yi}`)
}
ComputeSkipReason.loadComputeSkipReason = loadComputeSkipReason;

function storeComputeSkipReason(ue) {
	return Yi => {
		if (ue === "no-state") Yi.storeUint(0, 2);
		else if (ue === "bad-state") Yi.storeUint(1, 2);
		else if (ue === "no-gas") Yi.storeUint(2, 2);
		else throw new Error(`Unknown ComputeSkipReason: ${ue}`)
	}
}
ComputeSkipReason.storeComputeSkipReason = storeComputeSkipReason;
var DepthBalanceInfo = {};
Object.defineProperty(DepthBalanceInfo, "__esModule", {
	value: !0
});
DepthBalanceInfo.storeDepthBalanceInfo = DepthBalanceInfo.loadDepthBalanceInfo = void 0;
const CurrencyCollection_1$2 = CurrencyCollection;

function loadDepthBalanceInfo(ue) {
	return {
		splitDepth: ue.loadUint(5),
		balance: (0, CurrencyCollection_1$2.loadCurrencyCollection)(ue)
	}
}
DepthBalanceInfo.loadDepthBalanceInfo = loadDepthBalanceInfo;

function storeDepthBalanceInfo(ue) {
	return Yi => {
		Yi.storeUint(ue.splitDepth, 5), Yi.store((0, CurrencyCollection_1$2.storeCurrencyCollection)(ue.balance))
	}
}
DepthBalanceInfo.storeDepthBalanceInfo = storeDepthBalanceInfo;
var HashUpdate = {};
Object.defineProperty(HashUpdate, "__esModule", {
	value: !0
});
HashUpdate.storeHashUpdate = HashUpdate.loadHashUpdate = void 0;

function loadHashUpdate(ue) {
	if (ue.loadUint(8) !== 114) throw Error("Invalid data");
	const Yi = ue.loadBuffer(32),
		ea = ue.loadBuffer(32);
	return {
		oldHash: Yi,
		newHash: ea
	}
}
HashUpdate.loadHashUpdate = loadHashUpdate;

function storeHashUpdate(ue) {
	return Yi => {
		Yi.storeUint(114, 8), Yi.storeBuffer(ue.oldHash), Yi.storeBuffer(ue.newHash)
	}
}
HashUpdate.storeHashUpdate = storeHashUpdate;
var MasterchainStateExtra = {};
Object.defineProperty(MasterchainStateExtra, "__esModule", {
	value: !0
});
MasterchainStateExtra.loadMasterchainStateExtra = void 0;
const Dictionary_1 = requireDictionary(),
	CurrencyCollection_1$1 = CurrencyCollection;

function loadMasterchainStateExtra(ue) {
	if (ue.loadUint(16) !== 52262) throw Error("Invalid data");
	ue.loadBit() && ue.loadRef();
	let Yi = ue.loadUintBig(256),
		ea = Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.Int(32), Dictionary_1.Dictionary.Values.Cell(), ue);
	const ta = (0, CurrencyCollection_1$1.loadCurrencyCollection)(ue);
	return {
		config: ea,
		configAddress: Yi,
		globalBalance: ta
	}
}
MasterchainStateExtra.loadMasterchainStateExtra = loadMasterchainStateExtra;
var Message = {};
Object.defineProperty(Message, "__esModule", {
	value: !0
});
Message.MessageValue = Message.storeMessage = Message.loadMessage = void 0;
const Builder_1$2 = requireBuilder(),
	CommonMessageInfo_1 = CommonMessageInfo,
	StateInit_1 = StateInit;

function loadMessage$1(ue) {
	const Yi = (0, CommonMessageInfo_1.loadCommonMessageInfo)(ue);
	let ea = null;
	ue.loadBit() && (ue.loadBit() ? ea = (0, StateInit_1.loadStateInit)(ue.loadRef().beginParse()) : ea = (0, StateInit_1.loadStateInit)(ue));
	const ta = ue.loadBit() ? ue.loadRef() : ue.asCell();
	return {
		info: Yi,
		init: ea,
		body: ta
	}
}
Message.loadMessage = loadMessage$1;

function storeMessage(ue, Yi) {
	return ea => {
		if (ea.store((0, CommonMessageInfo_1.storeCommonMessageInfo)(ue.info)), ue.init) {
			ea.storeBit(!0);
			let na = (0, Builder_1$2.beginCell)().store((0, StateInit_1.storeStateInit)(ue.init)),
				ra = !1;
			Yi && Yi.forceRef ? ra = !0 : ra = ea.availableBits - 2 < na.bits + ue.body.bits.length, ra ? (ea.storeBit(!0), ea.storeRef(na)) : (ea.storeBit(!1), ea.storeBuilder(na))
		} else ea.storeBit(!1);
		let ta = !1;
		Yi && Yi.forceRef ? ta = !0 : ta = ea.availableBits - 1 < ue.body.bits.length || ea.refs + ue.body.refs.length > 4, ta ? (ea.storeBit(!0), ea.storeRef(ue.body)) : (ea.storeBit(!1), ea.storeBuilder(ue.body.asBuilder()))
	}
}
Message.storeMessage = storeMessage;
Message.MessageValue = {
	serialize(ue, Yi) {
		Yi.storeRef((0, Builder_1$2.beginCell)().store(storeMessage(ue)))
	},
	parse(ue) {
		return loadMessage$1(ue.loadRef().beginParse())
	}
};
var SendMode$1 = {};
Object.defineProperty(SendMode$1, "__esModule", {
	value: !0
});
SendMode$1.SendMode = void 0;
var SendMode;
(function(ue) {
	ue[ue.CARRY_ALL_REMAINING_BALANCE = 128] = "CARRY_ALL_REMAINING_BALANCE", ue[ue.CARRY_ALL_REMAINING_INCOMING_VALUE = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE", ue[ue.DESTROY_ACCOUNT_IF_ZERO = 32] = "DESTROY_ACCOUNT_IF_ZERO", ue[ue.PAY_GAS_SEPARATELY = 1] = "PAY_GAS_SEPARATELY", ue[ue.IGNORE_ERRORS = 2] = "IGNORE_ERRORS", ue[ue.NONE = 0] = "NONE"
})(SendMode || (SendMode$1.SendMode = SendMode = {}));
var ReserveMode$1 = {};
Object.defineProperty(ReserveMode$1, "__esModule", {
	value: !0
});
ReserveMode$1.ReserveMode = void 0;
var ReserveMode;
(function(ue) {
	ue[ue.THIS_AMOUNT = 0] = "THIS_AMOUNT", ue[ue.LEAVE_THIS_AMOUNT = 1] = "LEAVE_THIS_AMOUNT", ue[ue.AT_MOST_THIS_AMOUNT = 2] = "AT_MOST_THIS_AMOUNT", ue[ue.LEAVE_MAX_THIS_AMOUNT = 3] = "LEAVE_MAX_THIS_AMOUNT", ue[ue.BEFORE_BALANCE_PLUS_THIS_AMOUNT = 4] = "BEFORE_BALANCE_PLUS_THIS_AMOUNT", ue[ue.LEAVE_BBALANCE_PLUS_THIS_AMOUNT = 5] = "LEAVE_BBALANCE_PLUS_THIS_AMOUNT", ue[ue.BEFORE_BALANCE_MINUS_THIS_AMOUNT = 12] = "BEFORE_BALANCE_MINUS_THIS_AMOUNT", ue[ue.LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT = 13] = "LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT"
})(ReserveMode || (ReserveMode$1.ReserveMode = ReserveMode = {}));
var ShardAccount = {};
Object.defineProperty(ShardAccount, "__esModule", {
	value: !0
});
ShardAccount.storeShardAccount = ShardAccount.loadShardAccount = void 0;
const Builder_1$1 = requireBuilder(),
	Account_1 = Account;

function loadShardAccount(ue) {
	let Yi = ue.loadRef(),
		ea;
	if (!Yi.isExotic) {
		let ta = Yi.beginParse();
		ta.loadBit() && (ea = (0, Account_1.loadAccount)(ta))
	}
	return {
		account: ea,
		lastTransactionHash: ue.loadUintBig(256),
		lastTransactionLt: ue.loadUintBig(64)
	}
}
ShardAccount.loadShardAccount = loadShardAccount;

function storeShardAccount(ue) {
	return Yi => {
		ue.account ? Yi.storeRef((0, Builder_1$1.beginCell)().storeBit(!0).store((0, Account_1.storeAccount)(ue.account))) : Yi.storeRef((0, Builder_1$1.beginCell)().storeBit(!1)), Yi.storeUint(ue.lastTransactionHash, 256), Yi.storeUint(ue.lastTransactionLt, 64)
	}
}
ShardAccount.storeShardAccount = storeShardAccount;
var ShardAccounts = {};
(function(ue) {
	Object.defineProperty(ue, "__esModule", {
		value: !0
	}), ue.storeShardAccounts = ue.loadShardAccounts = ue.ShardAccountRefValue = void 0;
	const Yi = requireDictionary(),
		ea = DepthBalanceInfo,
		ta = ShardAccount;
	ue.ShardAccountRefValue = {
		parse: ia => {
			let aa = (0, ea.loadDepthBalanceInfo)(ia),
				oa = (0, ta.loadShardAccount)(ia);
			return {
				depthBalanceInfo: aa,
				shardAccount: oa
			}
		},
		serialize(ia, aa) {
			aa.store((0, ea.storeDepthBalanceInfo)(ia.depthBalanceInfo)), aa.store((0, ta.storeShardAccount)(ia.shardAccount))
		}
	};

	function na(ia) {
		return Yi.Dictionary.load(Yi.Dictionary.Keys.BigUint(256), ue.ShardAccountRefValue, ia)
	}
	ue.loadShardAccounts = na;

	function ra(ia) {
		return aa => {
			aa.storeDict(ia)
		}
	}
	ue.storeShardAccounts = ra
})(ShardAccounts);
var ShardIdent = {};
Object.defineProperty(ShardIdent, "__esModule", {
	value: !0
});
ShardIdent.storeShardIdent = ShardIdent.loadShardIdent = void 0;

function loadShardIdent(ue) {
	if (ue.loadUint(2) !== 0) throw Error("Invalid data");
	return {
		shardPrefixBits: ue.loadUint(6),
		workchainId: ue.loadInt(32),
		shardPrefix: ue.loadUintBig(64)
	}
}
ShardIdent.loadShardIdent = loadShardIdent;

function storeShardIdent(ue) {
	return Yi => {
		Yi.storeUint(0, 2), Yi.storeUint(ue.shardPrefixBits, 6), Yi.storeInt(ue.workchainId, 32), Yi.storeUint(ue.shardPrefix, 64)
	}
}
ShardIdent.storeShardIdent = storeShardIdent;
var ShardStateUnsplit = {};
Object.defineProperty(ShardStateUnsplit, "__esModule", {
	value: !0
});
ShardStateUnsplit.loadShardStateUnsplit = void 0;
const MasterchainStateExtra_1 = MasterchainStateExtra,
	ShardAccounts_1 = ShardAccounts,
	ShardIdent_1 = ShardIdent;

function loadShardStateUnsplit(ue) {
	if (ue.loadUint(32) !== 2418257890) throw Error("Invalid data");
	let Yi = ue.loadInt(32),
		ea = (0, ShardIdent_1.loadShardIdent)(ue),
		ta = ue.loadUint(32),
		na = ue.loadUint(32),
		ra = ue.loadUint(32),
		ia = ue.loadUintBig(64),
		aa = ue.loadUint(32);
	ue.loadRef();
	let oa = ue.loadBit(),
		la = ue.loadRef(),
		sa;
	la.isExotic || (sa = (0, ShardAccounts_1.loadShardAccounts)(la.beginParse())), ue.loadRef();
	let ca = ue.loadBit(),
		ua = null;
	if (ca) {
		let da = ue.loadRef();
		da.isExotic || (ua = (0, MasterchainStateExtra_1.loadMasterchainStateExtra)(da.beginParse()))
	}
	return {
		globalId: Yi,
		shardId: ea,
		seqno: ta,
		vertSeqNo: na,
		genUtime: ra,
		genLt: ia,
		minRefMcSeqno: aa,
		beforeSplit: oa,
		accounts: sa,
		extras: ua
	}
}
ShardStateUnsplit.loadShardStateUnsplit = loadShardStateUnsplit;
var SplitMergeInfo = {};
Object.defineProperty(SplitMergeInfo, "__esModule", {
	value: !0
});
SplitMergeInfo.storeSplitMergeInfo = SplitMergeInfo.loadSplitMergeInfo = void 0;

function loadSplitMergeInfo(ue) {
	let Yi = ue.loadUint(6),
		ea = ue.loadUint(6),
		ta = ue.loadUintBig(256),
		na = ue.loadUintBig(256);
	return {
		currentShardPrefixLength: Yi,
		accountSplitDepth: ea,
		thisAddress: ta,
		siblingAddress: na
	}
}
SplitMergeInfo.loadSplitMergeInfo = loadSplitMergeInfo;

function storeSplitMergeInfo(ue) {
	return Yi => {
		Yi.storeUint(ue.currentShardPrefixLength, 6), Yi.storeUint(ue.accountSplitDepth, 6), Yi.storeUint(ue.thisAddress, 256), Yi.storeUint(ue.siblingAddress, 256)
	}
}
SplitMergeInfo.storeSplitMergeInfo = storeSplitMergeInfo;
var StorageUsedShort = {};
Object.defineProperty(StorageUsedShort, "__esModule", {
	value: !0
});
StorageUsedShort.storeStorageUsedShort = StorageUsedShort.loadStorageUsedShort = void 0;

function loadStorageUsedShort(ue) {
	let Yi = ue.loadVarUintBig(3),
		ea = ue.loadVarUintBig(3);
	return {
		cells: Yi,
		bits: ea
	}
}
StorageUsedShort.loadStorageUsedShort = loadStorageUsedShort;

function storeStorageUsedShort(ue) {
	return Yi => {
		Yi.storeVarUint(ue.cells, 3), Yi.storeVarUint(ue.bits, 3)
	}
}
StorageUsedShort.storeStorageUsedShort = storeStorageUsedShort;
var Transaction$1 = {},
	TransactionDescription = {},
	TransactionActionPhase = {};
Object.defineProperty(TransactionActionPhase, "__esModule", {
	value: !0
});
TransactionActionPhase.storeTransactionActionPhase = TransactionActionPhase.loadTransactionActionPhase = void 0;
const AccountStatusChange_1$1 = AccountStatusChange,
	StorageUsedShort_1$1 = StorageUsedShort;

function loadTransactionActionPhase(ue) {
	let Yi = ue.loadBit(),
		ea = ue.loadBit(),
		ta = ue.loadBit(),
		na = (0, AccountStatusChange_1$1.loadAccountStatusChange)(ue),
		ra = ue.loadBit() ? ue.loadCoins() : void 0,
		ia = ue.loadBit() ? ue.loadCoins() : void 0,
		aa = ue.loadInt(32),
		oa = ue.loadBit() ? ue.loadInt(32) : void 0,
		la = ue.loadUint(16),
		sa = ue.loadUint(16),
		ca = ue.loadUint(16),
		ua = ue.loadUint(16),
		da = ue.loadUintBig(256),
		ha = (0, StorageUsedShort_1$1.loadStorageUsedShort)(ue);
	return {
		success: Yi,
		valid: ea,
		noFunds: ta,
		statusChange: na,
		totalFwdFees: ra,
		totalActionFees: ia,
		resultCode: aa,
		resultArg: oa,
		totalActions: la,
		specActions: sa,
		skippedActions: ca,
		messagesCreated: ua,
		actionListHash: da,
		totalMessageSize: ha
	}
}
TransactionActionPhase.loadTransactionActionPhase = loadTransactionActionPhase;

function storeTransactionActionPhase(ue) {
	return Yi => {
		Yi.storeBit(ue.success), Yi.storeBit(ue.valid), Yi.storeBit(ue.noFunds), Yi.store((0, AccountStatusChange_1$1.storeAccountStatusChange)(ue.statusChange)), Yi.storeMaybeCoins(ue.totalFwdFees), Yi.storeMaybeCoins(ue.totalActionFees), Yi.storeInt(ue.resultCode, 32), Yi.storeMaybeInt(ue.resultArg, 32), Yi.storeUint(ue.totalActions, 16), Yi.storeUint(ue.specActions, 16), Yi.storeUint(ue.skippedActions, 16), Yi.storeUint(ue.messagesCreated, 16), Yi.storeUint(ue.actionListHash, 256), Yi.store((0, StorageUsedShort_1$1.storeStorageUsedShort)(ue.totalMessageSize))
	}
}
TransactionActionPhase.storeTransactionActionPhase = storeTransactionActionPhase;
var TransactionBouncePhase = {};
Object.defineProperty(TransactionBouncePhase, "__esModule", {
	value: !0
});
TransactionBouncePhase.storeTransactionBouncePhase = TransactionBouncePhase.loadTransactionBouncePhase = void 0;
const StorageUsedShort_1 = StorageUsedShort;

function loadTransactionBouncePhase(ue) {
	if (ue.loadBit()) {
		let Yi = (0, StorageUsedShort_1.loadStorageUsedShort)(ue),
			ea = ue.loadCoins(),
			ta = ue.loadCoins();
		return {
			type: "ok",
			messageSize: Yi,
			messageFees: ea,
			forwardFees: ta
		}
	}
	if (ue.loadBit()) {
		let Yi = (0, StorageUsedShort_1.loadStorageUsedShort)(ue),
			ea = ue.loadCoins();
		return {
			type: "no-funds",
			messageSize: Yi,
			requiredForwardFees: ea
		}
	}
	return {
		type: "negative-funds"
	}
}
TransactionBouncePhase.loadTransactionBouncePhase = loadTransactionBouncePhase;

function storeTransactionBouncePhase(ue) {
	return Yi => {
		if (ue.type === "ok") Yi.storeBit(!0), Yi.store((0, StorageUsedShort_1.storeStorageUsedShort)(ue.messageSize)), Yi.storeCoins(ue.messageFees), Yi.storeCoins(ue.forwardFees);
		else if (ue.type === "negative-funds") Yi.storeBit(!1), Yi.storeBit(!1);
		else if (ue.type === "no-funds") Yi.storeBit(!1), Yi.storeBit(!0), Yi.store((0, StorageUsedShort_1.storeStorageUsedShort)(ue.messageSize)), Yi.storeCoins(ue.requiredForwardFees);
		else throw new Error("Invalid TransactionBouncePhase type")
	}
}
TransactionBouncePhase.storeTransactionBouncePhase = storeTransactionBouncePhase;
var TransactionComputePhase = {};
Object.defineProperty(TransactionComputePhase, "__esModule", {
	value: !0
});
TransactionComputePhase.storeTransactionComputePhase = TransactionComputePhase.loadTransactionComputePhase = void 0;
const Builder_1 = requireBuilder(),
	ComputeSkipReason_1 = ComputeSkipReason;

function loadTransactionComputePhase(ue) {
	if (!ue.loadBit()) return {
		type: "skipped",
		reason: (0, ComputeSkipReason_1.loadComputeSkipReason)(ue)
	};
	let Yi = ue.loadBit(),
		ea = ue.loadBit(),
		ta = ue.loadBit(),
		na = ue.loadCoins();
	const ra = ue.loadRef().beginParse();
	let ia = ra.loadVarUintBig(3),
		aa = ra.loadVarUintBig(3),
		oa = ra.loadBit() ? ra.loadVarUintBig(2) : void 0,
		la = ra.loadUint(8),
		sa = ra.loadInt(32),
		ca = ra.loadBit() ? ra.loadInt(32) : void 0,
		ua = ra.loadUint(32),
		da = ra.loadUintBig(256),
		ha = ra.loadUintBig(256);
	return {
		type: "vm",
		success: Yi,
		messageStateUsed: ea,
		accountActivated: ta,
		gasFees: na,
		gasUsed: ia,
		gasLimit: aa,
		gasCredit: oa,
		mode: la,
		exitCode: sa,
		exitArg: ca,
		vmSteps: ua,
		vmInitStateHash: da,
		vmFinalStateHash: ha
	}
}
TransactionComputePhase.loadTransactionComputePhase = loadTransactionComputePhase;

function storeTransactionComputePhase(ue) {
	return Yi => {
		if (ue.type === "skipped") {
			Yi.storeBit(0), Yi.store((0, ComputeSkipReason_1.storeComputeSkipReason)(ue.reason));
			return
		}
		Yi.storeBit(1), Yi.storeBit(ue.success), Yi.storeBit(ue.messageStateUsed), Yi.storeBit(ue.accountActivated), Yi.storeCoins(ue.gasFees), Yi.storeRef((0, Builder_1.beginCell)().storeVarUint(ue.gasUsed, 3).storeVarUint(ue.gasLimit, 3).store(ea => ue.gasCredit !== void 0 && ue.gasCredit !== null ? ea.storeBit(1).storeVarUint(ue.gasCredit, 2) : ea.storeBit(0)).storeUint(ue.mode, 8).storeInt(ue.exitCode, 32).store(ea => ue.exitArg !== void 0 && ue.exitArg !== null ? ea.storeBit(1).storeInt(ue.exitArg, 32) : ea.storeBit(0)).storeUint(ue.vmSteps, 32).storeUint(ue.vmInitStateHash, 256).storeUint(ue.vmFinalStateHash, 256).endCell())
	}
}
TransactionComputePhase.storeTransactionComputePhase = storeTransactionComputePhase;
var TransactionCreditPhase = {};
Object.defineProperty(TransactionCreditPhase, "__esModule", {
	value: !0
});
TransactionCreditPhase.storeTransactionCreditPhase = TransactionCreditPhase.loadTransactionCreditPhase = void 0;
const CurrencyCollection_1 = CurrencyCollection;

function loadTransactionCreditPhase(ue) {
	const Yi = ue.loadBit() ? ue.loadCoins() : void 0,
		ea = (0, CurrencyCollection_1.loadCurrencyCollection)(ue);
	return {
		dueFeesColelcted: Yi,
		credit: ea
	}
}
TransactionCreditPhase.loadTransactionCreditPhase = loadTransactionCreditPhase;

function storeTransactionCreditPhase(ue) {
	return Yi => {
		ue.dueFeesColelcted === null || ue.dueFeesColelcted === void 0 ? Yi.storeBit(!1) : (Yi.storeBit(!0), Yi.storeCoins(ue.dueFeesColelcted)), Yi.store((0, CurrencyCollection_1.storeCurrencyCollection)(ue.credit))
	}
}
TransactionCreditPhase.storeTransactionCreditPhase = storeTransactionCreditPhase;
var TransactionStoragePhase = {};
Object.defineProperty(TransactionStoragePhase, "__esModule", {
	value: !0
});
TransactionStoragePhase.storeTransactionsStoragePhase = TransactionStoragePhase.loadTransactionStoragePhase = void 0;
const AccountStatusChange_1 = AccountStatusChange;

function loadTransactionStoragePhase(ue) {
	const Yi = ue.loadCoins();
	let ea;
	ue.loadBit() && (ea = ue.loadCoins());
	const ta = (0, AccountStatusChange_1.loadAccountStatusChange)(ue);
	return {
		storageFeesCollected: Yi,
		storageFeesDue: ea,
		statusChange: ta
	}
}
TransactionStoragePhase.loadTransactionStoragePhase = loadTransactionStoragePhase;

function storeTransactionsStoragePhase(ue) {
	return Yi => {
		Yi.storeCoins(ue.storageFeesCollected), ue.storageFeesDue === null || ue.storageFeesDue === void 0 ? Yi.storeBit(!1) : (Yi.storeBit(!0), Yi.storeCoins(ue.storageFeesDue)), Yi.store((0, AccountStatusChange_1.storeAccountStatusChange)(ue.statusChange))
	}
}
TransactionStoragePhase.storeTransactionsStoragePhase = storeTransactionsStoragePhase;
var hasRequiredTransactionDescription;

function requireTransactionDescription() {
	if (hasRequiredTransactionDescription) return TransactionDescription;
	hasRequiredTransactionDescription = 1, Object.defineProperty(TransactionDescription, "__esModule", {
		value: !0
	}), TransactionDescription.storeTransactionDescription = TransactionDescription.loadTransactionDescription = void 0;
	const ue = requireBuilder(),
		Yi = SplitMergeInfo,
		ea = requireTransaction(),
		ta = TransactionActionPhase,
		na = TransactionBouncePhase,
		ra = TransactionComputePhase,
		ia = TransactionCreditPhase,
		aa = TransactionStoragePhase;

	function oa(sa) {
		let ca = sa.loadUint(4);
		if (ca === 0) {
			const ua = sa.loadBit();
			let da;
			sa.loadBit() && (da = (0, aa.loadTransactionStoragePhase)(sa));
			let ha;
			sa.loadBit() && (ha = (0, ia.loadTransactionCreditPhase)(sa));
			let pa = (0, ra.loadTransactionComputePhase)(sa),
				va;
			sa.loadBit() && (va = (0, ta.loadTransactionActionPhase)(sa.loadRef().beginParse()));
			let ba = sa.loadBit(),
				Ea;
			sa.loadBit() && (Ea = (0, na.loadTransactionBouncePhase)(sa));
			const Sa = sa.loadBit();
			return {
				type: "generic",
				creditFirst: ua,
				storagePhase: da,
				creditPhase: ha,
				computePhase: pa,
				actionPhase: va,
				bouncePhase: Ea,
				aborted: ba,
				destroyed: Sa
			}
		}
		if (ca === 1) return {
			type: "storage",
			storagePhase: (0, aa.loadTransactionStoragePhase)(sa)
		};
		if (ca === 2 || ca === 3) {
			const ua = ca === 3;
			let da = (0, aa.loadTransactionStoragePhase)(sa),
				ha = (0, ra.loadTransactionComputePhase)(sa),
				pa;
			sa.loadBit() && (pa = (0, ta.loadTransactionActionPhase)(sa.loadRef().beginParse()));
			const va = sa.loadBit(),
				ba = sa.loadBit();
			return {
				type: "tick-tock",
				isTock: ua,
				storagePhase: da,
				computePhase: ha,
				actionPhase: pa,
				aborted: va,
				destroyed: ba
			}
		}
		if (ca === 4) {
			let ua = (0, Yi.loadSplitMergeInfo)(sa),
				da;
			sa.loadBit() && (da = (0, aa.loadTransactionStoragePhase)(sa));
			let ha = (0, ra.loadTransactionComputePhase)(sa),
				pa;
			sa.loadBit() && (pa = (0, ta.loadTransactionActionPhase)(sa.loadRef().beginParse()));
			const va = sa.loadBit(),
				ba = sa.loadBit();
			return {
				type: "split-prepare",
				splitInfo: ua,
				storagePhase: da,
				computePhase: ha,
				actionPhase: pa,
				aborted: va,
				destroyed: ba
			}
		}
		if (ca === 5) {
			let ua = (0, Yi.loadSplitMergeInfo)(sa),
				da = (0, ea.loadTransaction)(sa.loadRef().beginParse());
			const ha = sa.loadBit();
			return {
				type: "split-install",
				splitInfo: ua,
				prepareTransaction: da,
				installed: ha
			}
		}
		throw Error(`Unsupported transaction description type ${ca}`)
	}
	TransactionDescription.loadTransactionDescription = oa;

	function la(sa) {
		return ca => {
			if (sa.type === "generic") ca.storeUint(0, 4), ca.storeBit(sa.creditFirst), sa.storagePhase ? (ca.storeBit(!0), ca.store((0, aa.storeTransactionsStoragePhase)(sa.storagePhase))) : ca.storeBit(!1), sa.creditPhase ? (ca.storeBit(!0), ca.store((0, ia.storeTransactionCreditPhase)(sa.creditPhase))) : ca.storeBit(!1), ca.store((0, ra.storeTransactionComputePhase)(sa.computePhase)), sa.actionPhase ? (ca.storeBit(!0), ca.storeRef((0, ue.beginCell)().store((0, ta.storeTransactionActionPhase)(sa.actionPhase)))) : ca.storeBit(!1), ca.storeBit(sa.aborted), sa.bouncePhase ? (ca.storeBit(!0), ca.store((0, na.storeTransactionBouncePhase)(sa.bouncePhase))) : ca.storeBit(!1), ca.storeBit(sa.destroyed);
			else if (sa.type === "storage") ca.storeUint(1, 4), ca.store((0, aa.storeTransactionsStoragePhase)(sa.storagePhase));
			else if (sa.type === "tick-tock") ca.storeUint(sa.isTock ? 3 : 2, 4), ca.store((0, aa.storeTransactionsStoragePhase)(sa.storagePhase)), ca.store((0, ra.storeTransactionComputePhase)(sa.computePhase)), sa.actionPhase ? (ca.storeBit(!0), ca.storeRef((0, ue.beginCell)().store((0, ta.storeTransactionActionPhase)(sa.actionPhase)))) : ca.storeBit(!1), ca.storeBit(sa.aborted), ca.storeBit(sa.destroyed);
			else if (sa.type === "split-prepare") ca.storeUint(4, 4), ca.store((0, Yi.storeSplitMergeInfo)(sa.splitInfo)), sa.storagePhase ? (ca.storeBit(!0), ca.store((0, aa.storeTransactionsStoragePhase)(sa.storagePhase))) : ca.storeBit(!1), ca.store((0, ra.storeTransactionComputePhase)(sa.computePhase)), sa.actionPhase ? (ca.storeBit(!0), ca.store((0, ta.storeTransactionActionPhase)(sa.actionPhase))) : ca.storeBit(!1), ca.storeBit(sa.aborted), ca.storeBit(sa.destroyed);
			else if (sa.type === "split-install") ca.storeUint(5, 4), ca.store((0, Yi.storeSplitMergeInfo)(sa.splitInfo)), ca.storeRef((0, ue.beginCell)().store((0, ea.storeTransaction)(sa.prepareTransaction))), ca.storeBit(sa.installed);
			else throw Error(`Unsupported transaction description type ${sa.type}`)
		}
	}
	return TransactionDescription.storeTransactionDescription = la, TransactionDescription
}
var hasRequiredTransaction;

function requireTransaction() {
	if (hasRequiredTransaction) return Transaction$1;
	hasRequiredTransaction = 1, Object.defineProperty(Transaction$1, "__esModule", {
		value: !0
	}), Transaction$1.storeTransaction = Transaction$1.loadTransaction = void 0;
	const ue = requireBuilder(),
		Yi = requireDictionary(),
		ea = AccountStatus,
		ta = CurrencyCollection,
		na = HashUpdate,
		ra = Message,
		ia = requireTransactionDescription();

	function aa(la) {
		let sa = la.asCell();
		if (la.loadUint(4) !== 7) throw Error("Invalid data");
		let ca = la.loadUintBig(256),
			ua = la.loadUintBig(64),
			da = la.loadUintBig(256),
			ha = la.loadUintBig(64),
			pa = la.loadUint(32),
			va = la.loadUint(15),
			ba = (0, ea.loadAccountStatus)(la),
			Ea = (0, ea.loadAccountStatus)(la),
			Ca = la.loadRef().beginParse(),
			ka = Ca.loadBit() ? (0, ra.loadMessage)(Ca.loadRef().beginParse()) : void 0,
			Pa = Ca.loadDict(Yi.Dictionary.Keys.Uint(15), ra.MessageValue);
		Ca.endParse();
		let ja = (0, ta.loadCurrencyCollection)(la),
			Za = (0, na.loadHashUpdate)(la.loadRef().beginParse()),
			Ga = (0, ia.loadTransactionDescription)(la.loadRef().beginParse());
		return {
			address: ca,
			lt: ua,
			prevTransactionHash: da,
			prevTransactionLt: ha,
			now: pa,
			outMessagesCount: va,
			oldStatus: ba,
			endStatus: Ea,
			inMessage: ka,
			outMessages: Pa,
			totalFees: ja,
			stateUpdate: Za,
			description: Ga,
			raw: sa,
			hash: () => sa.hash()
		}
	}
	Transaction$1.loadTransaction = aa;

	function oa(la) {
		return sa => {
			sa.storeUint(7, 4), sa.storeUint(la.address, 256), sa.storeUint(la.lt, 64), sa.storeUint(la.prevTransactionHash, 256), sa.storeUint(la.prevTransactionLt, 64), sa.storeUint(la.now, 32), sa.storeUint(la.outMessagesCount, 15), sa.store((0, ea.storeAccountStatus)(la.oldStatus)), sa.store((0, ea.storeAccountStatus)(la.endStatus));
			let ca = (0, ue.beginCell)();
			la.inMessage ? (ca.storeBit(!0), ca.storeRef((0, ue.beginCell)().store((0, ra.storeMessage)(la.inMessage)))) : ca.storeBit(!1), ca.storeDict(la.outMessages), sa.storeRef(ca), sa.store((0, ta.storeCurrencyCollection)(la.totalFees)), sa.storeRef((0, ue.beginCell)().store((0, na.storeHashUpdate)(la.stateUpdate))), sa.storeRef((0, ue.beginCell)().store((0, ia.storeTransactionDescription)(la.description)))
		}
	}
	return Transaction$1.storeTransaction = oa, Transaction$1
}(function(ue) {
	Object.defineProperty(ue, "__esModule", {
		value: !0
	}), ue.storeSplitMergeInfo = ue.loadSplitMergeInfo = ue.storeLibRef = ue.loadLibRef = ue.storeSimpleLibrary = ue.loadSimpleLibrary = ue.loadShardStateUnsplit = ue.storeShardIdent = ue.loadShardIdent = ue.storeShardAccounts = ue.loadShardAccounts = ue.ShardAccountRefValue = ue.storeShardAccount = ue.loadShardAccount = ue.ReserveMode = ue.SendMode = ue.storeMessageRelaxed = ue.loadMessageRelaxed = ue.storeMessage = ue.loadMessage = ue.loadMasterchainStateExtra = ue.storeHashUpdate = ue.loadHashUpdate = ue.storeDepthBalanceInfo = ue.loadDepthBalanceInfo = ue.storeCurrencyCollection = ue.loadCurrencyCollection = ue.storeComputeSkipReason = ue.loadComputeSkipReason = ue.storeCommonMessageInfoRelaxed = ue.loadCommonMessageInfoRelaxed = ue.storeCommonMessageInfo = ue.loadCommonMessageInfo = ue.storeOutList = ue.loadOutList = ue.storeOutAction = ue.loadOutAction = ue.storeAccountStorage = ue.loadAccountStorage = ue.storeAccountStatusChange = ue.loadAccountStatusChange = ue.storeAccountStatus = ue.loadAccountStatus = ue.storeAccountState = ue.loadAccountState = ue.storeAccount = ue.loadAccount = ue.comment = ue.external = ue.internal = void 0, ue.storeTransactionsStoragePhase = ue.loadTransactionStoragePhase = ue.storeTransactionDescription = ue.loadTransactionDescription = ue.storeTransactionCreditPhase = ue.loadTransactionCreditPhase = ue.storeTransactionComputePhase = ue.loadTransactionComputePhase = ue.storeTransactionBouncePhase = ue.loadTransactionBouncePhase = ue.storeTransactionActionPhase = ue.loadTransactionActionPhase = ue.storeTransaction = ue.loadTransaction = ue.storeTickTock = ue.loadTickTock = ue.storeStorageUsedShort = ue.loadStorageUsedShort = ue.storeStorageUsed = ue.loadStorageUsed = ue.storeStorageInfo = ue.loadStorageInfo = ue.storeStateInit = ue.loadStateInit = void 0;
	var Yi = _helpers;
	Object.defineProperty(ue, "internal", {
		enumerable: !0,
		get: function() {
			return Yi.internal
		}
	}), Object.defineProperty(ue, "external", {
		enumerable: !0,
		get: function() {
			return Yi.external
		}
	}), Object.defineProperty(ue, "comment", {
		enumerable: !0,
		get: function() {
			return Yi.comment
		}
	});
	var ea = Account;
	Object.defineProperty(ue, "loadAccount", {
		enumerable: !0,
		get: function() {
			return ea.loadAccount
		}
	}), Object.defineProperty(ue, "storeAccount", {
		enumerable: !0,
		get: function() {
			return ea.storeAccount
		}
	});
	var ta = AccountState;
	Object.defineProperty(ue, "loadAccountState", {
		enumerable: !0,
		get: function() {
			return ta.loadAccountState
		}
	}), Object.defineProperty(ue, "storeAccountState", {
		enumerable: !0,
		get: function() {
			return ta.storeAccountState
		}
	});
	var na = AccountStatus;
	Object.defineProperty(ue, "loadAccountStatus", {
		enumerable: !0,
		get: function() {
			return na.loadAccountStatus
		}
	}), Object.defineProperty(ue, "storeAccountStatus", {
		enumerable: !0,
		get: function() {
			return na.storeAccountStatus
		}
	});
	var ra = AccountStatusChange;
	Object.defineProperty(ue, "loadAccountStatusChange", {
		enumerable: !0,
		get: function() {
			return ra.loadAccountStatusChange
		}
	}), Object.defineProperty(ue, "storeAccountStatusChange", {
		enumerable: !0,
		get: function() {
			return ra.storeAccountStatusChange
		}
	});
	var ia = AccountStorage;
	Object.defineProperty(ue, "loadAccountStorage", {
		enumerable: !0,
		get: function() {
			return ia.loadAccountStorage
		}
	}), Object.defineProperty(ue, "storeAccountStorage", {
		enumerable: !0,
		get: function() {
			return ia.storeAccountStorage
		}
	});
	var aa = OutList;
	Object.defineProperty(ue, "loadOutAction", {
		enumerable: !0,
		get: function() {
			return aa.loadOutAction
		}
	}), Object.defineProperty(ue, "storeOutAction", {
		enumerable: !0,
		get: function() {
			return aa.storeOutAction
		}
	}), Object.defineProperty(ue, "loadOutList", {
		enumerable: !0,
		get: function() {
			return aa.loadOutList
		}
	}), Object.defineProperty(ue, "storeOutList", {
		enumerable: !0,
		get: function() {
			return aa.storeOutList
		}
	});
	var oa = CommonMessageInfo;
	Object.defineProperty(ue, "loadCommonMessageInfo", {
		enumerable: !0,
		get: function() {
			return oa.loadCommonMessageInfo
		}
	}), Object.defineProperty(ue, "storeCommonMessageInfo", {
		enumerable: !0,
		get: function() {
			return oa.storeCommonMessageInfo
		}
	});
	var la = CommonMessageInfoRelaxed;
	Object.defineProperty(ue, "loadCommonMessageInfoRelaxed", {
		enumerable: !0,
		get: function() {
			return la.loadCommonMessageInfoRelaxed
		}
	}), Object.defineProperty(ue, "storeCommonMessageInfoRelaxed", {
		enumerable: !0,
		get: function() {
			return la.storeCommonMessageInfoRelaxed
		}
	});
	var sa = ComputeSkipReason;
	Object.defineProperty(ue, "loadComputeSkipReason", {
		enumerable: !0,
		get: function() {
			return sa.loadComputeSkipReason
		}
	}), Object.defineProperty(ue, "storeComputeSkipReason", {
		enumerable: !0,
		get: function() {
			return sa.storeComputeSkipReason
		}
	});
	var ca = CurrencyCollection;
	Object.defineProperty(ue, "loadCurrencyCollection", {
		enumerable: !0,
		get: function() {
			return ca.loadCurrencyCollection
		}
	}), Object.defineProperty(ue, "storeCurrencyCollection", {
		enumerable: !0,
		get: function() {
			return ca.storeCurrencyCollection
		}
	});
	var ua = DepthBalanceInfo;
	Object.defineProperty(ue, "loadDepthBalanceInfo", {
		enumerable: !0,
		get: function() {
			return ua.loadDepthBalanceInfo
		}
	}), Object.defineProperty(ue, "storeDepthBalanceInfo", {
		enumerable: !0,
		get: function() {
			return ua.storeDepthBalanceInfo
		}
	});
	var da = HashUpdate;
	Object.defineProperty(ue, "loadHashUpdate", {
		enumerable: !0,
		get: function() {
			return da.loadHashUpdate
		}
	}), Object.defineProperty(ue, "storeHashUpdate", {
		enumerable: !0,
		get: function() {
			return da.storeHashUpdate
		}
	});
	var ha = MasterchainStateExtra;
	Object.defineProperty(ue, "loadMasterchainStateExtra", {
		enumerable: !0,
		get: function() {
			return ha.loadMasterchainStateExtra
		}
	});
	var pa = Message;
	Object.defineProperty(ue, "loadMessage", {
		enumerable: !0,
		get: function() {
			return pa.loadMessage
		}
	}), Object.defineProperty(ue, "storeMessage", {
		enumerable: !0,
		get: function() {
			return pa.storeMessage
		}
	});
	var va = MessageRelaxed;
	Object.defineProperty(ue, "loadMessageRelaxed", {
		enumerable: !0,
		get: function() {
			return va.loadMessageRelaxed
		}
	}), Object.defineProperty(ue, "storeMessageRelaxed", {
		enumerable: !0,
		get: function() {
			return va.storeMessageRelaxed
		}
	});
	var ba = SendMode$1;
	Object.defineProperty(ue, "SendMode", {
		enumerable: !0,
		get: function() {
			return ba.SendMode
		}
	});
	var Ea = ReserveMode$1;
	Object.defineProperty(ue, "ReserveMode", {
		enumerable: !0,
		get: function() {
			return Ea.ReserveMode
		}
	});
	var Sa = ShardAccount;
	Object.defineProperty(ue, "loadShardAccount", {
		enumerable: !0,
		get: function() {
			return Sa.loadShardAccount
		}
	}), Object.defineProperty(ue, "storeShardAccount", {
		enumerable: !0,
		get: function() {
			return Sa.storeShardAccount
		}
	});
	var Ca = ShardAccounts;
	Object.defineProperty(ue, "ShardAccountRefValue", {
		enumerable: !0,
		get: function() {
			return Ca.ShardAccountRefValue
		}
	}), Object.defineProperty(ue, "loadShardAccounts", {
		enumerable: !0,
		get: function() {
			return Ca.loadShardAccounts
		}
	}), Object.defineProperty(ue, "storeShardAccounts", {
		enumerable: !0,
		get: function() {
			return Ca.storeShardAccounts
		}
	});
	var ka = ShardIdent;
	Object.defineProperty(ue, "loadShardIdent", {
		enumerable: !0,
		get: function() {
			return ka.loadShardIdent
		}
	}), Object.defineProperty(ue, "storeShardIdent", {
		enumerable: !0,
		get: function() {
			return ka.storeShardIdent
		}
	});
	var Pa = ShardStateUnsplit;
	Object.defineProperty(ue, "loadShardStateUnsplit", {
		enumerable: !0,
		get: function() {
			return Pa.loadShardStateUnsplit
		}
	});
	var ja = SimpleLibrary;
	Object.defineProperty(ue, "loadSimpleLibrary", {
		enumerable: !0,
		get: function() {
			return ja.loadSimpleLibrary
		}
	}), Object.defineProperty(ue, "storeSimpleLibrary", {
		enumerable: !0,
		get: function() {
			return ja.storeSimpleLibrary
		}
	});
	var Za = LibRef;
	Object.defineProperty(ue, "loadLibRef", {
		enumerable: !0,
		get: function() {
			return Za.loadLibRef
		}
	}), Object.defineProperty(ue, "storeLibRef", {
		enumerable: !0,
		get: function() {
			return Za.storeLibRef
		}
	});
	var Ga = SplitMergeInfo;
	Object.defineProperty(ue, "loadSplitMergeInfo", {
		enumerable: !0,
		get: function() {
			return Ga.loadSplitMergeInfo
		}
	}), Object.defineProperty(ue, "storeSplitMergeInfo", {
		enumerable: !0,
		get: function() {
			return Ga.storeSplitMergeInfo
		}
	});
	var Ja = StateInit;
	Object.defineProperty(ue, "loadStateInit", {
		enumerable: !0,
		get: function() {
			return Ja.loadStateInit
		}
	}), Object.defineProperty(ue, "storeStateInit", {
		enumerable: !0,
		get: function() {
			return Ja.storeStateInit
		}
	});
	var Ua = StorageInto;
	Object.defineProperty(ue, "loadStorageInfo", {
		enumerable: !0,
		get: function() {
			return Ua.loadStorageInfo
		}
	}), Object.defineProperty(ue, "storeStorageInfo", {
		enumerable: !0,
		get: function() {
			return Ua.storeStorageInfo
		}
	});
	var xa = StorageUsed;
	Object.defineProperty(ue, "loadStorageUsed", {
		enumerable: !0,
		get: function() {
			return xa.loadStorageUsed
		}
	}), Object.defineProperty(ue, "storeStorageUsed", {
		enumerable: !0,
		get: function() {
			return xa.storeStorageUsed
		}
	});
	var ma = StorageUsedShort;
	Object.defineProperty(ue, "loadStorageUsedShort", {
		enumerable: !0,
		get: function() {
			return ma.loadStorageUsedShort
		}
	}), Object.defineProperty(ue, "storeStorageUsedShort", {
		enumerable: !0,
		get: function() {
			return ma.storeStorageUsedShort
		}
	});
	var fa = TickTock;
	Object.defineProperty(ue, "loadTickTock", {
		enumerable: !0,
		get: function() {
			return fa.loadTickTock
		}
	}), Object.defineProperty(ue, "storeTickTock", {
		enumerable: !0,
		get: function() {
			return fa.storeTickTock
		}
	});
	var ga = requireTransaction();
	Object.defineProperty(ue, "loadTransaction", {
		enumerable: !0,
		get: function() {
			return ga.loadTransaction
		}
	}), Object.defineProperty(ue, "storeTransaction", {
		enumerable: !0,
		get: function() {
			return ga.storeTransaction
		}
	});
	var wa = TransactionActionPhase;
	Object.defineProperty(ue, "loadTransactionActionPhase", {
		enumerable: !0,
		get: function() {
			return wa.loadTransactionActionPhase
		}
	}), Object.defineProperty(ue, "storeTransactionActionPhase", {
		enumerable: !0,
		get: function() {
			return wa.storeTransactionActionPhase
		}
	});
	var Ma = TransactionBouncePhase;
	Object.defineProperty(ue, "loadTransactionBouncePhase", {
		enumerable: !0,
		get: function() {
			return Ma.loadTransactionBouncePhase
		}
	}), Object.defineProperty(ue, "storeTransactionBouncePhase", {
		enumerable: !0,
		get: function() {
			return Ma.storeTransactionBouncePhase
		}
	});
	var Aa = TransactionComputePhase;
	Object.defineProperty(ue, "loadTransactionComputePhase", {
		enumerable: !0,
		get: function() {
			return Aa.loadTransactionComputePhase
		}
	}), Object.defineProperty(ue, "storeTransactionComputePhase", {
		enumerable: !0,
		get: function() {
			return Aa.storeTransactionComputePhase
		}
	});
	var Ra = TransactionCreditPhase;
	Object.defineProperty(ue, "loadTransactionCreditPhase", {
		enumerable: !0,
		get: function() {
			return Ra.loadTransactionCreditPhase
		}
	}), Object.defineProperty(ue, "storeTransactionCreditPhase", {
		enumerable: !0,
		get: function() {
			return Ra.storeTransactionCreditPhase
		}
	});
	var Ta = requireTransactionDescription();
	Object.defineProperty(ue, "loadTransactionDescription", {
		enumerable: !0,
		get: function() {
			return Ta.loadTransactionDescription
		}
	}), Object.defineProperty(ue, "storeTransactionDescription", {
		enumerable: !0,
		get: function() {
			return Ta.storeTransactionDescription
		}
	});
	var La = TransactionStoragePhase;
	Object.defineProperty(ue, "loadTransactionStoragePhase", {
		enumerable: !0,
		get: function() {
			return La.loadTransactionStoragePhase
		}
	}), Object.defineProperty(ue, "storeTransactionsStoragePhase", {
		enumerable: !0,
		get: function() {
			return La.storeTransactionsStoragePhase
		}
	})
})(_export);
var openContract$1 = {};
Object.defineProperty(openContract$1, "__esModule", {
	value: !0
});
openContract$1.openContract = void 0;
const Address_1 = Address$1,
	Cell_1 = requireCell();

function openContract(ue, Yi) {
	let ea, ta = null;
	if (!Address_1.Address.isAddress(ue.address)) throw Error("Invalid address");
	if (ea = ue.address, ue.init) {
		if (!(ue.init.code instanceof Cell_1.Cell)) throw Error("Invalid init.code");
		if (!(ue.init.data instanceof Cell_1.Cell)) throw Error("Invalid init.data");
		ta = ue.init
	}
	let na = Yi({
		address: ea,
		init: ta
	});
	return new Proxy(ue, {
		get(ra, ia) {
			const aa = ra[ia];
			return typeof ia == "string" && (ia.startsWith("get") || ia.startsWith("send")) && typeof aa == "function" ? (...oa) => aa.apply(ra, [na, ...oa]) : aa
		}
	})
}
openContract$1.openContract = openContract;
var ComputeError$1 = {};
Object.defineProperty(ComputeError$1, "__esModule", {
	value: !0
});
ComputeError$1.ComputeError = void 0;
class ComputeError extends Error {
	constructor(Yi, ea, ta) {
		super(Yi), this.exitCode = ea, this.debugLogs = ta && ta.debugLogs ? ta.debugLogs : null, this.logs = ta && ta.logs ? ta.logs : null, Object.setPrototypeOf(this, ComputeError.prototype)
	}
}
ComputeError$1.ComputeError = ComputeError;
var getMethodId$1 = {};
Object.defineProperty(getMethodId$1, "__esModule", {
	value: !0
});
getMethodId$1.getMethodId = void 0;
const TABLE = new Int16Array([0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920]);

function crc16(ue) {
	ue instanceof Buffer || (ue = Buffer.from(ue));
	let Yi = 0;
	for (let ea = 0; ea < ue.length; ea++) {
		const ta = ue[ea];
		Yi = (TABLE[(Yi >> 8 ^ ta) & 255] ^ Yi << 8) & 65535
	}
	return Yi
}

function getMethodId(ue) {
	return crc16(ue) & 65535 | 65536
}
getMethodId$1.getMethodId = getMethodId;
var safeSign$1 = {};
Object.defineProperty(safeSign$1, "__esModule", {
	value: !0
});
safeSign$1.safeSignVerify = safeSign$1.safeSign = void 0;
const crypto_1 = requireDist(),
	MIN_SEED_LENGTH = 8,
	MAX_SEED_LENGTH = 64;

function createSafeSignHash(ue, Yi) {
	let ea = Buffer.from(Yi);
	if (ea.length > MAX_SEED_LENGTH) throw Error("Seed can	 be longer than 64 bytes");
	if (ea.length < MIN_SEED_LENGTH) throw Error("Seed must be at least 8 bytes");
	return (0, crypto_1.sha256_sync)(Buffer.concat([Buffer.from([255, 255]), ea, ue.hash()]))
}

function safeSign(ue, Yi, ea = "ton-safe-sign-magic") {
	return (0, crypto_1.sign)(createSafeSignHash(ue, ea), Yi)
}
safeSign$1.safeSign = safeSign;

function safeSignVerify(ue, Yi, ea, ta = "ton-safe-sign-magic") {
	return (0, crypto_1.signVerify)(createSafeSignHash(ue, ta), Yi, ea)
}
safeSign$1.safeSignVerify = safeSignVerify;
(function(ue) {
	var Yi = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(ga, wa, Ma, Aa) {
			Aa === void 0 && (Aa = Ma);
			var Ra = Object.getOwnPropertyDescriptor(wa, Ma);
			(!Ra || ("get" in Ra ? !wa.__esModule : Ra.writable || Ra.configurable)) && (Ra = {
				enumerable: !0,
				get: function() {
					return wa[Ma]
				}
			}), Object.defineProperty(ga, Aa, Ra)
		} : function(ga, wa, Ma, Aa) {
			Aa === void 0 && (Aa = Ma), ga[Aa] = wa[Ma]
		}),
		ea = commonjsGlobal && commonjsGlobal.__exportStar || function(ga, wa) {
			for (var Ma in ga) Ma !== "default" && !Object.prototype.hasOwnProperty.call(wa, Ma) && Yi(wa, ga, Ma)
		};
	Object.defineProperty(ue, "__esModule", {
		value: !0
	}), ue.safeSignVerify = ue.safeSign = ue.getMethodId = ue.base32Encode = ue.base32Decode = ue.crc32c = ue.crc16 = ue.fromNano = ue.toNano = ue.ComputeError = ue.openContract = ue.TupleBuilder = ue.TupleReader = ue.serializeTuple = ue.parseTuple = ue.generateMerkleUpdate = ue.generateMerkleProofDirect = ue.generateMerkleProof = ue.exoticPruned = ue.exoticMerkleUpdate = ue.convertToMerkleProof = ue.exoticMerkleProof = ue.Dictionary = ue.Cell = ue.CellType = ue.Slice = ue.beginCell = ue.Builder = ue.BitBuilder = ue.BitReader = ue.BitString = ue.contractAddress = ue.ADNLAddress = ue.ExternalAddress = ue.address = ue.Address = void 0;
	var ta = Address$1;
	Object.defineProperty(ue, "Address", {
		enumerable: !0,
		get: function() {
			return ta.Address
		}
	}), Object.defineProperty(ue, "address", {
		enumerable: !0,
		get: function() {
			return ta.address
		}
	});
	var na = ExternalAddress$1;
	Object.defineProperty(ue, "ExternalAddress", {
		enumerable: !0,
		get: function() {
			return na.ExternalAddress
		}
	});
	var ra = ADNLAddress$1;
	Object.defineProperty(ue, "ADNLAddress", {
		enumerable: !0,
		get: function() {
			return ra.ADNLAddress
		}
	});
	var ia = contractAddress$1;
	Object.defineProperty(ue, "contractAddress", {
		enumerable: !0,
		get: function() {
			return ia.contractAddress
		}
	});
	var aa = requireBitString();
	Object.defineProperty(ue, "BitString", {
		enumerable: !0,
		get: function() {
			return aa.BitString
		}
	});
	var oa = BitReader$1;
	Object.defineProperty(ue, "BitReader", {
		enumerable: !0,
		get: function() {
			return oa.BitReader
		}
	});
	var la = requireBitBuilder();
	Object.defineProperty(ue, "BitBuilder", {
		enumerable: !0,
		get: function() {
			return la.BitBuilder
		}
	});
	var sa = requireBuilder();
	Object.defineProperty(ue, "Builder", {
		enumerable: !0,
		get: function() {
			return sa.Builder
		}
	}), Object.defineProperty(ue, "beginCell", {
		enumerable: !0,
		get: function() {
			return sa.beginCell
		}
	});
	var ca = requireSlice();
	Object.defineProperty(ue, "Slice", {
		enumerable: !0,
		get: function() {
			return ca.Slice
		}
	});
	var ua = CellType$1;
	Object.defineProperty(ue, "CellType", {
		enumerable: !0,
		get: function() {
			return ua.CellType
		}
	});
	var da = requireCell();
	Object.defineProperty(ue, "Cell", {
		enumerable: !0,
		get: function() {
			return da.Cell
		}
	});
	var ha = requireDictionary();
	Object.defineProperty(ue, "Dictionary", {
		enumerable: !0,
		get: function() {
			return ha.Dictionary
		}
	});
	var pa = requireExoticMerkleProof();
	Object.defineProperty(ue, "exoticMerkleProof", {
		enumerable: !0,
		get: function() {
			return pa.exoticMerkleProof
		}
	}), Object.defineProperty(ue, "convertToMerkleProof", {
		enumerable: !0,
		get: function() {
			return pa.convertToMerkleProof
		}
	});
	var va = exoticMerkleUpdate$1;
	Object.defineProperty(ue, "exoticMerkleUpdate", {
		enumerable: !0,
		get: function() {
			return va.exoticMerkleUpdate
		}
	});
	var ba = exoticPruned$1;
	Object.defineProperty(ue, "exoticPruned", {
		enumerable: !0,
		get: function() {
			return ba.exoticPruned
		}
	});
	var Ea = requireGenerateMerkleProof();
	Object.defineProperty(ue, "generateMerkleProof", {
		enumerable: !0,
		get: function() {
			return Ea.generateMerkleProof
		}
	}), Object.defineProperty(ue, "generateMerkleProofDirect", {
		enumerable: !0,
		get: function() {
			return Ea.generateMerkleProofDirect
		}
	});
	var Sa = requireGenerateMerkleUpdate();
	Object.defineProperty(ue, "generateMerkleUpdate", {
		enumerable: !0,
		get: function() {
			return Sa.generateMerkleUpdate
		}
	});
	var Ca = tuple;
	Object.defineProperty(ue, "parseTuple", {
		enumerable: !0,
		get: function() {
			return Ca.parseTuple
		}
	}), Object.defineProperty(ue, "serializeTuple", {
		enumerable: !0,
		get: function() {
			return Ca.serializeTuple
		}
	});
	var ka = reader;
	Object.defineProperty(ue, "TupleReader", {
		enumerable: !0,
		get: function() {
			return ka.TupleReader
		}
	});
	var Pa = builder;
	Object.defineProperty(ue, "TupleBuilder", {
		enumerable: !0,
		get: function() {
			return Pa.TupleBuilder
		}
	}), ea(_export, ue);
	var ja = openContract$1;
	Object.defineProperty(ue, "openContract", {
		enumerable: !0,
		get: function() {
			return ja.openContract
		}
	});
	var Za = ComputeError$1;
	Object.defineProperty(ue, "ComputeError", {
		enumerable: !0,
		get: function() {
			return Za.ComputeError
		}
	});
	var Ga = convert;
	Object.defineProperty(ue, "toNano", {
		enumerable: !0,
		get: function() {
			return Ga.toNano
		}
	}), Object.defineProperty(ue, "fromNano", {
		enumerable: !0,
		get: function() {
			return Ga.fromNano
		}
	});
	var Ja = crc16$2;
	Object.defineProperty(ue, "crc16", {
		enumerable: !0,
		get: function() {
			return Ja.crc16
		}
	});
	var Ua = crc32c$1;
	Object.defineProperty(ue, "crc32c", {
		enumerable: !0,
		get: function() {
			return Ua.crc32c
		}
	});
	var xa = base32;
	Object.defineProperty(ue, "base32Decode", {
		enumerable: !0,
		get: function() {
			return xa.base32Decode
		}
	}), Object.defineProperty(ue, "base32Encode", {
		enumerable: !0,
		get: function() {
			return xa.base32Encode
		}
	});
	var ma = getMethodId$1;
	Object.defineProperty(ue, "getMethodId", {
		enumerable: !0,
		get: function() {
			return ma.getMethodId
		}
	});
	var fa = safeSign$1;
	Object.defineProperty(ue, "safeSign", {
		enumerable: !0,
		get: function() {
			return fa.safeSign
		}
	}), Object.defineProperty(ue, "safeSignVerify", {
		enumerable: !0,
		get: function() {
			return fa.safeSignVerify
		}
	})
})(dist$1);
var TransformationType;
(function(ue) {
	ue[ue.PLAIN_TO_CLASS = 0] = "PLAIN_TO_CLASS", ue[ue.CLASS_TO_PLAIN = 1] = "CLASS_TO_PLAIN", ue[ue.CLASS_TO_CLASS = 2] = "CLASS_TO_CLASS"
})(TransformationType || (TransformationType = {}));
var MetadataStorage$1 = function() {
		function ue() {
			this._typeMetadatas = new Map, this._transformMetadatas = new Map, this._exposeMetadatas = new Map, this._excludeMetadatas = new Map, this._ancestorsMap = new Map
		}
		return ue.prototype.addTypeMetadata = function(Yi) {
			this._typeMetadatas.has(Yi.target) || this._typeMetadatas.set(Yi.target, new Map), this._typeMetadatas.get(Yi.target).set(Yi.propertyName, Yi)
		}, ue.prototype.addTransformMetadata = function(Yi) {
			this._transformMetadatas.has(Yi.target) || this._transformMetadatas.set(Yi.target, new Map), this._transformMetadatas.get(Yi.target).has(Yi.propertyName) || this._transformMetadatas.get(Yi.target).set(Yi.propertyName, []), this._transformMetadatas.get(Yi.target).get(Yi.propertyName).push(Yi)
		}, ue.prototype.addExposeMetadata = function(Yi) {
			this._exposeMetadatas.has(Yi.target) || this._exposeMetadatas.set(Yi.target, new Map), this._exposeMetadatas.get(Yi.target).set(Yi.propertyName, Yi)
		}, ue.prototype.addExcludeMetadata = function(Yi) {
			this._excludeMetadatas.has(Yi.target) || this._excludeMetadatas.set(Yi.target, new Map), this._excludeMetadatas.get(Yi.target).set(Yi.propertyName, Yi)
		}, ue.prototype.findTransformMetadatas = function(Yi, ea, ta) {
			return this.findMetadatas(this._transformMetadatas, Yi, ea).filter(function(na) {
				return !na.options || na.options.toClassOnly === !0 && na.options.toPlainOnly === !0 ? !0 : na.options.toClassOnly === !0 ? ta === TransformationType.CLASS_TO_CLASS || ta === TransformationType.PLAIN_TO_CLASS : na.options.toPlainOnly === !0 ? ta === TransformationType.CLASS_TO_PLAIN : !0
			})
		}, ue.prototype.findExcludeMetadata = function(Yi, ea) {
			return this.findMetadata(this._excludeMetadatas, Yi, ea)
		}, ue.prototype.findExposeMetadata = function(Yi, ea) {
			return this.findMetadata(this._exposeMetadatas, Yi, ea)
		}, ue.prototype.findExposeMetadataByCustomName = function(Yi, ea) {
			return this.getExposedMetadatas(Yi).find(function(ta) {
				return ta.options && ta.options.name === ea
			})
		}, ue.prototype.findTypeMetadata = function(Yi, ea) {
			return this.findMetadata(this._typeMetadatas, Yi, ea)
		}, ue.prototype.getStrategy = function(Yi) {
			var ea = this._excludeMetadatas.get(Yi),
				ta = ea && ea.get(void 0),
				na = this._exposeMetadatas.get(Yi),
				ra = na && na.get(void 0);
			return ta && ra || !ta && !ra ? "none" : ta ? "excludeAll" : "exposeAll"
		}, ue.prototype.getExposedMetadatas = function(Yi) {
			return this.getMetadata(this._exposeMetadatas, Yi)
		}, ue.prototype.getExcludedMetadatas = function(Yi) {
			return this.getMetadata(this._excludeMetadatas, Yi)
		}, ue.prototype.getExposedProperties = function(Yi, ea) {
			return this.getExposedMetadatas(Yi).filter(function(ta) {
				return !ta.options || ta.options.toClassOnly === !0 && ta.options.toPlainOnly === !0 ? !0 : ta.options.toClassOnly === !0 ? ea === TransformationType.CLASS_TO_CLASS || ea === TransformationType.PLAIN_TO_CLASS : ta.options.toPlainOnly === !0 ? ea === TransformationType.CLASS_TO_PLAIN : !0
			}).map(function(ta) {
				return ta.propertyName
			})
		}, ue.prototype.getExcludedProperties = function(Yi, ea) {
			return this.getExcludedMetadatas(Yi).filter(function(ta) {
				return !ta.options || ta.options.toClassOnly === !0 && ta.options.toPlainOnly === !0 ? !0 : ta.options.toClassOnly === !0 ? ea === TransformationType.CLASS_TO_CLASS || ea === TransformationType.PLAIN_TO_CLASS : ta.options.toPlainOnly === !0 ? ea === TransformationType.CLASS_TO_PLAIN : !0
			}).map(function(ta) {
				return ta.propertyName
			})
		}, ue.prototype.clear = function() {
			this._typeMetadatas.clear(), this._exposeMetadatas.clear(), this._excludeMetadatas.clear(), this._ancestorsMap.clear()
		}, ue.prototype.getMetadata = function(Yi, ea) {
			var ta = Yi.get(ea),
				na;
			ta && (na = Array.from(ta.values()).filter(function(ca) {
				return ca.propertyName !== void 0
			}));
			for (var ra = [], ia = 0, aa = this.getAncestors(ea); ia < aa.length; ia++) {
				var oa = aa[ia],
					la = Yi.get(oa);
				if (la) {
					var sa = Array.from(la.values()).filter(function(ca) {
						return ca.propertyName !== void 0
					});
					ra.push.apply(ra, sa)
				}
			}
			return ra.concat(na || [])
		}, ue.prototype.findMetadata = function(Yi, ea, ta) {
			var na = Yi.get(ea);
			if (na) {
				var ra = na.get(ta);
				if (ra) return ra
			}
			for (var ia = 0, aa = this.getAncestors(ea); ia < aa.length; ia++) {
				var oa = aa[ia],
					la = Yi.get(oa);
				if (la) {
					var sa = la.get(ta);
					if (sa) return sa
				}
			}
		}, ue.prototype.findMetadatas = function(Yi, ea, ta) {
			var na = Yi.get(ea),
				ra;
			na && (ra = na.get(ta));
			for (var ia = [], aa = 0, oa = this.getAncestors(ea); aa < oa.length; aa++) {
				var la = oa[aa],
					sa = Yi.get(la);
				sa && sa.has(ta) && ia.push.apply(ia, sa.get(ta))
			}
			return ia.slice().reverse().concat((ra || []).slice().reverse())
		}, ue.prototype.getAncestors = function(Yi) {
			if (!Yi) return [];
			if (!this._ancestorsMap.has(Yi)) {
				for (var ea = [], ta = Object.getPrototypeOf(Yi.prototype.constructor); typeof ta.prototype < "u"; ta = Object.getPrototypeOf(ta.prototype.constructor)) ea.push(ta);
				this._ancestorsMap.set(Yi, ea)
			}
			return this._ancestorsMap.get(Yi)
		}, ue
	}(),
	defaultMetadataStorage = new MetadataStorage$1;

function getGlobal$1() {
	if (typeof globalThis < "u") return globalThis;
	if (typeof global$1 < "u") return global$1;
	if (typeof window < "u") return window;
	if (typeof self < "u") return self
}

function isPromise$2(ue) {
	return ue !== null && typeof ue == "object" && typeof ue.then == "function"
}
var __spreadArray$1 = function(ue, Yi, ea) {
	if (ea || arguments.length === 2)
		for (var ta = 0, na = Yi.length, ra; ta < na; ta++)(ra || !(ta in Yi)) && (ra || (ra = Array.prototype.slice.call(Yi, 0, ta)), ra[ta] = Yi[ta]);
	return ue.concat(ra || Array.prototype.slice.call(Yi))
};

function instantiateArrayType(ue) {
	var Yi = new ue;
	return !(Yi instanceof Set) && !("push" in Yi) ? [] : Yi
}
var TransformOperationExecutor = function() {
		function ue(Yi, ea) {
			this.transformationType = Yi, this.options = ea, this.recursionStack = new Set
		}
		return ue.prototype.transform = function(Yi, ea, ta, na, ra, ia) {
			var aa = this;
			if (ia === void 0 && (ia = 0), Array.isArray(ea) || ea instanceof Set) {
				var oa = na && this.transformationType === TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(na) : [];
				return ea.forEach(function(va, ba) {
					var Ea = Yi ? Yi[ba] : void 0;
					if (!aa.options.enableCircularCheck || !aa.isCircular(va)) {
						var Sa = void 0;
						if (typeof ta != "function" && ta && ta.options && ta.options.discriminator && ta.options.discriminator.property && ta.options.discriminator.subTypes) {
							if (aa.transformationType === TransformationType.PLAIN_TO_CLASS) {
								Sa = ta.options.discriminator.subTypes.find(function(ja) {
									return ja.name === va[ta.options.discriminator.property]
								});
								var Ca = {
										newObject: oa,
										object: va,
										property: void 0
									},
									ka = ta.typeFunction(Ca);
								Sa === void 0 ? Sa = ka : Sa = Sa.value, ta.options.keepDiscriminatorProperty || delete va[ta.options.discriminator.property]
							}
							aa.transformationType === TransformationType.CLASS_TO_CLASS && (Sa = va.constructor), aa.transformationType === TransformationType.CLASS_TO_PLAIN && (va[ta.options.discriminator.property] = ta.options.discriminator.subTypes.find(function(ja) {
								return ja.value === va.constructor
							}).name)
						} else Sa = ta;
						var Pa = aa.transform(Ea, va, Sa, void 0, va instanceof Map, ia + 1);
						oa instanceof Set ? oa.add(Pa) : oa.push(Pa)
					} else aa.transformationType === TransformationType.CLASS_TO_CLASS && (oa instanceof Set ? oa.add(va) : oa.push(va))
				}), oa
			} else {
				if (ta === String && !ra) return ea == null ? ea : String(ea);
				if (ta === Number && !ra) return ea == null ? ea : Number(ea);
				if (ta === Boolean && !ra) return ea == null ? ea : !!ea;
				if ((ta === Date || ea instanceof Date) && !ra) return ea instanceof Date ? new Date(ea.valueOf()) : ea == null ? ea : new Date(ea);
				if (getGlobal$1().Buffer && (ta === Buffer || ea instanceof Buffer) && !ra) return ea == null ? ea : Buffer.from(ea);
				if (isPromise$2(ea) && !ra) return new Promise(function(va, ba) {
					ea.then(function(Ea) {
						return va(aa.transform(void 0, Ea, ta, void 0, void 0, ia + 1))
					}, ba)
				});
				if (!ra && ea !== null && typeof ea == "object" && typeof ea.then == "function") return ea;
				if (typeof ea == "object" && ea !== null) {
					!ta && ea.constructor !== Object && (!Array.isArray(ea) && ea.constructor === Array || (ta = ea.constructor)), !ta && Yi && (ta = Yi.constructor), this.options.enableCircularCheck && this.recursionStack.add(ea);
					var la = this.getKeys(ta, ea, ra),
						sa = Yi || {};
					!Yi && (this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS) && (ra ? sa = new Map : ta ? sa = new ta : sa = {});
					for (var ca = function(va) {
							if (va === "__proto__" || va === "constructor") return "continue";
							var ba = va,
								Ea = va,
								Sa = va;
							if (!ua.options.ignoreDecorators && ta) {
								if (ua.transformationType === TransformationType.PLAIN_TO_CLASS) {
									var Ca = defaultMetadataStorage.findExposeMetadataByCustomName(ta, va);
									Ca && (Sa = Ca.propertyName, Ea = Ca.propertyName)
								} else if (ua.transformationType === TransformationType.CLASS_TO_PLAIN || ua.transformationType === TransformationType.CLASS_TO_CLASS) {
									var Ca = defaultMetadataStorage.findExposeMetadata(ta, va);
									Ca && Ca.options && Ca.options.name && (Ea = Ca.options.name)
								}
							}
							var ka = void 0;
							ua.transformationType === TransformationType.PLAIN_TO_CLASS ? ka = ea[ba] : ea instanceof Map ? ka = ea.get(ba) : ea[ba] instanceof Function ? ka = ea[ba]() : ka = ea[ba];
							var Pa = void 0,
								ja = ka instanceof Map;
							if (ta && ra) Pa = ta;
							else if (ta) {
								var Za = defaultMetadataStorage.findTypeMetadata(ta, Sa);
								if (Za) {
									var Ga = {
											newObject: sa,
											object: ea,
											property: Sa
										},
										Ja = Za.typeFunction ? Za.typeFunction(Ga) : Za.reflectedType;
									Za.options && Za.options.discriminator && Za.options.discriminator.property && Za.options.discriminator.subTypes ? ea[ba] instanceof Array ? Pa = Za : (ua.transformationType === TransformationType.PLAIN_TO_CLASS && (Pa = Za.options.discriminator.subTypes.find(function(Ma) {
										if (ka && ka instanceof Object && Za.options.discriminator.property in ka) return Ma.name === ka[Za.options.discriminator.property]
									}), Pa === void 0 ? Pa = Ja : Pa = Pa.value, Za.options.keepDiscriminatorProperty || ka && ka instanceof Object && Za.options.discriminator.property in ka && delete ka[Za.options.discriminator.property]), ua.transformationType === TransformationType.CLASS_TO_CLASS && (Pa = ka.constructor), ua.transformationType === TransformationType.CLASS_TO_PLAIN && ka && (ka[Za.options.discriminator.property] = Za.options.discriminator.subTypes.find(function(Ma) {
										return Ma.value === ka.constructor
									}).name)) : Pa = Ja, ja = ja || Za.reflectedType === Map
								} else if (ua.options.targetMaps) ua.options.targetMaps.filter(function(Ma) {
									return Ma.target === ta && !!Ma.properties[Sa]
								}).forEach(function(Ma) {
									return Pa = Ma.properties[Sa]
								});
								else if (ua.options.enableImplicitConversion && ua.transformationType === TransformationType.PLAIN_TO_CLASS) {
									var Ua = Reflect.getMetadata("design:type", ta.prototype, Sa);
									Ua && (Pa = Ua)
								}
							}
							var xa = Array.isArray(ea[ba]) ? ua.getReflectedType(ta, Sa) : void 0,
								ma = Yi ? Yi[ba] : void 0;
							if (sa.constructor.prototype) {
								var fa = Object.getOwnPropertyDescriptor(sa.constructor.prototype, Ea);
								if ((ua.transformationType === TransformationType.PLAIN_TO_CLASS || ua.transformationType === TransformationType.CLASS_TO_CLASS) && (fa && !fa.set || sa[Ea] instanceof Function)) return "continue"
							}
							if (!ua.options.enableCircularCheck || !ua.isCircular(ka)) {
								var ga = ua.transformationType === TransformationType.PLAIN_TO_CLASS ? Ea : va,
									wa = void 0;
								ua.transformationType === TransformationType.CLASS_TO_PLAIN ? (wa = ea[ga], wa = ua.applyCustomTransformations(wa, ta, ga, ea, ua.transformationType), wa = ea[ga] === wa ? ka : wa, wa = ua.transform(ma, wa, Pa, xa, ja, ia + 1)) : ka === void 0 && ua.options.exposeDefaultValues ? wa = sa[Ea] : (wa = ua.transform(ma, ka, Pa, xa, ja, ia + 1), wa = ua.applyCustomTransformations(wa, ta, ga, ea, ua.transformationType)), (wa !== void 0 || ua.options.exposeUnsetFields) && (sa instanceof Map ? sa.set(Ea, wa) : sa[Ea] = wa)
							} else if (ua.transformationType === TransformationType.CLASS_TO_CLASS) {
								var wa = ka;
								wa = ua.applyCustomTransformations(wa, ta, va, ea, ua.transformationType), (wa !== void 0 || ua.options.exposeUnsetFields) && (sa instanceof Map ? sa.set(Ea, wa) : sa[Ea] = wa)
							}
						}, ua = this, da = 0, ha = la; da < ha.length; da++) {
						var pa = ha[da];
						ca(pa)
					}
					return this.options.enableCircularCheck && this.recursionStack.delete(ea), sa
				} else return ea
			}
		}, ue.prototype.applyCustomTransformations = function(Yi, ea, ta, na, ra) {
			var ia = this,
				aa = defaultMetadataStorage.findTransformMetadatas(ea, ta, this.transformationType);
			return this.options.version !== void 0 && (aa = aa.filter(function(oa) {
				return oa.options ? ia.checkVersion(oa.options.since, oa.options.until) : !0
			})), this.options.groups && this.options.groups.length ? aa = aa.filter(function(oa) {
				return oa.options ? ia.checkGroups(oa.options.groups) : !0
			}) : aa = aa.filter(function(oa) {
				return !oa.options || !oa.options.groups || !oa.options.groups.length
			}), aa.forEach(function(oa) {
				Yi = oa.transformFn({
					value: Yi,
					key: ta,
					obj: na,
					type: ra,
					options: ia.options
				})
			}), Yi
		}, ue.prototype.isCircular = function(Yi) {
			return this.recursionStack.has(Yi)
		}, ue.prototype.getReflectedType = function(Yi, ea) {
			if (Yi) {
				var ta = defaultMetadataStorage.findTypeMetadata(Yi, ea);
				return ta ? ta.reflectedType : void 0
			}
		}, ue.prototype.getKeys = function(Yi, ea, ta) {
			var na = this,
				ra = defaultMetadataStorage.getStrategy(Yi);
			ra === "none" && (ra = this.options.strategy || "exposeAll");
			var ia = [];
			if ((ra === "exposeAll" || ta) && (ea instanceof Map ? ia = Array.from(ea.keys()) : ia = Object.keys(ea)), ta) return ia;
			if (this.options.ignoreDecorators && this.options.excludeExtraneousValues && Yi) {
				var aa = defaultMetadataStorage.getExposedProperties(Yi, this.transformationType),
					oa = defaultMetadataStorage.getExcludedProperties(Yi, this.transformationType);
				ia = __spreadArray$1(__spreadArray$1([], aa, !0), oa, !0)
			}
			if (!this.options.ignoreDecorators && Yi) {
				var aa = defaultMetadataStorage.getExposedProperties(Yi, this.transformationType);
				this.transformationType === TransformationType.PLAIN_TO_CLASS && (aa = aa.map(function(ca) {
					var ua = defaultMetadataStorage.findExposeMetadata(Yi, ca);
					return ua && ua.options && ua.options.name ? ua.options.name : ca
				})), this.options.excludeExtraneousValues ? ia = aa : ia = ia.concat(aa);
				var la = defaultMetadataStorage.getExcludedProperties(Yi, this.transformationType);
				la.length > 0 && (ia = ia.filter(function(ca) {
					return !la.includes(ca)
				})), this.options.version !== void 0 && (ia = ia.filter(function(ca) {
					var ua = defaultMetadataStorage.findExposeMetadata(Yi, ca);
					return !ua || !ua.options ? !0 : na.checkVersion(ua.options.since, ua.options.until)
				})), this.options.groups && this.options.groups.length ? ia = ia.filter(function(ca) {
					var ua = defaultMetadataStorage.findExposeMetadata(Yi, ca);
					return !ua || !ua.options ? !0 : na.checkGroups(ua.options.groups)
				}) : ia = ia.filter(function(ca) {
					var ua = defaultMetadataStorage.findExposeMetadata(Yi, ca);
					return !ua || !ua.options || !ua.options.groups || !ua.options.groups.length
				})
			}
			return this.options.excludePrefixes && this.options.excludePrefixes.length && (ia = ia.filter(function(sa) {
				return na.options.excludePrefixes.every(function(ca) {
					return sa.substr(0, ca.length) !== ca
				})
			})), ia = ia.filter(function(sa, ca, ua) {
				return ua.indexOf(sa) === ca
			}), ia
		}, ue.prototype.checkVersion = function(Yi, ea) {
			var ta = !0;
			return ta && Yi && (ta = this.options.version >= Yi), ta && ea && (ta = this.options.version < ea), ta
		}, ue.prototype.checkGroups = function(Yi) {
			return Yi ? this.options.groups.some(function(ea) {
				return Yi.includes(ea)
			}) : !0
		}, ue
	}(),
	defaultOptions = {
		enableCircularCheck: !1,
		enableImplicitConversion: !1,
		excludeExtraneousValues: !1,
		excludePrefixes: void 0,
		exposeDefaultValues: !1,
		exposeUnsetFields: !0,
		groups: void 0,
		ignoreDecorators: !1,
		strategy: void 0,
		targetMaps: void 0,
		version: void 0
	},
	__assign$1 = function() {
		return __assign$1 = Object.assign || function(ue) {
			for (var Yi, ea = 1, ta = arguments.length; ea < ta; ea++) {
				Yi = arguments[ea];
				for (var na in Yi) Object.prototype.hasOwnProperty.call(Yi, na) && (ue[na] = Yi[na])
			}
			return ue
		}, __assign$1.apply(this, arguments)
	},
	ClassTransformer = function() {
		function ue() {}
		return ue.prototype.instanceToPlain = function(Yi, ea) {
			var ta = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, __assign$1(__assign$1({}, defaultOptions), ea));
			return ta.transform(void 0, Yi, void 0, void 0, void 0, void 0)
		}, ue.prototype.classToPlainFromExist = function(Yi, ea, ta) {
			var na = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, __assign$1(__assign$1({}, defaultOptions), ta));
			return na.transform(ea, Yi, void 0, void 0, void 0, void 0)
		}, ue.prototype.plainToInstance = function(Yi, ea, ta) {
			var na = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, __assign$1(__assign$1({}, defaultOptions), ta));
			return na.transform(void 0, ea, Yi, void 0, void 0, void 0)
		}, ue.prototype.plainToClassFromExist = function(Yi, ea, ta) {
			var na = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, __assign$1(__assign$1({}, defaultOptions), ta));
			return na.transform(Yi, ea, void 0, void 0, void 0, void 0)
		}, ue.prototype.instanceToInstance = function(Yi, ea) {
			var ta = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, __assign$1(__assign$1({}, defaultOptions), ea));
			return ta.transform(void 0, Yi, void 0, void 0, void 0, void 0)
		}, ue.prototype.classToClassFromExist = function(Yi, ea, ta) {
			var na = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, __assign$1(__assign$1({}, defaultOptions), ta));
			return na.transform(ea, Yi, void 0, void 0, void 0, void 0)
		}, ue.prototype.serialize = function(Yi, ea) {
			return JSON.stringify(this.instanceToPlain(Yi, ea))
		}, ue.prototype.deserialize = function(Yi, ea, ta) {
			var na = JSON.parse(ea);
			return this.plainToInstance(Yi, na, ta)
		}, ue.prototype.deserializeArray = function(Yi, ea, ta) {
			var na = JSON.parse(ea);
			return this.plainToInstance(Yi, na, ta)
		}, ue
	}();

function Expose(ue) {
	return ue === void 0 && (ue = {}),
		function(Yi, ea) {
			defaultMetadataStorage.addExposeMetadata({
				target: Yi instanceof Function ? Yi : Yi.constructor,
				propertyName: ea,
				options: ue
			})
		}
}

function Transform(ue, Yi) {
	return Yi === void 0 && (Yi = {}),
		function(ea, ta) {
			defaultMetadataStorage.addTransformMetadata({
				target: ea.constructor,
				propertyName: ta,
				transformFn: ue,
				options: Yi
			})
		}
}

function Type(ue, Yi) {
	return Yi === void 0 && (Yi = {}),
		function(ea, ta) {
			var na = Reflect.getMetadata("design:type", ea, ta);
			defaultMetadataStorage.addTypeMetadata({
				target: ea.constructor,
				propertyName: ta,
				reflectedType: na,
				typeFunction: ue,
				options: Yi
			})
		}
}
var classTransformer = new ClassTransformer;

function plainToInstance(ue, Yi, ea) {
	return classTransformer.plainToInstance(ue, Yi, ea)
}
var ValidationMetadata = function() {
		function ue(Yi) {
			this.groups = [], this.each = !1, this.context = void 0, this.type = Yi.type, this.name = Yi.name, this.target = Yi.target, this.propertyName = Yi.propertyName, this.constraints = Yi == null ? void 0 : Yi.constraints, this.constraintCls = Yi.constraintCls, this.validationTypeOptions = Yi.validationTypeOptions, Yi.validationOptions && (this.message = Yi.validationOptions.message, this.groups = Yi.validationOptions.groups, this.always = Yi.validationOptions.always, this.each = Yi.validationOptions.each, this.context = Yi.validationOptions.context)
		}
		return ue
	}(),
	ValidationSchemaToMetadataTransformer = function() {
		function ue() {}
		return ue.prototype.transform = function(Yi) {
			var ea = [];
			return Object.keys(Yi.properties).forEach(function(ta) {
				Yi.properties[ta].forEach(function(na) {
					var ra = {
							message: na.message,
							groups: na.groups,
							always: na.always,
							each: na.each
						},
						ia = {
							type: na.type,
							name: na.name,
							target: Yi.name,
							propertyName: ta,
							constraints: na.constraints,
							validationTypeOptions: na.options,
							validationOptions: ra
						};
					ea.push(new ValidationMetadata(ia))
				})
			}), ea
		}, ue
	}();

function convertToArray(ue) {
	return ue instanceof Map ? Array.from(ue.values()) : Array.isArray(ue) ? ue : Array.from(ue)
}

function getGlobal() {
	if (typeof globalThis < "u") return globalThis;
	if (typeof global$1 < "u") return global$1;
	if (typeof window < "u") return window;
	if (typeof self < "u") return self
}

function isPromise$1(ue) {
	return ue !== null && typeof ue == "object" && typeof ue.then == "function"
}
var __values = function(ue) {
		var Yi = typeof Symbol == "function" && Symbol.iterator,
			ea = Yi && ue[Yi],
			ta = 0;
		if (ea) return ea.call(ue);
		if (ue && typeof ue.length == "number") return {
			next: function() {
				return ue && ta >= ue.length && (ue = void 0), {
					value: ue && ue[ta++],
					done: !ue
				}
			}
		};
		throw new TypeError(Yi ? "Object is not iterable." : "Symbol.iterator is not defined.")
	},
	__read$2 = function(ue, Yi) {
		var ea = typeof Symbol == "function" && ue[Symbol.iterator];
		if (!ea) return ue;
		var ta = ea.call(ue),
			na, ra = [],
			ia;
		try {
			for (;
				(Yi === void 0 || Yi-- > 0) && !(na = ta.next()).done;) ra.push(na.value)
		} catch (aa) {
			ia = {
				error: aa
			}
		} finally {
			try {
				na && !na.done && (ea = ta.return) && ea.call(ta)
			} finally {
				if (ia) throw ia.error
			}
		}
		return ra
	},
	__spreadArray = function(ue, Yi, ea) {
		if (ea || arguments.length === 2)
			for (var ta = 0, na = Yi.length, ra; ta < na; ta++)(ra || !(ta in Yi)) && (ra || (ra = Array.prototype.slice.call(Yi, 0, ta)), ra[ta] = Yi[ta]);
		return ue.concat(ra || Array.prototype.slice.call(Yi))
	},
	MetadataStorage = function() {
		function ue() {
			this.validationMetadatas = new Map, this.constraintMetadatas = new Map
		}
		return Object.defineProperty(ue.prototype, "hasValidationMetaData", {
			get: function() {
				return !!this.validationMetadatas.size
			},
			enumerable: !1,
			configurable: !0
		}), ue.prototype.addValidationSchema = function(Yi) {
			var ea = this,
				ta = new ValidationSchemaToMetadataTransformer().transform(Yi);
			ta.forEach(function(na) {
				return ea.addValidationMetadata(na)
			})
		}, ue.prototype.addValidationMetadata = function(Yi) {
			var ea = this.validationMetadatas.get(Yi.target);
			ea ? ea.push(Yi) : this.validationMetadatas.set(Yi.target, [Yi])
		}, ue.prototype.addConstraintMetadata = function(Yi) {
			var ea = this.constraintMetadatas.get(Yi.target);
			ea ? ea.push(Yi) : this.constraintMetadatas.set(Yi.target, [Yi])
		}, ue.prototype.groupByPropertyName = function(Yi) {
			var ea = {};
			return Yi.forEach(function(ta) {
				ea[ta.propertyName] || (ea[ta.propertyName] = []), ea[ta.propertyName].push(ta)
			}), ea
		}, ue.prototype.getTargetValidationMetadatas = function(Yi, ea, ta, na, ra) {
			var ia, aa, oa = function(Ca) {
					return typeof Ca.always < "u" ? Ca.always : Ca.groups && Ca.groups.length ? !1 : ta
				},
				la = function(Ca) {
					return !!(na && (!ra || !ra.length) && Ca.groups && Ca.groups.length)
				},
				sa = this.validationMetadatas.get(Yi) || [],
				ca = sa.filter(function(Ca) {
					return Ca.target !== Yi && Ca.target !== ea ? !1 : oa(Ca) ? !0 : la(Ca) ? !1 : ra && ra.length > 0 ? Ca.groups && !!Ca.groups.find(function(ka) {
						return ra.indexOf(ka) !== -1
					}) : !0
				}),
				ua = [];
			try {
				for (var da = __values(this.validationMetadatas.entries()), ha = da.next(); !ha.done; ha = da.next()) {
					var pa = __read$2(ha.value, 2),
						va = pa[0],
						ba = pa[1];
					Yi.prototype instanceof va && ua.push.apply(ua, __spreadArray([], __read$2(ba), !1))
				}
			} catch (Ca) {
				ia = {
					error: Ca
				}
			} finally {
				try {
					ha && !ha.done && (aa = da.return) && aa.call(da)
				} finally {
					if (ia) throw ia.error
				}
			}
			var Ea = ua.filter(function(Ca) {
					return typeof Ca.target == "string" || Ca.target === Yi || Ca.target instanceof Function && !(Yi.prototype instanceof Ca.target) ? !1 : oa(Ca) ? !0 : la(Ca) ? !1 : ra && ra.length > 0 ? Ca.groups && !!Ca.groups.find(function(ka) {
						return ra.indexOf(ka) !== -1
					}) : !0
				}),
				Sa = Ea.filter(function(Ca) {
					return !ca.find(function(ka) {
						return ka.propertyName === Ca.propertyName && ka.type === Ca.type
					})
				});
			return ca.concat(Sa)
		}, ue.prototype.getTargetValidatorConstraints = function(Yi) {
			return this.constraintMetadatas.get(Yi) || []
		}, ue
	}();

function getMetadataStorage() {
	var ue = getGlobal();
	return ue.classValidatorMetadataStorage || (ue.classValidatorMetadataStorage = new MetadataStorage), globalThis.classValidatorMetadataStorage
}
var ValidationError = function() {
		function ue() {}
		return ue.prototype.toString = function(Yi, ea, ta, na) {
			var ra = this;
			Yi === void 0 && (Yi = !1), ea === void 0 && (ea = !1), ta === void 0 && (ta = ""), na === void 0 && (na = !1);
			var ia = Yi ? "\x1B[1m" : "",
				aa = Yi ? "\x1B[22m" : "",
				oa = function() {
					var ca;
					return (na ? Object.values : Object.keys)((ca = ra.constraints) !== null && ca !== void 0 ? ca : {}).join(", ")
				},
				la = function(ca) {
					return " - property ".concat(ia).concat(ta).concat(ca).concat(aa, " has failed the following constraints: ").concat(ia).concat(oa()).concat(aa, ` 
`)
				};
			if (ea) {
				var sa = Number.isInteger(+this.property) ? "[".concat(this.property, "]") : "".concat(ta ? "." : "").concat(this.property);
				return this.constraints ? la(sa) : this.children ? this.children.map(function(ca) {
					return ca.toString(Yi, !0, "".concat(ta).concat(sa), na)
				}).join("") : ""
			} else return "An instance of ".concat(ia).concat(this.target ? this.target.constructor.name : "an object").concat(aa, ` has failed the validation:
`) + (this.constraints ? la(this.property) : "") + (this.children ? this.children.map(function(ca) {
				return ca.toString(Yi, !0, ra.property, na)
			}).join("") : "")
		}, ue
	}(),
	ValidationTypes = function() {
		function ue() {}
		return ue.isValid = function(Yi) {
			var ea = this;
			return Yi !== "isValid" && Yi !== "getMessage" && Object.keys(this).map(function(ta) {
				return ea[ta]
			}).indexOf(Yi) !== -1
		}, ue.CUSTOM_VALIDATION = "customValidation", ue.NESTED_VALIDATION = "nestedValidation", ue.PROMISE_VALIDATION = "promiseValidation", ue.CONDITIONAL_VALIDATION = "conditionalValidation", ue.WHITELIST = "whitelistValidation", ue.IS_DEFINED = "isDefined", ue
	}();

function constraintToString(ue) {
	return Array.isArray(ue) ? ue.join(", ") : (typeof ue == "symbol" && (ue = ue.description), "".concat(ue))
}
var ValidationUtils = function() {
		function ue() {}
		return ue.replaceMessageSpecialTokens = function(Yi, ea) {
			var ta;
			return Yi instanceof Function ? ta = Yi(ea) : typeof Yi == "string" && (ta = Yi), ta && Array.isArray(ea.constraints) && ea.constraints.forEach(function(na, ra) {
				ta = ta.replace(new RegExp("\\$constraint".concat(ra + 1), "g"), constraintToString(na))
			}), ta && ea.value !== void 0 && ea.value !== null && ["string", "boolean", "number"].includes(typeof ea.value) && (ta = ta.replace(/\$value/g, ea.value)), ta && (ta = ta.replace(/\$property/g, ea.property)), ta && (ta = ta.replace(/\$target/g, ea.targetName)), ta
		}, ue
	}(),
	__read$1 = function(ue, Yi) {
		var ea = typeof Symbol == "function" && ue[Symbol.iterator];
		if (!ea) return ue;
		var ta = ea.call(ue),
			na, ra = [],
			ia;
		try {
			for (;
				(Yi === void 0 || Yi-- > 0) && !(na = ta.next()).done;) ra.push(na.value)
		} catch (aa) {
			ia = {
				error: aa
			}
		} finally {
			try {
				na && !na.done && (ea = ta.return) && ea.call(ta)
			} finally {
				if (ia) throw ia.error
			}
		}
		return ra
	},
	ValidationExecutor = function() {
		function ue(Yi, ea) {
			this.validator = Yi, this.validatorOptions = ea, this.awaitingPromises = [], this.ignoreAsyncValidations = !1, this.metadataStorage = getMetadataStorage()
		}
		return ue.prototype.execute = function(Yi, ea, ta) {
			var na = this,
				ra, ia;
			!this.metadataStorage.hasValidationMetaData && ((ra = this.validatorOptions) === null || ra === void 0 ? void 0 : ra.enableDebugMessages) === !0 && console.warn(`No validation metadata found. No validation will be  performed. There are multiple possible reasons:
  - There may be multiple class-validator versions installed. You will need to flatten your dependencies to fix the issue.
  - This validation runs before any file with validation decorator was parsed by NodeJS.`);
			var aa = this.validatorOptions ? this.validatorOptions.groups : void 0,
				oa = this.validatorOptions && this.validatorOptions.strictGroups || !1,
				la = this.validatorOptions && this.validatorOptions.always || !1,
				sa = ((ia = this.validatorOptions) === null || ia === void 0 ? void 0 : ia.forbidUnknownValues) === void 0 || this.validatorOptions.forbidUnknownValues !== !1,
				ca = this.metadataStorage.getTargetValidationMetadatas(Yi.constructor, ea, la, oa, aa),
				ua = this.metadataStorage.groupByPropertyName(ca);
			if (this.validatorOptions && sa && !ca.length) {
				var da = new ValidationError;
				(!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === void 0 || this.validatorOptions.validationError.target === !0) && (da.target = Yi), da.value = void 0, da.property = void 0, da.children = [], da.constraints = {
					unknownValue: "an unknown value was passed to the validate function"
				}, ta.push(da);
				return
			}
			this.validatorOptions && this.validatorOptions.whitelist && this.whitelist(Yi, ua, ta), Object.keys(ua).forEach(function(ha) {
				var pa = Yi[ha],
					va = ua[ha].filter(function(Ea) {
						return Ea.type === ValidationTypes.IS_DEFINED
					}),
					ba = ua[ha].filter(function(Ea) {
						return Ea.type !== ValidationTypes.IS_DEFINED && Ea.type !== ValidationTypes.WHITELIST
					});
				pa instanceof Promise && ba.find(function(Ea) {
					return Ea.type === ValidationTypes.PROMISE_VALIDATION
				}) ? na.awaitingPromises.push(pa.then(function(Ea) {
					na.performValidations(Yi, Ea, ha, va, ba, ta)
				})) : na.performValidations(Yi, pa, ha, va, ba, ta)
			})
		}, ue.prototype.whitelist = function(Yi, ea, ta) {
			var na = this,
				ra = [];
			Object.keys(Yi).forEach(function(ia) {
				(!ea[ia] || ea[ia].length === 0) && ra.push(ia)
			}), ra.length > 0 && (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted ? ra.forEach(function(ia) {
				var aa, oa = na.generateValidationError(Yi, Yi[ia], ia);
				oa.constraints = (aa = {}, aa[ValidationTypes.WHITELIST] = "property ".concat(ia, " should not exist"), aa), oa.children = void 0, ta.push(oa)
			}) : ra.forEach(function(ia) {
				return delete Yi[ia]
			}))
		}, ue.prototype.stripEmptyErrors = function(Yi) {
			var ea = this;
			return Yi.filter(function(ta) {
				if (ta.children && (ta.children = ea.stripEmptyErrors(ta.children)), Object.keys(ta.constraints).length === 0) {
					if (ta.children.length === 0) return !1;
					delete ta.constraints
				}
				return !0
			})
		}, ue.prototype.performValidations = function(Yi, ea, ta, na, ra, ia) {
			var aa = ra.filter(function(ua) {
					return ua.type === ValidationTypes.CUSTOM_VALIDATION
				}),
				oa = ra.filter(function(ua) {
					return ua.type === ValidationTypes.NESTED_VALIDATION
				}),
				la = ra.filter(function(ua) {
					return ua.type === ValidationTypes.CONDITIONAL_VALIDATION
				}),
				sa = this.generateValidationError(Yi, ea, ta);
			ia.push(sa);
			var ca = this.conditionalValidations(Yi, ea, la);
			ca && (this.customValidations(Yi, ea, na, sa), this.mapContexts(Yi, ea, na, sa), !(ea === void 0 && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === !0) && (ea === null && this.validatorOptions && this.validatorOptions.skipNullProperties === !0 || ea == null && this.validatorOptions && this.validatorOptions.skipMissingProperties === !0 || (this.customValidations(Yi, ea, aa, sa), this.nestedValidations(ea, oa, sa), this.mapContexts(Yi, ea, ra, sa), this.mapContexts(Yi, ea, aa, sa))))
		}, ue.prototype.generateValidationError = function(Yi, ea, ta) {
			var na = new ValidationError;
			return (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === void 0 || this.validatorOptions.validationError.target === !0) && (na.target = Yi), (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.value === void 0 || this.validatorOptions.validationError.value === !0) && (na.value = ea), na.property = ta, na.children = [], na.constraints = {}, na
		}, ue.prototype.conditionalValidations = function(Yi, ea, ta) {
			return ta.map(function(na) {
				return na.constraints[0](Yi, ea)
			}).reduce(function(na, ra) {
				return na && ra
			}, !0)
		}, ue.prototype.customValidations = function(Yi, ea, ta, na) {
			var ra = this;
			ta.forEach(function(ia) {
				ra.metadataStorage.getTargetValidatorConstraints(ia.constraintCls).forEach(function(aa) {
					if (!(aa.async && ra.ignoreAsyncValidations) && !(ra.validatorOptions && ra.validatorOptions.stopAtFirstError && Object.keys(na.constraints || {}).length > 0)) {
						var oa = {
							targetName: Yi.constructor ? Yi.constructor.name : void 0,
							property: ia.propertyName,
							object: Yi,
							value: ea,
							constraints: ia.constraints
						};
						if (!ia.each || !(Array.isArray(ea) || ea instanceof Set || ea instanceof Map)) {
							var la = aa.instance.validate(ea, oa);
							if (isPromise$1(la)) {
								var sa = la.then(function(ka) {
									if (!ka) {
										var Pa = __read$1(ra.createValidationError(Yi, ea, ia, aa), 2),
											ja = Pa[0],
											Za = Pa[1];
										na.constraints[ja] = Za, ia.context && (na.contexts || (na.contexts = {}), na.contexts[ja] = Object.assign(na.contexts[ja] || {}, ia.context))
									}
								});
								ra.awaitingPromises.push(sa)
							} else if (!la) {
								var ca = __read$1(ra.createValidationError(Yi, ea, ia, aa), 2),
									ua = ca[0],
									da = ca[1];
								na.constraints[ua] = da
							}
							return
						}
						var ha = convertToArray(ea),
							pa = ha.map(function(ka) {
								return aa.instance.validate(ka, oa)
							}),
							va = pa.some(function(ka) {
								return isPromise$1(ka)
							});
						if (va) {
							var ba = pa.map(function(ka) {
									return isPromise$1(ka) ? ka : Promise.resolve(ka)
								}),
								Ea = Promise.all(ba).then(function(ka) {
									var Pa = ka.every(function(Ja) {
										return Ja
									});
									if (!Pa) {
										var ja = __read$1(ra.createValidationError(Yi, ea, ia, aa), 2),
											Za = ja[0],
											Ga = ja[1];
										na.constraints[Za] = Ga, ia.context && (na.contexts || (na.contexts = {}), na.contexts[Za] = Object.assign(na.contexts[Za] || {}, ia.context))
									}
								});
							ra.awaitingPromises.push(Ea);
							return
						}
						var Sa = pa.every(function(ka) {
							return ka
						});
						if (!Sa) {
							var Ca = __read$1(ra.createValidationError(Yi, ea, ia, aa), 2),
								ua = Ca[0],
								da = Ca[1];
							na.constraints[ua] = da
						}
					}
				})
			})
		}, ue.prototype.nestedValidations = function(Yi, ea, ta) {
			var na = this;
			Yi !== void 0 && ea.forEach(function(ra) {
				if (!(ra.type !== ValidationTypes.NESTED_VALIDATION && ra.type !== ValidationTypes.PROMISE_VALIDATION) && !(na.validatorOptions && na.validatorOptions.stopAtFirstError && Object.keys(ta.constraints || {}).length > 0))
					if (Array.isArray(Yi) || Yi instanceof Set || Yi instanceof Map) {
						var ia = Yi instanceof Set ? Array.from(Yi) : Yi;
						ia.forEach(function(ca, ua) {
							na.performValidations(Yi, ca, ua.toString(), [], ea, ta.children)
						})
					} else if (Yi instanceof Object) {
					var aa = typeof ra.target == "string" ? ra.target : ra.target.name;
					na.execute(Yi, aa, ta.children)
				} else {
					var oa = __read$1(na.createValidationError(ra.target, Yi, ra), 2),
						la = oa[0],
						sa = oa[1];
					ta.constraints[la] = sa
				}
			})
		}, ue.prototype.mapContexts = function(Yi, ea, ta, na) {
			var ra = this;
			return ta.forEach(function(ia) {
				if (ia.context) {
					var aa = void 0;
					if (ia.type === ValidationTypes.CUSTOM_VALIDATION) {
						var oa = ra.metadataStorage.getTargetValidatorConstraints(ia.constraintCls);
						aa = oa[0]
					}
					var la = ra.getConstraintType(ia, aa);
					na.constraints[la] && (na.contexts || (na.contexts = {}), na.contexts[la] = Object.assign(na.contexts[la] || {}, ia.context))
				}
			})
		}, ue.prototype.createValidationError = function(Yi, ea, ta, na) {
			var ra = Yi.constructor ? Yi.constructor.name : void 0,
				ia = this.getConstraintType(ta, na),
				aa = {
					targetName: ra,
					property: ta.propertyName,
					object: Yi,
					value: ea,
					constraints: ta.constraints
				},
				oa = ta.message || "";
			!ta.message && (!this.validatorOptions || this.validatorOptions && !this.validatorOptions.dismissDefaultMessages) && na && na.instance.defaultMessage instanceof Function && (oa = na.instance.defaultMessage(aa));
			var la = ValidationUtils.replaceMessageSpecialTokens(oa, aa);
			return [ia, la]
		}, ue.prototype.getConstraintType = function(Yi, ea) {
			var ta = ea && ea.name ? ea.name : Yi.type;
			return ta
		}, ue
	}(),
	__awaiter = function(ue, Yi, ea, ta) {
		function na(ra) {
			return ra instanceof ea ? ra : new ea(function(ia) {
				ia(ra)
			})
		}
		return new(ea || (ea = Promise))(function(ra, ia) {
			function aa(sa) {
				try {
					la(ta.next(sa))
				} catch (ca) {
					ia(ca)
				}
			}

			function oa(sa) {
				try {
					la(ta.throw(sa))
				} catch (ca) {
					ia(ca)
				}
			}

			function la(sa) {
				sa.done ? ra(sa.value) : na(sa.value).then(aa, oa)
			}
			la((ta = ta.apply(ue, Yi || [])).next())
		})
	},
	__generator = function(ue, Yi) {
		var ea = {
				label: 0,
				sent: function() {
					if (ra[0] & 1) throw ra[1];
					return ra[1]
				},
				trys: [],
				ops: []
			},
			ta, na, ra, ia;
		return ia = {
			next: aa(0),
			throw: aa(1),
			return: aa(2)
		}, typeof Symbol == "function" && (ia[Symbol.iterator] = function() {
			return this
		}), ia;

		function aa(la) {
			return function(sa) {
				return oa([la, sa])
			}
		}

		function oa(la) {
			if (ta) throw new TypeError("Generator is already executing.");
			for (; ia && (ia = 0, la[0] && (ea = 0)), ea;) try {
				if (ta = 1, na && (ra = la[0] & 2 ? na.return : la[0] ? na.throw || ((ra = na.return) && ra.call(na), 0) : na.next) && !(ra = ra.call(na, la[1])).done) return ra;
				switch (na = 0, ra && (la = [la[0] & 2, ra.value]), la[0]) {
					case 0:
					case 1:
						ra = la;
						break;
					case 4:
						return ea.label++, {
							value: la[1],
							done: !1
						};
					case 5:
						ea.label++, na = la[1], la = [0];
						continue;
					case 7:
						la = ea.ops.pop(), ea.trys.pop();
						continue;
					default:
						if (ra = ea.trys, !(ra = ra.length > 0 && ra[ra.length - 1]) && (la[0] === 6 || la[0] === 2)) {
							ea = 0;
							continue
						}
						if (la[0] === 3 && (!ra || la[1] > ra[0] && la[1] < ra[3])) {
							ea.label = la[1];
							break
						}
						if (la[0] === 6 && ea.label < ra[1]) {
							ea.label = ra[1], ra = la;
							break
						}
						if (ra && ea.label < ra[2]) {
							ea.label = ra[2], ea.ops.push(la);
							break
						}
						ra[2] && ea.ops.pop(), ea.trys.pop();
						continue
				}
				la = Yi.call(ue, ea)
			} catch (sa) {
				la = [6, sa], na = 0
			} finally {
				ta = ra = 0
			}
			if (la[0] & 5) throw la[1];
			return {
				value: la[0] ? la[1] : void 0,
				done: !0
			}
		}
	},
	Validator = function() {
		function ue() {}
		return ue.prototype.validate = function(Yi, ea, ta) {
			return this.coreValidate(Yi, ea, ta)
		}, ue.prototype.validateOrReject = function(Yi, ea, ta) {
			return __awaiter(this, void 0, void 0, function() {
				var na;
				return __generator(this, function(ra) {
					switch (ra.label) {
						case 0:
							return [4, this.coreValidate(Yi, ea, ta)];
						case 1:
							return na = ra.sent(), na.length ? [2, Promise.reject(na)] : [2]
					}
				})
			})
		}, ue.prototype.validateSync = function(Yi, ea, ta) {
			var na = typeof Yi == "string" ? ea : Yi,
				ra = typeof Yi == "string" ? ta : ea,
				ia = typeof Yi == "string" ? Yi : void 0,
				aa = new ValidationExecutor(this, ra);
			aa.ignoreAsyncValidations = !0;
			var oa = [];
			return aa.execute(na, ia, oa), aa.stripEmptyErrors(oa)
		}, ue.prototype.coreValidate = function(Yi, ea, ta) {
			var na = typeof Yi == "string" ? ea : Yi,
				ra = typeof Yi == "string" ? ta : ea,
				ia = typeof Yi == "string" ? Yi : void 0,
				aa = new ValidationExecutor(this, ra),
				oa = [];
			return aa.execute(na, ia, oa), Promise.all(aa.awaitingPromises).then(function() {
				return aa.stripEmptyErrors(oa)
			})
		}, ue
	}(),
	defaultContainer = new(function() {
		function ue() {
			this.instances = []
		}
		return ue.prototype.get = function(Yi) {
			var ea = this.instances.find(function(ta) {
				return ta.type === Yi
			});
			return ea || (ea = {
				type: Yi,
				object: new Yi
			}, this.instances.push(ea)), ea.object
		}, ue
	}());

function getFromContainer(ue) {
	return defaultContainer.get(ue)
}
var ConstraintMetadata = function() {
	function ue(Yi, ea, ta) {
		ta === void 0 && (ta = !1), this.target = Yi, this.name = ea, this.async = ta
	}
	return Object.defineProperty(ue.prototype, "instance", {
		get: function() {
			return getFromContainer(this.target)
		},
		enumerable: !1,
		configurable: !0
	}), ue
}();

function registerDecorator(ue) {
	var Yi;
	if (ue.validator instanceof Function) {
		Yi = ue.validator;
		var ea = getFromContainer(MetadataStorage).getTargetValidatorConstraints(ue.validator);
		if (ea.length > 1) throw "More than one implementation of ValidatorConstraintInterface found for validator on: ".concat(ue.target.name, ":").concat(ue.propertyName)
	} else {
		var ta = ue.validator;
		Yi = function() {
			function ra() {}
			return ra.prototype.validate = function(ia, aa) {
				return ta.validate(ia, aa)
			}, ra.prototype.defaultMessage = function(ia) {
				return ta.defaultMessage ? ta.defaultMessage(ia) : ""
			}, ra
		}(), getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(Yi, ue.name, ue.async))
	}
	var na = {
		type: ue.name && ValidationTypes.isValid(ue.name) ? ue.name : ValidationTypes.CUSTOM_VALIDATION,
		name: ue.name,
		target: ue.target,
		propertyName: ue.propertyName,
		validationOptions: ue.options,
		constraintCls: Yi,
		constraints: ue.constraints
	};
	getMetadataStorage().addValidationMetadata(new ValidationMetadata(na))
}

function buildMessage(ue, Yi) {
	return function(ea) {
		var ta = Yi && Yi.each ? "each value in " : "";
		return ue(ta, ea)
	}
}

function ValidateBy(ue, Yi) {
	return function(ea, ta) {
		registerDecorator({
			name: ue.name,
			target: ea.constructor,
			propertyName: ta,
			options: Yi,
			constraints: ue.constraints,
			validator: ue.validator
		})
	}
}

function IsOptional(ue) {
	return function(Yi, ea) {
		var ta = {
			type: ValidationTypes.CONDITIONAL_VALIDATION,
			target: Yi.constructor,
			propertyName: ea,
			constraints: [function(na, ra) {
				return na[ea] !== null && na[ea] !== void 0
			}],
			validationOptions: ue
		};
		getMetadataStorage().addValidationMetadata(new ValidationMetadata(ta))
	}
}

function ValidatorConstraint(ue) {
	return function(Yi) {
		var ea = ue,
			ta = "";
		ta || (ta = Yi.name, ta || (ta = ta.replace(/\.?([A-Z]+)/g, function(ra, ia) {
			return "_" + ia.toLowerCase()
		}).replace(/^_/, "")));
		var na = new ConstraintMetadata(Yi, ta, ea);
		getMetadataStorage().addConstraintMetadata(na)
	}
}

function Validate(ue, Yi, ea) {
	return function(ta, na) {
		var ra = {
			type: ValidationTypes.CUSTOM_VALIDATION,
			target: ta.constructor,
			propertyName: na,
			constraintCls: ue,
			constraints: Array.isArray(Yi) ? Yi : void 0,
			validationOptions: Array.isArray(Yi) ? ea : Yi
		};
		getMetadataStorage().addValidationMetadata(new ValidationMetadata(ra))
	}
}

function ValidateIf(ue, Yi) {
	return function(ea, ta) {
		var na = {
			type: ValidationTypes.CONDITIONAL_VALIDATION,
			target: ea.constructor,
			propertyName: ta,
			constraints: [ue],
			validationOptions: Yi
		};
		getMetadataStorage().addValidationMetadata(new ValidationMetadata(na))
	}
}
var __assign = function() {
	return __assign = Object.assign || function(ue) {
		for (var Yi, ea = 1, ta = arguments.length; ea < ta; ea++) {
			Yi = arguments[ea];
			for (var na in Yi) Object.prototype.hasOwnProperty.call(Yi, na) && (ue[na] = Yi[na])
		}
		return ue
	}, __assign.apply(this, arguments)
};

function ValidateNested(ue) {
	var Yi = __assign({}, ue),
		ea = Yi.each ? "each value in " : "";
	return Yi.message = Yi.message || ea + "nested property $property must be either object or array",
		function(ta, na) {
			var ra = {
				type: ValidationTypes.NESTED_VALIDATION,
				target: ta.constructor,
				propertyName: na,
				validationOptions: Yi
			};
			getMetadataStorage().addValidationMetadata(new ValidationMetadata(ra))
		}
}
var IS_IN = "isIn";

function isIn(ue, Yi) {
	return Array.isArray(Yi) && Yi.some(function(ea) {
		return ea === ue
	})
}

function IsIn(ue, Yi) {
	return ValidateBy({
		name: IS_IN,
		constraints: [ue],
		validator: {
			validate: function(ea, ta) {
				return isIn(ea, ta == null ? void 0 : ta.constraints[0])
			},
			defaultMessage: buildMessage(function(ea) {
				return ea + "$property must be one of the following values: $constraint1"
			}, Yi)
		}
	}, Yi)
}
var IS_BOOLEAN = "isBoolean";

function isBoolean$1(ue) {
	return ue instanceof Boolean || typeof ue == "boolean"
}

function IsBoolean(ue) {
	return ValidateBy({
		name: IS_BOOLEAN,
		validator: {
			validate: function(Yi, ea) {
				return isBoolean$1(Yi)
			},
			defaultMessage: buildMessage(function(Yi) {
				return Yi + "$property must be a boolean value"
			}, ue)
		}
	}, ue)
}
var IS_NUMBER = "isNumber";

function isNumber$1(ue, Yi) {
	if (Yi === void 0 && (Yi = {}), typeof ue != "number") return !1;
	if (ue === 1 / 0 || ue === -1 / 0) return !!Yi.allowInfinity;
	if (Number.isNaN(ue)) return !!Yi.allowNaN;
	if (Yi.maxDecimalPlaces !== void 0) {
		var ea = 0;
		if (ue % 1 !== 0 && (ea = ue.toString().split(".")[1].length), ea > Yi.maxDecimalPlaces) return !1
	}
	return Number.isFinite(ue)
}

function IsNumber(ue, Yi) {
	return ue === void 0 && (ue = {}), ValidateBy({
		name: IS_NUMBER,
		constraints: [ue],
		validator: {
			validate: function(ea, ta) {
				return isNumber$1(ea, ta == null ? void 0 : ta.constraints[0])
			},
			defaultMessage: buildMessage(function(ea) {
				return ea + "$property must be a number conforming to the specified constraints"
			}, Yi)
		}
	}, Yi)
}
var __read = function(ue, Yi) {
		var ea = typeof Symbol == "function" && ue[Symbol.iterator];
		if (!ea) return ue;
		var ta = ea.call(ue),
			na, ra = [],
			ia;
		try {
			for (;
				(Yi === void 0 || Yi-- > 0) && !(na = ta.next()).done;) ra.push(na.value)
		} catch (aa) {
			ia = {
				error: aa
			}
		} finally {
			try {
				na && !na.done && (ea = ta.return) && ea.call(ta)
			} finally {
				if (ia) throw ia.error
			}
		}
		return ra
	},
	IS_ENUM = "isEnum";

function isEnum(ue, Yi) {
	var ea = Object.keys(Yi).map(function(ta) {
		return Yi[ta]
	});
	return ea.includes(ue)
}

function validEnumValues(ue) {
	return Object.entries(ue).filter(function(Yi) {
		var ea = __read(Yi, 2),
			ta = ea[0];
		return ea[1], isNaN(parseInt(ta))
	}).map(function(Yi) {
		var ea = __read(Yi, 2);
		ea[0];
		var ta = ea[1];
		return ta
	})
}

function IsEnum(ue, Yi) {
	return ValidateBy({
		name: IS_ENUM,
		constraints: [ue, validEnumValues(ue)],
		validator: {
			validate: function(ea, ta) {
				return isEnum(ea, ta == null ? void 0 : ta.constraints[0])
			},
			defaultMessage: buildMessage(function(ea) {
				return ea + "$property must be one of the following values: $constraint2"
			}, Yi)
		}
	}, Yi)
}
var IS_INT = "isInt";

function isInt(ue) {
	return typeof ue == "number" && Number.isInteger(ue)
}

function IsInt(ue) {
	return ValidateBy({
		name: IS_INT,
		validator: {
			validate: function(Yi, ea) {
				return isInt(Yi)
			},
			defaultMessage: buildMessage(function(Yi) {
				return Yi + "$property must be an integer number"
			}, ue)
		}
	}, ue)
}
var IS_STRING = "isString";

function isString$2(ue) {
	return ue instanceof String || typeof ue == "string"
}

function IsString(ue) {
	return ValidateBy({
		name: IS_STRING,
		validator: {
			validate: function(Yi, ea) {
				return isString$2(Yi)
			},
			defaultMessage: buildMessage(function(Yi) {
				return Yi + "$property must be a string"
			}, ue)
		}
	}, ue)
}
var IS_ARRAY = "isArray";

function isArray$1(ue) {
	return Array.isArray(ue)
}

function IsArray(ue) {
	return ValidateBy({
		name: IS_ARRAY,
		validator: {
			validate: function(Yi, ea) {
				return isArray$1(Yi)
			},
			defaultMessage: buildMessage(function(Yi) {
				return Yi + "$property must be an array"
			}, ue)
		}
	}, ue)
}

function isObject$1(ue) {
	return ue != null && (typeof ue == "object" || typeof ue == "function") && !Array.isArray(ue)
}
var ARRAY_MIN_SIZE = "arrayMinSize";

function arrayMinSize(ue, Yi) {
	return Array.isArray(ue) && ue.length >= Yi
}

function ArrayMinSize(ue, Yi) {
	return ValidateBy({
		name: ARRAY_MIN_SIZE,
		constraints: [ue],
		validator: {
			validate: function(ea, ta) {
				return arrayMinSize(ea, ta == null ? void 0 : ta.constraints[0])
			},
			defaultMessage: buildMessage(function(ea) {
				return ea + "$property must contain at least $constraint1 elements"
			}, Yi)
		}
	}, Yi)
}
var ARRAY_MAX_SIZE = "arrayMaxSize";

function arrayMaxSize(ue, Yi) {
	return Array.isArray(ue) && ue.length <= Yi
}

function ArrayMaxSize(ue, Yi) {
	return ValidateBy({
		name: ARRAY_MAX_SIZE,
		constraints: [ue],
		validator: {
			validate: function(ea, ta) {
				return arrayMaxSize(ea, ta == null ? void 0 : ta.constraints[0])
			},
			defaultMessage: buildMessage(function(ea) {
				return ea + "$property must contain no more than $constraint1 elements"
			}, Yi)
		}
	}, Yi)
}
var IS_NOT_EMPTY_OBJECT = "isNotEmptyObject";

function isNotEmptyObject(ue, Yi) {
	if (!isObject$1(ue)) return !1;
	if ((Yi == null ? void 0 : Yi.nullable) === !1) return !Object.values(ue).every(function(ta) {
		return ta == null
	});
	for (var ea in ue)
		if (ue.hasOwnProperty(ea)) return !0;
	return !1
}

function IsNotEmptyObject(ue, Yi) {
	return ValidateBy({
		name: IS_NOT_EMPTY_OBJECT,
		constraints: [ue],
		validator: {
			validate: function(ea, ta) {
				return isNotEmptyObject(ea, ta == null ? void 0 : ta.constraints[0])
			},
			defaultMessage: buildMessage(function(ea) {
				return ea + "$property must be a non-empty object"
			}, Yi)
		}
	}, Yi)
}

function validateSync(ue, Yi, ea) {
	return typeof ue == "string" ? getFromContainer(Validator).validateSync(ue, Yi, ea) : getFromContainer(Validator).validateSync(ue, Yi)
}
const t$2 = (ue, ...Yi) => {
		const [ea] = Yi;
		return useNuxtApp().$i18n.t(ue, ea ?? {})
	},
	d$1 = (ue, Yi) => useNuxtApp().$i18n.d(ue, Yi ?? {}),
	useLocale = () => {
		const ue = useNuxtApp().$webApp.storage,
			{
				setLocale: Yi,
				defaultLocale: ea,
				availableLocales: ta
			} = useNuxtApp().$i18n,
			na = {
				key: "language_code",
				get() {
					return ue.local.get(na.key) || void 0
				},
				set(aa) {
					aa ? ue.local.set(na.key, aa) : ue.local.remove(na.key)
				}
			},
			ra = (aa, oa) => {
				const la = aa || oa;
				return !la || !ta.includes(la) ? ea : la
			};
		return {
			_flow: {
				init: () => {
					var sa;
					const aa = na.get(),
						oa = (sa = useNuxtApp().$webApp.dataUnsafe.user) == null ? void 0 : sa.language_code,
						la = ra(aa, oa);
					Yi(la)
				}
			},
			debug: {
				store: na
			}
		}
	};
/*!
 *  decimal.js v10.4.3
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var EXP_LIMIT = 9e15,
	MAX_DIGITS = 1e9,
	NUMERALS = "0123456789abcdef",
	LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",
	PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",
	DEFAULTS = {
		precision: 20,
		rounding: 4,
		modulo: 1,
		toExpNeg: -7,
		toExpPos: 21,
		minE: -EXP_LIMIT,
		maxE: EXP_LIMIT,
		crypto: !1
	},
	inexact, quadrant, external = !0,
	decimalError = "[DecimalError] ",
	invalidArgument = decimalError + "Invalid argument: ",
	precisionLimitExceeded = decimalError + "Precision limit exceeded",
	cryptoUnavailable = decimalError + "crypto unavailable",
	tag = "[object Decimal]",
	mathfloor = Math.floor,
	mathpow = Math.pow,
	isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
	isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
	isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
	isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
	BASE = 1e7,
	LOG_BASE = 7,
	MAX_SAFE_INTEGER = 9007199254740991,
	LN10_PRECISION = LN10.length - 1,
	PI_PRECISION = PI.length - 1,
	P$1 = {
		toStringTag: tag
	};
P$1.absoluteValue = P$1.abs = function() {
	var ue = new this.constructor(this);
	return ue.s < 0 && (ue.s = 1), finalise(ue)
};
P$1.ceil = function() {
	return finalise(new this.constructor(this), this.e + 1, 2)
};
P$1.clampedTo = P$1.clamp = function(ue, Yi) {
	var ea, ta = this,
		na = ta.constructor;
	if (ue = new na(ue), Yi = new na(Yi), !ue.s || !Yi.s) return new na(NaN);
	if (ue.gt(Yi)) throw Error(invalidArgument + Yi);
	return ea = ta.cmp(ue), ea < 0 ? ue : ta.cmp(Yi) > 0 ? Yi : new na(ta)
};
P$1.comparedTo = P$1.cmp = function(ue) {
	var Yi, ea, ta, na, ra = this,
		ia = ra.d,
		aa = (ue = new ra.constructor(ue)).d,
		oa = ra.s,
		la = ue.s;
	if (!ia || !aa) return !oa || !la ? NaN : oa !== la ? oa : ia === aa ? 0 : !ia ^ oa < 0 ? 1 : -1;
	if (!ia[0] || !aa[0]) return ia[0] ? oa : aa[0] ? -la : 0;
	if (oa !== la) return oa;
	if (ra.e !== ue.e) return ra.e > ue.e ^ oa < 0 ? 1 : -1;
	for (ta = ia.length, na = aa.length, Yi = 0, ea = ta < na ? ta : na; Yi < ea; ++Yi)
		if (ia[Yi] !== aa[Yi]) return ia[Yi] > aa[Yi] ^ oa < 0 ? 1 : -1;
	return ta === na ? 0 : ta > na ^ oa < 0 ? 1 : -1
};
P$1.cosine = P$1.cos = function() {
	var ue, Yi, ea = this,
		ta = ea.constructor;
	return ea.d ? ea.d[0] ? (ue = ta.precision, Yi = ta.rounding, ta.precision = ue + Math.max(ea.e, ea.sd()) + LOG_BASE, ta.rounding = 1, ea = cosine(ta, toLessThanHalfPi(ta, ea)), ta.precision = ue, ta.rounding = Yi, finalise(quadrant == 2 || quadrant == 3 ? ea.neg() : ea, ue, Yi, !0)) : new ta(1) : new ta(NaN)
};
P$1.cubeRoot = P$1.cbrt = function() {
	var ue, Yi, ea, ta, na, ra, ia, aa, oa, la, sa = this,
		ca = sa.constructor;
	if (!sa.isFinite() || sa.isZero()) return new ca(sa);
	for (external = !1, ra = sa.s * mathpow(sa.s * sa, 1 / 3), !ra || Math.abs(ra) == 1 / 0 ? (ea = digitsToString(sa.d), ue = sa.e, (ra = (ue - ea.length + 1) % 3) && (ea += ra == 1 || ra == -2 ? "0" : "00"), ra = mathpow(ea, 1 / 3), ue = mathfloor((ue + 1) / 3) - (ue % 3 == (ue < 0 ? -1 : 2)), ra == 1 / 0 ? ea = "5e" + ue : (ea = ra.toExponential(), ea = ea.slice(0, ea.indexOf("e") + 1) + ue), ta = new ca(ea), ta.s = sa.s) : ta = new ca(ra.toString()), ia = (ue = ca.precision) + 3;;)
		if (aa = ta, oa = aa.times(aa).times(aa), la = oa.plus(sa), ta = divide(la.plus(sa).times(aa), la.plus(oa), ia + 2, 1), digitsToString(aa.d).slice(0, ia) === (ea = digitsToString(ta.d)).slice(0, ia))
			if (ea = ea.slice(ia - 3, ia + 1), ea == "9999" || !na && ea == "4999") {
				if (!na && (finalise(aa, ue + 1, 0), aa.times(aa).times(aa).eq(sa))) {
					ta = aa;
					break
				}
				ia += 4, na = 1
			} else {
				(!+ea || !+ea.slice(1) && ea.charAt(0) == "5") && (finalise(ta, ue + 1, 1), Yi = !ta.times(ta).times(ta).eq(sa));
				break
			} return external = !0, finalise(ta, ue, ca.rounding, Yi)
};
P$1.decimalPlaces = P$1.dp = function() {
	var ue, Yi = this.d,
		ea = NaN;
	if (Yi) {
		if (ue = Yi.length - 1, ea = (ue - mathfloor(this.e / LOG_BASE)) * LOG_BASE, ue = Yi[ue], ue)
			for (; ue % 10 == 0; ue /= 10) ea--;
		ea < 0 && (ea = 0)
	}
	return ea
};
P$1.dividedBy = P$1.div = function(ue) {
	return divide(this, new this.constructor(ue))
};
P$1.dividedToIntegerBy = P$1.divToInt = function(ue) {
	var Yi = this,
		ea = Yi.constructor;
	return finalise(divide(Yi, new ea(ue), 0, 1, 1), ea.precision, ea.rounding)
};
P$1.equals = P$1.eq = function(ue) {
	return this.cmp(ue) === 0
};
P$1.floor = function() {
	return finalise(new this.constructor(this), this.e + 1, 3)
};
P$1.greaterThan = P$1.gt = function(ue) {
	return this.cmp(ue) > 0
};
P$1.greaterThanOrEqualTo = P$1.gte = function(ue) {
	var Yi = this.cmp(ue);
	return Yi == 1 || Yi === 0
};
P$1.hyperbolicCosine = P$1.cosh = function() {
	var ue, Yi, ea, ta, na, ra = this,
		ia = ra.constructor,
		aa = new ia(1);
	if (!ra.isFinite()) return new ia(ra.s ? 1 / 0 : NaN);
	if (ra.isZero()) return aa;
	ea = ia.precision, ta = ia.rounding, ia.precision = ea + Math.max(ra.e, ra.sd()) + 4, ia.rounding = 1, na = ra.d.length, na < 32 ? (ue = Math.ceil(na / 3), Yi = (1 / tinyPow(4, ue)).toString()) : (ue = 16, Yi = "2.3283064365386962890625e-10"), ra = taylorSeries(ia, 1, ra.times(Yi), new ia(1), !0);
	for (var oa, la = ue, sa = new ia(8); la--;) oa = ra.times(ra), ra = aa.minus(oa.times(sa.minus(oa.times(sa))));
	return finalise(ra, ia.precision = ea, ia.rounding = ta, !0)
};
P$1.hyperbolicSine = P$1.sinh = function() {
	var ue, Yi, ea, ta, na = this,
		ra = na.constructor;
	if (!na.isFinite() || na.isZero()) return new ra(na);
	if (Yi = ra.precision, ea = ra.rounding, ra.precision = Yi + Math.max(na.e, na.sd()) + 4, ra.rounding = 1, ta = na.d.length, ta < 3) na = taylorSeries(ra, 2, na, na, !0);
	else {
		ue = 1.4 * Math.sqrt(ta), ue = ue > 16 ? 16 : ue | 0, na = na.times(1 / tinyPow(5, ue)), na = taylorSeries(ra, 2, na, na, !0);
		for (var ia, aa = new ra(5), oa = new ra(16), la = new ra(20); ue--;) ia = na.times(na), na = na.times(aa.plus(ia.times(oa.times(ia).plus(la))))
	}
	return ra.precision = Yi, ra.rounding = ea, finalise(na, Yi, ea, !0)
};
P$1.hyperbolicTangent = P$1.tanh = function() {
	var ue, Yi, ea = this,
		ta = ea.constructor;
	return ea.isFinite() ? ea.isZero() ? new ta(ea) : (ue = ta.precision, Yi = ta.rounding, ta.precision = ue + 7, ta.rounding = 1, divide(ea.sinh(), ea.cosh(), ta.precision = ue, ta.rounding = Yi)) : new ta(ea.s)
};
P$1.inverseCosine = P$1.acos = function() {
	var ue, Yi = this,
		ea = Yi.constructor,
		ta = Yi.abs().cmp(1),
		na = ea.precision,
		ra = ea.rounding;
	return ta !== -1 ? ta === 0 ? Yi.isNeg() ? getPi(ea, na, ra) : new ea(0) : new ea(NaN) : Yi.isZero() ? getPi(ea, na + 4, ra).times(.5) : (ea.precision = na + 6, ea.rounding = 1, Yi = Yi.asin(), ue = getPi(ea, na + 4, ra).times(.5), ea.precision = na, ea.rounding = ra, ue.minus(Yi))
};
P$1.inverseHyperbolicCosine = P$1.acosh = function() {
	var ue, Yi, ea = this,
		ta = ea.constructor;
	return ea.lte(1) ? new ta(ea.eq(1) ? 0 : NaN) : ea.isFinite() ? (ue = ta.precision, Yi = ta.rounding, ta.precision = ue + Math.max(Math.abs(ea.e), ea.sd()) + 4, ta.rounding = 1, external = !1, ea = ea.times(ea).minus(1).sqrt().plus(ea), external = !0, ta.precision = ue, ta.rounding = Yi, ea.ln()) : new ta(ea)
};
P$1.inverseHyperbolicSine = P$1.asinh = function() {
	var ue, Yi, ea = this,
		ta = ea.constructor;
	return !ea.isFinite() || ea.isZero() ? new ta(ea) : (ue = ta.precision, Yi = ta.rounding, ta.precision = ue + 2 * Math.max(Math.abs(ea.e), ea.sd()) + 6, ta.rounding = 1, external = !1, ea = ea.times(ea).plus(1).sqrt().plus(ea), external = !0, ta.precision = ue, ta.rounding = Yi, ea.ln())
};
P$1.inverseHyperbolicTangent = P$1.atanh = function() {
	var ue, Yi, ea, ta, na = this,
		ra = na.constructor;
	return na.isFinite() ? na.e >= 0 ? new ra(na.abs().eq(1) ? na.s / 0 : na.isZero() ? na : NaN) : (ue = ra.precision, Yi = ra.rounding, ta = na.sd(), Math.max(ta, ue) < 2 * -na.e - 1 ? finalise(new ra(na), ue, Yi, !0) : (ra.precision = ea = ta - na.e, na = divide(na.plus(1), new ra(1).minus(na), ea + ue, 1), ra.precision = ue + 4, ra.rounding = 1, na = na.ln(), ra.precision = ue, ra.rounding = Yi, na.times(.5))) : new ra(NaN)
};
P$1.inverseSine = P$1.asin = function() {
	var ue, Yi, ea, ta, na = this,
		ra = na.constructor;
	return na.isZero() ? new ra(na) : (Yi = na.abs().cmp(1), ea = ra.precision, ta = ra.rounding, Yi !== -1 ? Yi === 0 ? (ue = getPi(ra, ea + 4, ta).times(.5), ue.s = na.s, ue) : new ra(NaN) : (ra.precision = ea + 6, ra.rounding = 1, na = na.div(new ra(1).minus(na.times(na)).sqrt().plus(1)).atan(), ra.precision = ea, ra.rounding = ta, na.times(2)))
};
P$1.inverseTangent = P$1.atan = function() {
	var ue, Yi, ea, ta, na, ra, ia, aa, oa, la = this,
		sa = la.constructor,
		ca = sa.precision,
		ua = sa.rounding;
	if (la.isFinite()) {
		if (la.isZero()) return new sa(la);
		if (la.abs().eq(1) && ca + 4 <= PI_PRECISION) return ia = getPi(sa, ca + 4, ua).times(.25), ia.s = la.s, ia
	} else {
		if (!la.s) return new sa(NaN);
		if (ca + 4 <= PI_PRECISION) return ia = getPi(sa, ca + 4, ua).times(.5), ia.s = la.s, ia
	}
	for (sa.precision = aa = ca + 10, sa.rounding = 1, ea = Math.min(28, aa / LOG_BASE + 2 | 0), ue = ea; ue; --ue) la = la.div(la.times(la).plus(1).sqrt().plus(1));
	for (external = !1, Yi = Math.ceil(aa / LOG_BASE), ta = 1, oa = la.times(la), ia = new sa(la), na = la; ue !== -1;)
		if (na = na.times(oa), ra = ia.minus(na.div(ta += 2)), na = na.times(oa), ia = ra.plus(na.div(ta += 2)), ia.d[Yi] !== void 0)
			for (ue = Yi; ia.d[ue] === ra.d[ue] && ue--;);
	return ea && (ia = ia.times(2 << ea - 1)), external = !0, finalise(ia, sa.precision = ca, sa.rounding = ua, !0)
};
P$1.isFinite = function() {
	return !!this.d
};
P$1.isInteger = P$1.isInt = function() {
	return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2
};
P$1.isNaN = function() {
	return !this.s
};
P$1.isNegative = P$1.isNeg = function() {
	return this.s < 0
};
P$1.isPositive = P$1.isPos = function() {
	return this.s > 0
};
P$1.isZero = function() {
	return !!this.d && this.d[0] === 0
};
P$1.lessThan = P$1.lt = function(ue) {
	return this.cmp(ue) < 0
};
P$1.lessThanOrEqualTo = P$1.lte = function(ue) {
	return this.cmp(ue) < 1
};
P$1.logarithm = P$1.log = function(ue) {
	var Yi, ea, ta, na, ra, ia, aa, oa, la = this,
		sa = la.constructor,
		ca = sa.precision,
		ua = sa.rounding,
		da = 5;
	if (ue == null) ue = new sa(10), Yi = !0;
	else {
		if (ue = new sa(ue), ea = ue.d, ue.s < 0 || !ea || !ea[0] || ue.eq(1)) return new sa(NaN);
		Yi = ue.eq(10)
	}
	if (ea = la.d, la.s < 0 || !ea || !ea[0] || la.eq(1)) return new sa(ea && !ea[0] ? -1 / 0 : la.s != 1 ? NaN : ea ? 0 : 1 / 0);
	if (Yi)
		if (ea.length > 1) ra = !0;
		else {
			for (na = ea[0]; na % 10 === 0;) na /= 10;
			ra = na !== 1
		} if (external = !1, aa = ca + da, ia = naturalLogarithm(la, aa), ta = Yi ? getLn10(sa, aa + 10) : naturalLogarithm(ue, aa), oa = divide(ia, ta, aa, 1), checkRoundingDigits(oa.d, na = ca, ua))
		do
			if (aa += 10, ia = naturalLogarithm(la, aa), ta = Yi ? getLn10(sa, aa + 10) : naturalLogarithm(ue, aa), oa = divide(ia, ta, aa, 1), !ra) {
				+digitsToString(oa.d).slice(na + 1, na + 15) + 1 == 1e14 && (oa = finalise(oa, ca + 1, 0));
				break
			} while (checkRoundingDigits(oa.d, na += 10, ua));
	return external = !0, finalise(oa, ca, ua)
};
P$1.minus = P$1.sub = function(ue) {
	var Yi, ea, ta, na, ra, ia, aa, oa, la, sa, ca, ua, da = this,
		ha = da.constructor;
	if (ue = new ha(ue), !da.d || !ue.d) return !da.s || !ue.s ? ue = new ha(NaN) : da.d ? ue.s = -ue.s : ue = new ha(ue.d || da.s !== ue.s ? da : NaN), ue;
	if (da.s != ue.s) return ue.s = -ue.s, da.plus(ue);
	if (la = da.d, ua = ue.d, aa = ha.precision, oa = ha.rounding, !la[0] || !ua[0]) {
		if (ua[0]) ue.s = -ue.s;
		else if (la[0]) ue = new ha(da);
		else return new ha(oa === 3 ? -0 : 0);
		return external ? finalise(ue, aa, oa) : ue
	}
	if (ea = mathfloor(ue.e / LOG_BASE), sa = mathfloor(da.e / LOG_BASE), la = la.slice(), ra = sa - ea, ra) {
		for (ca = ra < 0, ca ? (Yi = la, ra = -ra, ia = ua.length) : (Yi = ua, ea = sa, ia = la.length), ta = Math.max(Math.ceil(aa / LOG_BASE), ia) + 2, ra > ta && (ra = ta, Yi.length = 1), Yi.reverse(), ta = ra; ta--;) Yi.push(0);
		Yi.reverse()
	} else {
		for (ta = la.length, ia = ua.length, ca = ta < ia, ca && (ia = ta), ta = 0; ta < ia; ta++)
			if (la[ta] != ua[ta]) {
				ca = la[ta] < ua[ta];
				break
			} ra = 0
	}
	for (ca && (Yi = la, la = ua, ua = Yi, ue.s = -ue.s), ia = la.length, ta = ua.length - ia; ta > 0; --ta) la[ia++] = 0;
	for (ta = ua.length; ta > ra;) {
		if (la[--ta] < ua[ta]) {
			for (na = ta; na && la[--na] === 0;) la[na] = BASE - 1;
			--la[na], la[ta] += BASE
		}
		la[ta] -= ua[ta]
	}
	for (; la[--ia] === 0;) la.pop();
	for (; la[0] === 0; la.shift()) --ea;
	return la[0] ? (ue.d = la, ue.e = getBase10Exponent(la, ea), external ? finalise(ue, aa, oa) : ue) : new ha(oa === 3 ? -0 : 0)
};
P$1.modulo = P$1.mod = function(ue) {
	var Yi, ea = this,
		ta = ea.constructor;
	return ue = new ta(ue), !ea.d || !ue.s || ue.d && !ue.d[0] ? new ta(NaN) : !ue.d || ea.d && !ea.d[0] ? finalise(new ta(ea), ta.precision, ta.rounding) : (external = !1, ta.modulo == 9 ? (Yi = divide(ea, ue.abs(), 0, 3, 1), Yi.s *= ue.s) : Yi = divide(ea, ue, 0, ta.modulo, 1), Yi = Yi.times(ue), external = !0, ea.minus(Yi))
};
P$1.naturalExponential = P$1.exp = function() {
	return naturalExponential(this)
};
P$1.naturalLogarithm = P$1.ln = function() {
	return naturalLogarithm(this)
};
P$1.negated = P$1.neg = function() {
	var ue = new this.constructor(this);
	return ue.s = -ue.s, finalise(ue)
};
P$1.plus = P$1.add = function(ue) {
	var Yi, ea, ta, na, ra, ia, aa, oa, la, sa, ca = this,
		ua = ca.constructor;
	if (ue = new ua(ue), !ca.d || !ue.d) return !ca.s || !ue.s ? ue = new ua(NaN) : ca.d || (ue = new ua(ue.d || ca.s === ue.s ? ca : NaN)), ue;
	if (ca.s != ue.s) return ue.s = -ue.s, ca.minus(ue);
	if (la = ca.d, sa = ue.d, aa = ua.precision, oa = ua.rounding, !la[0] || !sa[0]) return sa[0] || (ue = new ua(ca)), external ? finalise(ue, aa, oa) : ue;
	if (ra = mathfloor(ca.e / LOG_BASE), ta = mathfloor(ue.e / LOG_BASE), la = la.slice(), na = ra - ta, na) {
		for (na < 0 ? (ea = la, na = -na, ia = sa.length) : (ea = sa, ta = ra, ia = la.length), ra = Math.ceil(aa / LOG_BASE), ia = ra > ia ? ra + 1 : ia + 1, na > ia && (na = ia, ea.length = 1), ea.reverse(); na--;) ea.push(0);
		ea.reverse()
	}
	for (ia = la.length, na = sa.length, ia - na < 0 && (na = ia, ea = sa, sa = la, la = ea), Yi = 0; na;) Yi = (la[--na] = la[na] + sa[na] + Yi) / BASE | 0, la[na] %= BASE;
	for (Yi && (la.unshift(Yi), ++ta), ia = la.length; la[--ia] == 0;) la.pop();
	return ue.d = la, ue.e = getBase10Exponent(la, ta), external ? finalise(ue, aa, oa) : ue
};
P$1.precision = P$1.sd = function(ue) {
	var Yi, ea = this;
	if (ue !== void 0 && ue !== !!ue && ue !== 1 && ue !== 0) throw Error(invalidArgument + ue);
	return ea.d ? (Yi = getPrecision(ea.d), ue && ea.e + 1 > Yi && (Yi = ea.e + 1)) : Yi = NaN, Yi
};
P$1.round = function() {
	var ue = this,
		Yi = ue.constructor;
	return finalise(new Yi(ue), ue.e + 1, Yi.rounding)
};
P$1.sine = P$1.sin = function() {
	var ue, Yi, ea = this,
		ta = ea.constructor;
	return ea.isFinite() ? ea.isZero() ? new ta(ea) : (ue = ta.precision, Yi = ta.rounding, ta.precision = ue + Math.max(ea.e, ea.sd()) + LOG_BASE, ta.rounding = 1, ea = sine(ta, toLessThanHalfPi(ta, ea)), ta.precision = ue, ta.rounding = Yi, finalise(quadrant > 2 ? ea.neg() : ea, ue, Yi, !0)) : new ta(NaN)
};
P$1.squareRoot = P$1.sqrt = function() {
	var ue, Yi, ea, ta, na, ra, ia = this,
		aa = ia.d,
		oa = ia.e,
		la = ia.s,
		sa = ia.constructor;
	if (la !== 1 || !aa || !aa[0]) return new sa(!la || la < 0 && (!aa || aa[0]) ? NaN : aa ? ia : 1 / 0);
	for (external = !1, la = Math.sqrt(+ia), la == 0 || la == 1 / 0 ? (Yi = digitsToString(aa), (Yi.length + oa) % 2 == 0 && (Yi += "0"), la = Math.sqrt(Yi), oa = mathfloor((oa + 1) / 2) - (oa < 0 || oa % 2), la == 1 / 0 ? Yi = "5e" + oa : (Yi = la.toExponential(), Yi = Yi.slice(0, Yi.indexOf("e") + 1) + oa), ta = new sa(Yi)) : ta = new sa(la.toString()), ea = (oa = sa.precision) + 3;;)
		if (ra = ta, ta = ra.plus(divide(ia, ra, ea + 2, 1)).times(.5), digitsToString(ra.d).slice(0, ea) === (Yi = digitsToString(ta.d)).slice(0, ea))
			if (Yi = Yi.slice(ea - 3, ea + 1), Yi == "9999" || !na && Yi == "4999") {
				if (!na && (finalise(ra, oa + 1, 0), ra.times(ra).eq(ia))) {
					ta = ra;
					break
				}
				ea += 4, na = 1
			} else {
				(!+Yi || !+Yi.slice(1) && Yi.charAt(0) == "5") && (finalise(ta, oa + 1, 1), ue = !ta.times(ta).eq(ia));
				break
			} return external = !0, finalise(ta, oa, sa.rounding, ue)
};
P$1.tangent = P$1.tan = function() {
	var ue, Yi, ea = this,
		ta = ea.constructor;
	return ea.isFinite() ? ea.isZero() ? new ta(ea) : (ue = ta.precision, Yi = ta.rounding, ta.precision = ue + 10, ta.rounding = 1, ea = ea.sin(), ea.s = 1, ea = divide(ea, new ta(1).minus(ea.times(ea)).sqrt(), ue + 10, 0), ta.precision = ue, ta.rounding = Yi, finalise(quadrant == 2 || quadrant == 4 ? ea.neg() : ea, ue, Yi, !0)) : new ta(NaN)
};
P$1.times = P$1.mul = function(ue) {
	var Yi, ea, ta, na, ra, ia, aa, oa, la, sa = this,
		ca = sa.constructor,
		ua = sa.d,
		da = (ue = new ca(ue)).d;
	if (ue.s *= sa.s, !ua || !ua[0] || !da || !da[0]) return new ca(!ue.s || ua && !ua[0] && !da || da && !da[0] && !ua ? NaN : !ua || !da ? ue.s / 0 : ue.s * 0);
	for (ea = mathfloor(sa.e / LOG_BASE) + mathfloor(ue.e / LOG_BASE), oa = ua.length, la = da.length, oa < la && (ra = ua, ua = da, da = ra, ia = oa, oa = la, la = ia), ra = [], ia = oa + la, ta = ia; ta--;) ra.push(0);
	for (ta = la; --ta >= 0;) {
		for (Yi = 0, na = oa + ta; na > ta;) aa = ra[na] + da[ta] * ua[na - ta - 1] + Yi, ra[na--] = aa % BASE | 0, Yi = aa / BASE | 0;
		ra[na] = (ra[na] + Yi) % BASE | 0
	}
	for (; !ra[--ia];) ra.pop();
	return Yi ? ++ea : ra.shift(), ue.d = ra, ue.e = getBase10Exponent(ra, ea), external ? finalise(ue, ca.precision, ca.rounding) : ue
};
P$1.toBinary = function(ue, Yi) {
	return toStringBinary(this, 2, ue, Yi)
};
P$1.toDecimalPlaces = P$1.toDP = function(ue, Yi) {
	var ea = this,
		ta = ea.constructor;
	return ea = new ta(ea), ue === void 0 ? ea : (checkInt32(ue, 0, MAX_DIGITS), Yi === void 0 ? Yi = ta.rounding : checkInt32(Yi, 0, 8), finalise(ea, ue + ea.e + 1, Yi))
};
P$1.toExponential = function(ue, Yi) {
	var ea, ta = this,
		na = ta.constructor;
	return ue === void 0 ? ea = finiteToString(ta, !0) : (checkInt32(ue, 0, MAX_DIGITS), Yi === void 0 ? Yi = na.rounding : checkInt32(Yi, 0, 8), ta = finalise(new na(ta), ue + 1, Yi), ea = finiteToString(ta, !0, ue + 1)), ta.isNeg() && !ta.isZero() ? "-" + ea : ea
};
P$1.toFixed = function(ue, Yi) {
	var ea, ta, na = this,
		ra = na.constructor;
	return ue === void 0 ? ea = finiteToString(na) : (checkInt32(ue, 0, MAX_DIGITS), Yi === void 0 ? Yi = ra.rounding : checkInt32(Yi, 0, 8), ta = finalise(new ra(na), ue + na.e + 1, Yi), ea = finiteToString(ta, !1, ue + ta.e + 1)), na.isNeg() && !na.isZero() ? "-" + ea : ea
};
P$1.toFraction = function(ue) {
	var Yi, ea, ta, na, ra, ia, aa, oa, la, sa, ca, ua, da = this,
		ha = da.d,
		pa = da.constructor;
	if (!ha) return new pa(da);
	if (la = ea = new pa(1), ta = oa = new pa(0), Yi = new pa(ta), ra = Yi.e = getPrecision(ha) - da.e - 1, ia = ra % LOG_BASE, Yi.d[0] = mathpow(10, ia < 0 ? LOG_BASE + ia : ia), ue == null) ue = ra > 0 ? Yi : la;
	else {
		if (aa = new pa(ue), !aa.isInt() || aa.lt(la)) throw Error(invalidArgument + aa);
		ue = aa.gt(Yi) ? ra > 0 ? Yi : la : aa
	}
	for (external = !1, aa = new pa(digitsToString(ha)), sa = pa.precision, pa.precision = ra = ha.length * LOG_BASE * 2; ca = divide(aa, Yi, 0, 1, 1), na = ea.plus(ca.times(ta)), na.cmp(ue) != 1;) ea = ta, ta = na, na = la, la = oa.plus(ca.times(na)), oa = na, na = Yi, Yi = aa.minus(ca.times(na)), aa = na;
	return na = divide(ue.minus(ea), ta, 0, 1, 1), oa = oa.plus(na.times(la)), ea = ea.plus(na.times(ta)), oa.s = la.s = da.s, ua = divide(la, ta, ra, 1).minus(da).abs().cmp(divide(oa, ea, ra, 1).minus(da).abs()) < 1 ? [la, ta] : [oa, ea], pa.precision = sa, external = !0, ua
};
P$1.toHexadecimal = P$1.toHex = function(ue, Yi) {
	return toStringBinary(this, 16, ue, Yi)
};
P$1.toNearest = function(ue, Yi) {
	var ea = this,
		ta = ea.constructor;
	if (ea = new ta(ea), ue == null) {
		if (!ea.d) return ea;
		ue = new ta(1), Yi = ta.rounding
	} else {
		if (ue = new ta(ue), Yi === void 0 ? Yi = ta.rounding : checkInt32(Yi, 0, 8), !ea.d) return ue.s ? ea : ue;
		if (!ue.d) return ue.s && (ue.s = ea.s), ue
	}
	return ue.d[0] ? (external = !1, ea = divide(ea, ue, 0, Yi, 1).times(ue), external = !0, finalise(ea)) : (ue.s = ea.s, ea = ue), ea
};
P$1.toNumber = function() {
	return +this
};
P$1.toOctal = function(ue, Yi) {
	return toStringBinary(this, 8, ue, Yi)
};
P$1.toPower = P$1.pow = function(ue) {
	var Yi, ea, ta, na, ra, ia, aa = this,
		oa = aa.constructor,
		la = +(ue = new oa(ue));
	if (!aa.d || !ue.d || !aa.d[0] || !ue.d[0]) return new oa(mathpow(+aa, la));
	if (aa = new oa(aa), aa.eq(1)) return aa;
	if (ta = oa.precision, ra = oa.rounding, ue.eq(1)) return finalise(aa, ta, ra);
	if (Yi = mathfloor(ue.e / LOG_BASE), Yi >= ue.d.length - 1 && (ea = la < 0 ? -la : la) <= MAX_SAFE_INTEGER) return na = intPow(oa, aa, ea, ta), ue.s < 0 ? new oa(1).div(na) : finalise(na, ta, ra);
	if (ia = aa.s, ia < 0) {
		if (Yi < ue.d.length - 1) return new oa(NaN);
		if (ue.d[Yi] & 1 || (ia = 1), aa.e == 0 && aa.d[0] == 1 && aa.d.length == 1) return aa.s = ia, aa
	}
	return ea = mathpow(+aa, la), Yi = ea == 0 || !isFinite(ea) ? mathfloor(la * (Math.log("0." + digitsToString(aa.d)) / Math.LN10 + aa.e + 1)) : new oa(ea + "").e, Yi > oa.maxE + 1 || Yi < oa.minE - 1 ? new oa(Yi > 0 ? ia / 0 : 0) : (external = !1, oa.rounding = aa.s = 1, ea = Math.min(12, (Yi + "").length), na = naturalExponential(ue.times(naturalLogarithm(aa, ta + ea)), ta), na.d && (na = finalise(na, ta + 5, 1), checkRoundingDigits(na.d, ta, ra) && (Yi = ta + 10, na = finalise(naturalExponential(ue.times(naturalLogarithm(aa, Yi + ea)), Yi), Yi + 5, 1), +digitsToString(na.d).slice(ta + 1, ta + 15) + 1 == 1e14 && (na = finalise(na, ta + 1, 0)))), na.s = ia, external = !0, oa.rounding = ra, finalise(na, ta, ra))
};
P$1.toPrecision = function(ue, Yi) {
	var ea, ta = this,
		na = ta.constructor;
	return ue === void 0 ? ea = finiteToString(ta, ta.e <= na.toExpNeg || ta.e >= na.toExpPos) : (checkInt32(ue, 1, MAX_DIGITS), Yi === void 0 ? Yi = na.rounding : checkInt32(Yi, 0, 8), ta = finalise(new na(ta), ue, Yi), ea = finiteToString(ta, ue <= ta.e || ta.e <= na.toExpNeg, ue)), ta.isNeg() && !ta.isZero() ? "-" + ea : ea
};
P$1.toSignificantDigits = P$1.toSD = function(ue, Yi) {
	var ea = this,
		ta = ea.constructor;
	return ue === void 0 ? (ue = ta.precision, Yi = ta.rounding) : (checkInt32(ue, 1, MAX_DIGITS), Yi === void 0 ? Yi = ta.rounding : checkInt32(Yi, 0, 8)), finalise(new ta(ea), ue, Yi)
};
P$1.toString = function() {
	var ue = this,
		Yi = ue.constructor,
		ea = finiteToString(ue, ue.e <= Yi.toExpNeg || ue.e >= Yi.toExpPos);
	return ue.isNeg() && !ue.isZero() ? "-" + ea : ea
};
P$1.truncated = P$1.trunc = function() {
	return finalise(new this.constructor(this), this.e + 1, 1)
};
P$1.valueOf = P$1.toJSON = function() {
	var ue = this,
		Yi = ue.constructor,
		ea = finiteToString(ue, ue.e <= Yi.toExpNeg || ue.e >= Yi.toExpPos);
	return ue.isNeg() ? "-" + ea : ea
};

function digitsToString(ue) {
	var Yi, ea, ta, na = ue.length - 1,
		ra = "",
		ia = ue[0];
	if (na > 0) {
		for (ra += ia, Yi = 1; Yi < na; Yi++) ta = ue[Yi] + "", ea = LOG_BASE - ta.length, ea && (ra += getZeroString(ea)), ra += ta;
		ia = ue[Yi], ta = ia + "", ea = LOG_BASE - ta.length, ea && (ra += getZeroString(ea))
	} else if (ia === 0) return "0";
	for (; ia % 10 === 0;) ia /= 10;
	return ra + ia
}

function checkInt32(ue, Yi, ea) {
	if (ue !== ~~ue || ue < Yi || ue > ea) throw Error(invalidArgument + ue)
}

function checkRoundingDigits(ue, Yi, ea, ta) {
	var na, ra, ia, aa;
	for (ra = ue[0]; ra >= 10; ra /= 10) --Yi;
	return --Yi < 0 ? (Yi += LOG_BASE, na = 0) : (na = Math.ceil((Yi + 1) / LOG_BASE), Yi %= LOG_BASE), ra = mathpow(10, LOG_BASE - Yi), aa = ue[na] % ra | 0, ta == null ? Yi < 3 ? (Yi == 0 ? aa = aa / 100 | 0 : Yi == 1 && (aa = aa / 10 | 0), ia = ea < 4 && aa == 99999 || ea > 3 && aa == 49999 || aa == 5e4 || aa == 0) : ia = (ea < 4 && aa + 1 == ra || ea > 3 && aa + 1 == ra / 2) && (ue[na + 1] / ra / 100 | 0) == mathpow(10, Yi - 2) - 1 || (aa == ra / 2 || aa == 0) && (ue[na + 1] / ra / 100 | 0) == 0 : Yi < 4 ? (Yi == 0 ? aa = aa / 1e3 | 0 : Yi == 1 ? aa = aa / 100 | 0 : Yi == 2 && (aa = aa / 10 | 0), ia = (ta || ea < 4) && aa == 9999 || !ta && ea > 3 && aa == 4999) : ia = ((ta || ea < 4) && aa + 1 == ra || !ta && ea > 3 && aa + 1 == ra / 2) && (ue[na + 1] / ra / 1e3 | 0) == mathpow(10, Yi - 3) - 1, ia
}

function convertBase(ue, Yi, ea) {
	for (var ta, na = [0], ra, ia = 0, aa = ue.length; ia < aa;) {
		for (ra = na.length; ra--;) na[ra] *= Yi;
		for (na[0] += NUMERALS.indexOf(ue.charAt(ia++)), ta = 0; ta < na.length; ta++) na[ta] > ea - 1 && (na[ta + 1] === void 0 && (na[ta + 1] = 0), na[ta + 1] += na[ta] / ea | 0, na[ta] %= ea)
	}
	return na.reverse()
}

function cosine(ue, Yi) {
	var ea, ta, na;
	if (Yi.isZero()) return Yi;
	ta = Yi.d.length, ta < 32 ? (ea = Math.ceil(ta / 3), na = (1 / tinyPow(4, ea)).toString()) : (ea = 16, na = "2.3283064365386962890625e-10"), ue.precision += ea, Yi = taylorSeries(ue, 1, Yi.times(na), new ue(1));
	for (var ra = ea; ra--;) {
		var ia = Yi.times(Yi);
		Yi = ia.times(ia).minus(ia).times(8).plus(1)
	}
	return ue.precision -= ea, Yi
}
var divide = function() {
	function ue(ta, na, ra) {
		var ia, aa = 0,
			oa = ta.length;
		for (ta = ta.slice(); oa--;) ia = ta[oa] * na + aa, ta[oa] = ia % ra | 0, aa = ia / ra | 0;
		return aa && ta.unshift(aa), ta
	}

	function Yi(ta, na, ra, ia) {
		var aa, oa;
		if (ra != ia) oa = ra > ia ? 1 : -1;
		else
			for (aa = oa = 0; aa < ra; aa++)
				if (ta[aa] != na[aa]) {
					oa = ta[aa] > na[aa] ? 1 : -1;
					break
				} return oa
	}

	function ea(ta, na, ra, ia) {
		for (var aa = 0; ra--;) ta[ra] -= aa, aa = ta[ra] < na[ra] ? 1 : 0, ta[ra] = aa * ia + ta[ra] - na[ra];
		for (; !ta[0] && ta.length > 1;) ta.shift()
	}
	return function(ta, na, ra, ia, aa, oa) {
		var la, sa, ca, ua, da, ha, pa, va, ba, Ea, Sa, Ca, ka, Pa, ja, Za, Ga, Ja, Ua, xa, ma = ta.constructor,
			fa = ta.s == na.s ? 1 : -1,
			ga = ta.d,
			wa = na.d;
		if (!ga || !ga[0] || !wa || !wa[0]) return new ma(!ta.s || !na.s || (ga ? wa && ga[0] == wa[0] : !wa) ? NaN : ga && ga[0] == 0 || !wa ? fa * 0 : fa / 0);
		for (oa ? (da = 1, sa = ta.e - na.e) : (oa = BASE, da = LOG_BASE, sa = mathfloor(ta.e / da) - mathfloor(na.e / da)), Ua = wa.length, Ga = ga.length, ba = new ma(fa), Ea = ba.d = [], ca = 0; wa[ca] == (ga[ca] || 0); ca++);
		if (wa[ca] > (ga[ca] || 0) && sa--, ra == null ? (Pa = ra = ma.precision, ia = ma.rounding) : aa ? Pa = ra + (ta.e - na.e) + 1 : Pa = ra, Pa < 0) Ea.push(1), ha = !0;
		else {
			if (Pa = Pa / da + 2 | 0, ca = 0, Ua == 1) {
				for (ua = 0, wa = wa[0], Pa++;
					(ca < Ga || ua) && Pa--; ca++) ja = ua * oa + (ga[ca] || 0), Ea[ca] = ja / wa | 0, ua = ja % wa | 0;
				ha = ua || ca < Ga
			} else {
				for (ua = oa / (wa[0] + 1) | 0, ua > 1 && (wa = ue(wa, ua, oa), ga = ue(ga, ua, oa), Ua = wa.length, Ga = ga.length), Za = Ua, Sa = ga.slice(0, Ua), Ca = Sa.length; Ca < Ua;) Sa[Ca++] = 0;
				xa = wa.slice(), xa.unshift(0), Ja = wa[0], wa[1] >= oa / 2 && ++Ja;
				do ua = 0, la = Yi(wa, Sa, Ua, Ca), la < 0 ? (ka = Sa[0], Ua != Ca && (ka = ka * oa + (Sa[1] || 0)), ua = ka / Ja | 0, ua > 1 ? (ua >= oa && (ua = oa - 1), pa = ue(wa, ua, oa), va = pa.length, Ca = Sa.length, la = Yi(pa, Sa, va, Ca), la == 1 && (ua--, ea(pa, Ua < va ? xa : wa, va, oa))) : (ua == 0 && (la = ua = 1), pa = wa.slice()), va = pa.length, va < Ca && pa.unshift(0), ea(Sa, pa, Ca, oa), la == -1 && (Ca = Sa.length, la = Yi(wa, Sa, Ua, Ca), la < 1 && (ua++, ea(Sa, Ua < Ca ? xa : wa, Ca, oa))), Ca = Sa.length) : la === 0 && (ua++, Sa = [0]), Ea[ca++] = ua, la && Sa[0] ? Sa[Ca++] = ga[Za] || 0 : (Sa = [ga[Za]], Ca = 1); while ((Za++ < Ga || Sa[0] !== void 0) && Pa--);
				ha = Sa[0] !== void 0
			}
			Ea[0] || Ea.shift()
		}
		if (da == 1) ba.e = sa, inexact = ha;
		else {
			for (ca = 1, ua = Ea[0]; ua >= 10; ua /= 10) ca++;
			ba.e = ca + sa * da - 1, finalise(ba, aa ? ra + ba.e + 1 : ra, ia, ha)
		}
		return ba
	}
}();

function finalise(ue, Yi, ea, ta) {
	var na, ra, ia, aa, oa, la, sa, ca, ua, da = ue.constructor;
	e: if (Yi != null) {
		if (ca = ue.d, !ca) return ue;
		for (na = 1, aa = ca[0]; aa >= 10; aa /= 10) na++;
		if (ra = Yi - na, ra < 0) ra += LOG_BASE, ia = Yi, sa = ca[ua = 0], oa = sa / mathpow(10, na - ia - 1) % 10 | 0;
		else if (ua = Math.ceil((ra + 1) / LOG_BASE), aa = ca.length, ua >= aa)
			if (ta) {
				for (; aa++ <= ua;) ca.push(0);
				sa = oa = 0, na = 1, ra %= LOG_BASE, ia = ra - LOG_BASE + 1
			} else break e;
		else {
			for (sa = aa = ca[ua], na = 1; aa >= 10; aa /= 10) na++;
			ra %= LOG_BASE, ia = ra - LOG_BASE + na, oa = ia < 0 ? 0 : sa / mathpow(10, na - ia - 1) % 10 | 0
		}
		if (ta = ta || Yi < 0 || ca[ua + 1] !== void 0 || (ia < 0 ? sa : sa % mathpow(10, na - ia - 1)), la = ea < 4 ? (oa || ta) && (ea == 0 || ea == (ue.s < 0 ? 3 : 2)) : oa > 5 || oa == 5 && (ea == 4 || ta || ea == 6 && (ra > 0 ? ia > 0 ? sa / mathpow(10, na - ia) : 0 : ca[ua - 1]) % 10 & 1 || ea == (ue.s < 0 ? 8 : 7)), Yi < 1 || !ca[0]) return ca.length = 0, la ? (Yi -= ue.e + 1, ca[0] = mathpow(10, (LOG_BASE - Yi % LOG_BASE) % LOG_BASE), ue.e = -Yi || 0) : ca[0] = ue.e = 0, ue;
		if (ra == 0 ? (ca.length = ua, aa = 1, ua--) : (ca.length = ua + 1, aa = mathpow(10, LOG_BASE - ra), ca[ua] = ia > 0 ? (sa / mathpow(10, na - ia) % mathpow(10, ia) | 0) * aa : 0), la)
			for (;;)
				if (ua == 0) {
					for (ra = 1, ia = ca[0]; ia >= 10; ia /= 10) ra++;
					for (ia = ca[0] += aa, aa = 1; ia >= 10; ia /= 10) aa++;
					ra != aa && (ue.e++, ca[0] == BASE && (ca[0] = 1));
					break
				} else {
					if (ca[ua] += aa, ca[ua] != BASE) break;
					ca[ua--] = 0, aa = 1
				} for (ra = ca.length; ca[--ra] === 0;) ca.pop()
	}
	return external && (ue.e > da.maxE ? (ue.d = null, ue.e = NaN) : ue.e < da.minE && (ue.e = 0, ue.d = [0])), ue
}

function finiteToString(ue, Yi, ea) {
	if (!ue.isFinite()) return nonFiniteToString(ue);
	var ta, na = ue.e,
		ra = digitsToString(ue.d),
		ia = ra.length;
	return Yi ? (ea && (ta = ea - ia) > 0 ? ra = ra.charAt(0) + "." + ra.slice(1) + getZeroString(ta) : ia > 1 && (ra = ra.charAt(0) + "." + ra.slice(1)), ra = ra + (ue.e < 0 ? "e" : "e+") + ue.e) : na < 0 ? (ra = "0." + getZeroString(-na - 1) + ra, ea && (ta = ea - ia) > 0 && (ra += getZeroString(ta))) : na >= ia ? (ra += getZeroString(na + 1 - ia), ea && (ta = ea - na - 1) > 0 && (ra = ra + "." + getZeroString(ta))) : ((ta = na + 1) < ia && (ra = ra.slice(0, ta) + "." + ra.slice(ta)), ea && (ta = ea - ia) > 0 && (na + 1 === ia && (ra += "."), ra += getZeroString(ta))), ra
}

function getBase10Exponent(ue, Yi) {
	var ea = ue[0];
	for (Yi *= LOG_BASE; ea >= 10; ea /= 10) Yi++;
	return Yi
}

function getLn10(ue, Yi, ea) {
	if (Yi > LN10_PRECISION) throw external = !0, ea && (ue.precision = ea), Error(precisionLimitExceeded);
	return finalise(new ue(LN10), Yi, 1, !0)
}

function getPi(ue, Yi, ea) {
	if (Yi > PI_PRECISION) throw Error(precisionLimitExceeded);
	return finalise(new ue(PI), Yi, ea, !0)
}

function getPrecision(ue) {
	var Yi = ue.length - 1,
		ea = Yi * LOG_BASE + 1;
	if (Yi = ue[Yi], Yi) {
		for (; Yi % 10 == 0; Yi /= 10) ea--;
		for (Yi = ue[0]; Yi >= 10; Yi /= 10) ea++
	}
	return ea
}

function getZeroString(ue) {
	for (var Yi = ""; ue--;) Yi += "0";
	return Yi
}

function intPow(ue, Yi, ea, ta) {
	var na, ra = new ue(1),
		ia = Math.ceil(ta / LOG_BASE + 4);
	for (external = !1;;) {
		if (ea % 2 && (ra = ra.times(Yi), truncate$1(ra.d, ia) && (na = !0)), ea = mathfloor(ea / 2), ea === 0) {
			ea = ra.d.length - 1, na && ra.d[ea] === 0 && ++ra.d[ea];
			break
		}
		Yi = Yi.times(Yi), truncate$1(Yi.d, ia)
	}
	return external = !0, ra
}

function isOdd(ue) {
	return ue.d[ue.d.length - 1] & 1
}

function maxOrMin(ue, Yi, ea) {
	for (var ta, na = new ue(Yi[0]), ra = 0; ++ra < Yi.length;)
		if (ta = new ue(Yi[ra]), ta.s) na[ea](ta) && (na = ta);
		else {
			na = ta;
			break
		} return na
}

function naturalExponential(ue, Yi) {
	var ea, ta, na, ra, ia, aa, oa, la = 0,
		sa = 0,
		ca = 0,
		ua = ue.constructor,
		da = ua.rounding,
		ha = ua.precision;
	if (!ue.d || !ue.d[0] || ue.e > 17) return new ua(ue.d ? ue.d[0] ? ue.s < 0 ? 0 : 1 / 0 : 1 : ue.s ? ue.s < 0 ? 0 : ue : NaN);
	for (Yi == null ? (external = !1, oa = ha) : oa = Yi, aa = new ua(.03125); ue.e > -2;) ue = ue.times(aa), ca += 5;
	for (ta = Math.log(mathpow(2, ca)) / Math.LN10 * 2 + 5 | 0, oa += ta, ea = ra = ia = new ua(1), ua.precision = oa;;) {
		if (ra = finalise(ra.times(ue), oa, 1), ea = ea.times(++sa), aa = ia.plus(divide(ra, ea, oa, 1)), digitsToString(aa.d).slice(0, oa) === digitsToString(ia.d).slice(0, oa)) {
			for (na = ca; na--;) ia = finalise(ia.times(ia), oa, 1);
			if (Yi == null)
				if (la < 3 && checkRoundingDigits(ia.d, oa - ta, da, la)) ua.precision = oa += 10, ea = ra = aa = new ua(1), sa = 0, la++;
				else return finalise(ia, ua.precision = ha, da, external = !0);
			else return ua.precision = ha, ia
		}
		ia = aa
	}
}

function naturalLogarithm(ue, Yi) {
	var ea, ta, na, ra, ia, aa, oa, la, sa, ca, ua, da = 1,
		ha = 10,
		pa = ue,
		va = pa.d,
		ba = pa.constructor,
		Ea = ba.rounding,
		Sa = ba.precision;
	if (pa.s < 0 || !va || !va[0] || !pa.e && va[0] == 1 && va.length == 1) return new ba(va && !va[0] ? -1 / 0 : pa.s != 1 ? NaN : va ? 0 : pa);
	if (Yi == null ? (external = !1, sa = Sa) : sa = Yi, ba.precision = sa += ha, ea = digitsToString(va), ta = ea.charAt(0), Math.abs(ra = pa.e) < 15e14) {
		for (; ta < 7 && ta != 1 || ta == 1 && ea.charAt(1) > 3;) pa = pa.times(ue), ea = digitsToString(pa.d), ta = ea.charAt(0), da++;
		ra = pa.e, ta > 1 ? (pa = new ba("0." + ea), ra++) : pa = new ba(ta + "." + ea.slice(1))
	} else return la = getLn10(ba, sa + 2, Sa).times(ra + ""), pa = naturalLogarithm(new ba(ta + "." + ea.slice(1)), sa - ha).plus(la), ba.precision = Sa, Yi == null ? finalise(pa, Sa, Ea, external = !0) : pa;
	for (ca = pa, oa = ia = pa = divide(pa.minus(1), pa.plus(1), sa, 1), ua = finalise(pa.times(pa), sa, 1), na = 3;;) {
		if (ia = finalise(ia.times(ua), sa, 1), la = oa.plus(divide(ia, new ba(na), sa, 1)), digitsToString(la.d).slice(0, sa) === digitsToString(oa.d).slice(0, sa))
			if (oa = oa.times(2), ra !== 0 && (oa = oa.plus(getLn10(ba, sa + 2, Sa).times(ra + ""))), oa = divide(oa, new ba(da), sa, 1), Yi == null)
				if (checkRoundingDigits(oa.d, sa - ha, Ea, aa)) ba.precision = sa += ha, la = ia = pa = divide(ca.minus(1), ca.plus(1), sa, 1), ua = finalise(pa.times(pa), sa, 1), na = aa = 1;
				else return finalise(oa, ba.precision = Sa, Ea, external = !0);
		else return ba.precision = Sa, oa;
		oa = la, na += 2
	}
}

function nonFiniteToString(ue) {
	return String(ue.s * ue.s / 0)
}

function parseDecimal(ue, Yi) {
	var ea, ta, na;
	for ((ea = Yi.indexOf(".")) > -1 && (Yi = Yi.replace(".", "")), (ta = Yi.search(/e/i)) > 0 ? (ea < 0 && (ea = ta), ea += +Yi.slice(ta + 1), Yi = Yi.substring(0, ta)) : ea < 0 && (ea = Yi.length), ta = 0; Yi.charCodeAt(ta) === 48; ta++);
	for (na = Yi.length; Yi.charCodeAt(na - 1) === 48; --na);
	if (Yi = Yi.slice(ta, na), Yi) {
		if (na -= ta, ue.e = ea = ea - ta - 1, ue.d = [], ta = (ea + 1) % LOG_BASE, ea < 0 && (ta += LOG_BASE), ta < na) {
			for (ta && ue.d.push(+Yi.slice(0, ta)), na -= LOG_BASE; ta < na;) ue.d.push(+Yi.slice(ta, ta += LOG_BASE));
			Yi = Yi.slice(ta), ta = LOG_BASE - Yi.length
		} else ta -= na;
		for (; ta--;) Yi += "0";
		ue.d.push(+Yi), external && (ue.e > ue.constructor.maxE ? (ue.d = null, ue.e = NaN) : ue.e < ue.constructor.minE && (ue.e = 0, ue.d = [0]))
	} else ue.e = 0, ue.d = [0];
	return ue
}

function parseOther(ue, Yi) {
	var ea, ta, na, ra, ia, aa, oa, la, sa;
	if (Yi.indexOf("_") > -1) {
		if (Yi = Yi.replace(/(\d)_(?=\d)/g, "$1"), isDecimal.test(Yi)) return parseDecimal(ue, Yi)
	} else if (Yi === "Infinity" || Yi === "NaN") return +Yi || (ue.s = NaN), ue.e = NaN, ue.d = null, ue;
	if (isHex.test(Yi)) ea = 16, Yi = Yi.toLowerCase();
	else if (isBinary.test(Yi)) ea = 2;
	else if (isOctal.test(Yi)) ea = 8;
	else throw Error(invalidArgument + Yi);
	for (ra = Yi.search(/p/i), ra > 0 ? (oa = +Yi.slice(ra + 1), Yi = Yi.substring(2, ra)) : Yi = Yi.slice(2), ra = Yi.indexOf("."), ia = ra >= 0, ta = ue.constructor, ia && (Yi = Yi.replace(".", ""), aa = Yi.length, ra = aa - ra, na = intPow(ta, new ta(ea), ra, ra * 2)), la = convertBase(Yi, ea, BASE), sa = la.length - 1, ra = sa; la[ra] === 0; --ra) la.pop();
	return ra < 0 ? new ta(ue.s * 0) : (ue.e = getBase10Exponent(la, sa), ue.d = la, external = !1, ia && (ue = divide(ue, na, aa * 4)), oa && (ue = ue.times(Math.abs(oa) < 54 ? mathpow(2, oa) : Decimal.pow(2, oa))), external = !0, ue)
}

function sine(ue, Yi) {
	var ea, ta = Yi.d.length;
	if (ta < 3) return Yi.isZero() ? Yi : taylorSeries(ue, 2, Yi, Yi);
	ea = 1.4 * Math.sqrt(ta), ea = ea > 16 ? 16 : ea | 0, Yi = Yi.times(1 / tinyPow(5, ea)), Yi = taylorSeries(ue, 2, Yi, Yi);
	for (var na, ra = new ue(5), ia = new ue(16), aa = new ue(20); ea--;) na = Yi.times(Yi), Yi = Yi.times(ra.plus(na.times(ia.times(na).minus(aa))));
	return Yi
}

function taylorSeries(ue, Yi, ea, ta, na) {
	var ra, ia, aa, oa, la = ue.precision,
		sa = Math.ceil(la / LOG_BASE);
	for (external = !1, oa = ea.times(ea), aa = new ue(ta);;) {
		if (ia = divide(aa.times(oa), new ue(Yi++ * Yi++), la, 1), aa = na ? ta.plus(ia) : ta.minus(ia), ta = divide(ia.times(oa), new ue(Yi++ * Yi++), la, 1), ia = aa.plus(ta), ia.d[sa] !== void 0) {
			for (ra = sa; ia.d[ra] === aa.d[ra] && ra--;);
			if (ra == -1) break
		}
		ra = aa, aa = ta, ta = ia, ia = ra
	}
	return external = !0, ia.d.length = sa + 1, ia
}

function tinyPow(ue, Yi) {
	for (var ea = ue; --Yi;) ea *= ue;
	return ea
}

function toLessThanHalfPi(ue, Yi) {
	var ea, ta = Yi.s < 0,
		na = getPi(ue, ue.precision, 1),
		ra = na.times(.5);
	if (Yi = Yi.abs(), Yi.lte(ra)) return quadrant = ta ? 4 : 1, Yi;
	if (ea = Yi.divToInt(na), ea.isZero()) quadrant = ta ? 3 : 2;
	else {
		if (Yi = Yi.minus(ea.times(na)), Yi.lte(ra)) return quadrant = isOdd(ea) ? ta ? 2 : 3 : ta ? 4 : 1, Yi;
		quadrant = isOdd(ea) ? ta ? 1 : 4 : ta ? 3 : 2
	}
	return Yi.minus(na).abs()
}

function toStringBinary(ue, Yi, ea, ta) {
	var na, ra, ia, aa, oa, la, sa, ca, ua, da = ue.constructor,
		ha = ea !== void 0;
	if (ha ? (checkInt32(ea, 1, MAX_DIGITS), ta === void 0 ? ta = da.rounding : checkInt32(ta, 0, 8)) : (ea = da.precision, ta = da.rounding), !ue.isFinite()) sa = nonFiniteToString(ue);
	else {
		for (sa = finiteToString(ue), ia = sa.indexOf("."), ha ? (na = 2, Yi == 16 ? ea = ea * 4 - 3 : Yi == 8 && (ea = ea * 3 - 2)) : na = Yi, ia >= 0 && (sa = sa.replace(".", ""), ua = new da(1), ua.e = sa.length - ia, ua.d = convertBase(finiteToString(ua), 10, na), ua.e = ua.d.length), ca = convertBase(sa, 10, na), ra = oa = ca.length; ca[--oa] == 0;) ca.pop();
		if (!ca[0]) sa = ha ? "0p+0" : "0";
		else {
			if (ia < 0 ? ra-- : (ue = new da(ue), ue.d = ca, ue.e = ra, ue = divide(ue, ua, ea, ta, 0, na), ca = ue.d, ra = ue.e, la = inexact), ia = ca[ea], aa = na / 2, la = la || ca[ea + 1] !== void 0, la = ta < 4 ? (ia !== void 0 || la) && (ta === 0 || ta === (ue.s < 0 ? 3 : 2)) : ia > aa || ia === aa && (ta === 4 || la || ta === 6 && ca[ea - 1] & 1 || ta === (ue.s < 0 ? 8 : 7)), ca.length = ea, la)
				for (; ++ca[--ea] > na - 1;) ca[ea] = 0, ea || (++ra, ca.unshift(1));
			for (oa = ca.length; !ca[oa - 1]; --oa);
			for (ia = 0, sa = ""; ia < oa; ia++) sa += NUMERALS.charAt(ca[ia]);
			if (ha) {
				if (oa > 1)
					if (Yi == 16 || Yi == 8) {
						for (ia = Yi == 16 ? 4 : 3, --oa; oa % ia; oa++) sa += "0";
						for (ca = convertBase(sa, na, Yi), oa = ca.length; !ca[oa - 1]; --oa);
						for (ia = 1, sa = "1."; ia < oa; ia++) sa += NUMERALS.charAt(ca[ia])
					} else sa = sa.charAt(0) + "." + sa.slice(1);
				sa = sa + (ra < 0 ? "p" : "p+") + ra
			} else if (ra < 0) {
				for (; ++ra;) sa = "0" + sa;
				sa = "0." + sa
			} else if (++ra > oa)
				for (ra -= oa; ra--;) sa += "0";
			else ra < oa && (sa = sa.slice(0, ra) + "." + sa.slice(ra))
		}
		sa = (Yi == 16 ? "0x" : Yi == 2 ? "0b" : Yi == 8 ? "0o" : "") + sa
	}
	return ue.s < 0 ? "-" + sa : sa
}

function truncate$1(ue, Yi) {
	if (ue.length > Yi) return ue.length = Yi, !0
}

function abs(ue) {
	return new this(ue).abs()
}

function acos(ue) {
	return new this(ue).acos()
}

function acosh(ue) {
	return new this(ue).acosh()
}

function add(ue, Yi) {
	return new this(ue).plus(Yi)
}

function asin(ue) {
	return new this(ue).asin()
}

function asinh(ue) {
	return new this(ue).asinh()
}

function atan(ue) {
	return new this(ue).atan()
}

function atanh(ue) {
	return new this(ue).atanh()
}

function atan2(ue, Yi) {
	ue = new this(ue), Yi = new this(Yi);
	var ea, ta = this.precision,
		na = this.rounding,
		ra = ta + 4;
	return !ue.s || !Yi.s ? ea = new this(NaN) : !ue.d && !Yi.d ? (ea = getPi(this, ra, 1).times(Yi.s > 0 ? .25 : .75), ea.s = ue.s) : !Yi.d || ue.isZero() ? (ea = Yi.s < 0 ? getPi(this, ta, na) : new this(0), ea.s = ue.s) : !ue.d || Yi.isZero() ? (ea = getPi(this, ra, 1).times(.5), ea.s = ue.s) : Yi.s < 0 ? (this.precision = ra, this.rounding = 1, ea = this.atan(divide(ue, Yi, ra, 1)), Yi = getPi(this, ra, 1), this.precision = ta, this.rounding = na, ea = ue.s < 0 ? ea.minus(Yi) : ea.plus(Yi)) : ea = this.atan(divide(ue, Yi, ra, 1)), ea
}

function cbrt(ue) {
	return new this(ue).cbrt()
}

function ceil(ue) {
	return finalise(ue = new this(ue), ue.e + 1, 2)
}

function clamp(ue, Yi, ea) {
	return new this(ue).clamp(Yi, ea)
}

function config(ue) {
	if (!ue || typeof ue != "object") throw Error(decimalError + "Object expected");
	var Yi, ea, ta, na = ue.defaults === !0,
		ra = ["precision", 1, MAX_DIGITS, "rounding", 0, 8, "toExpNeg", -EXP_LIMIT, 0, "toExpPos", 0, EXP_LIMIT, "maxE", 0, EXP_LIMIT, "minE", -EXP_LIMIT, 0, "modulo", 0, 9];
	for (Yi = 0; Yi < ra.length; Yi += 3)
		if (ea = ra[Yi], na && (this[ea] = DEFAULTS[ea]), (ta = ue[ea]) !== void 0)
			if (mathfloor(ta) === ta && ta >= ra[Yi + 1] && ta <= ra[Yi + 2]) this[ea] = ta;
			else throw Error(invalidArgument + ea + ": " + ta);
	if (ea = "crypto", na && (this[ea] = DEFAULTS[ea]), (ta = ue[ea]) !== void 0)
		if (ta === !0 || ta === !1 || ta === 0 || ta === 1)
			if (ta)
				if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) this[ea] = !0;
				else throw Error(cryptoUnavailable);
	else this[ea] = !1;
	else throw Error(invalidArgument + ea + ": " + ta);
	return this
}

function cos(ue) {
	return new this(ue).cos()
}

function cosh(ue) {
	return new this(ue).cosh()
}

function clone(ue) {
	var Yi, ea, ta;

	function na(ra) {
		var ia, aa, oa, la = this;
		if (!(la instanceof na)) return new na(ra);
		if (la.constructor = na, isDecimalInstance(ra)) {
			la.s = ra.s, external ? !ra.d || ra.e > na.maxE ? (la.e = NaN, la.d = null) : ra.e < na.minE ? (la.e = 0, la.d = [0]) : (la.e = ra.e, la.d = ra.d.slice()) : (la.e = ra.e, la.d = ra.d ? ra.d.slice() : ra.d);
			return
		}
		if (oa = typeof ra, oa === "number") {
			if (ra === 0) {
				la.s = 1 / ra < 0 ? -1 : 1, la.e = 0, la.d = [0];
				return
			}
			if (ra < 0 ? (ra = -ra, la.s = -1) : la.s = 1, ra === ~~ra && ra < 1e7) {
				for (ia = 0, aa = ra; aa >= 10; aa /= 10) ia++;
				external ? ia > na.maxE ? (la.e = NaN, la.d = null) : ia < na.minE ? (la.e = 0, la.d = [0]) : (la.e = ia, la.d = [ra]) : (la.e = ia, la.d = [ra]);
				return
			} else if (ra * 0 !== 0) {
				ra || (la.s = NaN), la.e = NaN, la.d = null;
				return
			}
			return parseDecimal(la, ra.toString())
		} else if (oa !== "string") throw Error(invalidArgument + ra);
		return (aa = ra.charCodeAt(0)) === 45 ? (ra = ra.slice(1), la.s = -1) : (aa === 43 && (ra = ra.slice(1)), la.s = 1), isDecimal.test(ra) ? parseDecimal(la, ra) : parseOther(la, ra)
	}
	if (na.prototype = P$1, na.ROUND_UP = 0, na.ROUND_DOWN = 1, na.ROUND_CEIL = 2, na.ROUND_FLOOR = 3, na.ROUND_HALF_UP = 4, na.ROUND_HALF_DOWN = 5, na.ROUND_HALF_EVEN = 6, na.ROUND_HALF_CEIL = 7, na.ROUND_HALF_FLOOR = 8, na.EUCLID = 9, na.config = na.set = config, na.clone = clone, na.isDecimal = isDecimalInstance, na.abs = abs, na.acos = acos, na.acosh = acosh, na.add = add, na.asin = asin, na.asinh = asinh, na.atan = atan, na.atanh = atanh, na.atan2 = atan2, na.cbrt = cbrt, na.ceil = ceil, na.clamp = clamp, na.cos = cos, na.cosh = cosh, na.div = div, na.exp = exp, na.floor = floor, na.hypot = hypot, na.ln = ln$1, na.log = log$1, na.log10 = log10, na.log2 = log2, na.max = max, na.min = min, na.mod = mod, na.mul = mul, na.pow = pow, na.random = random, na.round = round, na.sign = sign, na.sin = sin, na.sinh = sinh, na.sqrt = sqrt, na.sub = sub, na.sum = sum, na.tan = tan, na.tanh = tanh, na.trunc = trunc, ue === void 0 && (ue = {}), ue && ue.defaults !== !0)
		for (ta = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], Yi = 0; Yi < ta.length;) ue.hasOwnProperty(ea = ta[Yi++]) || (ue[ea] = this[ea]);
	return na.config(ue), na
}

function div(ue, Yi) {
	return new this(ue).div(Yi)
}

function exp(ue) {
	return new this(ue).exp()
}

function floor(ue) {
	return finalise(ue = new this(ue), ue.e + 1, 3)
}

function hypot() {
	var ue, Yi, ea = new this(0);
	for (external = !1, ue = 0; ue < arguments.length;)
		if (Yi = new this(arguments[ue++]), Yi.d) ea.d && (ea = ea.plus(Yi.times(Yi)));
		else {
			if (Yi.s) return external = !0, new this(1 / 0);
			ea = Yi
		} return external = !0, ea.sqrt()
}

function isDecimalInstance(ue) {
	return ue instanceof Decimal || ue && ue.toStringTag === tag || !1
}

function ln$1(ue) {
	return new this(ue).ln()
}

function log$1(ue, Yi) {
	return new this(ue).log(Yi)
}

function log2(ue) {
	return new this(ue).log(2)
}

function log10(ue) {
	return new this(ue).log(10)
}

function max() {
	return maxOrMin(this, arguments, "lt")
}

function min() {
	return maxOrMin(this, arguments, "gt")
}

function mod(ue, Yi) {
	return new this(ue).mod(Yi)
}

function mul(ue, Yi) {
	return new this(ue).mul(Yi)
}

function pow(ue, Yi) {
	return new this(ue).pow(Yi)
}

function random(ue) {
	var Yi, ea, ta, na, ra = 0,
		ia = new this(1),
		aa = [];
	if (ue === void 0 ? ue = this.precision : checkInt32(ue, 1, MAX_DIGITS), ta = Math.ceil(ue / LOG_BASE), this.crypto)
		if (crypto.getRandomValues)
			for (Yi = crypto.getRandomValues(new Uint32Array(ta)); ra < ta;) na = Yi[ra], na >= 429e7 ? Yi[ra] = crypto.getRandomValues(new Uint32Array(1))[0] : aa[ra++] = na % 1e7;
		else if (crypto.randomBytes) {
		for (Yi = crypto.randomBytes(ta *= 4); ra < ta;) na = Yi[ra] + (Yi[ra + 1] << 8) + (Yi[ra + 2] << 16) + ((Yi[ra + 3] & 127) << 24), na >= 214e7 ? crypto.randomBytes(4).copy(Yi, ra) : (aa.push(na % 1e7), ra += 4);
		ra = ta / 4
	} else throw Error(cryptoUnavailable);
	else
		for (; ra < ta;) aa[ra++] = Math.random() * 1e7 | 0;
	for (ta = aa[--ra], ue %= LOG_BASE, ta && ue && (na = mathpow(10, LOG_BASE - ue), aa[ra] = (ta / na | 0) * na); aa[ra] === 0; ra--) aa.pop();
	if (ra < 0) ea = 0, aa = [0];
	else {
		for (ea = -1; aa[0] === 0; ea -= LOG_BASE) aa.shift();
		for (ta = 1, na = aa[0]; na >= 10; na /= 10) ta++;
		ta < LOG_BASE && (ea -= LOG_BASE - ta)
	}
	return ia.e = ea, ia.d = aa, ia
}

function round(ue) {
	return finalise(ue = new this(ue), ue.e + 1, this.rounding)
}

function sign(ue) {
	return ue = new this(ue), ue.d ? ue.d[0] ? ue.s : 0 * ue.s : ue.s || NaN
}

function sin(ue) {
	return new this(ue).sin()
}

function sinh(ue) {
	return new this(ue).sinh()
}

function sqrt(ue) {
	return new this(ue).sqrt()
}

function sub(ue, Yi) {
	return new this(ue).sub(Yi)
}

function sum() {
	var ue = 0,
		Yi = arguments,
		ea = new this(Yi[ue]);
	for (external = !1; ea.s && ++ue < Yi.length;) ea = ea.plus(Yi[ue]);
	return external = !0, finalise(ea, this.precision, this.rounding)
}

function tan(ue) {
	return new this(ue).tan()
}

function tanh(ue) {
	return new this(ue).tanh()
}

function trunc(ue) {
	return finalise(ue = new this(ue), ue.e + 1, 1)
}
P$1[Symbol.for("nodejs.util.inspect.custom")] = P$1.toString;
P$1[Symbol.toStringTag] = "Decimal";
var Decimal = P$1.constructor = clone(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
const getDecimal = ue => {
		try {
			const Yi = new Decimal(ue);
			return Yi.isNaN() ? void 0 : Yi
		} catch {
			return
		}
	},
	_joinParts = (ue, Yi) => `${ue||"0"}.${Yi||"0"}`,
	sanitizeFloatLine = ue => {
		ue = ue.replace(/[^\d.-]/g, "");
		const Yi = ue.startsWith("-");
		ue = ue.replaceAll("-", "").replace(".", " ").replaceAll(".", "").replace(" ", ".");
		let [ea, ta] = ue.split(".");
		ea && (ea = ea.replace(/^0+/g, "")), ta && (ta = ta.replace(/0+$/g, ""));
		const na = _joinParts(ea, ta);
		return Yi ? `-${na}` : na
	},
	formatFloatLine = (ue, Yi) => {
		typeof ue == "number" && (ue = ue.toString()), ue instanceof Decimal && (ue = ue.toString()), ue = sanitizeFloatLine(ue), ue = (Yi == null ? void 0 : Yi.accuracy) === void 0 ? ue : Yi.rounding ? new Decimal(ue).toFixed(Yi.accuracy, Yi.rounding) : new Decimal(ue).toFixed(Yi.accuracy);
		const ea = ue.startsWith("-"),
			ta = ue.replace("-", "").split("."),
			na = ta[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
		if (ta[1] === void 0) return ea ? `-${na}` : na;
		const ra = _joinParts(na, ta[1]);
		return ea ? `-${ra}` : ra
	},
	formatBp = (ue, Yi) => formatFloatLine(ue, {
		accuracy: Yi ?? 0,
		rounding: Decimal.ROUND_DOWN
	}),
	trimTrailingZeroes = ue => {
		const [Yi, ea] = ue.split(".");
		if (!ea) return ue;
		const ta = ea.replace(/0+$/g, "");
		return ta ? [Yi, ta].join(".") : Yi
	},
	getFiatFromSymbol = ue => {
		switch (ue.toUpperCase().trim()) {
			case "USD":
				return {
					letter: "$"
				}
		}
	},
	getWalletAmount = (ue, Yi) => {
		const ea = ca => ra ? `${ra.letter}${ca}` : `${ca} ${Yi}`,
			ta = ca => h$2("span", {
				class: "service"
			}, ca),
			na = ca => ra ? h$2("span", [ta(ra.letter), ca]) : h$2("span", [ca, " ", ta(Yi)]),
			ra = getFiatFromSymbol(Yi),
			ia = formatFloatLine(ue),
			aa = formatFloatLine(ue, {
				accuracy: 2,
				rounding: Decimal.ROUND_DOWN
			}),
			oa = ue.isZero() ? "0" : ue.lessThan(.01) ? "<0.01" : trimTrailingZeroes(aa),
			la = ue.isZero() ? ea("0") : ue.lessThan(.01) ? ra ? `<${ra.letter}0.01` : `<0.01 ${Yi}` : ea(trimTrailingZeroes(aa)),
			sa = ue.isZero() ? na("0") : ue.lessThan(.01) ? ra ? h$2("span", [ta(`<${ra.letter}`), "0.01"]) : h$2("span", [ta("<"), "0.01", " ", ta(Yi)]) : na(trimTrailingZeroes(aa));
		return {
			value: ue,
			backend: ia,
			backendWithSymbol: ea(ia),
			frontend: aa,
			frontendWithSymbol: ea(aa),
			default: oa,
			defaultWithSymbol: la,
			defaultH: sa
		}
	};
var __defProp$b = Object.defineProperty,
	__getOwnPropDesc$8 = Object.getOwnPropertyDescriptor,
	__decorateClass$b = (ue, Yi, ea, ta) => {
		for (var na = ta > 1 ? void 0 : ta ? __getOwnPropDesc$8(Yi, ea) : Yi, ra = ue.length - 1, ia; ra >= 0; ra--)(ia = ue[ra]) && (na = (ta ? ia(Yi, ea, na) : ia(na)) || na);
		return ta && na && __defProp$b(Yi, ea, na), na
	};
const transform$1 = (ue, Yi) => {
		const ea = plainToInstance(ue, Yi, {
			strategy: "excludeAll"
		});
		return (Array.isArray(ea) ? ea : [ea]).forEach(na => {
			const ra = validateSync(na, ue);
			if (ra.length !== 0) throw err("Invalid DTO", ra)
		}), ea
	},
	Default = ue => Transform(({
		value: Yi
	}) => Yi ?? ue),
	GetDecimal = () => Transform(({
		value: ue
	}) => getDecimal(ue)),
	GetNumber = () => Transform(({
		value: ue
	}) => ue == null ? void 0 : Number(ue)),
	NullToUndefined = () => Transform(({
		value: ue
	}) => ue === null ? void 0 : ue),
	PositiveIntegerOrUndefined = () => Transform(({
		value: ue
	}) => ue < 0 ? void 0 : ue),
	EmptyToUndefined = () => Transform(({
		value: ue
	}) => ue === "" ? void 0 : ue),
	isTONAddress = ue => {
		if (typeof ue != "string" || !ue) return !1;
		try {
			return dist$1.Address.parse(ue), !0
		} catch {
			return !1
		}
	};
let IsTONAddress = class {
	validate(ue) {
		return isTONAddress(ue)
	}
	defaultMessage() {
		return "Invalid TON address"
	}
};
IsTONAddress = __decorateClass$b([ValidatorConstraint()], IsTONAddress);
const axiosClient = axios.create();
axiosClient.interceptors.request.use(ue => {
	const Yi = useAuth().getters.getAccessToken.value;
	Yi && !ue._omitAuthHeader && ue.headers.set("Authorization", `Bearer ${Yi}`);
	const ea = useNuxtApp().$i18n.locale.value;
	return ue.headers.set("Lang", ea), ue
});
axiosClient.interceptors.response.use(ue => ue, async ue => {
	var ta;
	const Yi = ue.config,
		ea = (ta = ue.response) == null ? void 0 : ta.status;
	if (!ue.config._retry) {
		if (ea === void 0) return ue.config._retry = !0, axiosClient(ue.config);
		if (ea === 401 && !Yi._skipRetry) return await useAuth().setters.refreshUserToken() ? (ue.config._retry = !0, axiosClient(ue.config)) : Promise.reject(ue)
	}
	return Promise.reject(ue)
});
var SERVICE = (ue => (ue.GATEWAY = "GATEWAY", ue.GAME = "GAME", ue.WALLET = "WALLET", ue.SUBSCRIPTION = "SUBSCRIPTION", ue.TRIBE = "TRIBE", ue.USER = "USER", ue.EARN = "EARN", ue))(SERVICE || {});
class DataClient {
	constructor() {
		Io(this, "gatewayBase");
		Io(this, "gameBase");
		Io(this, "walletBase");
		Io(this, "subscriptionBase");
		Io(this, "tribeBase");
		Io(this, "userBase");
		Io(this, "earnBase");
		if (this.gatewayBase = "https://gateway.blum.codes", typeof this.gatewayBase != "string" && !this.gatewayBase) throw new Error("VITE_GATEWAY_API is not set");
		if (this.gameBase = "https://game-domain.blum.codes", typeof this.gameBase != "string" && !this.gameBase) throw new Error("VITE_GAME_API is not set");
		if (this.walletBase = "https://wallet-domain.blum.codes", typeof this.walletBase != "string" && !this.walletBase) throw new Error("VITE_WALLET_API is not set");
		if (this.subscriptionBase = "https://subscription.blum.codes", typeof this.subscriptionBase != "string" && !this.subscriptionBase) throw new Error("VITE_SUBSCRIPTION_API is not set");
		if (this.tribeBase = "https://tribe-domain.blum.codes", typeof this.tribeBase != "string" && !this.tribeBase) throw new Error("VITE_TRIBE_API is not set");
		if (this.userBase = "https://user-domain.blum.codes", typeof this.userBase != "string" && !this.userBase) throw new Error("VITE_USER_API is not set");
		if (this.earnBase = "https://earn-domain.blum.codes", typeof this.earnBase != "string" && !this.earnBase) throw new Error("VITE_EARN_API is not set")
	}
	buildUrl(Yi, ea) {
		const ta = Yi.v ?? 1;
		let na = (() => {
			switch (Yi.service) {
				case "GATEWAY":
					return `${this.gatewayBase}/v${ta}${Yi.url}`;
				case "GAME":
					return `${this.gameBase}/api/v${ta}${Yi.url}`;
				case "WALLET":
					return `${this.walletBase}/api/v${ta}${Yi.url}`;
				case "SUBSCRIPTION":
					return `${this.subscriptionBase}${Yi.url}`;
				case "TRIBE":
					return `${this.tribeBase}/api/v${ta}${Yi.url}`;
				case "USER":
					return `${this.userBase}/api/v${ta}${Yi.url}`;
				case "EARN":
					return `${this.earnBase}/api/v${ta}${Yi.url}`;
				default:
					throw Yi.service, err("Unknown service")
			}
		})();
		if (ea) {
			const ra = `pageSize=${ea.pageSize}`;
			na += na.includes("?") ? `&${ra}` : `?${ra}`
		}
		return na
	}
	async get(Yi, ea, ta, na) {
		var ra, ia, aa;
		try {
			const oa = this.buildUrl(Yi, na == null ? void 0 : na.pagination),
				la = await axiosClient(oa, na);
			return {
				err: !1,
				data: (() => {
					if (!la.data) throw err("No data");
					return transform$1(ea, la.data)
				})()
			}
		} catch (oa) {
			return oa instanceof AxiosError ? {
				err: !0,
				code: (ra = oa.response) == null ? void 0 : ra.status,
				message: (ia = oa.response) == null ? void 0 : ia.data.message,
				data: (aa = oa.response) == null ? void 0 : aa.data
			} : {
				err: !0
			}
		}
	}
	async post(Yi, ea, ta, na) {
		var ra, ia, aa;
		try {
			const oa = this.buildUrl(Yi, na == null ? void 0 : na.pagination),
				la = (() => {
					if (ea) return ea.cls ? transform$1(ea.cls, ea.body) : ea.body
				})(),
				sa = await axiosClient.post(oa, la, na);
			return {
				err: !1,
				data: (() => {
					if (ta !== void 0) {
						if (!sa.data) throw err("No data");
						return transform$1(ta, sa.data)
					}
				})()
			}
		} catch (oa) {
			return oa instanceof AxiosError ? {
				err: !0,
				code: (ra = oa.response) == null ? void 0 : ra.status,
				message: (ia = oa.response) == null ? void 0 : ia.data.message,
				data: (aa = oa.response) == null ? void 0 : aa.data
			} : {
				err: !0
			}
		}
	}
	async delete(Yi, ea) {
		var ta, na, ra;
		try {
			const ia = this.buildUrl(Yi, ea == null ? void 0 : ea.pagination);
			return await axiosClient.delete(ia, ea), {
				err: !1,
				data: void 0
			}
		} catch (ia) {
			return ia instanceof AxiosError ? {
				err: !0,
				code: (ta = ia.response) == null ? void 0 : ta.status,
				message: (na = ia.response) == null ? void 0 : na.data.message,
				data: (ra = ia.response) == null ? void 0 : ra.data
			} : {
				err: !0
			}
		}
	}
}
const dataClient = new DataClient;
var __defProp$a = Object.defineProperty,
	__getOwnPropDesc$7 = Object.getOwnPropertyDescriptor,
	__decorateClass$a = (ue, Yi, ea, ta) => {
		for (var na = ta > 1 ? void 0 : ta ? __getOwnPropDesc$7(Yi, ea) : Yi, ra = ue.length - 1, ia; ra >= 0; ra--)(ia = ue[ra]) && (na = (ta ? ia(Yi, ea, na) : ia(na)) || na);
		return ta && na && __defProp$a(Yi, ea, na), na
	};
const getFileUrl = ue => ue.startsWith("https://") || ue.startsWith("http://") ? ue : `${useRuntimeConfig().public.UPLOADER_URL}/${ue}`;
class FileUploadResponse {
	constructor() {
		Io(this, "key")
	}
	get url() {
		return getFileUrl(this.key)
	}
}
__decorateClass$a([Expose(), IsString()], FileUploadResponse.prototype, "key", 2);
__decorateClass$a([Expose()], FileUploadResponse.prototype, "url", 1);
const getFirstPrintableSymbol = ue => {
		if (ue.length === 0) return;
		const Yi = ue.match(/[\p{L}\p{N}\p{P}\p{S}]/u);
		return Yi ? Yi[0] : void 0
	},
	capitalize$1 = ue => ue.charAt(0).toUpperCase() + ue.slice(1);
var __defProp$9 = Object.defineProperty,
	__getOwnPropDesc$6 = Object.getOwnPropertyDescriptor,
	__decorateClass$9 = (ue, Yi, ea, ta) => {
		for (var na = ta > 1 ? void 0 : ta ? __getOwnPropDesc$6(Yi, ea) : Yi, ra = ue.length - 1, ia; ra >= 0; ra--)(ia = ue[ra]) && (na = (ta ? ia(Yi, ea, na) : ia(na)) || na);
		return ta && na && __defProp$9(Yi, ea, na), na
	};
class FrensResponse {
	constructor() {
		Io(this, "username");
		Io(this, "totalFrens");
		Io(this, "farmBalance");
		Io(this, "_avatarFileKey")
	}
	get avatarUrl() {
		return this._avatarFileKey ? getFileUrl(this._avatarFileKey) : void 0
	}
	get letterAvatar() {
		var Yi;
		return (Yi = getFirstPrintableSymbol(this.username)) == null ? void 0 : Yi.toUpperCase()
	}
}
__decorateClass$9([Expose(), IsString()], FrensResponse.prototype, "username", 2);
__decorateClass$9([Expose({
	name: "totalFriends"
}), GetNumber(), IsNumber()], FrensResponse.prototype, "totalFrens", 2);
__decorateClass$9([Expose(), IsOptional(), IsString()], FrensResponse.prototype, "farmBalance", 2);
__decorateClass$9([Expose({
	name: "avatarFileKey"
}), IsOptional(), IsString()], FrensResponse.prototype, "_avatarFileKey", 2);
__decorateClass$9([Expose()], FrensResponse.prototype, "avatarUrl", 1);
__decorateClass$9([Expose()], FrensResponse.prototype, "letterAvatar", 1);
class FrensListResponse {
	constructor() {
		Io(this, "frens");
		Io(this, "nextPageToken")
	}
}
__decorateClass$9([Expose({
	name: "friends"
}), Type(() => FrensResponse), IsArray(), ValidateNested({
	each: !0
})], FrensListResponse.prototype, "frens", 2);
__decorateClass$9([Expose(), IsOptional(), IsString()], FrensListResponse.prototype, "nextPageToken", 2);
class FrensUsing {
	constructor() {
		Io(this, "usedInvitation");
		Io(this, "amountForClaim");
		Io(this, "referralToken");
		Io(this, "percentFromFriends");
		Io(this, "percentFromFriendsOfFriends");
		Io(this, "canClaim");
		Io(this, "canClaimAt")
	}
}
__decorateClass$9([Expose(), GetNumber(), IsNumber()], FrensUsing.prototype, "usedInvitation", 2);
__decorateClass$9([Expose(), GetDecimal(), IsNotEmptyObject()], FrensUsing.prototype, "amountForClaim", 2);
__decorateClass$9([Expose(), IsString()], FrensUsing.prototype, "referralToken", 2);
__decorateClass$9([Expose(), GetNumber(), IsNumber()], FrensUsing.prototype, "percentFromFriends", 2);
__decorateClass$9([Expose(), GetNumber(), IsNumber()], FrensUsing.prototype, "percentFromFriendsOfFriends", 2);
__decorateClass$9([Expose(), IsBoolean()], FrensUsing.prototype, "canClaim", 2);
__decorateClass$9([Expose(), IsOptional(), GetNumber(), IsNumber()], FrensUsing.prototype, "canClaimAt", 2);
class FrensClaim {
	constructor() {
		Io(this, "claimBalance")
	}
}
__decorateClass$9([Expose(), GetDecimal(), IsNotEmptyObject()], FrensClaim.prototype, "claimBalance", 2);
var TASK_ITEM_MODE = (ue => (ue.CARD = "card", ue.SHORT_CARD = "short-card", ue.LIST_ITEM = "list-item", ue))(TASK_ITEM_MODE || {}),
	TASK_PILL_MODE = (ue => (ue.DARK = "dark", ue.LIGHT = "light", ue))(TASK_PILL_MODE || {}),
	TASKS_CLAIM_OVERRIDE = (ue => (ue.LOADING = "LOADING", ue.DONE = "DONE", ue))(TASKS_CLAIM_OVERRIDE || {});
const isTaskFinished = (ue, Yi) => ue === TASK_STATUS.FINISHED && Yi === void 0,
	isTaskHasAction = (ue, Yi) => {
		const ea = Yi[ue.id];
		return !ue.status || ea !== void 0 ? !1 : ue.kind === TASK_KIND.GROUP ? !("subTasks" in ue) || !ue.subTasks ? !1 : ue.subTasks.some(ta => isTaskHasAction(ta, Yi)) : ue.kind === TASK_KIND.QUEST ? ue.status === TASK_STATUS.READY_FOR_CLAIM ? !0 : !("subTasks" in ue) || !ue.subTasks ? !1 : ue.subTasks.some(ta => isTaskHasAction(ta, Yi)) : ue.kind === TASK_KIND.ONGOING ? ue.status === TASK_STATUS.READY_FOR_CLAIM : [TASK_STATUS.READY_FOR_VERIFY, TASK_STATUS.READY_FOR_CLAIM].includes(ue.status)
	},
	isTaskStarted = ue => ue === TASK_STATUS.STARTED,
	isTaskHidden = ue => ue.id === "8b2324a1-931c-4061-81d7-f759f1653001";
var TASK_VERIFY_STATUS = (ue => (ue.UNKNOWN_ERROR = "UNKNOWN_ERROR", ue.WRONG_KEYWORD = "WRONG_KEYWORD", ue.SUCCESS = "SUCCESS", ue))(TASK_VERIFY_STATUS || {});
const isTaskHasSubtasks = ue => [TASK_KIND.QUEST, TASK_KIND.GROUP].includes(ue),
	sortTasks = (ue, Yi) => [...ue].sort((ea, ta) => {
		const na = isTaskFinished(ea.status, Yi[ea.id]),
			ra = isTaskFinished(ta.status, Yi[ta.id]);
		return na && !ra ? 1 : !na && ra ? -1 : 0
	}),
	getTasksSectionMode = ue => {
		switch (ue.sectionType) {
			case TASK_SECTION_TYPE.DEFAULT:
				return "list-item";
			case TASK_SECTION_TYPE.HIGHLIGHTS:
				return "card";
			case TASK_SECTION_TYPE.WEEKLY_ROUTINE:
				return "short-card";
			default:
				throw ue.sectionType, err("Unknown section type")
		}
	};
var __defProp$8 = Object.defineProperty,
	__decorateClass$8 = (ue, Yi, ea, ta) => {
		for (var na = void 0, ra = ue.length - 1, ia; ra >= 0; ra--)(ia = ue[ra]) && (na = ia(Yi, ea, na) || na);
		return na && __defProp$8(Yi, ea, na), na
	},
	_a$1, _b$1, _c, _d;
class FarmingResponse {
	constructor() {
		Io(this, "balance");
		Io(this, "startTime");
		Io(this, "endTime");
		Io(this, "earningsRate")
	}
}
__decorateClass$8([Expose(), GetDecimal(), IsNotEmptyObject()], FarmingResponse.prototype, "balance");
__decorateClass$8([Expose(), IsInt()], FarmingResponse.prototype, "startTime");
__decorateClass$8([Expose(), IsInt()], FarmingResponse.prototype, "endTime");
__decorateClass$8([Expose(), GetDecimal(), IsNotEmptyObject()], FarmingResponse.prototype, "earningsRate");
class BalanceResponse {
	constructor() {
		Io(this, "availableBalance");
		Io(this, "playPasses");
		Io(this, "timestamp")
	}
}
__decorateClass$8([Expose(), GetDecimal(), IsNotEmptyObject()], BalanceResponse.prototype, "availableBalance");
__decorateClass$8([Expose(), IsInt()], BalanceResponse.prototype, "playPasses");
__decorateClass$8([Expose(), IsInt()], BalanceResponse.prototype, "timestamp");
class BalanceWithFarmingResponse extends BalanceResponse {
	constructor() {
		super(...arguments);
		Io(this, "farming");
		Io(this, "isFastFarmingEnabled")
	}
}
__decorateClass$8([Expose(), Type(() => FarmingResponse), IsOptional(), ValidateNested()], BalanceWithFarmingResponse.prototype, "farming");
__decorateClass$8([Expose(), Default(!1), IsBoolean()], BalanceWithFarmingResponse.prototype, "isFastFarmingEnabled");
class BackendTimeResponse {
	constructor() {
		Io(this, "now")
	}
}
__decorateClass$8([Expose(), IsInt()], BackendTimeResponse.prototype, "now");
var TASK_TYPE = (ue => (ue.SOCIAL_MEDIA_CHECK = "SOCIAL_MEDIA_CHECK", ue.SOCIAL_SUBSCRIPTION = "SOCIAL_SUBSCRIPTION", ue.PROGRESS_TARGET = "PROGRESS_TARGET", ue.APPLICATION_LAUNCH = "APPLICATION_LAUNCH", ue.PARTNER_INTEGRATION = "PARTNER_INTEGRATION", ue.GROUPING_TASK = "GROUPING_TASK", ue.WALLET_CONNECTION = "WALLET_CONNECTION", ue.ONCHAIN_TRANSACTION = "ONCHAIN_TRANSACTION", ue.INTERNAL = "INTERNAL", ue.GROUP = "GROUP", ue))(TASK_TYPE || {}),
	TASK_STATUS = (ue => (ue.NOT_STARTED = "NOT_STARTED", ue.STARTED = "STARTED", ue.READY_FOR_VERIFY = "READY_FOR_VERIFY", ue.READY_FOR_CLAIM = "READY_FOR_CLAIM", ue.FINISHED = "FINISHED", ue))(TASK_STATUS || {}),
	TASK_KIND = (ue => (ue.INITIAL = "INITIAL", ue.ONGOING = "ONGOING", ue.QUEST = "QUEST", ue.ROUTINE = "ROUTINE", ue.GROUP = "GROUP", ue))(TASK_KIND || {}),
	TASK_VALIDATION_TYPE = (ue => (ue.DEFAULT = "DEFAULT", ue.KEYWORD = "KEYWORD", ue))(TASK_VALIDATION_TYPE || {}),
	TASK_SECTION_TYPE = (ue => (ue.DEFAULT = "DEFAULT", ue.WEEKLY_ROUTINE = "WEEKLY_ROUTINE", ue.HIGHLIGHTS = "HIGHLIGHTS", ue))(TASK_SECTION_TYPE || {});
class TaskSocialSubscription {
	constructor() {
		Io(this, "url");
		Io(this, "openInTelegram")
	}
}
__decorateClass$8([Expose(), IsString()], TaskSocialSubscription.prototype, "url");
__decorateClass$8([Expose(), IsBoolean()], TaskSocialSubscription.prototype, "openInTelegram");
class TaskOnchainTransaction {
	constructor() {
		Io(this, "amount");
		Io(this, "address")
	}
}
__decorateClass$8([Expose(), Default("0.05"), GetDecimal(), IsNotEmptyObject()], TaskOnchainTransaction.prototype, "amount");
__decorateClass$8([Expose(), Default("0:3d9cdbd448b01e6c9c73847bf9b313162bf457af19383185d1dfd24c6eabeb73"), Validate(IsTONAddress)], TaskOnchainTransaction.prototype, "address");
class TaskProgressTarget {
	constructor() {
		Io(this, "progress");
		Io(this, "target");
		Io(this, "accuracy");
		Io(this, "postfix")
	}
}
__decorateClass$8([Expose(), GetDecimal(), IsNotEmptyObject()], TaskProgressTarget.prototype, "progress");
__decorateClass$8([Expose(), GetDecimal(), IsNotEmptyObject()], TaskProgressTarget.prototype, "target");
__decorateClass$8([Expose(), Default(1), IsNumber()], TaskProgressTarget.prototype, "accuracy");
__decorateClass$8([Expose(), IsOptional(), IsString()], TaskProgressTarget.prototype, "postfix");
class TaskApplicationLaunch {
	constructor() {
		Io(this, "url")
	}
}
__decorateClass$8([Expose(), IsString()], TaskApplicationLaunch.prototype, "url");
class TaskBase {
	constructor() {
		Io(this, "id");
		Io(this, "type");
		Io(this, "kind");
		Io(this, "status");
		Io(this, "reward");
		Io(this, "title");
		Io(this, "iconFileKey");
		Io(this, "isDisclaimerRequired");
		Io(this, "productName");
		Io(this, "validationType");
		Io(this, "socialSubscription");
		Io(this, "progressTarget");
		Io(this, "applicationLaunch");
		Io(this, "onchainTransaction")
	}
}
__decorateClass$8([Expose(), IsString()], TaskBase.prototype, "id");
__decorateClass$8([Expose(), IsEnum(TASK_TYPE)], TaskBase.prototype, "type");
__decorateClass$8([Expose(), IsEnum(TASK_KIND)], TaskBase.prototype, "kind");
__decorateClass$8([Expose(), IsOptional(), IsEnum(TASK_STATUS)], TaskBase.prototype, "status");
__decorateClass$8([Expose(), GetDecimal(), IsNotEmptyObject()], TaskBase.prototype, "reward");
__decorateClass$8([Expose(), IsString()], TaskBase.prototype, "title");
__decorateClass$8([Expose(), IsString()], TaskBase.prototype, "iconFileKey");
__decorateClass$8([Expose(), IsOptional(), IsBoolean()], TaskBase.prototype, "isDisclaimerRequired");
__decorateClass$8([Expose(), IsOptional(), IsString()], TaskBase.prototype, "productName");
__decorateClass$8([Expose(), EmptyToUndefined(), Default("DEFAULT"), IsEnum(TASK_VALIDATION_TYPE)], TaskBase.prototype, "validationType");
__decorateClass$8([Expose(), Type(() => TaskSocialSubscription), ValidateIf(ue => ["SOCIAL_MEDIA_CHECK", "SOCIAL_SUBSCRIPTION"].includes(ue.type)), ValidateNested()], TaskBase.prototype, "socialSubscription");
__decorateClass$8([Expose(), Type(() => TaskProgressTarget), ValidateIf(ue => ue.type === "PROGRESS_TARGET"), ValidateNested()], TaskBase.prototype, "progressTarget");
__decorateClass$8([Expose(), Type(() => TaskApplicationLaunch), ValidateIf(ue => ue.type === "APPLICATION_LAUNCH"), ValidateNested()], TaskBase.prototype, "applicationLaunch");
__decorateClass$8([Expose(), Transform(ue => {
	if (ue.obj.onchainTransaction) return ue.obj.onchainTransaction;
	if (ue.obj.type === "ONCHAIN_TRANSACTION") return plainToInstance(TaskOnchainTransaction, {})
}), Type(() => TaskOnchainTransaction), ValidateIf(ue => ue.type === "ONCHAIN_TRANSACTION"), ValidateNested()], TaskBase.prototype, "onchainTransaction");
class Task extends TaskBase {
	constructor() {
		super(...arguments);
		Io(this, "bannerFileKey");
		Io(this, "description");
		Io(this, "subTasks");
		Io(this, "color")
	}
}
__decorateClass$8([Expose(), IsOptional(), IsString()], Task.prototype, "bannerFileKey");
__decorateClass$8([Expose(), IsOptional(), IsString()], Task.prototype, "description");
__decorateClass$8([Expose(), Type(() => TaskBase), ValidateIf(ue => isTaskHasSubtasks(ue.kind)), ValidateNested({
	each: !0
})], Task.prototype, "subTasks");
__decorateClass$8([Expose(), IsOptional(), IsString()], Task.prototype, "color");
class TasksSubSection {
	constructor() {
		Io(this, "title");
		Io(this, "tasks")
	}
}
__decorateClass$8([Expose(), IsString()], TasksSubSection.prototype, "title");
__decorateClass$8([Expose(), Type(() => Task), IsArray(), ValidateNested({
	each: !0
})], TasksSubSection.prototype, "tasks");
class TasksSection {
	constructor() {
		Io(this, "title");
		Io(this, "description");
		Io(this, "tasks");
		Io(this, "subSections");
		Io(this, "sectionType")
	}
}
__decorateClass$8([Expose(), IsString(), IsOptional()], TasksSection.prototype, "title");
__decorateClass$8([Expose(), IsString(), IsOptional()], TasksSection.prototype, "description");
__decorateClass$8([Expose(), Type(() => Task), IsArray(), ValidateNested({
	each: !0
})], TasksSection.prototype, "tasks");
__decorateClass$8([Expose(), Type(() => TasksSubSection), IsArray(), ValidateNested({
	each: !0
})], TasksSection.prototype, "subSections");
__decorateClass$8([Expose(), IsString(), IsEnum(TASK_SECTION_TYPE)], TasksSection.prototype, "sectionType");
class DailyRewardReward {
	constructor() {
		Io(this, "passes");
		Io(this, "points")
	}
}
__decorateClass$8([Expose(), IsInt()], DailyRewardReward.prototype, "passes");
__decorateClass$8([Expose(), GetDecimal(), IsNotEmptyObject()], DailyRewardReward.prototype, "points");
class DailyRewardDay {
	constructor() {
		Io(this, "ordinal");
		Io(this, "reward")
	}
}
__decorateClass$8([Expose(), IsInt()], DailyRewardDay.prototype, "ordinal");
__decorateClass$8([Expose(), Type(() => DailyRewardReward), IsNotEmptyObject(), ValidateNested()], DailyRewardDay.prototype, "reward");
class DailyReward {
	constructor() {
		Io(this, "countInRow");
		Io(this, "days")
	}
}
__decorateClass$8([Expose(), IsOptional(), IsInt()], DailyReward.prototype, "countInRow");
__decorateClass$8([Expose(), Type(() => DailyRewardDay), IsArray(), ArrayMinSize(4), ArrayMaxSize(4), ValidateNested({
	each: !0
})], DailyReward.prototype, "days");
var GAME_ASSETS_TYPE = (ue => (ue.CLOVER = "CLOVER", ue.FREEZE = "FREEZE", ue.BOMB = "BOMB", ue.DOGS = "DOGS", ue))(GAME_ASSETS_TYPE || {});
class GameAssetPropertiesBase {
	constructor() {
		Io(this, "probability")
	}
}
__decorateClass$8([Expose(), GetNumber(), IsNumber()], GameAssetPropertiesBase.prototype, "probability");
class GameAssetPropertiesClickable extends GameAssetPropertiesBase {
	constructor() {
		super(...arguments);
		Io(this, "perClick")
	}
}
__decorateClass$8([Expose(), GetNumber(), IsInt()], GameAssetPropertiesClickable.prototype, "perClick");
var Ws, Gs, zs, Zs;
Zs = _d = "CLOVER", zs = _c = "BOMB", Gs = _b$1 = "FREEZE", Ws = _a$1 = "DOGS";
class GameAssetsProperties {
	constructor() {
		Io(this, Zs);
		Io(this, zs);
		Io(this, Gs);
		Io(this, Ws)
	}
}
__decorateClass$8([Expose(), Type(() => GameAssetPropertiesClickable), IsNotEmptyObject(), ValidateNested()], GameAssetsProperties.prototype, _d);
__decorateClass$8([Expose(), Type(() => GameAssetPropertiesBase), IsNotEmptyObject(), ValidateNested()], GameAssetsProperties.prototype, _c);
__decorateClass$8([Expose(), Type(() => GameAssetPropertiesBase), IsNotEmptyObject(), ValidateNested()], GameAssetsProperties.prototype, _b$1);
__decorateClass$8([Expose(), Type(() => GameAssetPropertiesClickable), ValidateNested(), IsOptional()], GameAssetsProperties.prototype, _a$1);
class PlayResponse {
	constructor() {
		Io(this, "gameId");
		Io(this, "assets")
	}
}
__decorateClass$8([Expose(), IsString()], PlayResponse.prototype, "gameId");
__decorateClass$8([Expose(), Type(() => GameAssetsProperties), IsNotEmptyObject(), ValidateNested()], PlayResponse.prototype, "assets");
class GameDropEligibility {
	constructor() {
		Io(this, "eligible")
	}
}
__decorateClass$8([Expose(), IsBoolean()], GameDropEligibility.prototype, "eligible");
var __defProp$7 = Object.defineProperty,
	__decorateClass$7 = (ue, Yi, ea, ta) => {
		for (var na = void 0, ra = ue.length - 1, ia; ra >= 0; ra--)(ia = ue[ra]) && (na = ia(Yi, ea, na) || na);
		return na && __defProp$7(Yi, ea, na), na
	};
class IDResponse {
	constructor() {
		Io(this, "id")
	}
}
__decorateClass$7([Expose(), Transform(({
	obj: ue
}) => {
	var Yi;
	return (Yi = ue == null ? void 0 : ue.id) == null ? void 0 : Yi.id
}), IsString()], IDResponse.prototype, "id");
class PaginationResponse {}
var __defProp$6 = Object.defineProperty,
	__getOwnPropDesc$5 = Object.getOwnPropertyDescriptor,
	__decorateClass$6 = (ue, Yi, ea, ta) => {
		for (var na = ta > 1 ? void 0 : ta ? __getOwnPropDesc$5(Yi, ea) : Yi, ra = ue.length - 1, ia; ra >= 0; ra--)(ia = ue[ra]) && (na = (ta ? ia(Yi, ea, na) : ia(na)) || na);
		return ta && na && __defProp$6(Yi, ea, na), na
	},
	TRIBE_MEMBER_ROLE = (ue => (ue.MEMBER = "MEMBER", ue.OWNER = "OWNER", ue))(TRIBE_MEMBER_ROLE || {}),
	TRIBE_CREATION_ERROR = (ue => (ue.NOT_ENOUGH_RIGHTS = "NOT_ENOUGH_RIGHTS", ue.CHAT_IS_NOT_FOUND = "CHAT_IS_NOT_FOUND", ue))(TRIBE_CREATION_ERROR || {}),
	TRIBE_USER_PERK = (ue => (ue.FARMING15 = "FARMING15", ue.FARMING10 = "FARMING10", ue))(TRIBE_USER_PERK || {});
class Tribe {
	constructor() {
		Io(this, "id");
		Io(this, "title");
		Io(this, "chatName");
		Io(this, "_avatarFileKey");
		Io(this, "defaultAvatar");
		Io(this, "earnBalance");
		Io(this, "countMembers");
		Io(this, "role")
	}
	getTelegramUrl() {
		return `https://t.me/${this.chatName}`
	}
	getAvatarUrl() {
		return this._avatarFileKey ? getFileUrl(this._avatarFileKey) : void 0
	}
	getIsEarnBalanceCalculating() {
		return this.earnBalance.isNegative()
	}
	getEarnBalanceOrCalculating() {
		return this.getIsEarnBalanceCalculating() ? "Calculating..." : formatBp(this.earnBalance) + " BP"
	}
}
__decorateClass$6([Expose(), IsString()], Tribe.prototype, "id", 2);
__decorateClass$6([Expose(), IsString()], Tribe.prototype, "title", 2);
__decorateClass$6([Expose({
	name: "chatname"
}), IsString()], Tribe.prototype, "chatName", 2);
__decorateClass$6([Expose()], Tribe.prototype, "getTelegramUrl", 1);
__decorateClass$6([Expose({
	name: "avatarFileKey"
}), IsOptional(), IsString()], Tribe.prototype, "_avatarFileKey", 2);
__decorateClass$6([Expose()], Tribe.prototype, "getAvatarUrl", 1);
__decorateClass$6([Expose(), IsNumber(), Transform(({
	value: ue
}) => ue >= 0 && ue <= 9 ? ue : 0)], Tribe.prototype, "defaultAvatar", 2);
__decorateClass$6([Expose(), GetDecimal(), IsNotEmptyObject()], Tribe.prototype, "earnBalance", 2);
__decorateClass$6([Expose()], Tribe.prototype, "getIsEarnBalanceCalculating", 1);
__decorateClass$6([Expose()], Tribe.prototype, "getEarnBalanceOrCalculating", 1);
__decorateClass$6([Expose(), IsInt()], Tribe.prototype, "countMembers", 2);
__decorateClass$6([Expose(), NullToUndefined(), IsOptional(), IsEnum(TRIBE_MEMBER_ROLE)], Tribe.prototype, "role", 2);
class TribeUserBase {
	constructor() {
		Io(this, "id");
		Io(this, "username");
		Io(this, "_avatarFileKey");
		Io(this, "earnedPoints");
		Io(this, "perk")
	}
}
__decorateClass$6([Expose(), IsString()], TribeUserBase.prototype, "id", 2);
__decorateClass$6([Expose(), IsString()], TribeUserBase.prototype, "username", 2);
__decorateClass$6([Expose({
	name: "avatarFileKey"
}), IsOptional(), IsString()], TribeUserBase.prototype, "_avatarFileKey", 2);
__decorateClass$6([Expose(), GetDecimal(), IsNotEmptyObject()], TribeUserBase.prototype, "earnedPoints", 2);
__decorateClass$6([Expose(), IsOptional(), IsEnum(TRIBE_USER_PERK)], TribeUserBase.prototype, "perk", 2);
class TribeUser extends TribeUserBase {
	get letterAvatar() {
		var Yi;
		return (Yi = getFirstPrintableSymbol(this.username)) == null ? void 0 : Yi.toUpperCase()
	}
	get avatarUrl() {
		return this._avatarFileKey ? getFileUrl(this._avatarFileKey) : void 0
	}
}
__decorateClass$6([Expose()], TribeUser.prototype, "letterAvatar", 1);
__decorateClass$6([Expose()], TribeUser.prototype, "avatarUrl", 1);
class TribeUserExtended extends TribeUserBase {
	constructor() {
		super(...arguments);
		Io(this, "rank")
	}
	get letterAvatar() {
		var ea;
		return (ea = getFirstPrintableSymbol(this.username)) == null ? void 0 : ea.toUpperCase()
	}
	get avatarUrl() {
		return this._avatarFileKey ? getFileUrl(this._avatarFileKey) : void 0
	}
}
__decorateClass$6([Expose(), IsNumber()], TribeUserExtended.prototype, "rank", 2);
__decorateClass$6([Expose()], TribeUserExtended.prototype, "letterAvatar", 1);
__decorateClass$6([Expose()], TribeUserExtended.prototype, "avatarUrl", 1);
class TribeUsersLeaderboard {
	constructor() {
		Io(this, "title");
		Io(this, "items");
		Io(this, "me");
		Io(this, "updatedAt")
	}
}
__decorateClass$6([Expose(), IsString()], TribeUsersLeaderboard.prototype, "title", 2);
__decorateClass$6([Expose(), Type(() => TribeUser), IsArray(), ValidateNested({
	each: !0
})], TribeUsersLeaderboard.prototype, "items", 2);
__decorateClass$6([Expose(), Type(() => TribeUserExtended), ValidateNested(), IsOptional()], TribeUsersLeaderboard.prototype, "me", 2);
__decorateClass$6([Expose(), IsString()], TribeUsersLeaderboard.prototype, "updatedAt", 2);
class TribeExtendedRank {
	constructor() {
		Io(this, "tribe");
		Io(this, "user")
	}
}
__decorateClass$6([Expose(), PositiveIntegerOrUndefined(), IsNumber(), IsOptional()], TribeExtendedRank.prototype, "tribe", 2);
__decorateClass$6([Expose(), PositiveIntegerOrUndefined(), IsNumber(), IsOptional()], TribeExtendedRank.prototype, "user", 2);
class TribeExtended extends Tribe {
	constructor() {
		super(...arguments);
		Io(this, "perk");
		Io(this, "rank")
	}
}
__decorateClass$6([Expose(), IsOptional(), IsEnum(TRIBE_USER_PERK)], TribeExtended.prototype, "perk", 2);
__decorateClass$6([Expose(), Type(() => TribeExtendedRank), ValidateNested(), Transform(({
	value: ue
}) => ue && typeof ue == "object" ? ue : plainToInstance(TribeExtendedRank, {
	tribe: ue,
	user: void 0
}))], TribeExtended.prototype, "rank", 2);
class TribeWithPagination extends PaginationResponse {
	constructor() {
		super(...arguments);
		Io(this, "items")
	}
}
__decorateClass$6([Expose(), Type(() => Tribe), IsArray(), ValidateNested({
	each: !0
})], TribeWithPagination.prototype, "items", 2);
class TribeUserWithPagination extends PaginationResponse {
	constructor() {
		super(...arguments);
		Io(this, "items")
	}
}
__decorateClass$6([Expose(), Type(() => TribeUser), IsArray(), ValidateNested({
	each: !0
})], TribeUserWithPagination.prototype, "items", 2);
class TribeValidationBot {
	constructor() {
		Io(this, "name")
	}
}
__decorateClass$6([Expose(), IsString()], TribeValidationBot.prototype, "name", 2);
const getTribeRankLabel = ue => {
		if (ue === void 0) return {
			label: "N/A"
		};
		const Yi = `#${formatFloatLine(ue,{accuracy:0})}`;
		return ue === 1 ? {
			icon: "emoji/GoldMedal",
			label: Yi
		} : ue === 2 ? {
			icon: "emoji/SilverMedal",
			label: Yi
		} : ue === 3 ? {
			icon: "emoji/BronzeMedal",
			label: Yi
		} : {
			label: Yi
		}
	},
	isTribeUserPerkBalanceHighlited = ue => ue === "FARMING15";
var __defProp$5 = Object.defineProperty,
	__getOwnPropDesc$4 = Object.getOwnPropertyDescriptor,
	__decorateClass$5 = (ue, Yi, ea, ta) => {
		for (var na = ta > 1 ? void 0 : ta ? __getOwnPropDesc$4(Yi, ea) : Yi, ra = ue.length - 1, ia; ra >= 0; ra--)(ia = ue[ra]) && (na = (ta ? ia(Yi, ea, na) : ia(na)) || na);
		return ta && na && __defProp$5(Yi, ea, na), na
	},
	_a, _b;
class UserResponse extends IDResponse {
	constructor() {
		super(...arguments);
		Io(this, "username");
		Io(this, "avatarKey")
	}
	get avatarUrl() {
		return this.avatarKey ? getFileUrl(this.avatarKey) : void 0
	}
}
__decorateClass$5([Expose(), IsString()], UserResponse.prototype, "username", 2);
__decorateClass$5([Expose({
	name: "avatarFileKey"
}), IsOptional(), IsString()], UserResponse.prototype, "avatarKey", 2);
__decorateClass$5([Expose()], UserResponse.prototype, "avatarUrl", 1);
var JWT = (ue => (ue.ACCESS = "ACCESS", ue.REFRESH = "REFRESH", ue))(JWT || {}),
	Ks, Ys;
Ys = _b = "ACCESS", Ks = _a = "REFRESH";
class JWTResponse {
	constructor() {
		Io(this, Ys);
		Io(this, Ks)
	}
}
__decorateClass$5([Expose({
	name: "access"
}), IsString()], JWTResponse.prototype, _b, 2);
__decorateClass$5([Expose({
	name: "refresh"
}), IsString()], JWTResponse.prototype, _a, 2);
class JWTWithUserResponse extends JWTResponse {
	constructor() {
		super(...arguments);
		Io(this, "user")
	}
}
__decorateClass$5([Expose(), Type(() => UserResponse), IsNotEmptyObject(), ValidateNested()], JWTWithUserResponse.prototype, "user", 2);
class AuthResponse {
	constructor() {
		Io(this, "tokenWithUser");
		Io(this, "justCreated")
	}
}
__decorateClass$5([Expose({
	name: "token"
}), Type(() => JWTWithUserResponse), IsNotEmptyObject(), ValidateNested()], AuthResponse.prototype, "tokenWithUser", 2);
__decorateClass$5([Expose(), IsOptional(), IsBoolean()], AuthResponse.prototype, "justCreated", 2);
var AUTH_ERROR = (ue => (ue.USERNAME_INVALID = "Invalid username", ue.USERNAME_TAKEN = "Username is not available", ue))(AUTH_ERROR || {}),
	SOCIAL_PROVIDER = (ue => (ue.GOOGLE = "PROVIDER_GOOGLE", ue.TELEGRAM = "PROVIDER_TELEGRAM", ue.TELEGRAM_MINI_APP = "PROVIDER_TELEGRAM_MINI_APP", ue.APPLE = "PROVIDER_APPLE", ue))(SOCIAL_PROVIDER || {});
class SocialProviderResponse {
	constructor() {
		Io(this, "providers")
	}
}
__decorateClass$5([Expose(), IsNotEmptyObject(), IsEnum(SOCIAL_PROVIDER, {
	each: !0
})], SocialProviderResponse.prototype, "providers", 2);
class UserCheckUsernameRequest {
	constructor() {
		Io(this, "username")
	}
}
__decorateClass$5([Expose(), IsString()], UserCheckUsernameRequest.prototype, "username", 2);
const sliceWalletAddress = (ue, Yi = 4) => {
	const ea = Yi * 2 + 3;
	return ue.length <= ea ? ue : ue.slice(0, Yi) + "..." + ue.slice(Yi * -1)
};
var __defProp$4 = Object.defineProperty,
	__getOwnPropDesc$3 = Object.getOwnPropertyDescriptor,
	__decorateClass$4 = (ue, Yi, ea, ta) => {
		for (var na = ta > 1 ? void 0 : ta ? __getOwnPropDesc$3(Yi, ea) : Yi, ra = ue.length - 1, ia; ra >= 0; ra--)(ia = ue[ra]) && (na = (ta ? ia(Yi, ea, na) : ia(na)) || na);
		return ta && na && __defProp$4(Yi, ea, na), na
	},
	WALLET_BALANCE_STATUS = (ue => (ue.PENDING = "PENDING", ue.READY = "READY", ue.REFETCHING = "REFETCHING", ue))(WALLET_BALANCE_STATUS || {});
class Wallet {
	constructor() {
		Io(this, "_address");
		Io(this, "status");
		Io(this, "isAvailable")
	}
	get address() {
		return {
			default: this._address,
			short: sliceWalletAddress(this._address, 3)
		}
	}
}
__decorateClass$4([Expose({
	name: "address"
}), IsString()], Wallet.prototype, "_address", 2);
__decorateClass$4([Expose()], Wallet.prototype, "address", 1);
__decorateClass$4([Expose(), IsEnum(WALLET_BALANCE_STATUS)], Wallet.prototype, "status", 2);
__decorateClass$4([Expose(), IsOptional(), IsBoolean()], Wallet.prototype, "isAvailable", 2);
class FiatValue {
	constructor() {
		Io(this, "_USD")
	}
	get USD() {
		return this._USD ? getWalletAmount(this._USD, "USD") : void 0
	}
}
__decorateClass$4([Expose({
	name: "usd"
}), GetDecimal(), IsOptional()], FiatValue.prototype, "_USD", 2);
__decorateClass$4([Expose()], FiatValue.prototype, "USD", 1);
class TonBalance {
	constructor() {
		Io(this, "currencyId");
		Io(this, "_balance");
		Io(this, "fiatValue");
		Io(this, "fiatValuesUpdatedAt")
	}
	get balance() {
		return getWalletAmount(this._balance, "TON")
	}
}
__decorateClass$4([Expose(), IsString()], TonBalance.prototype, "currencyId", 2);
__decorateClass$4([Expose({
	name: "availableBalance"
}), GetDecimal(), IsNotEmptyObject()], TonBalance.prototype, "_balance", 2);
__decorateClass$4([Expose()], TonBalance.prototype, "balance", 1);
__decorateClass$4([Expose(), Type(() => FiatValue), IsNotEmptyObject(), ValidateNested()], TonBalance.prototype, "fiatValue", 2);
__decorateClass$4([Expose(), IsOptional(), IsNumber()], TonBalance.prototype, "fiatValuesUpdatedAt", 2);
class JettonBalance {
	constructor() {
		Io(this, "currencyId");
		Io(this, "address");
		Io(this, "name");
		Io(this, "symbol");
		Io(this, "imageUrl");
		Io(this, "_balance");
		Io(this, "fiatValue");
		Io(this, "fiatValuesUpdatedAt")
	}
	get balance() {
		return getWalletAmount(this._balance, this.symbol)
	}
}
__decorateClass$4([Expose(), IsString()], JettonBalance.prototype, "currencyId", 2);
__decorateClass$4([Expose(), IsString()], JettonBalance.prototype, "address", 2);
__decorateClass$4([Expose(), IsString()], JettonBalance.prototype, "name", 2);
__decorateClass$4([Expose(), IsString()], JettonBalance.prototype, "symbol", 2);
__decorateClass$4([Expose(), IsString()], JettonBalance.prototype, "imageUrl", 2);
__decorateClass$4([Expose({
	name: "availableBalance"
}), GetDecimal(), IsNotEmptyObject()], JettonBalance.prototype, "_balance", 2);
__decorateClass$4([Expose()], JettonBalance.prototype, "balance", 1);
__decorateClass$4([Expose(), Type(() => FiatValue), IsNotEmptyObject(), ValidateNested()], JettonBalance.prototype, "fiatValue", 2);
__decorateClass$4([Expose(), IsOptional(), IsNumber()], JettonBalance.prototype, "fiatValuesUpdatedAt", 2);
class PointBalance {
	constructor() {
		Io(this, "currencyId");
		Io(this, "name");
		Io(this, "symbol");
		Io(this, "imageUrl");
		Io(this, "_balance");
		Io(this, "fiatValue")
	}
	get balance() {
		return getWalletAmount(this._balance, this.symbol)
	}
}
__decorateClass$4([Expose(), IsString()], PointBalance.prototype, "currencyId", 2);
__decorateClass$4([Expose(), IsString()], PointBalance.prototype, "name", 2);
__decorateClass$4([Expose(), IsString()], PointBalance.prototype, "symbol", 2);
__decorateClass$4([Expose(), IsString()], PointBalance.prototype, "imageUrl", 2);
__decorateClass$4([Expose({
	name: "balance"
}), GetDecimal(), IsNotEmptyObject()], PointBalance.prototype, "_balance", 2);
__decorateClass$4([Expose()], PointBalance.prototype, "balance", 1);
__decorateClass$4([Expose(), Type(() => FiatValue), IsNotEmptyObject(), ValidateNested()], PointBalance.prototype, "fiatValue", 2);
class PointBalanceResponse {
	constructor() {
		Io(this, "points");
		Io(this, "totalFiatValue")
	}
}
__decorateClass$4([Expose(), Type(() => PointBalance), IsArray(), ValidateNested({
	each: !0
})], PointBalanceResponse.prototype, "points", 2);
__decorateClass$4([Expose(), Type(() => FiatValue), IsNotEmptyObject(), ValidateNested()], PointBalanceResponse.prototype, "totalFiatValue", 2);
class WalletBalance extends Wallet {
	constructor() {
		super(...arguments);
		Io(this, "_updatedAt");
		Io(this, "totalFiatValue");
		Io(this, "tonBalance");
		Io(this, "jettonBalances")
	}
	get updatedAt() {
		return new Date(this._updatedAt)
	}
}
__decorateClass$4([Expose({
	name: "updatedAt"
}), IsNumber()], WalletBalance.prototype, "_updatedAt", 2);
__decorateClass$4([Expose()], WalletBalance.prototype, "updatedAt", 1);
__decorateClass$4([Expose(), Type(() => FiatValue), IsNotEmptyObject(), ValidateNested()], WalletBalance.prototype, "totalFiatValue", 2);
__decorateClass$4([Expose(), Type(() => TonBalance), IsNotEmptyObject(), ValidateNested()], WalletBalance.prototype, "tonBalance", 2);
__decorateClass$4([Expose(), Type(() => JettonBalance), IsArray(), ValidateNested({
	each: !0
})], WalletBalance.prototype, "jettonBalances", 2);
var __defProp$3 = Object.defineProperty,
	__getOwnPropDesc$2 = Object.getOwnPropertyDescriptor,
	__decorateClass$3 = (ue, Yi, ea, ta) => {
		for (var na = ta > 1 ? void 0 : ta ? __getOwnPropDesc$2(Yi, ea) : Yi, ra = ue.length - 1, ia; ra >= 0; ra--)(ia = ue[ra]) && (na = (ta ? ia(Yi, ea, na) : ia(na)) || na);
		return ta && na && __defProp$3(Yi, ea, na), na
	},
	HistoryShared;
(ue => {
	class Yi {
		constructor() {
			Io(this, "id");
			Io(this, "_amount");
			Io(this, "name");
			Io(this, "symbol");
			Io(this, "imageUrl")
		}
		get amount() {
			return getWalletAmount(this._amount, this.symbol)
		}
		get isInternal() {
			return ["BP", "PP"].includes(this.symbol)
		}
	}
	__decorateClass$3([Expose(), IsString()], Yi.prototype, "id", 2), __decorateClass$3([Expose({
		name: "amount"
	}), GetDecimal(), IsNotEmptyObject()], Yi.prototype, "_amount", 2), __decorateClass$3([Expose()], Yi.prototype, "amount", 1), __decorateClass$3([Expose(), IsString()], Yi.prototype, "name", 2), __decorateClass$3([Expose(), IsString()], Yi.prototype, "symbol", 2), __decorateClass$3([Expose(), IsString()], Yi.prototype, "imageUrl", 2), __decorateClass$3([Expose()], Yi.prototype, "isInternal", 1), ue.Currency = Yi;
	class ea {
		constructor() {
			Io(this, "id")
		}
	}
	__decorateClass$3([Expose(), IsString()], ea.prototype, "id", 2), ue.Nft = ea;
	class ta {
		constructor() {
			Io(this, "name")
		}
	}
	__decorateClass$3([Expose(), IsString()], ta.prototype, "name", 2), ue.Preview = ta;
	let na;
	(ia => {
		ia.PENDING = "PENDING", ia.OK = "OK", ia.FAILED = "FAILED"
	})(na = ue.STATUS || (ue.STATUS = {})), (ia => {
		ia.UNKNOWN = "UNKNOWN"
	})(ue.KIND_UNKNOWN || (ue.KIND_UNKNOWN = {}));
	class ra {
		constructor() {
			Io(this, "status");
			Io(this, "preview")
		}
	}
	__decorateClass$3([Expose(), IsEnum(na)], ra.prototype, "status", 2), __decorateClass$3([Expose(), Type(() => ta), IsNotEmptyObject(), ValidateNested()], ra.prototype, "preview", 2), ue._ActionPayloadDtoBase = ra
})(HistoryShared || (HistoryShared = {}));
const pad = ue => ue.toString().padStart(2, "0"),
	getMmSsFromMs = ue => {
		const Yi = Math.floor(ue / 1e3),
			ea = Math.floor(Yi / 60),
			ta = Yi % 60;
		return `${pad(ea)}:${pad(ta)}`
	},
	hmFromMs = ue => {
		if (ue <= 0) return {
			h: "00",
			m: "00"
		};
		const Yi = Math.floor(ue / 1e3),
			ea = Math.floor(Yi / 3600),
			ta = Math.floor(Yi % 3600 / 60);
		return ta === 60 ? {
			h: pad(ea + 1),
			m: "00"
		} : {
			h: pad(ea),
			m: pad(ta)
		}
	},
	dhFromMs = ue => {
		const {
			h: Yi
		} = hmFromMs(ue);
		if (Yi === "00") return {
			d: "00",
			h: Yi
		};
		const ea = Math.floor(parseInt(Yi) / 24),
			ta = parseInt(Yi) % 24;
		return {
			d: pad(ea),
			h: pad(ta)
		}
	},
	getHHMmFromMs = (ue, Yi = "default") => {
		const {
			h: ea,
			m: ta
		} = hmFromMs(ue);
		switch (Yi) {
			case "default":
				return `${ea}:${ta}`;
			case "letters":
				return `${ea}h ${ta}m`;
			default:
				throw err("Unknown type")
		}
	},
	getDDHHFromMs = ue => {
		const {
			d: Yi,
			h: ea
		} = dhFromMs(ue);
		return `${Yi}d ${ea}h`
	},
	getFormattedDate = ue => {
		const Yi = pad(ue.getDate()),
			ea = pad(ue.getMonth() + 1),
			ta = ue.getFullYear();
		return `${Yi}.${ea}.${ta}`
	},
	getDateShort = ue => d$1(ue, {
		month: "short",
		day: "numeric",
		hour: "numeric",
		minute: "numeric"
	}),
	toInternalDate = ue => {
		const Yi = ra => ra.toString().padStart(2, "0"),
			ea = new Date(ue);
		ea.setHours(0, 0, 0, 0);
		const ta = new Date;
		ta.setHours(0, 0, 0, 0);
		const na = ea < ta ? "past" : ea > ta ? "future" : "today";
		return {
			date: ea,
			stamp: ea.getTime(),
			iso: `${ea.getFullYear()}-${Yi(ea.getMonth()+1)}-${Yi(ea.getDate())}`,
			formatted: d$1(ea, {
				year: "numeric",
				month: "short",
				day: "numeric"
			}),
			relative: na
		}
	};
var __defProp$2 = Object.defineProperty,
	__getOwnPropDesc$1 = Object.getOwnPropertyDescriptor,
	__decorateClass$2 = (ue, Yi, ea, ta) => {
		for (var na = ta > 1 ? void 0 : ta ? __getOwnPropDesc$1(Yi, ea) : Yi, ra = ue.length - 1, ia; ra >= 0; ra--)(ia = ue[ra]) && (na = (ta ? ia(Yi, ea, na) : ia(na)) || na);
		return ta && na && __defProp$2(Yi, ea, na), na
	},
	HistoryPoints;
(ue => {
	let Yi;
	(oa => {
		oa.IN = "IN", oa.OUT = "OUT", oa.UNKNOWN = "UNKNOWN"
	})(Yi = ue.TYPE || (ue.TYPE = {}));
	let ea;
	(oa => {
		oa.CLAIM_FARMING = "CLAIM_FARMING", oa.CLAIM_TASK = "CLAIM_TASK", oa.CLAIM_REFERRAL = "CLAIM_REFERRAL", oa.CLAIM_CHECK_IN = "CLAIM_CHECK_IN", oa.DROP_GAME = "DROP_GAME", oa.BLUM_DROP = "BLUM_DROP", oa.WALLET_MIGRATION = "WALLET_MIGRATION"
	})(ea = ue.KIND_IN || (ue.KIND_IN = {}));
	let ta;
	(oa => {
		oa.DROP_GAME = "DROP_GAME"
	})(ta = ue.KIND_OUT || (ue.KIND_OUT = {}));
	class na {
		constructor() {
			Io(this, "currency")
		}
	}
	__decorateClass$2([Expose(), Type(() => HistoryShared.Currency), ValidateNested()], na.prototype, "currency", 2), ue.Asset = na;
	class ra extends HistoryShared._ActionPayloadDtoBase {
		constructor() {
			super(...arguments);
			Io(this, "inbound");
			Io(this, "outbound")
		}
	}
	__decorateClass$2([Expose(), Type(() => na), IsOptional(), ValidateNested()], ra.prototype, "inbound", 2), __decorateClass$2([Expose(), Type(() => na), IsOptional(), ValidateNested()], ra.prototype, "outbound", 2);
	class ia {
		constructor() {
			Io(this, "instance");
			Io(this, "type");
			Io(this, "kind");
			Io(this, "payload");
			Io(this, "_timestamp")
		}
		get date() {
			return toInternalDate(new Date(this._timestamp))
		}
	}
	__decorateClass$2([Expose(), Transform(() => "point")], ia.prototype, "instance", 2), __decorateClass$2([Expose(), IsEnum(Yi)], ia.prototype, "type", 2), __decorateClass$2([Expose(), Default(HistoryShared.KIND_UNKNOWN), IsIn([...Object.values(ea), ...Object.values(HistoryShared.KIND_UNKNOWN)])], ia.prototype, "kind", 2), __decorateClass$2([Expose(), Type(() => ra), IsNotEmptyObject(), ValidateNested()], ia.prototype, "payload", 2), __decorateClass$2([Expose({
		name: "timestamp"
	}), IsNumber()], ia.prototype, "_timestamp", 2), __decorateClass$2([Expose()], ia.prototype, "date", 1), ue._ActionDto = ia;
	class aa {
		constructor() {
			Io(this, "actions");
			Io(this, "nextPageToken")
		}
	}
	__decorateClass$2([Expose(), Type(() => ia), IsArray(), ValidateNested({
		each: !0
	})], aa.prototype, "actions", 2), __decorateClass$2([Expose(), IsString()], aa.prototype, "nextPageToken", 2), ue._ActionPaginatedDto = aa, ue.guards = {
		in: oa => oa.type === "IN",
		unknown: oa => oa.type === "UNKNOWN"
	}, ue._validator = oa => {
		const la = [],
			sa = ca => !isEnum(oa.kind, ca) && la.push(`Unexpected kind [${JSON.stringify(ca)}]`);
		switch (oa.type) {
			case "IN":
				sa(ea);
				break;
			case "OUT":
				sa(ta);
				break;
			case "UNKNOWN":
				sa(HistoryShared.KIND_UNKNOWN);
				break;
			default:
				throw oa.type, err("Unexpected history type")
		}
		return oa.type === "IN" && !oa.payload.inbound && la.push("Inbound asset is missing"), la.length ? {
			err: !0,
			errors: la
		} : {
			err: !1,
			data: oa
		}
	}, ue.mapAction = oa => oa.map(la => {
		const sa = (0, ue._validator)(la);
		return sa.err ? {
			type: "UNKNOWN",
			kind: HistoryShared.KIND_UNKNOWN.UNKNOWN,
			date: la.date,
			instance: la.instance,
			payload: {
				status: la.payload.status,
				preview: la.payload.preview
			}
		} : sa.data
	})
})(HistoryPoints || (HistoryPoints = {}));
const getRandomInt = (ue, Yi) => Math.floor(Math.random() * (Yi - ue + 1)) + ue,
	mockTime$1 = (() => {
		let ue = new Date;
		return {
			mock: () => {
				const ea = getRandomInt(1, 12);
				return ue = new Date(ue.getTime() + ea * 60 * 60 * 1e3), ue.getTime()
			}
		}
	})(),
	getTransformedHistory$1 = ue => {
		ue.timestamp = mockTime$1.mock();
		const Yi = transform$1(HistoryPoints._ActionDto, ue),
			ea = HistoryPoints._validator(Yi);
		if (ea.err) throw err("Invalid history", ea.errors);
		return ea.data
	},
	exampleCurrencyBound$1 = {
		currency: {
			id: "bp",
			amount: "123.456",
			name: "Blum Point",
			symbol: "BP",
			imageUrl: "https://example.com/ton.png"
		}
	},
	exampleCurrencyNotBpBound = {
		currency: {
			id: "ton",
			amount: "123.456",
			name: "AnTONio Montanna",
			symbol: "TON",
			imageUrl: "https://example.com/ton.png"
		}
	},
	basePayload$1 = {
		status: HistoryShared.STATUS.OK,
		preview: {
			name: "Preview name"
		}
	},
	casesMockGetters$1 = {
		diffStatus: () => [getTransformedHistory$1({
			type: HistoryPoints.TYPE.IN,
			kind: HistoryPoints.KIND_IN.DROP_GAME,
			payload: {
				...basePayload$1,
				inbound: exampleCurrencyBound$1,
				status: HistoryShared.STATUS.PENDING
			}
		})],
		farming: () => [getTransformedHistory$1({
			type: HistoryPoints.TYPE.IN,
			kind: HistoryPoints.KIND_IN.DROP_GAME,
			payload: {
				...basePayload$1,
				inbound: exampleCurrencyNotBpBound,
				status: HistoryShared.STATUS.OK
			}
		})],
		task: () => [getTransformedHistory$1({
			type: HistoryPoints.TYPE.IN,
			kind: HistoryPoints.KIND_IN.CLAIM_TASK,
			payload: {
				...basePayload$1,
				inbound: exampleCurrencyBound$1,
				status: HistoryShared.STATUS.OK
			}
		})],
		referral: () => [getTransformedHistory$1({
			type: HistoryPoints.TYPE.IN,
			kind: HistoryPoints.KIND_IN.CLAIM_REFERRAL,
			payload: {
				...basePayload$1,
				inbound: exampleCurrencyBound$1,
				status: HistoryShared.STATUS.OK
			}
		})],
		checkIn: () => [getTransformedHistory$1({
			type: HistoryPoints.TYPE.IN,
			kind: HistoryPoints.KIND_IN.CLAIM_CHECK_IN,
			payload: {
				...basePayload$1,
				inbound: exampleCurrencyBound$1,
				status: HistoryShared.STATUS.OK
			}
		})],
		game: () => [getTransformedHistory$1({
			type: HistoryPoints.TYPE.IN,
			kind: HistoryPoints.KIND_IN.DROP_GAME,
			payload: {
				...basePayload$1,
				inbound: exampleCurrencyBound$1,
				status: HistoryShared.STATUS.OK
			}
		})],
		drop: () => [getTransformedHistory$1({
			type: HistoryPoints.TYPE.IN,
			kind: HistoryPoints.KIND_IN.BLUM_DROP,
			payload: {
				...basePayload$1,
				inbound: exampleCurrencyBound$1,
				status: HistoryShared.STATUS.OK
			}
		})],
		migration: () => [getTransformedHistory$1({
			type: HistoryPoints.TYPE.IN,
			kind: HistoryPoints.KIND_IN.WALLET_MIGRATION,
			payload: {
				...basePayload$1,
				inbound: exampleCurrencyBound$1,
				status: HistoryShared.STATUS.OK
			}
		})],
		unknown: () => [getTransformedHistory$1({
			type: HistoryPoints.TYPE.UNKNOWN,
			kind: HistoryShared.KIND_UNKNOWN.UNKNOWN,
			payload: {
				...basePayload$1,
				inbound: exampleCurrencyBound$1,
				status: HistoryShared.STATUS.OK
			}
		})]
	},
	getFullMockHistory$1 = () => Object.values(casesMockGetters$1).map(Yi => Yi()).flat();
var __defProp$1 = Object.defineProperty,
	__getOwnPropDesc = Object.getOwnPropertyDescriptor,
	__decorateClass$1 = (ue, Yi, ea, ta) => {
		for (var na = ta > 1 ? void 0 : ta ? __getOwnPropDesc(Yi, ea) : Yi, ra = ue.length - 1, ia; ra >= 0; ra--)(ia = ue[ra]) && (na = (ta ? ia(Yi, ea, na) : ia(na)) || na);
		return ta && na && __defProp$1(Yi, ea, na), na
	},
	HistoryTokens;
(ue => {
	let Yi;
	(sa => {
		sa.IN = "IN", sa.OUT = "OUT", sa.SWAP = "SWAP", sa.UNQUANTIFIED = "UNQUANTIFIED", sa.UNKNOWN = "UNKNOWN"
	})(Yi = ue.TYPE || (ue.TYPE = {}));
	let ea;
	(sa => {
		sa.TRANSFER = "TRANSFER", sa.MINT = "MINT", sa.BID = "BID"
	})(ea = ue.KIND_IN || (ue.KIND_IN = {}));
	let ta;
	(sa => {
		sa.TRANSFER = "TRANSFER", sa.BURN = "BURN", sa.CONTRACT_EXEC = "CONTRACT_EXEC", sa.SUBSCRIBE = "SUBSCRIBE", sa.BID = "BID", sa.DOMAIN_RENEW = "DOMAIN_RENEW"
	})(ta = ue.KIND_OUT || (ue.KIND_OUT = {}));
	let na;
	(sa => {
		sa.SWAP = "SWAP"
	})(na = ue.KIND_SWAP || (ue.KIND_SWAP = {}));
	let ra;
	(sa => {
		sa.CONTRACT_DEPLOY = "CONTRACT_DEPLOY", sa.CONTRACT_EXEC = "CONTRACT_EXEC", sa.UNSUBSCRIBE = "UNSUBSCRIBE", sa.DOMAIN_RENEW = "DOMAIN_RENEW", sa.WITHDRAW_STAKE_REQUEST = "WITHDRAW_STAKE_REQUEST"
	})(ra = ue.KIND_UNQUANTIFIED || (ue.KIND_UNQUANTIFIED = {}));
	class ia {
		constructor() {
			Io(this, "currency");
			Io(this, "nft")
		}
	}
	__decorateClass$1([Expose(), Type(() => HistoryShared.Currency), IsOptional(), ValidateNested()], ia.prototype, "currency", 2), __decorateClass$1([Expose(), Type(() => HistoryShared.Nft), IsOptional(), ValidateNested()], ia.prototype, "nft", 2), ue.Asset = ia;
	class aa extends HistoryShared._ActionPayloadDtoBase {
		constructor() {
			super(...arguments);
			Io(this, "inbound");
			Io(this, "outbound")
		}
	}
	__decorateClass$1([Expose(), Type(() => ia), IsOptional(), ValidateNested()], aa.prototype, "inbound", 2), __decorateClass$1([Expose(), Type(() => ia), IsOptional(), ValidateNested()], aa.prototype, "outbound", 2);
	class oa {
		constructor() {
			Io(this, "instance");
			Io(this, "type");
			Io(this, "kind");
			Io(this, "payload");
			Io(this, "_timestamp")
		}
		get date() {
			return toInternalDate(new Date(this._timestamp))
		}
	}
	__decorateClass$1([Expose(), Transform(() => "token")], oa.prototype, "instance", 2), __decorateClass$1([Expose(), IsEnum(Yi)], oa.prototype, "type", 2), __decorateClass$1([Expose(), Default(HistoryShared.KIND_UNKNOWN), IsIn([...Object.values(ea), ...Object.values(ta), ...Object.values(na), ...Object.values(ra), ...Object.values(HistoryShared.KIND_UNKNOWN)])], oa.prototype, "kind", 2), __decorateClass$1([Expose(), Type(() => aa), IsNotEmptyObject(), ValidateNested()], oa.prototype, "payload", 2), __decorateClass$1([Expose({
		name: "timestamp"
	}), IsNumber()], oa.prototype, "_timestamp", 2), __decorateClass$1([Expose()], oa.prototype, "date", 1), ue._ActionDto = oa;
	class la {
		constructor() {
			Io(this, "actions");
			Io(this, "nextPageToken")
		}
	}
	__decorateClass$1([Expose(), Type(() => oa), IsArray(), ValidateNested({
		each: !0
	})], la.prototype, "actions", 2), __decorateClass$1([Expose(), IsString()], la.prototype, "nextPageToken", 2), ue._ActionPaginatedDto = la, ue.guards = {
		in: sa => sa.type === "IN",
		out: sa => sa.type === "OUT",
		swap: sa => sa.type === "SWAP",
		unquantified: sa => sa.type === "UNQUANTIFIED",
		unknown: sa => sa.type === "UNKNOWN"
	}, ue._validator = sa => {
		var da, ha;
		const ca = [],
			ua = pa => !isEnum(sa.kind, pa) && ca.push(`Unexpected kind [${JSON.stringify(pa)}]`);
		switch (sa.type) {
			case "IN":
				ua(ea);
				break;
			case "OUT":
				ua(ta);
				break;
			case "SWAP":
				ua(na);
				break;
			case "UNQUANTIFIED":
				ua(ra);
				break;
			case "UNKNOWN":
				ua(HistoryShared.KIND_UNKNOWN);
				break;
			default:
				throw sa.type, err("Unexpected history type")
		}
		return sa.type === "IN" && !sa.payload.inbound && ca.push("Inbound asset is missing"), sa.type === "OUT" && !sa.payload.outbound && ca.push("Outbound asset is missing"), sa.type === "SWAP" && (!sa.payload.inbound || !sa.payload.outbound) && ca.push("Inbound or outbound asset is missing"), sa.payload.inbound && !sa.payload.inbound.currency && !sa.payload.inbound.nft && ca.push("At least one inbound asset is missing"), sa.payload.outbound && !sa.payload.outbound.currency && !sa.payload.outbound.nft && ca.push("At least one outbound asset is missing"), sa.payload.inbound && sa.payload.inbound.currency && sa.payload.inbound.nft && ca.push("Inbound asset cannot be currency and NFT"), sa.payload.outbound && sa.payload.outbound.currency && sa.payload.outbound.nft && ca.push("Outbound asset cannot be currency and NFT"), sa.type === "SWAP" && (!((da = sa.payload.inbound) != null && da.currency) || !((ha = sa.payload.outbound) != null && ha.currency)) && ca.push("Swap should be between currencies"), ca.length ? {
			err: !0,
			errors: ca
		} : {
			err: !1,
			data: sa
		}
	}, ue.mapAction = sa => sa.map(ca => {
		const ua = (0, ue._validator)(ca);
		return ua.err ? {
			type: "UNKNOWN",
			kind: HistoryShared.KIND_UNKNOWN.UNKNOWN,
			date: ca.date,
			instance: ca.instance,
			payload: {
				status: ca.payload.status,
				preview: ca.payload.preview
			}
		} : ua.data
	})
})(HistoryTokens || (HistoryTokens = {}));
const mockTime = (() => {
		let ue = new Date;
		return {
			mock: () => {
				const ea = getRandomInt(1, 12);
				return ue = new Date(ue.getTime() + ea * 60 * 60 * 1e3), ue.getTime()
			}
		}
	})(),
	getTransformedHistory = ue => {
		ue.timestamp = mockTime.mock();
		const Yi = transform$1(HistoryTokens._ActionDto, ue),
			ea = HistoryTokens._validator(Yi);
		if (ea.err) throw err("Invalid history", ea.errors);
		return ea.data
	},
	exampleCurrencyBound = {
		currency: {
			id: "ton",
			amount: "123.455",
			name: "TON Crystal",
			symbol: "TON",
			imageUrl: "https://example.com/ton.png"
		}
	},
	exampleNftBound = {
		nft: {
			id: "nft-id"
		}
	},
	basePayload = {
		status: HistoryShared.STATUS.OK,
		preview: {
			name: "Preview name"
		}
	},
	casesMockGetters = {
		diffStatus: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.IN,
			kind: HistoryTokens.KIND_IN.TRANSFER,
			payload: {
				...basePayload,
				inbound: exampleCurrencyBound,
				status: HistoryShared.STATUS.PENDING
			}
		}), getTransformedHistory({
			type: HistoryTokens.TYPE.IN,
			kind: HistoryTokens.KIND_IN.TRANSFER,
			payload: {
				...basePayload,
				inbound: exampleCurrencyBound,
				status: HistoryShared.STATUS.OK
			}
		}), getTransformedHistory({
			type: HistoryTokens.TYPE.IN,
			kind: HistoryTokens.KIND_IN.TRANSFER,
			payload: {
				...basePayload,
				inbound: exampleCurrencyBound,
				status: HistoryShared.STATUS.FAILED
			}
		})],
		tonTransfer: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.IN,
			kind: HistoryTokens.KIND_IN.TRANSFER,
			payload: {
				...basePayload,
				inbound: exampleCurrencyBound
			}
		}), getTransformedHistory({
			type: HistoryTokens.TYPE.OUT,
			kind: HistoryTokens.KIND_OUT.TRANSFER,
			payload: {
				...basePayload,
				outbound: exampleCurrencyBound
			}
		})],
		jettonTransfer: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.IN,
			kind: HistoryTokens.KIND_IN.TRANSFER,
			payload: {
				...basePayload,
				inbound: exampleCurrencyBound
			}
		}), getTransformedHistory({
			type: HistoryTokens.TYPE.OUT,
			kind: HistoryTokens.KIND_IN.TRANSFER,
			payload: {
				...basePayload,
				outbound: exampleCurrencyBound
			}
		})],
		jettonBurn: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.OUT,
			kind: HistoryTokens.KIND_OUT.BURN,
			payload: {
				...basePayload,
				outbound: exampleCurrencyBound
			}
		})],
		jettonMint: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.IN,
			kind: HistoryTokens.KIND_IN.MINT,
			payload: {
				...basePayload,
				inbound: exampleCurrencyBound
			}
		})],
		nftItemTransfer: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.IN,
			kind: HistoryTokens.KIND_IN.TRANSFER,
			payload: {
				...basePayload,
				inbound: exampleNftBound
			}
		}), getTransformedHistory({
			type: HistoryTokens.TYPE.OUT,
			kind: HistoryTokens.KIND_OUT.TRANSFER,
			payload: {
				...basePayload,
				outbound: exampleNftBound
			}
		})],
		contractDeploy: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.UNQUANTIFIED,
			kind: HistoryTokens.KIND_UNQUANTIFIED.CONTRACT_DEPLOY,
			payload: {
				...basePayload
			}
		})],
		subscribe: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.OUT,
			kind: HistoryTokens.KIND_OUT.SUBSCRIBE,
			payload: {
				...basePayload,
				outbound: exampleCurrencyBound
			}
		})],
		unsubscribe: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.UNQUANTIFIED,
			kind: HistoryTokens.KIND_UNQUANTIFIED.UNSUBSCRIBE,
			payload: {
				...basePayload
			}
		})],
		auctionBid: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.IN,
			kind: HistoryTokens.KIND_IN.BID,
			payload: {
				...basePayload,
				inbound: exampleCurrencyBound
			}
		}), getTransformedHistory({
			type: HistoryTokens.TYPE.OUT,
			kind: HistoryTokens.KIND_OUT.BID,
			payload: {
				...basePayload,
				outbound: exampleCurrencyBound
			}
		})],
		nftPurchase: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.IN,
			kind: HistoryTokens.KIND_IN.TRANSFER,
			payload: {
				...basePayload,
				inbound: exampleNftBound
			}
		}), getTransformedHistory({
			type: HistoryTokens.TYPE.OUT,
			kind: HistoryTokens.KIND_OUT.TRANSFER,
			payload: {
				...basePayload,
				outbound: exampleNftBound
			}
		})],
		depositStake: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.IN,
			kind: HistoryTokens.KIND_IN.TRANSFER,
			payload: {
				...basePayload,
				inbound: exampleCurrencyBound
			}
		}), getTransformedHistory({
			type: HistoryTokens.TYPE.OUT,
			kind: HistoryTokens.KIND_OUT.TRANSFER,
			payload: {
				...basePayload,
				outbound: exampleCurrencyBound
			}
		})],
		withdrawStake: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.IN,
			kind: HistoryTokens.KIND_IN.TRANSFER,
			payload: {
				...basePayload,
				inbound: exampleCurrencyBound
			}
		}), getTransformedHistory({
			type: HistoryTokens.TYPE.OUT,
			kind: HistoryTokens.KIND_OUT.TRANSFER,
			payload: {
				...basePayload,
				outbound: exampleCurrencyBound
			}
		})],
		withdrawStakeRequest: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.UNQUANTIFIED,
			kind: HistoryTokens.KIND_UNQUANTIFIED.WITHDRAW_STAKE_REQUEST,
			payload: {
				...basePayload
			}
		})],
		jettonSwap: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.SWAP,
			kind: HistoryTokens.KIND_SWAP.SWAP,
			payload: {
				...basePayload,
				inbound: exampleCurrencyBound,
				outbound: exampleCurrencyBound
			}
		})],
		smartContractExec: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.UNQUANTIFIED,
			kind: HistoryTokens.KIND_UNQUANTIFIED.CONTRACT_EXEC,
			payload: {
				...basePayload
			}
		})],
		electionsRecoverStake: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.IN,
			kind: HistoryTokens.KIND_IN.TRANSFER,
			payload: {
				...basePayload,
				inbound: exampleCurrencyBound
			}
		}), getTransformedHistory({
			type: HistoryTokens.TYPE.OUT,
			kind: HistoryTokens.KIND_OUT.TRANSFER,
			payload: {
				...basePayload,
				outbound: exampleCurrencyBound
			}
		})],
		electionsDepositStake: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.IN,
			kind: HistoryTokens.KIND_IN.TRANSFER,
			payload: {
				...basePayload,
				inbound: exampleCurrencyBound
			}
		}), getTransformedHistory({
			type: HistoryTokens.TYPE.OUT,
			kind: HistoryTokens.KIND_OUT.TRANSFER,
			payload: {
				...basePayload,
				outbound: exampleCurrencyBound
			}
		})],
		domainRenew: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.UNQUANTIFIED,
			kind: HistoryTokens.KIND_UNQUANTIFIED.DOMAIN_RENEW,
			payload: {
				...basePayload
			}
		}), getTransformedHistory({
			type: HistoryTokens.TYPE.OUT,
			kind: HistoryTokens.KIND_OUT.DOMAIN_RENEW,
			payload: {
				...basePayload,
				outbound: exampleCurrencyBound
			}
		})],
		inscriptionTransfer: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.IN,
			kind: HistoryTokens.KIND_IN.TRANSFER,
			payload: {
				...basePayload,
				inbound: exampleCurrencyBound
			}
		}), getTransformedHistory({
			type: HistoryTokens.TYPE.OUT,
			kind: HistoryTokens.KIND_OUT.TRANSFER,
			payload: {
				...basePayload,
				outbound: exampleCurrencyBound
			}
		})],
		inscriptionMint: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.IN,
			kind: HistoryTokens.KIND_IN.MINT,
			payload: {
				...basePayload,
				inbound: exampleCurrencyBound
			}
		})],
		unknown: () => [getTransformedHistory({
			type: HistoryTokens.TYPE.UNKNOWN,
			kind: HistoryShared.KIND_UNKNOWN.UNKNOWN,
			payload: {
				...basePayload
			}
		})]
	},
	getFullMockHistory = () => Object.values(casesMockGetters).map(Yi => Yi()).flat(),
	debounce$1 = (ue, Yi = 300) => {
		let ea;
		const ta = () => {
			ea !== void 0 && (clearTimeout(ea), ea = void 0)
		};
		return {
			debouncedFunction: function(...ra) {
				ta(), ea = setTimeout(() => ue.apply(this, ra), Yi)
			},
			cancel: ta
		}
	},
	applyNewest = (ue, Yi) => {
		let ea;
		return async (...na) => {
			ea && ea.abort(), ea = new AbortController;
			const {
				signal: ra
			} = ea, ia = await ue(...na);
			ra.aborted || Yi(ia)
		}
	},
	calledNTimes = (ue, Yi, ea) => {
		ea || (ea = Yi * 100);
		let ta = 0;
		const na = () => ta = 0,
			{
				debouncedFunction: ra
			} = debounce$1(na, ea);
		return () => {
			ra(), ta++, ta === Yi && (ue(), na())
		}
	},
	awaitMs = async ue => {
		ue > 0 && await new Promise(Yi => setTimeout(Yi, ue))
	}, minExecutionTime = async (ue, Yi) => {
		const ea = performance.now();
		return await ue() ? (await awaitMs(Yi - (performance.now() - ea)), !0) : !1
	};
class Client {
	constructor() {
		Io(this, "isMock", !1);
		Io(this, "isWalletAvailable", !1)
	}
	getTZOffset() {
		return new Date().getTimezoneOffset()
	}
	async uploadFile(Yi, ea) {
		const ta = performance.now(),
			na = new FormData;
		na.append("content", Yi);
		const ra = await dataClient.post({
			url: "/file",
			service: SERVICE.GATEWAY
		}, {
			body: na
		}, FileUploadResponse, {
			onUploadProgress: ia => {
				const {
					loaded: aa,
					total: oa
				} = ia;
				oa && ea(Math.floor(aa * 100 / oa))
			}
		});
		return useLogger().debug("File uploaded", {
			time: (performance.now() - ta).toFixed(1),
			size: (Yi.size / 1e6).toFixed(1)
		}), ra
	}
	async me() {
		return await dataClient.get({
			url: "/user/me",
			service: SERVICE.USER
		}, UserResponse)
	}
	async checkUsername(Yi) {
		return await dataClient.post({
			url: "/user/username/check",
			service: SERVICE.USER
		}, {
			body: Yi,
			cls: UserCheckUsernameRequest
		})
	}
	get authUrl() {
		const Yi = SOCIAL_PROVIDER.TELEGRAM_MINI_APP;
		return "/auth/provider/{provider}".replace("{provider}", Yi)
	}
	async authOrCreate(Yi) {
		return await dataClient.post({
			url: this.authUrl,
			service: SERVICE.USER
		}, {
			body: Yi
		}, AuthResponse, {
			_skipRetry: !0,
			_omitAuthHeader: !0
		})
	}
	async refresh(Yi) {
		return await dataClient.post({
			url: "/auth/refresh",
			service: SERVICE.USER
		}, {
			body: {
				refresh: Yi
			}
		}, JWTResponse, {
			_skipRetry: !0,
			_omitAuthHeader: !0
		})
	}
	async getBackendTime() {
		return await dataClient.get({
			url: "/time/now",
			service: SERVICE.GAME
		}, BackendTimeResponse)
	}
	async getUserBalance() {
		return await dataClient.get({
			url: "/user/balance",
			service: SERVICE.GAME
		}, BalanceWithFarmingResponse)
	}
	async startFarming() {
		return await dataClient.post({
			url: "/farming/start",
			service: SERVICE.GAME
		}, void 0, FarmingResponse)
	}
	async claimFarming() {
		return await dataClient.post({
			url: "/farming/claim",
			service: SERVICE.GAME
		}, void 0, BalanceWithFarmingResponse)
	}
	async getTasksSections() {
		return await dataClient.get({
			url: "/tasks",
			service: SERVICE.EARN
		}, TasksSection, !0)
	}
	async startTask(Yi) {
		return await dataClient.post({
			url: `/tasks/${Yi}/start`,
			service: SERVICE.EARN
		}, void 0, Task)
	}
	async claimTask(Yi) {
		return await dataClient.post({
			url: `/tasks/${Yi}/claim`,
			service: SERVICE.EARN
		}, void 0, Task)
	}
	async verifyTask(Yi, ea) {
		return await dataClient.post({
			url: `/tasks/${Yi}/validate`,
			service: SERVICE.EARN
		}, {
			body: {
				keyword: ea
			}
		}, Task)
	}
	async getDailyReward() {
		const Yi = `/daily-reward?offset=${this.getTZOffset()}`;
		return await dataClient.get({
			url: Yi,
			service: SERVICE.GAME
		}, DailyReward)
	}
	async approveDailyRewardVisit() {
		const Yi = `/daily-reward?offset=${this.getTZOffset()}`;
		return await dataClient.post({
			url: Yi,
			service: SERVICE.GAME
		}, void 0)
	}
	async startGame() {
		return await dataClient.post({
			url: "/game/play",
			service: SERVICE.GAME,
			v: 2
		}, void 0, PlayResponse)
	}
	async claimGame(Yi) {
		return await dataClient.post({
			url: "/game/claim",
			service: SERVICE.GAME,
			v: 2
		}, {
			body: {
				payload: Yi
			}
		})
	}
	async isInDogsCohort() {
		return await dataClient.get({
			url: "/game/eligibility/dogs_drop",
			service: "http://env-5504045.user.cloudsg01.com",
			v: 2
		}, GameDropEligibility)
	}
	async getFrens(Yi) {
		return await dataClient.get({
			url: "/friends",
			service: SERVICE.USER
		}, FrensListResponse, !1, {
			pagination: Yi
		})
	}
	async getFrensUsing() {
		return await dataClient.get({
			url: "/friends/balance",
			service: SERVICE.USER
		}, FrensUsing)
	}
	async claimFrens() {
		return await dataClient.post({
			url: "/friends/claim",
			service: SERVICE.USER
		}, void 0, FrensClaim)
	}
	getTgAvatarUrl(Yi) {
		return dataClient.buildUrl({
			service: SERVICE.SUBSCRIPTION,
			url: `/user/avatar/${Yi}`
		})
	}
	async getMyTribe() {
		return await dataClient.get({
			url: "/tribe/my",
			service: SERVICE.TRIBE
		}, TribeExtended)
	}
	async getTribeByChatName(Yi) {
		return await dataClient.get({
			url: `/tribe/by-chatname/${Yi}`,
			service: SERVICE.TRIBE
		}, TribeExtended)
	}
	async resetMyTribeError() {
		return await dataClient.post({
			url: "/tribe/reset",
			service: SERVICE.TRIBE
		}, void 0)
	}
	async getTribesSearch(Yi) {
		const ea = Yi ? `/tribe?search=${Yi}` : "/tribe";
		return await dataClient.get({
			url: ea,
			service: SERVICE.TRIBE
		}, TribeWithPagination)
	}
	async getTribesLeaderboard() {
		return await dataClient.get({
			url: "/tribe/leaderboard",
			service: SERVICE.TRIBE
		}, TribeWithPagination)
	}
	async getTribeUsersLeaderboard(Yi) {
		return {
			err: !1,
			data: transform$1(TribeUsersLeaderboard, {
				title: "",
				items: [],
				me: void 0,
				updatedAt: ""
			})
		}
	}
	async getTribeValidationBot() {
		return await dataClient.get({
			url: "/tribe/bot",
			service: SERVICE.TRIBE
		}, TribeValidationBot)
	}
	async getMyTribeUsers() {
		return await dataClient.get({
			url: "/tribe/users",
			service: SERVICE.TRIBE
		}, TribeUserWithPagination)
	}
	async createTribe(Yi) {
		return await dataClient.post({
			url: "/tribe",
			service: SERVICE.TRIBE
		}, {
			body: {
				chatname: Yi.chatName,
				botName: Yi.botName
			}
		})
	}
	async leaveTribe(Yi) {
		return await dataClient.post({
			url: "/tribe/leave",
			service: SERVICE.TRIBE
		}, {
			body: {
				newOwnerUserId: Yi
			}
		})
	}
	async joinTribe(Yi) {
		return await dataClient.post({
			url: `/tribe/${Yi}/join`,
			service: SERVICE.TRIBE
		}, void 0)
	}
	async getConnectedWallet() {
		const Yi = await dataClient.get({
			url: "/wallet/my",
			service: SERVICE.WALLET
		}, Wallet);
		return this.isWalletAvailable && Yi.data && (Yi.data.isAvailable = !0), Yi
	}
	async getWalletBalance() {
		return await dataClient.get({
			url: "/wallet/my/balance?fiat=usd",
			service: SERVICE.WALLET
		}, WalletBalance)
	}
	async getWalletPointsBalance() {
		return await dataClient.get({
			url: "/wallet/my/points/balance",
			service: SERVICE.WALLET
		}, PointBalanceResponse)
	}
	async getTokensHistory(Yi, ea) {
		if (!this.isMock) {
			const ta = Yi ? `/wallet/my/actions_history?pageToken=${Yi}` : "/wallet/my/actions_history",
				na = await dataClient.get({
					url: ta,
					service: SERVICE.WALLET
				}, HistoryTokens._ActionPaginatedDto, !1);
			return na.err ? na : {
				err: !1,
				data: {
					actions: HistoryTokens.mapAction(na.data.actions),
					nextPageToken: na.data.nextPageToken
				}
			}
		}
		return await awaitMs(500), {
			err: !1,
			data: {
				actions: getFullMockHistory(),
				nextPageToken: "1"
			}
		}
	}
	async getPointsHistory(Yi) {
		if (!this.isMock) {
			const ea = Yi ? `/wallet/my/points/actions_history?pageToken=${Yi}` : "/wallet/my/points/actions_history",
				ta = await dataClient.get({
					url: ea,
					service: SERVICE.WALLET
				}, HistoryPoints._ActionPaginatedDto, !1);
			return ta.err ? ta : {
				err: !1,
				data: {
					actions: HistoryPoints.mapAction(ta.data.actions),
					nextPageToken: ta.data.nextPageToken
				}
			}
		}
		return await awaitMs(500), {
			err: !1,
			data: {
				actions: getFullMockHistory$1(),
				nextPageToken: "1"
			}
		}
	}
	async getCurrencyById(Yi) {
		return await awaitMs(500), {
			err: !0,
			code: 404
		}
	}
	async connectWallet(Yi) {
		return await dataClient.post({
			url: "/wallet/connect",
			service: SERVICE.WALLET
		}, {
			body: Yi
		})
	}
	async disconnectWallet() {
		return await dataClient.delete({
			url: "/wallet/disconnect",
			service: SERVICE.WALLET
		})
	}
}
const client = new Client,
	getDate = ue => {
		const Yi = new Date(ue);
		if (Yi instanceof Date && !isNaN(Yi.getTime())) return Yi
	},
	getExpirationDateFromToken = ue => {
		const Yi = ue.split(".");
		if (Yi.length === 3) try {
			const ea = JSON.parse(atob(Yi[1]));
			return typeof ea.exp != "number" ? void 0 : getDate(ea.exp * 1e3)
		} catch {
			return
		}
	},
	getTimeToTokenExpiration = ue => {
		const Yi = getExpirationDateFromToken(ue);
		if (!Yi) return;
		const ea = new Date,
			ta = Yi.getTime() - ea.getTime();
		return ta < 0 ? void 0 : ta
	};
var module$1 = {};
(function ue(Yi, ea, ta, na) {
		var ra = !!(Yi.Worker && Yi.Blob && Yi.Promise && Yi.OffscreenCanvas && Yi.OffscreenCanvasRenderingContext2D && Yi.HTMLCanvasElement && Yi.HTMLCanvasElement.prototype.transferControlToOffscreen && Yi.URL && Yi.URL.createObjectURL),
			ia = typeof Path2D == "function" && typeof DOMMatrix == "function",
			aa = function() {
				if (!Yi.OffscreenCanvas) return !1;
				var Ta = new OffscreenCanvas(1, 1),
					La = Ta.getContext("2d");
				La.fillRect(0, 0, 1, 1);
				var ya = Ta.transferToImageBitmap();
				try {
					La.createPattern(ya, "no-repeat")
				} catch {
					return !1
				}
				return !0
			}();

		function oa() {}

		function la(Ta) {
			var La = ea.exports.Promise,
				ya = La !== void 0 ? La : Yi.Promise;
			return typeof ya == "function" ? new ya(Ta) : (Ta(oa, oa), null)
		}
		var sa = function(Ta, La) {
				return {
					transform: function(ya) {
						if (Ta) return ya;
						if (La.has(ya)) return La.get(ya);
						var Ba = new OffscreenCanvas(ya.width, ya.height),
							io = Ba.getContext("2d");
						return io.drawImage(ya, 0, 0), La.set(ya, Ba), Ba
					},
					clear: function() {
						La.clear()
					}
				}
			}(aa, new Map),
			ca = function() {
				var Ta = Math.floor(16.666666666666668),
					La, ya, Ba = {},
					io = 0;
				return typeof requestAnimationFrame == "function" && typeof cancelAnimationFrame == "function" ? (La = function(oo) {
					var ao = Math.random();
					return Ba[ao] = requestAnimationFrame(function Ia(Na) {
						io === Na || io + Ta - 1 < Na ? (io = Na, delete Ba[ao], oo()) : Ba[ao] = requestAnimationFrame(Ia)
					}), ao
				}, ya = function(oo) {
					Ba[oo] && cancelAnimationFrame(Ba[oo])
				}) : (La = function(oo) {
					return setTimeout(oo, Ta)
				}, ya = function(oo) {
					return clearTimeout(oo)
				}), {
					frame: La,
					cancel: ya
				}
			}(),
			ua = function() {
				var Ta, La, ya = {};

				function Ba(io) {
					function oo(ao, Ia) {
						io.postMessage({
							options: ao || {},
							callback: Ia
						})
					}
					io.init = function(Ia) {
						var Na = Ia.transferControlToOffscreen();
						io.postMessage({
							canvas: Na
						}, [Na])
					}, io.fire = function(Ia, Na, za) {
						if (La) return oo(Ia, null), La;
						var ro = Math.random().toString(36).slice(2);
						return La = la(function(Va) {
							function Wa(qa) {
								qa.data.callback === ro && (delete ya[ro], io.removeEventListener("message", Wa), La = null, sa.clear(), za(), Va())
							}
							io.addEventListener("message", Wa), oo(Ia, ro), ya[ro] = Wa.bind(null, {
								data: {
									callback: ro
								}
							})
						}), La
					}, io.reset = function() {
						io.postMessage({
							reset: !0
						});
						for (var Ia in ya) ya[Ia](), delete ya[Ia]
					}
				}
				return function() {
					if (Ta) return Ta;
					if (!ta && ra) {
						var io = ["var CONFETTI, SIZE = {}, module = {};", "(" + ue.toString() + ")(this, module, true, SIZE);", "onmessage = function(msg) {", "  if (msg.data.options) {", "    CONFETTI(msg.data.options).then(function () {", "      if (msg.data.callback) {", "        postMessage({ callback: msg.data.callback });", "      }", "    });", "  } else if (msg.data.reset) {", "    CONFETTI && CONFETTI.reset();", "  } else if (msg.data.resize) {", "    SIZE.width = msg.data.resize.width;", "    SIZE.height = msg.data.resize.height;", "  } else if (msg.data.canvas) {", "    SIZE.width = msg.data.canvas.width;", "    SIZE.height = msg.data.canvas.height;", "    CONFETTI = module.exports.create(msg.data.canvas);", "  }", "}"].join(`
`);
						try {
							Ta = new Worker(URL.createObjectURL(new Blob([io])))
						} catch (oo) {
							return typeof console !== void 0 && typeof console.warn == "function" && console.warn("🎊 Could not load worker", oo), null
						}
						Ba(Ta)
					}
					return Ta
				}
			}(),
			da = {
				particleCount: 50,
				angle: 90,
				spread: 45,
				startVelocity: 45,
				decay: .9,
				gravity: 1,
				drift: 0,
				ticks: 200,
				x: .5,
				y: .5,
				shapes: ["square", "circle"],
				zIndex: 100,
				colors: ["#26ccff", "#a25afd", "#ff5e7e", "#88ff5a", "#fcff42", "#ffa62d", "#ff36ff"],
				disableForReducedMotion: !1,
				scalar: 1
			};

		function ha(Ta, La) {
			return La ? La(Ta) : Ta
		}

		function pa(Ta) {
			return Ta != null
		}

		function va(Ta, La, ya) {
			return ha(Ta && pa(Ta[La]) ? Ta[La] : da[La], ya)
		}

		function ba(Ta) {
			return Ta < 0 ? 0 : Math.floor(Ta)
		}

		function Ea(Ta, La) {
			return Math.floor(Math.random() * (La - Ta)) + Ta
		}

		function Sa(Ta) {
			return parseInt(Ta, 16)
		}

		function Ca(Ta) {
			return Ta.map(ka)
		}

		function ka(Ta) {
			var La = String(Ta).replace(/[^0-9a-f]/gi, "");
			return La.length < 6 && (La = La[0] + La[0] + La[1] + La[1] + La[2] + La[2]), {
				r: Sa(La.substring(0, 2)),
				g: Sa(La.substring(2, 4)),
				b: Sa(La.substring(4, 6))
			}
		}

		function Pa(Ta) {
			var La = va(Ta, "origin", Object);
			return La.x = va(La, "x", Number), La.y = va(La, "y", Number), La
		}

		function ja(Ta) {
			Ta.width = document.documentElement.clientWidth, Ta.height = document.documentElement.clientHeight
		}

		function Za(Ta) {
			var La = Ta.getBoundingClientRect();
			Ta.width = La.width, Ta.height = La.height
		}

		function Ga(Ta) {
			var La = document.createElement("canvas");
			return La.style.position = "fixed", La.style.top = "0px", La.style.left = "0px", La.style.pointerEvents = "none", La.style.zIndex = Ta, La
		}

		function Ja(Ta, La, ya, Ba, io, oo, ao, Ia, Na) {
			Ta.save(), Ta.translate(La, ya), Ta.rotate(oo), Ta.scale(Ba, io), Ta.arc(0, 0, 1, ao, Ia, Na), Ta.restore()
		}

		function Ua(Ta) {
			var La = Ta.angle * (Math.PI / 180),
				ya = Ta.spread * (Math.PI / 180);
			return {
				x: Ta.x,
				y: Ta.y,
				wobble: Math.random() * 10,
				wobbleSpeed: Math.min(.11, Math.random() * .1 + .05),
				velocity: Ta.startVelocity * .5 + Math.random() * Ta.startVelocity,
				angle2D: -La + (.5 * ya - Math.random() * ya),
				tiltAngle: (Math.random() * (.75 - .25) + .25) * Math.PI,
				color: Ta.color,
				shape: Ta.shape,
				tick: 0,
				totalTicks: Ta.ticks,
				decay: Ta.decay,
				drift: Ta.drift,
				random: Math.random() + 2,
				tiltSin: 0,
				tiltCos: 0,
				wobbleX: 0,
				wobbleY: 0,
				gravity: Ta.gravity * 3,
				ovalScalar: .6,
				scalar: Ta.scalar,
				flat: Ta.flat
			}
		}

		function xa(Ta, La) {
			La.x += Math.cos(La.angle2D) * La.velocity + La.drift, La.y += Math.sin(La.angle2D) * La.velocity + La.gravity, La.velocity *= La.decay, La.flat ? (La.wobble = 0, La.wobbleX = La.x + 10 * La.scalar, La.wobbleY = La.y + 10 * La.scalar, La.tiltSin = 0, La.tiltCos = 0, La.random = 1) : (La.wobble += La.wobbleSpeed, La.wobbleX = La.x + 10 * La.scalar * Math.cos(La.wobble), La.wobbleY = La.y + 10 * La.scalar * Math.sin(La.wobble), La.tiltAngle += .1, La.tiltSin = Math.sin(La.tiltAngle), La.tiltCos = Math.cos(La.tiltAngle), La.random = Math.random() + 2);
			var ya = La.tick++/La.totalTicks,Ba=La.x+La.random*La.tiltCos,io=La.y+La.random*La.tiltSin,oo=La.wobbleX+La.random*La.tiltCos,ao=La.wobbleY+La.random*La.tiltSin;if(Ta.fillStyle="rgba("+La.color.r+", "+La.color.g+", "+La.color.b+", "+(1-ya)+")",Ta.beginPath(),ia&&La.shape.type==="path"&&typeof La.shape.path=="string"&&Array.isArray(La.shape.matrix))Ta.fill(Ma(La.shape.path,La.shape.matrix,La.x,La.y,Math.abs(oo-Ba)*.1,Math.abs(ao-io)*.1,Math.PI/
			10 * La.wobble));
	else if (La.shape.type === "bitmap") {
		var Ia = Math.PI / 10 * La.wobble,
			Na = Math.abs(oo - Ba) * .1,
			za = Math.abs(ao - io) * .1,
			ro = La.shape.bitmap.width * La.scalar,
			Va = La.shape.bitmap.height * La.scalar,
			Wa = new DOMMatrix([Math.cos(Ia) * Na, Math.sin(Ia) * Na, -Math.sin(Ia) * za, Math.cos(Ia) * za, La.x, La.y]);
		Wa.multiplySelf(new DOMMatrix(La.shape.matrix));
		var qa = Ta.createPattern(sa.transform(La.shape.bitmap), "no-repeat");
		qa.setTransform(Wa), Ta.globalAlpha = 1 - ya, Ta.fillStyle = qa, Ta.fillRect(La.x - ro / 2, La.y - Va / 2, ro, Va), Ta.globalAlpha = 1
	} else if (La.shape === "circle") Ta.ellipse ? Ta.ellipse(La.x, La.y, Math.abs(oo - Ba) * La.ovalScalar, Math.abs(ao - io) * La.ovalScalar, Math.PI / 10 * La.wobble, 0, 2 * Math.PI) : Ja(Ta, La.x, La.y, Math.abs(oo - Ba) * La.ovalScalar, Math.abs(ao - io) * La.ovalScalar, Math.PI / 10 * La.wobble, 0, 2 * Math.PI);
	else if (La.shape === "star")
		for (var Ka = Math.PI / 2 * 3, lo = 4 * La.scalar, yo = 8 * La.scalar, fo = La.x, vo = La.y, so = 5, Xa = Math.PI / so; so--;) fo = La.x + Math.cos(Ka) * yo, vo = La.y + Math.sin(Ka) * yo, Ta.lineTo(fo, vo), Ka += Xa, fo = La.x + Math.cos(Ka) * lo, vo = La.y + Math.sin(Ka) * lo, Ta.lineTo(fo, vo), Ka += Xa;
	else Ta.moveTo(Math.floor(La.x), Math.floor(La.y)), Ta.lineTo(Math.floor(La.wobbleX), Math.floor(io)), Ta.lineTo(Math.floor(oo), Math.floor(ao)), Ta.lineTo(Math.floor(Ba), Math.floor(La.wobbleY));
	return Ta.closePath(), Ta.fill(), La.tick < La.totalTicks
}

function ma(Ta, La, ya, Ba, io) {
	var oo = La.slice(),
		ao = Ta.getContext("2d"),
		Ia, Na, za = la(function(ro) {
			function Va() {
				Ia = Na = null, ao.clearRect(0, 0, Ba.width, Ba.height), sa.clear(), io(), ro()
			}

			function Wa() {
				ta && !(Ba.width === na.width && Ba.height === na.height) && (Ba.width = Ta.width = na.width, Ba.height = Ta.height = na.height), !Ba.width && !Ba.height && (ya(Ta), Ba.width = Ta.width, Ba.height = Ta.height), ao.clearRect(0, 0, Ba.width, Ba.height), oo = oo.filter(function(qa) {
					return xa(ao, qa)
				}), oo.length ? Ia = ca.frame(Wa) : Va()
			}
			Ia = ca.frame(Wa), Na = Va
		});
	return {
		addFettis: function(ro) {
			return oo = oo.concat(ro), za
		},
		canvas: Ta,
		promise: za,
		reset: function() {
			Ia && ca.cancel(Ia), Na && Na()
		}
	}
}

function fa(Ta, La) {
	var ya = !Ta,
		Ba = !!va(La || {}, "resize"),
		io = !1,
		oo = va(La, "disableForReducedMotion", Boolean),
		ao = ra && !!va(La || {}, "useWorker"),
		Ia = ao ? ua() : null,
		Na = ya ? ja : Za,
		za = Ta && Ia ? !!Ta.__confetti_initialized : !1,
		ro = typeof matchMedia == "function" && matchMedia("(prefers-reduced-motion)").matches,
		Va;

	function Wa(Ka, lo, yo) {
		for (var fo = va(Ka, "particleCount", ba), vo = va(Ka, "angle", Number), so = va(Ka, "spread", Number), Xa = va(Ka, "startVelocity", Number), to = va(Ka, "decay", Number), ho = va(Ka, "gravity", Number), Eo = va(Ka, "drift", Number), wo = va(Ka, "colors", Ca), Ao = va(Ka, "ticks", Number), _o = va(Ka, "shapes"), Lo = va(Ka, "scalar"), Fo = !!va(Ka, "flat"), jo = Pa(Ka), eo = fo, Oa = [], Da = Ta.width * jo.x, Qa = Ta.height * jo.y; eo--;) Oa.push(Ua({
			x: Da,
			y: Qa,
			angle: vo,
			spread: so,
			startVelocity: Xa,
			color: wo[eo % wo.length],
			shape: _o[Ea(0, _o.length)],
			ticks: Ao,
			decay: to,
			gravity: ho,
			drift: Eo,
			scalar: Lo,
			flat: Fo
		}));
		return Va ? Va.addFettis(Oa) : (Va = ma(Ta, Oa, Na, lo, yo), Va.promise)
	}

	function qa(Ka) {
		var lo = oo || va(Ka, "disableForReducedMotion", Boolean),
			yo = va(Ka, "zIndex", Number);
		if (lo && ro) return la(function(Xa) {
			Xa()
		});
		ya && Va ? Ta = Va.canvas : ya && !Ta && (Ta = Ga(yo), document.body.appendChild(Ta)), Ba && !za && Na(Ta);
		var fo = {
			width: Ta.width,
			height: Ta.height
		};
		Ia && !za && Ia.init(Ta), za = !0, Ia && (Ta.__confetti_initialized = !0);

		function vo() {
			if (Ia) {
				var Xa = {
					getBoundingClientRect: function() {
						if (!ya) return Ta.getBoundingClientRect()
					}
				};
				Na(Xa), Ia.postMessage({
					resize: {
						width: Xa.width,
						height: Xa.height
					}
				});
				return
			}
			fo.width = fo.height = null
		}

		function so() {
			Va = null, Ba && (io = !1, Yi.removeEventListener("resize", vo)), ya && Ta && (document.body.contains(Ta) && document.body.removeChild(Ta), Ta = null, za = !1)
		}
		return Ba && !io && (io = !0, Yi.addEventListener("resize", vo, !1)), Ia ? Ia.fire(Ka, fo, so) : Wa(Ka, fo, so)
	}
	return qa.reset = function() {
		Ia && Ia.reset(), Va && Va.reset()
	}, qa
}
var ga;

function wa() {
	return ga || (ga = fa(null, {
		useWorker: !0,
		resize: !0
	})), ga
}

function Ma(Ta, La, ya, Ba, io, oo, ao) {
	var Ia = new Path2D(Ta),
		Na = new Path2D;
	Na.addPath(Ia, new DOMMatrix(La));
	var za = new Path2D;
	return za.addPath(Na, new DOMMatrix([Math.cos(ao) * io, Math.sin(ao) * io, -Math.sin(ao) * oo, Math.cos(ao) * oo, ya, Ba])), za
}

function Aa(Ta) {
	if (!ia) throw new Error("path confetti are not supported in this browser");
	var La, ya;
	typeof Ta == "string" ? La = Ta : (La = Ta.path, ya = Ta.matrix);
	var Ba = new Path2D(La),
		io = document.createElement("canvas"),
		oo = io.getContext("2d");
	if (!ya) {
		for (var ao = 1e3, Ia = ao, Na = ao, za = 0, ro = 0, Va, Wa, qa = 0; qa < ao; qa += 2)
			for (var Ka = 0; Ka < ao; Ka += 2) oo.isPointInPath(Ba, qa, Ka, "nonzero") && (Ia = Math.min(Ia, qa), Na = Math.min(Na, Ka), za = Math.max(za, qa), ro = Math.max(ro, Ka));
		Va = za - Ia, Wa = ro - Na;
		var lo = 10,
			yo = Math.min(lo / Va, lo / Wa);
		ya = [yo, 0, 0, yo, -Math.round(Va / 2 + Ia) * yo, -Math.round(Wa / 2 + Na) * yo]
	}
	return {
		type: "path",
		path: La,
		matrix: ya
	}
}

function Ra(Ta) {
	var La, ya = 1,
		Ba = "#000000",
		io = '"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", "EmojiOne Color", "Android Emoji", "Twemoji Mozilla", "system emoji", sans-serif';
	typeof Ta == "string" ? La = Ta : (La = Ta.text, ya = "scalar" in Ta ? Ta.scalar : ya, io = "fontFamily" in Ta ? Ta.fontFamily : io, Ba = "color" in Ta ? Ta.color : Ba);
	var oo = 10 * ya,
		ao = "" + oo + "px " + io,
		Ia = new OffscreenCanvas(oo, oo),
		Na = Ia.getContext("2d");
	Na.font = ao;
	var za = Na.measureText(La),
		ro = Math.ceil(za.actualBoundingBoxRight + za.actualBoundingBoxLeft),
		Va = Math.ceil(za.actualBoundingBoxAscent + za.actualBoundingBoxDescent),
		Wa = 2,
		qa = za.actualBoundingBoxLeft + Wa,
		Ka = za.actualBoundingBoxAscent + Wa;
	ro += Wa + Wa, Va += Wa + Wa, Ia = new OffscreenCanvas(ro, Va), Na = Ia.getContext("2d"), Na.font = ao, Na.fillStyle = Ba, Na.fillText(La, qa, Ka);
	var lo = 1 / ya;
	return {
		type: "bitmap",
		bitmap: Ia.transferToImageBitmap(),
		matrix: [lo, 0, 0, lo, -ro * lo / 2, -Va * lo / 2]
	}
}
ea.exports = function() {
return wa().apply(this, arguments)
}, ea.exports.reset = function() {
wa().reset()
}, ea.exports.create = fa, ea.exports.shapeFromPath = Aa, ea.exports.shapeFromText = Ra
})(function() {
	return typeof window < "u" ? window : typeof self < "u" ? self : this || {}
}(), module$1, !1);
const confetti = module$1.exports;
module$1.exports.create;
const useApp = () => {
	const ue = useState(() => !1, "$KhmmO9iXun"),
		Yi = useState("$61ORIPfkmn"),
		ea = useState(() => "DEFAULT", "$XZsGp9D0V5"),
		ta = computed(() => ea.value === "POKRAS"),
		na = useState(() => [], "$0hRCPyAwbv"),
		ra = computed(() => {
			if (!useAuth().getters.getUser.value) return !1;
			const ha = ["welcome", "preview", "daily-reward", "game"],
				pa = ["tribe"],
				va = useRoute().name;
			return typeof va == "string" && !ha.includes(va) && !pa.some(ba => va.startsWith(ba))
		}),
		ia = () => {
			document.body.style.overflowY = "hidden", document.body.style.marginTop = "100px", document.body.style.height = `${window.innerHeight+100}px`, document.body.style.paddingBottom = "100px", window.scrollTo(0, 100), useNuxtApp().$webApp.expand(), setTimeout(() => {
				ue.value = !0
			})
		},
		aa = () => {
			document.body.style.overflowY = "", document.body.style.marginTop = "", document.body.style.height = "", document.body.style.paddingBottom = "", window.scrollTo(0, 0), setTimeout(() => {
				ue.value = !1
			})
		},
		oa = () => {
			useNuxtApp().$webApp.HapticFeedback.notificationOccurred("success");
			const ha = {
				particleCount: 110,
				spread: 70,
				origin: {
					y: .7
				},
				colors: void 0
			};
			ta.value && (ha.colors = ["#FF00C7", "#F45DE9", "#282828", "#575756", "#FFFFFF"]), confetti(ha)
		},
		la = () => {
			const {
				TG_ANALYTICS_NAME: ha,
				TG_ANALYTICS_TOKEN: pa
			} = useRuntimeConfig().public;
			!ha || !pa || window.telegramAnalytics.init({
				appName: ha,
				token: pa
			})
		},
		sa = useState("$llOqE72OJB"),
		ca = (ha, pa, va) => sa.value = {
			title: ha,
			message: pa,
			buttons: va
		},
		ua = () => sa.value = void 0;
	useHead({
		bodyAttrs: {
			class: computed(() => `theme-${ea.value.toLowerCase()}`)
		}
	});
	const da = () => {
		useRouter().afterEach(ha => {
			typeof ha.name == "string" && na.value.unshift({
				name: ha.name,
				fullPath: ha.fullPath
			})
		})
	};
	return {
		blockOverflow: ia,
		unblockOverflow: aa,
		makeConfetti: oa,
		hasLayoutTabs: ra,
		previousRoute: computed(() => na.value[1]),
		isProd: computed(() => useRuntimeConfig().public.ENVIRONMENT === "prod"),
		_flow: {
			init: da
		},
		internal: {
			isOverflowBlocked: computed(() => ue.value),
			backFn: Yi,
			fallbackPopup: computed(() => sa.value),
			showFallbackPopup: ca,
			closeFallbackPopup: ua,
			theme: computed(() => ea.value),
			isPokrasTheme: ta,
			initTganalytics: la
		}
	}
};
var FEATURES = (ue => (ue.CAPTURE_POSTHOG = "capture_posthog", ue.CAPTURE_GTAG = "capture_gtag", ue.CAPTURE_GROUP_GENERAL = "capture_group_general", ue.CAPTURE_GROUP_GAME = "capture_group_game", ue.CAPTURE_GROUP_FARMING = "capture_group_farming", ue.CAPTURE_GROUP_FRIENDS_INVITE = "capture_group_friends_invite", ue.CAPTURE_GROUP_LAUNCH = "capture_group_launch", ue.CAPTURE_GROUP_TUTORIAL = "capture_group_tutorial", ue.CAPTURE_GROUP_WALLET = "capture_group_wallet", ue.CAPTURE_GROUP_TRIBES = "capture_group_tribes", ue))(FEATURES || {});
const useFeatures = () => {
	const ue = useState(() => [], "$ckXjRo4R1r"),
		Yi = () => {
			ue.value = ["capture_gtag", "capture_group_general", "capture_group_game", "capture_group_farming", "capture_group_friends_invite", "capture_group_launch", "capture_group_tutorial", "capture_group_wallet", "capture_group_tribes"], useApp().isProd.value || console.log("[FEATURES]", ue.value.join(", "))
		},
		ea = ta => ue.value.includes(ta);
	return {
		_flow: {
			init: Yi
		},
		list: computed(() => ue.value),
		isEnabled: ea
	}
};

function gtag(...ue) {
	var Yi;
	(Yi = window.dataLayer) == null || Yi.push(arguments)
}

function initGtag({
	tags: ue
}) {
	window.dataLayer = window.dataLayer || [];
	for (const Yi of ue)
		for (const ea of Yi.initCommands ?? []) gtag(...ea);
	gtag("js", new Date);
	for (const Yi of ue) gtag("config", Yi.id, Yi.config ?? {})
}

function resolveTags(ue) {
	const Yi = toRaw(ue),
		ea = Yi.tags.filter(Boolean).map(ta => typeof ta == "string" ? {
			id: ta
		} : ta);
	if (Yi.id) {
		const {
			id: ta,
			config: na,
			initCommands: ra
		} = Yi;
		ea.unshift({
			id: ta,
			config: na,
			initCommands: ra
		})
	}
	return ea
}

function disableAnalytics(ue) {
	window[`ga-disable-${ue}`] = !0
}

function enableAnalytics(ue) {
	const Yi = `ga-disable-${ue}`;
	Yi in window && delete window[Yi]
}

function useGtag() {
	const ue = useRuntimeConfig().public.gtag,
		Yi = resolveTags(ue);
	let ea;
	ea = gtag;
	const ta = aa => {
			const oa = [...Yi];
			let la = oa.find(sa => sa.id === aa);
			return la || (aa ? (la = {
				id: aa
			}, oa.unshift(la)) : la = oa[0]), la || console.error("[nuxt-gtag] Missing Google tag ID"), {
				tag: la,
				tags: oa
			}
		},
		na = aa => {
			{
				const {
					tag: oa,
					tags: la
				} = ta(aa);
				if (!oa) return;
				window.dataLayer || initGtag({
					tags: la
				}), document.head.querySelector("script[data-gtag]") || useHead({
					script: [{
						src: withQuery(ue.url, {
							id: oa.id
						}),
						"data-gtag": ""
					}]
				})
			}
		};

	function ra(aa) {
		{
			const {
				tag: oa
			} = ta(aa);
			oa && disableAnalytics(oa.id)
		}
	}

	function ia(aa) {
		{
			const {
				tag: oa
			} = ta(aa);
			oa && enableAnalytics(oa.id)
		}
	}
	return {
		gtag: ea,
		initialize: na,
		disableAnalytics: ra,
		enableAnalytics: ia
	}
}

function useTrackEvent(...ue) {
	const {
		gtag: Yi
	} = useGtag();
	Yi("event", ...ue)
}
var ANALYTICS_TRIBE_CREATE_SOURCE = (ue => (ue.DIRECT_SEARCH = "direct_search", ue.TOP_LIST = "top_list", ue.RANDOM_LIST = "random_list", ue.REFERRAL = "referral", ue.NONE = "none", ue))(ANALYTICS_TRIBE_CREATE_SOURCE || {});
const useAnalytics = () => {
		const ue = useNuxtApp().$webApp,
			{
				isEnabled: Yi
			} = useFeatures(),
			ea = computed(() => Yi(FEATURES.CAPTURE_POSTHOG) ? useNuxtApp().$posthog : void 0),
			ta = computed(() => Yi(FEATURES.CAPTURE_GTAG) ? useTrackEvent : void 0),
			na = (la, sa) => {
				const ca = {};
				return Object.entries(sa).forEach(([ua, da]) => {
					ca[ua] = (...ha) => Yi(la) && da(...ha)
				}), ca
			},
			ra = (la, sa) => {
				useApp().isProd.value || console.info("[ANALYTICS]", la, sa), ea.value && ea.value.capture(la, sa), ta.value && ta.value(la, sa)
			},
			ia = la => la instanceof Decimal ? la.toNumber() : la,
			aa = {
				general: na(FEATURES.CAPTURE_GROUP_GENERAL, {
					identify(la) {
						const sa = ca => {
							var ua, da, ha, pa;
							return {
								username: ca.username,
								language_code: (ua = ue.dataUnsafe.user) == null ? void 0 : ua.language_code,
								is_premium: (da = ue.dataUnsafe.user) == null ? void 0 : da.is_premium,
								allows_write_to_pm: (ha = ue.dataUnsafe.user) == null ? void 0 : ha.allows_write_to_pm,
								added_to_attachment_menu: (pa = ue.dataUnsafe.user) == null ? void 0 : pa.added_to_attachment_menu
							}
						};
						ea.value && (la ? ea.value.identify(la.id, sa(la)) : ea.value.reset()), ta.value && (la ? ta.value("login", {
							id: la.id,
							...sa(la)
						}) : ta.value("logout"))
					}
				}),
				game: na(FEATURES.CAPTURE_GROUP_GAME, {
					gameEnd: la => ra("game_end", {
						num: ia(la)
					}),
					shareWin: () => ra("share_win")
				}),
				farming: na(FEATURES.CAPTURE_GROUP_FARMING, {
					farmingStarted: () => ra("farming_started"),
					farmingClaimed: la => ra("farming_claimed", {
						num: ia(la)
					})
				}),
				friendsInvite: na(FEATURES.CAPTURE_GROUP_FRIENDS_INVITE, {
					inviteSent: ({
						method: la
					}) => ra("invite_sent", {
						method: la
					}),
					frensClaimed: la => ra("frens_claimed", {
						num: ia(la)
					})
				}),
				launch: na(FEATURES.CAPTURE_GROUP_LAUNCH, {
					sessionStart: () => ra("session_start"),
					checkLaunchFirstTime: () => {
						const la = "app_opened";
						(ue.storage.local.get(la) ?? void 0) || (ue.storage.local.set(la, getFormattedDate(new Date)), !useAuth().getters.getUser.value && ra("launch_first_time"))
					}
				}),
				tutorial: na(FEATURES.CAPTURE_GROUP_TUTORIAL, {
					usernameStep: () => ra("username_step"),
					accountCreated: la => ra("account_created", la)
				}),
				wallet: na(FEATURES.CAPTURE_GROUP_WALLET, {
					walletConnected: la => ra("wallet_connected", {
						name: la.name,
						$set: {
							wallet_address: la.walletAddress
						}
					}),
					walletDisconnected: () => ra("wallet_disconnected", {
						$unset: ["wallet_address"]
					})
				}),
				tribes: na(FEATURES.CAPTURE_GROUP_TRIBES, {
					tribeInviteSent: la => ra("tribe_invite_sent", la),
					tribeExit: la => ra("tribe_exit", la),
					tribeJoined: la => ra("tribe_joined", la)
				})
			};
		return {
			_flow: {
				init: () => {
					aa.launch.checkLaunchFirstTime()
				}
			},
			...aa
		}
	},
	mustGet = (ue, Yi) => {
		if (ue == null) throw new Error(`[MustGet] ${Yi} is undefined or null`);
		return ue
	},
	useAuth = () => {
		const ue = useState("$OWrSqFye87"),
			Yi = useState("$gU3rt8MuY1"),
			ea = useNuxtApp().$webApp,
			ta = ea.storage,
			na = useState("$4CUcwXlik5"),
			ra = useState("$OQ0mhcJWti"),
			ia = {
				getLocalStorageKey: ua => {
					switch (ua) {
						case JWT.ACCESS:
							return "access_token";
						case JWT.REFRESH:
							return "refresh_token";
						default:
							throw err("Invalid JWT type")
					}
				},
				_setAccessTokenTimeout: ua => {
					ra.value && (clearTimeout(ra.value), ra.value = void 0);
					const da = getTimeToTokenExpiration(ua),
						ha = 50 * 1e3;
					da !== void 0 && da >= ha && (ra.value = setTimeout(sa, da - ha))
				},
				async getToken(ua) {
					return await ta.cloud.get(this.getLocalStorageKey(ua)) || void 0
				},
				async setToken(ua, da) {
					return da === JWT.ACCESS && (Yi.value = ua, this._setAccessTokenTimeout(ua)), await ta.cloud.set(this.getLocalStorageKey(da), ua)
				},
				async removeToken(ua) {
					return ua === JWT.ACCESS && (Yi.value = void 0, ra.value && (clearTimeout(ra.value), ra.value = void 0)), await ta.cloud.remove(this.getLocalStorageKey(ua))
				},
				async setAllTokens(ua) {
					await Promise.all([this.setToken(ua[JWT.ACCESS], JWT.ACCESS), this.setToken(ua[JWT.REFRESH], JWT.REFRESH)])
				},
				async removeAllTokens() {
					await Promise.all([this.removeToken(JWT.ACCESS), this.removeToken(JWT.REFRESH)])
				},
				async _init() {
					const ua = await this.getToken(JWT.ACCESS);
					Yi.value = ua, ua && this._setAccessTokenTimeout(ua)
				}
			},
			aa = async (ua, da) => {
				ue.value = ua, await ia.setAllTokens(da)
			}, oa = async () => {
				var ha, pa;
				const ua = {
						query: ea.data,
						referralToken: ea.dataUnsafe.query.ref
					},
					da = await client.authOrCreate(ua);
				if (da.err) {
					if ((ha = da.message) != null && ha.includes(AUTH_ERROR.USERNAME_TAKEN) || (pa = da.message) != null && pa.includes(AUTH_ERROR.USERNAME_INVALID)) return await useRouter().replace({
						name: "welcome"
					}), !1;
					throw err("Auth failed")
				}
				return da.data.justCreated ? (na.value = da.data, await useRouter().replace({
					name: "welcome"
				})) : await aa(da.data.tokenWithUser.user, da.data.tokenWithUser), !0
			}, la = async () => {
				if (!Yi.value) return await oa();
				const ua = await client.me();
				return ua.err ? (await ia.removeAllTokens(), await oa()) : (ue.value = ua.data, !0)
			}, sa = async () => {
				const ua = await ia.getToken(JWT.REFRESH);
				if (!ua) return await oa();
				const da = await client.refresh(ua);
				return da.err ? (await ia.removeAllTokens(), await oa()) : (await ia.setAllTokens(da.data), !0)
			};
		return {
			_flow: {
				init: async () => {
					watch(ue, ua => {
						useLogger().configureUser(ua), useAnalytics().general.identify(ua)
					}), await ia._init(), await la()
				}
			},
			getters: {
				getUser: computed(() => ue.value),
				mustGetUser: computed(() => mustGet(ue.value, "user")),
				getAccessToken: computed(() => Yi.value),
				userToSetAfterWelcome: computed(() => na.value)
			},
			setters: {
				setTokensWithUser: aa,
				refreshUserToken: sa
			}
		}
	},
	auth_45global = ue => {
		const Yi = useAuth().getters.getUser.value;
		if (ue.name === "preview") return !0;
		if (!Yi && ue.name !== "welcome") return navigateTo({
			name: "welcome"
		});
		if (Yi && ue.name === "welcome") return navigateTo({
			name: "index"
		})
	},
	manifest_45route_45rule = async ue => {
		let Yi, ea;
		const ta = ([Yi, ea] = executeAsync(() => getRouteRules(ue.path)), Yi = await Yi, ea(), Yi);
		if (ta.redirect) return hasProtocol(ta.redirect, {
			acceptRelative: !0
		}) ? (window.location.href = ta.redirect, !1) : ta.redirect
	}, globalMiddleware = [validate, auth_45global, manifest_45route_45rule], namedMiddleware = {};

function createCurrentLocation(ue, Yi, ea) {
	const {
		pathname: ta,
		search: na,
		hash: ra
	} = Yi, ia = ue.indexOf("#");
	if (ia > -1) {
		const la = ra.includes(ue.slice(ia)) ? ue.slice(ia).length : 1;
		let sa = ra.slice(la);
		return sa[0] !== "/" && (sa = "/" + sa), withoutBase(sa, "")
	}
	const aa = withoutBase(ta, ue),
		oa = !ea || isEqual$1(aa, ea, {
			trailingSlash: !0
		}) ? aa : ea;
	return oa + (oa.includes("?") ? "" : na) + ra
}
const plugin = defineNuxtPlugin({
		name: "nuxt:router",
		enforce: "pre",
		async setup(ue) {
			var va;
			let Yi, ea, ta = useRuntimeConfig().app.baseURL;
			routerOptions.hashMode && !ta.includes("#") && (ta += "#");
			const na = ((va = routerOptions.history) == null ? void 0 : va.call(routerOptions, ta)) ?? (routerOptions.hashMode ? createWebHashHistory(ta) : createWebHistory(ta)),
				ra = routerOptions.routes ? ([Yi, ea] = executeAsync(() => routerOptions.routes(_routes)), Yi = await Yi, ea(), Yi ?? _routes) : _routes;
			let ia;
			const aa = createRouter({
				...routerOptions,
				scrollBehavior: (ba, Ea, Sa) => {
					if (Ea === START_LOCATION_NORMALIZED) {
						ia = Sa;
						return
					}
					if (routerOptions.scrollBehavior) {
						if (aa.options.scrollBehavior = routerOptions.scrollBehavior, "scrollRestoration" in window.history) {
							const Ca = aa.beforeEach(() => {
								Ca(), window.history.scrollRestoration = "manual"
							})
						}
						return routerOptions.scrollBehavior(ba, START_LOCATION_NORMALIZED, ia || Sa)
					}
				},
				history: na,
				routes: ra
			});
			"scrollRestoration" in window.history && (window.history.scrollRestoration = "auto"), ue.vueApp.use(aa);
			const oa = shallowRef(aa.currentRoute.value);
			aa.afterEach((ba, Ea) => {
				oa.value = Ea
			}), Object.defineProperty(ue.vueApp.config.globalProperties, "previousRoute", {
				get: () => oa.value
			});
			const la = createCurrentLocation(ta, window.location, ue.payload.path),
				sa = shallowRef(aa.currentRoute.value),
				ca = () => {
					sa.value = aa.currentRoute.value
				};
			ue.hook("page:finish", ca), aa.afterEach((ba, Ea) => {
				var Sa, Ca, ka, Pa;
				((Ca = (Sa = ba.matched[0]) == null ? void 0 : Sa.components) == null ? void 0 : Ca.default) === ((Pa = (ka = Ea.matched[0]) == null ? void 0 : ka.components) == null ? void 0 : Pa.default) && ca()
			});
			const ua = {};
			for (const ba in sa.value) Object.defineProperty(ua, ba, {
				get: () => sa.value[ba],
				enumerable: !0
			});
			ue._route = shallowReactive(ua), ue._middleware = ue._middleware || {
				global: [],
				named: {}
			};
			const da = useError();
			aa.afterEach(async (ba, Ea, Sa) => {
				delete ue._processingMiddleware, !ue.isHydrating && da.value && await ue.runWithContext(clearError), Sa && await ue.callHook("page:loading:end"), ba.matched.length === 0 && await ue.runWithContext(() => showError(createError$1({
					statusCode: 404,
					fatal: !1,
					statusMessage: `Page not found: ${ba.fullPath}`,
					data: {
						path: ba.fullPath
					}
				})))
			});
			try {
				[Yi, ea] = executeAsync(() => aa.isReady()), await Yi, ea()
			} catch (ba) {
				[Yi, ea] = executeAsync(() => ue.runWithContext(() => showError(ba))), await Yi, ea()
			}
			const ha = la !== aa.currentRoute.value.fullPath ? aa.resolve(la) : aa.currentRoute.value;
			ca();
			const pa = ue.payload.state._layout;
			return aa.beforeEach(async (ba, Ea) => {
				var Sa;
				await ue.callHook("page:loading:start"), ba.meta = reactive(ba.meta), ue.isHydrating && pa && !isReadonly(ba.meta.layout) && (ba.meta.layout = pa), ue._processingMiddleware = !0;
				{
					const Ca = new Set([...globalMiddleware, ...ue._middleware.global]);
					for (const ka of ba.matched) {
						const Pa = ka.meta.middleware;
						if (Pa)
							for (const ja of toArray$1(Pa)) Ca.add(ja)
					} {
						const ka = await ue.runWithContext(() => getRouteRules(ba.path));
						if (ka.appMiddleware)
							for (const Pa in ka.appMiddleware) ka.appMiddleware[Pa] ? Ca.add(Pa) : Ca.delete(Pa)
					}
					for (const ka of Ca) {
						const Pa = typeof ka == "string" ? ue._middleware.named[ka] || await ((Sa = namedMiddleware[ka]) == null ? void 0 : Sa.call(namedMiddleware).then(Za => Za.default || Za)) : ka;
						if (!Pa) throw new Error(`Unknown route middleware: '${ka}'.`);
						const ja = await ue.runWithContext(() => Pa(ba, Ea));
						if (!ue.payload.serverRendered && ue.isHydrating && (ja === !1 || ja instanceof Error)) {
							const Za = ja || createError$1({
								statusCode: 404,
								statusMessage: `Page Not Found: ${la}`
							});
							return await ue.runWithContext(() => showError(Za)), !1
						}
						if (ja !== !0 && (ja || ja === !1)) return ja
					}
				}
			}), aa.onError(async () => {
				delete ue._processingMiddleware, await ue.callHook("page:loading:end")
			}), ue.hooks.hookOnce("app:created", async () => {
				try {
					"name" in ha && (ha.name = void 0), await aa.replace({
						...ha,
						force: !0
					}), aa.options.scrollBehavior = routerOptions.scrollBehavior
				} catch (ba) {
					await ue.runWithContext(() => showError(ba))
				}
			}), {
				provide: {
					router: aa
				}
			}
		}
	}),
	requestIdleCallback = globalThis.requestIdleCallback || (ue => {
		const Yi = Date.now(),
			ea = {
				didTimeout: !1,
				timeRemaining: () => Math.max(0, 50 - (Date.now() - Yi))
			};
		return setTimeout(() => {
			ue(ea)
		}, 1)
	}),
	cancelIdleCallback = globalThis.cancelIdleCallback || (ue => {
		clearTimeout(ue)
	}),
	onNuxtReady = ue => {
		const Yi = useNuxtApp();
		Yi.isHydrating ? Yi.hooks.hookOnce("app:suspense:resolve", () => {
			requestIdleCallback(() => ue())
		}) : requestIdleCallback(() => ue())
	},
	payload_client_yVLowv6hDl = defineNuxtPlugin({
		name: "nuxt:payload",
		setup(ue) {
			useRouter().beforeResolve(async (Yi, ea) => {
				if (Yi.path === ea.path) return;
				const ta = await loadPayload(Yi.path);
				ta && Object.assign(ue.static.data, ta.data)
			}), onNuxtReady(() => {
				var Yi;
				ue.hooks.hook("link:prefetch", async ea => {
					const {
						hostname: ta
					} = new URL(ea, window.location.href);
					ta === window.location.hostname && await loadPayload(ea)
				}), ((Yi = navigator.connection) == null ? void 0 : Yi.effectiveType) !== "slow-2g" && setTimeout(getAppManifest, 1e3)
			})
		}
	}),
	navigation_repaint_client_bs2bWDGRIE = defineNuxtPlugin(() => {
		const ue = useRouter();
		onNuxtReady(() => {
			ue.beforeResolve(async () => {
				await new Promise(Yi => {
					setTimeout(Yi, 100), requestAnimationFrame(() => {
						setTimeout(Yi, 0)
					})
				})
			})
		})
	}),
	check_outdated_build_client_8vK7RkfGxZ = defineNuxtPlugin(ue => {
		let Yi;
		async function ea() {
			const ta = await getAppManifest();
			Yi && clearTimeout(Yi), Yi = setTimeout(ea, outdatedBuildInterval);
			try {
				const na = await $fetch(buildAssetsURL("builds/latest.json") + `?${Date.now()}`);
				na.id !== ta.id && ue.hooks.callHook("app:manifest:update", na)
			} catch {}
		}
		onNuxtReady(() => {
			Yi = setTimeout(ea, outdatedBuildInterval)
		})
	});

function reloadNuxtApp(ue = {}) {
	const Yi = ue.path || window.location.pathname;
	let ea = {};
	try {
		ea = destr(sessionStorage.getItem("nuxt:reload") || "{}")
	} catch {}
	if (ue.force || (ea == null ? void 0 : ea.path) !== Yi || (ea == null ? void 0 : ea.expires) < Date.now()) {
		try {
			sessionStorage.setItem("nuxt:reload", JSON.stringify({
				path: Yi,
				expires: Date.now() + (ue.ttl ?? 1e4)
			}))
		} catch {}
		if (ue.persistState) try {
			sessionStorage.setItem("nuxt:reload:state", JSON.stringify({
				state: useNuxtApp().payload.state
			}))
		} catch {}
		window.location.pathname !== Yi ? window.location.href = Yi : window.location.reload()
	}
}
const chunk_reload_client_UciE0i6zes = defineNuxtPlugin({
		name: "nuxt:chunk-reload",
		setup(ue) {
			const Yi = useRouter(),
				ea = useRuntimeConfig(),
				ta = new Set;
			Yi.beforeEach(() => {
				ta.clear()
			}), ue.hook("app:chunkError", ({
				error: ra
			}) => {
				ta.add(ra)
			});

			function na(ra) {
				const aa = "href" in ra && ra.href[0] === "#" ? ea.app.baseURL + ra.href : joinURL(ea.app.baseURL, ra.fullPath);
				reloadNuxtApp({
					path: aa,
					persistState: !0
				})
			}
			ue.hook("app:manifest:update", () => {
				Yi.beforeResolve(na)
			}), Yi.onError((ra, ia) => {
				ta.has(ra) && na(ia)
			})
		}
	}),
	components_plugin_KR1HBZs4kY = defineNuxtPlugin({
		name: "nuxt:global-components"
	}),
	layouts = {},
	prefetch_client_5tzzN0oIVL = defineNuxtPlugin({
		name: "nuxt:prefetch",
		setup(ue) {
			const Yi = useRouter();
			ue.hooks.hook("app:mounted", () => {
				Yi.beforeEach(async ea => {
					var na;
					const ta = (na = ea == null ? void 0 : ea.meta) == null ? void 0 : na.layout;
					ta && typeof layouts[ta] == "function" && await layouts[ta]()
				})
			}), ue.hooks.hook("link:prefetch", ea => {
				if (hasProtocol(ea)) return;
				const ta = Yi.resolve(ea);
				if (!ta) return;
				const na = ta.meta.layout;
				let ra = toArray$1(ta.meta.middleware);
				ra = ra.filter(ia => typeof ia == "string");
				for (const ia of ra) typeof namedMiddleware[ia] == "function" && namedMiddleware[ia]();
				na && typeof layouts[na] == "function" && layouts[na]()
			})
		}
	});
/*!
 * shared v9.14.0
 * (c) 2024 kazuya kawaguchi
 * Released under the MIT License.
 */
const inBrowser$1 = typeof window < "u",
	makeSymbol = (ue, Yi = !1) => Yi ? Symbol.for(ue) : Symbol(ue),
	generateFormatCacheKey = (ue, Yi, ea) => friendlyJSONstringify({
		l: ue,
		k: Yi,
		s: ea
	}),
	friendlyJSONstringify = ue => JSON.stringify(ue).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"),
	isNumber = ue => typeof ue == "number" && isFinite(ue),
	isDate$1 = ue => toTypeString(ue) === "[object Date]",
	isRegExp$1 = ue => toTypeString(ue) === "[object RegExp]",
	isEmptyObject = ue => isPlainObject$1(ue) && Object.keys(ue).length === 0,
	assign = Object.assign;
let _globalThis;
const getGlobalThis = () => _globalThis || (_globalThis = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global$1 < "u" ? global$1 : {});

function escapeHtml(ue) {
	return ue.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;")
}
const hasOwnProperty = Object.prototype.hasOwnProperty;

function hasOwn(ue, Yi) {
	return hasOwnProperty.call(ue, Yi)
}
const isArray = Array.isArray,
	isFunction = ue => typeof ue == "function",
	isString$1 = ue => typeof ue == "string",
	isBoolean = ue => typeof ue == "boolean",
	isSymbol = ue => typeof ue == "symbol",
	isObject = ue => ue !== null && typeof ue == "object",
	isPromise = ue => isObject(ue) && isFunction(ue.then) && isFunction(ue.catch),
	objectToString$1 = Object.prototype.toString,
	toTypeString = ue => objectToString$1.call(ue),
	isPlainObject$1 = ue => {
		if (!isObject(ue)) return !1;
		const Yi = Object.getPrototypeOf(ue);
		return Yi === null || Yi.constructor === Object
	},
	toDisplayString = ue => ue == null ? "" : isArray(ue) || isPlainObject$1(ue) && ue.toString === objectToString$1 ? JSON.stringify(ue, null, 2) : String(ue);

function join(ue, Yi = "") {
	return ue.reduce((ea, ta, na) => na === 0 ? ea + ta : ea + Yi + ta, "")
}

function incrementer(ue) {
	let Yi = ue;
	return () => ++Yi
}

function warn(ue, Yi) {
	typeof console < "u" && (console.warn("[intlify] " + ue), Yi && console.warn(Yi.stack))
}
const isNotObjectOrIsArray = ue => !isObject(ue) || isArray(ue);

function deepCopy(ue, Yi) {
	if (isNotObjectOrIsArray(ue) || isNotObjectOrIsArray(Yi)) throw new Error("Invalid value");
	const ea = [{
		src: ue,
		des: Yi
	}];
	for (; ea.length;) {
		const {
			src: ta,
			des: na
		} = ea.pop();
		Object.keys(ta).forEach(ra => {
			isNotObjectOrIsArray(ta[ra]) || isNotObjectOrIsArray(na[ra]) ? na[ra] = ta[ra] : ea.push({
				src: ta[ra],
				des: na[ra]
			})
		})
	}
}
const resource = {
		"base.back": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Back"
			}
		},
		"base.cancel": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Cancel"
			}
		},
		"base.close": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Close"
			}
		},
		"base.continue": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Continue"
			}
		},
		"base.copy_link": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Copy link"
			}
		},
		"base.ok": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Ok"
			}
		},
		"base.read_more": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Read more"
			}
		},
		"base.send": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Send"
			}
		},
		"copy.copied": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Copied to clipboard"
			}
		},
		"copy.failed_to_copy": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Failed to copy to clipboard"
			}
		},
		"memepad.explore.event.kind.bought": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Bought"
			}
		},
		"memepad.explore.event.kind.launched": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Launched"
			}
		},
		"memepad.explore.event.kind.sold": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Sold"
			}
		},
		"memepad.explore.launch.button_text": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Launch token"
			}
		},
		"memepad.explore.launch_modal.button_text": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Launch token"
			}
		},
		"memepad.explore.launch_modal.subtitle": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3,
					v: "Creating meme coins is easy. Just bring your idea and pay a "
				}, {
					t: 4,
					k: "fees"
				}, {
					t: 3,
					v: " TON network fee."
				}]
			}
		},
		"memepad.explore.launch_modal.title": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Meme coins"
			}
		},
		"memepad.explore.panel_list.title.bluming": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Bluming"
			}
		},
		"memepad.explore.panel_list.title.fresh": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Fresh"
			}
		},
		"memepad.explore.panel_list.title.stoned": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Stoned"
			}
		},
		"memepad.explore.panel_list.title.top_cap": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "TopCap"
			}
		},
		"memepad.explore.panel_list.title.yours": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Yours"
			}
		},
		"memepad.explore.spotlight.title": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Spotlight"
			}
		},
		"memepad.explore.title": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Memepad"
			}
		},
		"memepad.intro.button_text": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Get Started"
			}
		},
		"memepad.intro.note": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "This is a high‑risk investment and you should not expect to be protected if something goes wrong."
			}
		},
		"memepad.intro.title": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Trade and launch meme coins"
			}
		},
		"memepad.jetton.hit-target-sheet.title": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Hit the target"
			}
		},
		"memepad.jetton.hit_target_sheet.subtitle": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Get to 1000 TON market cap to start trading your meme coin on STON.fi"
			}
		},
		"memepad.jetton.hit_target_sheet.title": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Hit the target"
			}
		},
		"memepad.jetton.released.button_text": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Trade on Ston.Fi"
			}
		},
		"memepad.jetton.released.title": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Successfully Blumed to Ston.fi"
			}
		},
		"memepad.jetton.share_button_text": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Share the token link with friends"
			}
		},
		"memepad.jetton.top_charts_sheet.subtitle": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Achieve 500 TON market cap for Bluming status. More visibility leads to greater growth!"
			}
		},
		"memepad.jetton.top_charts_sheet.title": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Top the charts"
			}
		},
		"memepad.new.step_1.field_banner.description": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3,
					v: "Any image up to "
				}, {
					t: 4,
					k: "maxUploadSize"
				}, {
					t: 3,
					v: " MB"
				}]
			}
		},
		"memepad.new.step_1.field_banner.label": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Banner"
			}
		},
		"memepad.new.step_1.field_banner.uploading": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Uploading..."
			}
		},
		"memepad.new.step_1.field_description.label": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Description"
			}
		},
		"memepad.new.step_1.field_description.placeholder": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Coin summary: features, purpose, community"
			}
		},
		"memepad.new.step_1.field_icon.description": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3,
					v: "Any image up to "
				}, {
					t: 4,
					k: "maxUploadSize"
				}, {
					t: 3,
					v: " MB"
				}]
			}
		},
		"memepad.new.step_1.field_icon.label": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Icon"
			}
		},
		"memepad.new.step_1.field_name.label": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Name"
			}
		},
		"memepad.new.step_1.field_name.placeholder": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Full token name"
			}
		},
		"memepad.new.step_1.field_nsfw.label": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Let us know if a token is NSFW"
			}
		},
		"memepad.new.step_1.field_nsfw.message": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: `NSFW means "Not Safe For Work." We'll ask permission to display it.`
			}
		},
		"memepad.new.step_1.field_ticker.custom_validator_error": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Ticker must contain only uppercase letters"
			}
		},
		"memepad.new.step_1.field_ticker.label": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Ticker"
			}
		},
		"memepad.new.step_1.field_ticker.placeholder": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Short symbol for exchanges"
			}
		},
		"memepad.new.step_1.title": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Set your token's info"
			}
		},
		"memepad.new.step_2.title": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Personalise token"
			}
		},
		"memepad.new.step_3.buy-sheet.button-text": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Review"
			}
		},
		"memepad.new.step_3.buy-sheet.subtitle": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Boost investor confidence, and show commitment to your project."
			}
		},
		"memepad.new.step_3.buy-sheet.title": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Buy tokens?"
			}
		},
		"memepad.new.step_3.title": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Get your share"
			}
		},
		"memepad.new.step_4.title": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Overview"
			}
		},
		"memepad.new.step_launch.subtitle": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "You'll get a heads-up when the token is ready."
			}
		},
		"memepad.new.step_launch.title": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Launching"
			}
		},
		"memepad.social_providers.instagram.label": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Instagram"
			}
		},
		"memepad.social_providers.telegram.label": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Telegram"
			}
		},
		"memepad.social_providers.telegram.placeholder": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Chat"
			}
		},
		"memepad.social_providers.twitter.label": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "X"
			}
		},
		"memepad.social_providers.website.label": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Website"
			}
		},
		"tabs.earn": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Earn"
			}
		},
		"tabs.frens": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Frens"
			}
		},
		"tabs.home": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Home"
			}
		},
		"tabs.memepad": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Memepad"
			}
		},
		"tabs.wallet": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Wallet"
			}
		},
		"wallet.history.points.in_blum_drop": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Receive from Blum drop"
			}
		},
		"wallet.history.points.in_daily_rewards": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Receive from daily rewards"
			}
		},
		"wallet.history.points.in_drop_game": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Receive from drop game"
			}
		},
		"wallet.history.points.in_farming": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Receive from farming"
			}
		},
		"wallet.history.points.in_frens": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Receive from Frens"
			}
		},
		"wallet.history.points.in_task": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Receive from task"
			}
		},
		"wallet.history.points.in_wallet_migration": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Receive from wallet migration"
			}
		},
		"wallet.history.points.out_drop_game": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Spent for drop game"
			}
		},
		"wallet.history.tokens.in": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Received"
			}
		},
		"wallet.history.tokens.in_nft": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Received NFT"
			}
		},
		"wallet.history.tokens.other_contract_deploy": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Contract deploy"
			}
		},
		"wallet.history.tokens.other_contract_execution": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Contract execution"
			}
		},
		"wallet.history.tokens.other_domain_renew": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Domain renew"
			}
		},
		"wallet.history.tokens.other_stake_request": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Withdraw stake request"
			}
		},
		"wallet.history.tokens.other_unsubscribed": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Unsubscribed"
			}
		},
		"wallet.history.tokens.out": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Send"
			}
		},
		"wallet.history.tokens.out_nft": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Send NFT"
			}
		},
		"wallet.history.tokens.swap": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Swap"
			}
		},
		"wallet.history.unknown": {
			t: 0,
			b: {
				t: 2,
				i: [{
					t: 3
				}],
				s: "Unknown"
			}
		}
	},
	localeCodes = ["en"],
	localeLoaders = {
		en: [{
			key: "../locales/en.json",
			load: () => Promise.resolve(resource),
			cache: !0
		}]
	},
	vueI18nConfigs = [() => __vitePreload(() => import("./DyjZxngU.js"), [], import.meta.url)],
	normalizedLocales = [{
		code: "en",
		files: [{
			path: "/builds/blum/frontend-mini-app/telegram/locales/en.json"
		}]
	}],
	NUXT_I18N_MODULE_ID = "@nuxtjs/i18n",
	parallelPlugin = !1,
	isSSG = !1,
	DEFAULT_DYNAMIC_PARAMS_KEY = "nuxtI18n",
	DEFAULT_COOKIE_KEY = "i18n_redirected",
	SWITCH_LOCALE_PATH_LINK_IDENTIFIER = "nuxt-i18n-slp",
	inBrowser = typeof window < "u";

function getNormalizedLocales(ue) {
	ue = ue || [];
	const Yi = [];
	for (const ea of ue) isString$1(ea) ? Yi.push({
		code: ea
	}) : Yi.push(ea);
	return Yi
}

function isI18nInstance(ue) {
	return ue != null && "global" in ue && "mode" in ue
}

function isComposer(ue) {
	return ue != null && !("__composer" in ue) && "locale" in ue && isRef(ue.locale)
}

function isVueI18n(ue) {
	return ue != null && "__composer" in ue
}

function getI18nTarget(ue) {
	return isI18nInstance(ue) ? ue.global : ue
}

function getComposer$1(ue) {
	const Yi = getI18nTarget(ue);
	return isComposer(Yi) ? Yi : isVueI18n(Yi) ? Yi.__composer : Yi
}

function getLocale$1(ue) {
	return unref(getI18nTarget(ue).locale)
}

function getLocales(ue) {
	return unref(getI18nTarget(ue).locales)
}

function getLocaleCodes(ue) {
	return unref(getI18nTarget(ue).localeCodes)
}

function setLocale(ue, Yi) {
	const ea = getI18nTarget(ue);
	isRef(ea.locale) ? ea.locale.value = Yi : ea.locale = Yi
}

function getRouteName(ue) {
	return isString$1(ue) ? ue : isSymbol(ue) ? ue.toString() : "(null)"
}

function getLocaleRouteName(ue, Yi, {
	defaultLocale: ea,
	strategy: ta,
	routesNameSeparator: na,
	defaultLocaleRouteNameSuffix: ra,
	differentDomains: ia
}) {
	const aa = ta !== "no_prefix" || ia;
	let oa = getRouteName(ue) + (aa ? na + Yi : "");
	return Yi === ea && ta === "prefix_and_default" && (oa += na + ra), oa
}

function resolveBaseUrl(ue, Yi) {
	return isFunction(ue) ? ue(Yi) : ue
}

function matchBrowserLocale(ue, Yi) {
	const ea = [];
	for (const [ta, na] of Yi.entries()) {
		const ra = ue.find(ia => ia.language.toLowerCase() === na.toLowerCase());
		if (ra) {
			ea.push({
				code: ra.code,
				score: 1 - ta / Yi.length
			});
			break
		}
	}
	for (const [ta, na] of Yi.entries()) {
		const ra = na.split("-")[0].toLowerCase(),
			ia = ue.find(aa => aa.language.split("-")[0].toLowerCase() === ra);
		if (ia) {
			ea.push({
				code: ia.code,
				score: .999 - ta / Yi.length
			});
			break
		}
	}
	return ea
}
const DefaultBrowserLocaleMatcher = matchBrowserLocale;

function compareBrowserLocale(ue, Yi) {
	return ue.score === Yi.score ? Yi.code.length - ue.code.length : Yi.score - ue.score
}
const DefaultBrowerLocaleComparer = compareBrowserLocale;

function findBrowserLocale(ue, Yi, {
	matcher: ea = DefaultBrowserLocaleMatcher,
	comparer: ta = DefaultBrowerLocaleComparer
} = {}) {
	const na = [];
	for (const ia of ue) {
		const {
			code: aa
		} = ia, oa = ia.language || aa;
		na.push({
			code: aa,
			language: oa
		})
	}
	const ra = ea(na, Yi);
	return ra.length > 1 && ra.sort(ta), ra.length ? ra[0].code : ""
}

function getLocalesRegex(ue) {
	return new RegExp(`^/(${ue.join("|")})(?:/|$)`, "i")
}
const cacheMessages = new Map;
async function loadVueI18nOptions(ue, Yi) {
	const ea = {
		messages: {}
	};
	for (const ta of ue) {
		const {
			default: na
		} = await ta(), ra = isFunction(na) ? await Yi.runWithContext(async () => await na()) : na;
		deepCopy(ra, ea)
	}
	return ea
}

function makeFallbackLocaleCodes(ue, Yi) {
	let ea = [];
	if (isArray(ue)) ea = ue;
	else if (isObject(ue)) {
		const ta = [...Yi, "default"];
		for (const na of ta) ue[na] && (ea = [...ea, ...ue[na].filter(Boolean)])
	} else isString$1(ue) && Yi.every(ta => ta !== ue) && ea.push(ue);
	return ea
}
async function loadInitialMessages(ue, Yi, ea) {
	const {
		defaultLocale: ta,
		initialLocale: na,
		localeCodes: ra,
		fallbackLocale: ia,
		lazy: aa
	} = ea;
	if (aa && ia) {
		const la = makeFallbackLocaleCodes(ia, [ta, na]);
		await Promise.all(la.map(sa => loadAndSetLocaleMessages(sa, Yi, ue)))
	}
	const oa = aa ? [...new Set().add(ta).add(na)] : ra;
	return await Promise.all(oa.map(la => loadAndSetLocaleMessages(la, Yi, ue))), ue
}
async function loadMessage(ue, {
	key: Yi,
	load: ea
}) {
	let ta = null;
	try {
		const na = await ea().then(ra => ra.default || ra);
		isFunction(na) ? ta = await na(ue) : (ta = na, ta != null && cacheMessages && cacheMessages.set(Yi, ta))
	} catch (na) {
		console.error("Failed locale loading: " + na.message)
	}
	return ta
}
async function loadLocale(ue, Yi, ea) {
	const ta = Yi[ue];
	if (ta == null) {
		console.warn("Could not find messages for locale code: " + ue);
		return
	}
	const na = {};
	for (const ra of ta) {
		let ia = null;
		cacheMessages && cacheMessages.has(ra.key) && ra.cache ? ia = cacheMessages.get(ra.key) : ia = await loadMessage(ue, ra), ia != null && deepCopy(ia, na)
	}
	ea(ue, na)
}
async function loadAndSetLocaleMessages(ue, Yi, ea) {
	await loadLocale(ue, Yi, (na, ra) => {
		const ia = ea[na] || {};
		deepCopy(ra, ia), ea[na] = ia
	})
}

function split(ue, Yi) {
	return [ue.slice(0, Yi), ue.slice(Yi)]
}

function routeToObject(ue) {
	const {
		fullPath: Yi,
		query: ea,
		hash: ta,
		name: na,
		path: ra,
		params: ia,
		meta: aa,
		redirectedFrom: oa,
		matched: la
	} = ue;
	return {
		fullPath: Yi,
		params: ia,
		query: ea,
		hash: ta,
		name: na,
		path: ra,
		meta: aa,
		matched: la,
		redirectedFrom: oa
	}
}

function resolve({
	router: ue
}, Yi, ea, ta) {
	var la, sa;
	if (ea !== "prefix") return ue.resolve(Yi);
	const [na, ra] = split(Yi.path, 1), ia = `${na}${ta}${ra===""?ra:`/${ra}`}`, aa = (sa = (la = ue.options) == null ? void 0 : la.routes) == null ? void 0 : sa.find(ca => ca.path === ia);
	if (aa == null) return Yi;
	const oa = assign({}, Yi, aa);
	return oa.path = ia, ue.resolve(oa)
}
const RESOLVED_PREFIXED = new Set(["prefix_and_default", "prefix_except_default"]);

function prefixable(ue) {
	const {
		currentLocale: Yi,
		defaultLocale: ea,
		strategy: ta
	} = ue;
	return !(Yi === ea && RESOLVED_PREFIXED.has(ta)) && ta !== "no_prefix"
}
const DefaultPrefixable = prefixable;

function getRouteBaseName(ue, Yi) {
	const {
		routesNameSeparator: ea
	} = ue.runtimeConfig.public.i18n, ta = unref(Yi);
	return ta == null || !ta.name ? void 0 : getRouteName(ta.name).split(ea)[0]
}

function localePath(ue, Yi, ea) {
	var na;
	if (typeof Yi == "string" && hasProtocol(Yi, {
			acceptRelative: !0
		})) return Yi;
	const ta = resolveRoute(ue, Yi, ea);
	return ta == null ? "" : ((na = ta.redirectedFrom) == null ? void 0 : na.fullPath) || ta.fullPath
}

function localeRoute(ue, Yi, ea) {
	return resolveRoute(ue, Yi, ea) ?? void 0
}

function localeLocation(ue, Yi, ea) {
	return resolveRoute(ue, Yi, ea) ?? void 0
}

function resolveRoute(ue, Yi, ea) {
	const {
		router: ta,
		i18n: na
	} = ue, ra = ea || getLocale$1(na), {
		defaultLocale: ia,
		strategy: aa,
		trailingSlash: oa
	} = ue.runtimeConfig.public.i18n, la = extendPrefixable(ue.runtimeConfig);
	let sa;
	if (isString$1(Yi))
		if (Yi[0] === "/") {
			const {
				pathname: da,
				search: ha,
				hash: pa
			} = parsePath(Yi), va = parseQuery$1(ha);
			sa = {
				path: da,
				query: va,
				hash: pa
			}
		} else sa = {
			name: Yi
		};
	else sa = Yi;
	let ca = assign({}, sa);
	if ((da => "path" in da && !!da.path && !("name" in da))(ca)) {
		const da = resolve(ue, ca, aa, ra),
			ha = getRouteBaseName(ue, da);
		isString$1(ha) ? (ca = {
			name: getLocaleRouteName(ha, ra, ue.runtimeConfig.public.i18n),
			params: da.params,
			query: da.query,
			hash: da.hash
		}, ca.state = da.state) : (la({
			currentLocale: ra,
			defaultLocale: ia,
			strategy: aa
		}) && (ca.path = `/${ra}${ca.path}`), ca.path = oa ? withTrailingSlash(ca.path, !0) : withoutTrailingSlash(ca.path, !0))
	} else !ca.name && !("path" in ca) && (ca.name = getRouteBaseName(ue, ta.currentRoute.value)), ca.name = getLocaleRouteName(ca.name, ra, ue.runtimeConfig.public.i18n);
	try {
		const da = ta.resolve(ca);
		return da.name ? da : ta.resolve(Yi)
	} catch (da) {
		if (typeof da == "object" && "type" in da && da.type === 1) return null
	}
}
const DefaultSwitchLocalePathIntercepter = ue => ue;

function getLocalizableMetaFromDynamicParams(ue, Yi) {
	var ta;
	if (ue.runtimeConfig.public.i18n.experimental.switchLocalePathLinkSSR) return unref(ue.metaState.value);
	const ea = Yi.meta || {};
	return ((ta = unref(ea)) == null ? void 0 : ta[DEFAULT_DYNAMIC_PARAMS_KEY]) || {}
}

function switchLocalePath(ue, Yi, ea) {
	const ta = ea ?? ue.router.currentRoute.value,
		na = getRouteBaseName(ue, ta);
	if (!na) return "";
	const ra = extendSwitchLocalePathIntercepter(ue.runtimeConfig),
		ia = routeToObject(ta),
		aa = getLocalizableMetaFromDynamicParams(ue, ta)[Yi],
		oa = {
			...ia,
			name: na,
			params: {
				...ia.params,
				...aa
			}
		},
		la = localePath(ue, oa, Yi);
	return ra(la, Yi)
}

function localeHead(ue, {
	addDirAttribute: Yi = !1,
	addSeoAttributes: ea = !0,
	identifierAttribute: ta = "hid"
}) {
	const {
		defaultDirection: na
	} = useRuntimeConfig().public.i18n, ra = getComposer$1(ue.i18n), ia = {
		htmlAttrs: {},
		link: [],
		meta: []
	};
	if (unref(ra.locales) == null || unref(ra.baseUrl) == null) return ia;
	const aa = getLocale$1(ue.i18n),
		oa = getLocales(ue.i18n),
		la = getNormalizedLocales(oa).find(ua => ua.code === aa) || {
			code: aa
		},
		sa = la.language,
		ca = la.dir || na;
	return Yi && (ia.htmlAttrs.dir = ca), ea && aa && unref(ra.locales) && (sa && (ia.htmlAttrs.lang = sa), ia.link.push(...getHreflangLinks(ue, unref(oa), ta), ...getCanonicalLink(ue, ta, ea)), ia.meta.push(...getOgUrl(ue, ta, ea), ...getCurrentOgLocale(la, sa, ta), ...getAlternateOgLocales(unref(oa), sa, ta))), ia
}

function getBaseUrl() {
	const ue = useNuxtApp(),
		Yi = getComposer$1(ue.$i18n);
	return joinURL(unref(Yi.baseUrl), ue.$config.app.baseURL)
}

function getHreflangLinks(ue, Yi, ea) {
	const ta = getBaseUrl(),
		{
			defaultLocale: na,
			strategy: ra
		} = useRuntimeConfig().public.i18n,
		ia = [];
	if (ra === "no_prefix") return ia;
	const aa = new Map;
	for (const oa of Yi) {
		const la = oa.language;
		if (!la) {
			console.warn("Locale `language` ISO code is required to generate alternate link");
			continue
		}
		const [sa, ca] = la.split("-");
		sa && ca && (oa.isCatchallLocale || !aa.has(sa)) && aa.set(sa, oa), aa.set(la, oa)
	}
	for (const [oa, la] of aa.entries()) {
		const sa = switchLocalePath(ue, la.code);
		sa && ia.push({
			[ea]: `i18n-alt-${oa}`,
			rel: "alternate",
			href: toAbsoluteUrl(sa, ta),
			hreflang: oa
		})
	}
	if (na) {
		const oa = switchLocalePath(ue, na);
		oa && ia.push({
			[ea]: "i18n-xd",
			rel: "alternate",
			href: toAbsoluteUrl(oa, ta),
			hreflang: "x-default"
		})
	}
	return ia
}

function getCanonicalUrl(ue, Yi, ea) {
	const ta = ue.router.currentRoute.value,
		na = localeRoute(ue, {
			...ta,
			path: void 0,
			name: getRouteBaseName(ue, ta)
		});
	if (!na) return "";
	let ra = toAbsoluteUrl(na.path, Yi);
	const ia = isObject(ea) && ea.canonicalQueries || [],
		aa = na.query,
		oa = new URLSearchParams;
	for (const sa of ia)
		if (sa in aa) {
			const ca = aa[sa];
			isArray(ca) ? ca.forEach(ua => oa.append(sa, ua || "")) : oa.append(sa, ca || "")
		} const la = oa.toString();
	return la && (ra = `${ra}?${la}`), ra
}

function getCanonicalLink(ue, Yi, ea) {
	const ta = getBaseUrl(),
		na = getCanonicalUrl(ue, ta, ea);
	return na ? [{
		[Yi]: "i18n-can",
		rel: "canonical",
		href: na
	}] : []
}

function getOgUrl(ue, Yi, ea) {
	const ta = getBaseUrl(),
		na = getCanonicalUrl(ue, ta, ea);
	return na ? [{
		[Yi]: "i18n-og-url",
		property: "og:url",
		content: na
	}] : []
}

function getCurrentOgLocale(ue, Yi, ea) {
	return !ue || !Yi ? [] : [{
		[ea]: "i18n-og",
		property: "og:locale",
		content: hypenToUnderscore(Yi)
	}]
}

function getAlternateOgLocales(ue, Yi, ea) {
	return ue.filter(na => na.language && na.language !== Yi).map(na => ({
		[ea]: `i18n-og-alt-${na.language}`,
		property: "og:locale:alternate",
		content: hypenToUnderscore(na.language)
	}))
}

function hypenToUnderscore(ue) {
	return (ue || "").replace(/-/g, "_")
}

function toAbsoluteUrl(ue, Yi) {
	return ue.match(/^https?:\/\//) ? ue : joinURL(Yi, ue)
}

function createLocaleFromRouteGetter() {
	const {
		routesNameSeparator: ue,
		defaultLocaleRouteNameSuffix: Yi
	} = useRuntimeConfig().public.i18n, ea = `(${localeCodes.join("|")})`, ta = `(?:${ue}${Yi})?`, na = new RegExp(`${ue}${ea}${ta}$`, "i"), ra = getLocalesRegex(localeCodes);
	return aa => {
		if (isObject(aa)) {
			if (aa.name) {
				const la = (isString$1(aa.name) ? aa.name : aa.name.toString()).match(na);
				if (la && la.length > 1) return la[1]
			} else if (aa.path) {
				const oa = aa.path.match(ra);
				if (oa && oa.length > 1) return oa[1]
			}
		} else if (isString$1(aa)) {
			const oa = aa.match(ra);
			if (oa && oa.length > 1) return oa[1]
		}
		return ""
	}
}

function setCookieLocale(ue, Yi) {
	return callVueI18nInterfaces(ue, "setLocaleCookie", Yi)
}

function mergeLocaleMessage(ue, Yi, ea) {
	return callVueI18nInterfaces(ue, "mergeLocaleMessage", Yi, ea)
}
async function onBeforeLanguageSwitch(ue, Yi, ea, ta, na) {
	return callVueI18nInterfaces(ue, "onBeforeLanguageSwitch", Yi, ea, ta, na)
}

function onLanguageSwitched(ue, Yi, ea) {
	return callVueI18nInterfaces(ue, "onLanguageSwitched", Yi, ea)
}

function initCommonComposableOptions(ue) {
	return {
		i18n: ue ?? useNuxtApp().$i18n,
		router: useRouter(),
		runtimeConfig: useRuntimeConfig(),
		metaState: useState("nuxt-i18n-meta", () => ({}))
	}
}
async function loadAndSetLocale(ue, Yi, ea, ta = !1) {
	const {
		differentDomains: na,
		skipSettingLocaleOnNavigate: ra,
		lazy: ia
	} = ea, aa = runtimeDetectBrowserLanguage(ea), oa = useNuxtApp(), la = getLocale$1(Yi), sa = getLocaleCodes(Yi);

	function ca(da = la) {
		aa === !1 || !aa.useCookie || ra || setCookieLocale(Yi, da)
	}
	if (!ue || !ta && na || la === ue) return ca(), !1;
	const ua = await onBeforeLanguageSwitch(Yi, la, ue, ta, oa);
	if (ua && sa.includes(ua)) {
		if (la === ua) return ca(), !1;
		ue = ua
	}
	if (ia) {
		const da = getVueI18nPropertyValue(Yi, "fallbackLocale"),
			ha = (pa, va) => mergeLocaleMessage(Yi, pa, va);
		if (da) {
			const pa = makeFallbackLocaleCodes(da, [ue]);
			await Promise.all(pa.map(va => loadLocale(va, localeLoaders, ha)))
		}
		await loadLocale(ue, localeLoaders, ha)
	}
	return ra ? !1 : (ca(ue), setLocale(Yi, ue), await onLanguageSwitched(Yi, la, ue), !0)
}

function createLogger(ue) {
	return {
		log: console.log.bind(console, `${ue}:`)
	}
}

function detectLocale(ue, Yi, ea, ta, na) {
	const {
		strategy: ra,
		defaultLocale: ia,
		differentDomains: aa,
		multiDomainLocales: oa
	} = na, {
		localeCookie: la
	} = ta, sa = runtimeDetectBrowserLanguage(na);
	createLogger("detectLocale");
	const ca = isFunction(ea) ? ea() : ea,
		ua = detectBrowserLanguage(ue, ta, ca);
	if (ua.reason === DetectFailure.SSG_IGNORE) return ca;
	if (ua.locale && ua.from != null) return ua.locale;
	let da = "";
	aa || oa ? da || (da = getLocaleDomain(normalizedLocales, ra, ue)) : ra !== "no_prefix" && (da || (da = Yi(ue)));
	const ha = sa && sa.useCookie && la;
	return da || (da = ha || ca || ia || ""), da
}

function detectRedirect({
	route: ue,
	targetLocale: Yi,
	routeLocaleGetter: ea,
	calledWithRouting: ta = !1
}) {
	const na = useNuxtApp(),
		ra = initCommonComposableOptions(),
		{
			strategy: ia,
			differentDomains: aa
		} = ra.runtimeConfig.public.i18n;
	let oa = "";
	const {
		fullPath: la
	} = ue.to;
	if (!aa && (ta || ia !== "no_prefix") && ea(ue.to) !== Yi) {
		const sa = na.$switchLocalePath(Yi) || na.$localePath(la, Yi);
		isString$1(sa) && sa && !isEqual$1(sa, la) && !sa.startsWith("//") && (oa = ue.from && ue.from.fullPath === sa ? "" : sa)
	}
	if ((aa || isSSG) && ea(ue.to) !== Yi) {
		const sa = switchLocalePath(ra, Yi, ue.to);
		isString$1(sa) && sa && !isEqual$1(sa, la) && !sa.startsWith("//") && (oa = sa)
	}
	return oa
}

function isRootRedirectOptions(ue) {
	return isObject(ue) && "path" in ue && "statusCode" in ue
}
const useRedirectState = () => useState(NUXT_I18N_MODULE_ID + ":redirect", () => "");

function _navigate(ue, Yi) {
	return navigateTo(ue, {
		redirectCode: Yi
	})
}
async function navigate(ue, {
	status: Yi = 302,
	enableNavigate: ea = !1
} = {}) {
	const {
		nuxtApp: ta,
		i18n: na,
		locale: ra,
		route: ia
	} = ue, {
		rootRedirect: aa,
		differentDomains: oa,
		multiDomainLocales: la,
		skipSettingLocaleOnNavigate: sa,
		configLocales: ca,
		strategy: ua
	} = ta.$config.public.i18n;
	let {
		redirectPath: da
	} = ue;
	if (ia.path === "/" && aa) return isString$1(aa) ? da = "/" + aa : isRootRedirectOptions(aa) && (da = "/" + aa.path, Yi = aa.statusCode), da = ta.$localePath(da, ra), _navigate(da, Yi);
	if (!(sa && (na.__pendingLocale = ra, na.__pendingLocalePromise = new Promise(ha => {
			na.__resolvePendingLocalePromise = ha
		}), !ea))) {
		if (la && ua === "prefix_except_default") {
			const ha = getHost(),
				pa = ca.find(ba => {
					var Ea;
					return typeof ba != "string" ? (Ea = ba.defaultForDomains) == null ? void 0 : Ea.find(Sa => Sa === ha) : !1
				}),
				va = typeof pa != "string" ? pa == null ? void 0 : pa.code : void 0;
			if (ia.path.startsWith(`/${va}`)) return _navigate(ia.path.replace(`/${va}`, ""), Yi);
			if (!ia.path.startsWith(`/${ra}`) && ra !== va) {
				const Ea = createLocaleFromRouteGetter()(ia.path);
				return _navigate(Ea !== "" ? `/${ra+ia.path.replace(`/${Ea}`,"")}` : `/${ra+(ia.path==="/"?"":ia.path)}`, Yi)
			} else if (da && ia.path !== da) return _navigate(da, Yi);
			return
		}
		if (oa) {
			const ha = useRedirectState();
			ha.value && ha.value !== da && (ha.value = "", window.location.assign(da))
		} else if (da) return _navigate(da, Yi)
	}
}

function injectNuxtHelpers(ue, Yi) {
	defineGetter(ue, "$i18n", getI18nTarget(Yi)), defineGetter(ue, "$getRouteBaseName", wrapComposable(getRouteBaseName)), defineGetter(ue, "$localePath", wrapComposable(localePath)), defineGetter(ue, "$localeRoute", wrapComposable(localeRoute)), defineGetter(ue, "$switchLocalePath", wrapComposable(switchLocalePath)), defineGetter(ue, "$localeHead", wrapComposable(localeHead))
}

function extendPrefixable(ue = useRuntimeConfig()) {
	return Yi => DefaultPrefixable(Yi) && !ue.public.i18n.differentDomains
}

function extendSwitchLocalePathIntercepter(ue = useRuntimeConfig()) {
	return (Yi, ea) => {
		if (ue.public.i18n.differentDomains) {
			const ta = getDomainFromLocale(ea);
			return ta ? joinURL(ta, Yi) : Yi
		} else return DefaultSwitchLocalePathIntercepter(Yi)
	}
}

function extendBaseUrl() {
	return () => {
		const ue = useNuxtApp(),
			{
				baseUrl: Yi,
				defaultLocale: ea,
				differentDomains: ta
			} = ue.$config.public.i18n;
		if (isFunction(Yi)) return Yi(ue);
		const na = isFunction(ea) ? ea() : ea;
		if (ta && na) {
			const ra = getDomainFromLocale(na);
			if (ra) return ra
		}
		return Yi
	}
}

function parse$1(ue, Yi) {
	if (typeof ue != "string") throw new TypeError("argument str must be a string");
	const ea = {},
		ta = Yi || {},
		na = ta.decode || decode;
	let ra = 0;
	for (; ra < ue.length;) {
		const ia = ue.indexOf("=", ra);
		if (ia === -1) break;
		let aa = ue.indexOf(";", ra);
		if (aa === -1) aa = ue.length;
		else if (aa < ia) {
			ra = ue.lastIndexOf(";", ia - 1) + 1;
			continue
		}
		const oa = ue.slice(ra, ia).trim();
		if (ta != null && ta.filter && !(ta != null && ta.filter(oa))) {
			ra = aa + 1;
			continue
		}
		if (ea[oa] === void 0) {
			let la = ue.slice(ia + 1, aa).trim();
			la.codePointAt(0) === 34 && (la = la.slice(1, -1)), ea[oa] = tryDecode(la, na)
		}
		ra = aa + 1
	}
	return ea
}

function decode(ue) {
	return ue.includes("%") ? decodeURIComponent(ue) : ue
}

function tryDecode(ue, Yi) {
	try {
		return Yi(ue)
	} catch {
		return ue
	}
}
const fieldContentRegExp = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;

function serialize(ue, Yi, ea) {
	const ta = ea || {},
		na = ta.encode || encodeURIComponent;
	if (typeof na != "function") throw new TypeError("option encode is invalid");
	if (!fieldContentRegExp.test(ue)) throw new TypeError("argument name is invalid");
	const ra = na(Yi);
	if (ra && !fieldContentRegExp.test(ra)) throw new TypeError("argument val is invalid");
	let ia = ue + "=" + ra;
	if (ta.maxAge !== void 0 && ta.maxAge !== null) {
		const aa = ta.maxAge - 0;
		if (Number.isNaN(aa) || !Number.isFinite(aa)) throw new TypeError("option maxAge is invalid");
		ia += "; Max-Age=" + Math.floor(aa)
	}
	if (ta.domain) {
		if (!fieldContentRegExp.test(ta.domain)) throw new TypeError("option domain is invalid");
		ia += "; Domain=" + ta.domain
	}
	if (ta.path) {
		if (!fieldContentRegExp.test(ta.path)) throw new TypeError("option path is invalid");
		ia += "; Path=" + ta.path
	}
	if (ta.expires) {
		if (!isDate(ta.expires) || Number.isNaN(ta.expires.valueOf())) throw new TypeError("option expires is invalid");
		ia += "; Expires=" + ta.expires.toUTCString()
	}
	if (ta.httpOnly && (ia += "; HttpOnly"), ta.secure && (ia += "; Secure"), ta.priority) switch (typeof ta.priority == "string" ? ta.priority.toLowerCase() : ta.priority) {
		case "low": {
			ia += "; Priority=Low";
			break
		}
		case "medium": {
			ia += "; Priority=Medium";
			break
		}
		case "high": {
			ia += "; Priority=High";
			break
		}
		default:
			throw new TypeError("option priority is invalid")
	}
	if (ta.sameSite) switch (typeof ta.sameSite == "string" ? ta.sameSite.toLowerCase() : ta.sameSite) {
		case !0: {
			ia += "; SameSite=Strict";
			break
		}
		case "lax": {
			ia += "; SameSite=Lax";
			break
		}
		case "strict": {
			ia += "; SameSite=Strict";
			break
		}
		case "none": {
			ia += "; SameSite=None";
			break
		}
		default:
			throw new TypeError("option sameSite is invalid")
	}
	return ta.partitioned && (ia += "; Partitioned"), ia
}

function isDate(ue) {
	return Object.prototype.toString.call(ue) === "[object Date]" || ue instanceof Date
}
const defaults = Object.freeze({
	ignoreUnknown: !1,
	respectType: !1,
	respectFunctionNames: !1,
	respectFunctionProperties: !1,
	unorderedObjects: !0,
	unorderedArrays: !1,
	unorderedSets: !1,
	excludeKeys: void 0,
	excludeValues: void 0,
	replacer: void 0
});

function objectHash(ue, Yi) {
	Yi ? Yi = {
		...defaults,
		...Yi
	} : Yi = defaults;
	const ea = createHasher(Yi);
	return ea.dispatch(ue), ea.toString()
}
const defaultPrototypesKeys = Object.freeze(["prototype", "__proto__", "constructor"]);

function createHasher(ue) {
	let Yi = "",
		ea = new Map;
	const ta = na => {
		Yi += na
	};
	return {
		toString() {
			return Yi
		},
		getContext() {
			return ea
		},
		dispatch(na) {
			return ue.replacer && (na = ue.replacer(na)), this[na === null ? "null" : typeof na](na)
		},
		object(na) {
			if (na && typeof na.toJSON == "function") return this.object(na.toJSON());
			const ra = Object.prototype.toString.call(na);
			let ia = "";
			const aa = ra.length;
			aa < 10 ? ia = "unknown:[" + ra + "]" : ia = ra.slice(8, aa - 1), ia = ia.toLowerCase();
			let oa = null;
			if ((oa = ea.get(na)) === void 0) ea.set(na, ea.size);
			else return this.dispatch("[CIRCULAR:" + oa + "]");
			if (typeof Buffer < "u" && Buffer.isBuffer && Buffer.isBuffer(na)) return ta("buffer:"), ta(na.toString("utf8"));
			if (ia !== "object" && ia !== "function" && ia !== "asyncfunction") this[ia] ? this[ia](na) : ue.ignoreUnknown || this.unkown(na, ia);
			else {
				let la = Object.keys(na);
				ue.unorderedObjects && (la = la.sort());
				let sa = [];
				ue.respectType !== !1 && !isNativeFunction(na) && (sa = defaultPrototypesKeys), ue.excludeKeys && (la = la.filter(ua => !ue.excludeKeys(ua)), sa = sa.filter(ua => !ue.excludeKeys(ua))), ta("object:" + (la.length + sa.length) + ":");
				const ca = ua => {
					this.dispatch(ua), ta(":"), ue.excludeValues || this.dispatch(na[ua]), ta(",")
				};
				for (const ua of la) ca(ua);
				for (const ua of sa) ca(ua)
			}
		},
		array(na, ra) {
			if (ra = ra === void 0 ? ue.unorderedArrays !== !1 : ra, ta("array:" + na.length + ":"), !ra || na.length <= 1) {
				for (const oa of na) this.dispatch(oa);
				return
			}
			const ia = new Map,
				aa = na.map(oa => {
					const la = createHasher(ue);
					la.dispatch(oa);
					for (const [sa, ca] of la.getContext()) ia.set(sa, ca);
					return la.toString()
				});
			return ea = ia, aa.sort(), this.array(aa, !1)
		},
		date(na) {
			return ta("date:" + na.toJSON())
		},
		symbol(na) {
			return ta("symbol:" + na.toString())
		},
		unkown(na, ra) {
			if (ta(ra), !!na && (ta(":"), na && typeof na.entries == "function")) return this.array(Array.from(na.entries()), !0)
		},
		error(na) {
			return ta("error:" + na.toString())
		},
		boolean(na) {
			return ta("bool:" + na)
		},
		string(na) {
			ta("string:" + na.length + ":"), ta(na)
		},
		function(na) {
			ta("fn:"), isNativeFunction(na) ? this.dispatch("[native]") : this.dispatch(na.toString()), ue.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(na.name)), ue.respectFunctionProperties && this.object(na)
		},
		number(na) {
			return ta("number:" + na)
		},
		xml(na) {
			return ta("xml:" + na.toString())
		},
		null() {
			return ta("Null")
		},
		undefined() {
			return ta("Undefined")
		},
		regexp(na) {
			return ta("regex:" + na.toString())
		},
		uint8array(na) {
			return ta("uint8array:"), this.dispatch(Array.prototype.slice.call(na))
		},
		uint8clampedarray(na) {
			return ta("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(na))
		},
		int8array(na) {
			return ta("int8array:"), this.dispatch(Array.prototype.slice.call(na))
		},
		uint16array(na) {
			return ta("uint16array:"), this.dispatch(Array.prototype.slice.call(na))
		},
		int16array(na) {
			return ta("int16array:"), this.dispatch(Array.prototype.slice.call(na))
		},
		uint32array(na) {
			return ta("uint32array:"), this.dispatch(Array.prototype.slice.call(na))
		},
		int32array(na) {
			return ta("int32array:"), this.dispatch(Array.prototype.slice.call(na))
		},
		float32array(na) {
			return ta("float32array:"), this.dispatch(Array.prototype.slice.call(na))
		},
		float64array(na) {
			return ta("float64array:"), this.dispatch(Array.prototype.slice.call(na))
		},
		arraybuffer(na) {
			return ta("arraybuffer:"), this.dispatch(new Uint8Array(na))
		},
		url(na) {
			return ta("url:" + na.toString())
		},
		map(na) {
			ta("map:");
			const ra = [...na];
			return this.array(ra, ue.unorderedSets !== !1)
		},
		set(na) {
			ta("set:");
			const ra = [...na];
			return this.array(ra, ue.unorderedSets !== !1)
		},
		file(na) {
			return ta("file:"), this.dispatch([na.name, na.size, na.type, na.lastModfied])
		},
		blob() {
			if (ue.ignoreUnknown) return ta("[blob]");
			throw new Error(`Hashing Blob objects is currently not supported
Use "options.replacer" or "options.ignoreUnknown"
`)
		},
		domwindow() {
			return ta("domwindow")
		},
		bigint(na) {
			return ta("bigint:" + na.toString())
		},
		process() {
			return ta("process")
		},
		timer() {
			return ta("timer")
		},
		pipe() {
			return ta("pipe")
		},
		tcp() {
			return ta("tcp")
		},
		udp() {
			return ta("udp")
		},
		tty() {
			return ta("tty")
		},
		statwatcher() {
			return ta("statwatcher")
		},
		securecontext() {
			return ta("securecontext")
		},
		connection() {
			return ta("connection")
		},
		zlib() {
			return ta("zlib")
		},
		context() {
			return ta("context")
		},
		nodescript() {
			return ta("nodescript")
		},
		httpparser() {
			return ta("httpparser")
		},
		dataview() {
			return ta("dataview")
		},
		signal() {
			return ta("signal")
		},
		fsevent() {
			return ta("fsevent")
		},
		tlswrap() {
			return ta("tlswrap")
		}
	}
}
const nativeFunc = "[native code] }",
	nativeFuncLength = nativeFunc.length;

function isNativeFunction(ue) {
	return typeof ue != "function" ? !1 : Function.prototype.toString.call(ue).slice(-nativeFuncLength) === nativeFunc
}

function isEqual(ue, Yi, ea = {}) {
	return ue === Yi || objectHash(ue, ea) === objectHash(Yi, ea)
}

function klona(ue) {
	if (typeof ue != "object") return ue;
	var Yi, ea, ta = Object.prototype.toString.call(ue);
	if (ta === "[object Object]") {
		if (ue.constructor !== Object && typeof ue.constructor == "function") {
			ea = new ue.constructor;
			for (Yi in ue) ue.hasOwnProperty(Yi) && ea[Yi] !== ue[Yi] && (ea[Yi] = klona(ue[Yi]))
		} else {
			ea = {};
			for (Yi in ue) Yi === "__proto__" ? Object.defineProperty(ea, Yi, {
				value: klona(ue[Yi]),
				configurable: !0,
				enumerable: !0,
				writable: !0
			}) : ea[Yi] = klona(ue[Yi])
		}
		return ea
	}
	if (ta === "[object Array]") {
		for (Yi = ue.length, ea = Array(Yi); Yi--;) ea[Yi] = klona(ue[Yi]);
		return ea
	}
	return ta === "[object Set]" ? (ea = new Set, ue.forEach(function(na) {
		ea.add(klona(na))
	}), ea) : ta === "[object Map]" ? (ea = new Map, ue.forEach(function(na, ra) {
		ea.set(klona(ra), klona(na))
	}), ea) : ta === "[object Date]" ? new Date(+ue) : ta === "[object RegExp]" ? (ea = new RegExp(ue.source, ue.flags), ea.lastIndex = ue.lastIndex, ea) : ta === "[object DataView]" ? new ue.constructor(klona(ue.buffer)) : ta === "[object ArrayBuffer]" ? ue.slice(0) : ta.slice(-6) === "Array]" ? new ue.constructor(ue) : ue
}
const CookieDefaults = {
		path: "/",
		watch: !0,
		decode: ue => destr(decodeURIComponent(ue)),
		encode: ue => encodeURIComponent(typeof ue == "string" ? ue : JSON.stringify(ue))
	},
	store = window.cookieStore;

function useCookie(ue, Yi) {
	var oa;
	const ea = {
		...CookieDefaults,
		...Yi
	};
	ea.filter ?? (ea.filter = la => la === ue);
	const ta = readRawCookies(ea) || {};
	let na;
	ea.maxAge !== void 0 ? na = ea.maxAge * 1e3 : ea.expires && (na = ea.expires.getTime() - Date.now());
	const ra = na !== void 0 && na <= 0,
		ia = klona(ra ? void 0 : ta[ue] ?? ((oa = ea.default) == null ? void 0 : oa.call(ea))),
		aa = na && !ra ? cookieRef(ia, na, ea.watch && ea.watch !== "shallow") : ref$1(ia);
	{
		let la = null;
		try {
			!store && typeof BroadcastChannel < "u" && (la = new BroadcastChannel(`nuxt:cookies:${ue}`))
		} catch {}
		const sa = () => {
				ea.readonly || isEqual(aa.value, ta[ue]) || (writeClientCookie(ue, aa.value, ea), ta[ue] = klona(aa.value), la == null || la.postMessage({
					value: ea.encode(aa.value)
				}))
			},
			ca = ha => {
				var va;
				const pa = ha.refresh ? (va = readRawCookies(ea)) == null ? void 0 : va[ue] : ea.decode(ha.value);
				ua = !0, aa.value = pa, ta[ue] = klona(pa), nextTick(() => {
					ua = !1
				})
			};
		let ua = !1;
		const da = !!getCurrentScope$1();
		if (da && onScopeDispose(() => {
				ua = !0, sa(), la == null || la.close()
			}), store) {
			const ha = pa => {
				const va = pa.changed.find(Ea => Ea.name === ue),
					ba = pa.deleted.find(Ea => Ea.name === ue);
				va && ca({
					value: va.value
				}), ba && ca({
					value: null
				})
			};
			store.addEventListener("change", ha), da && onScopeDispose(() => store.removeEventListener("change", ha))
		} else la && (la.onmessage = ({
			data: ha
		}) => ca(ha));
		ea.watch ? watch(aa, () => {
			ua || sa()
		}, {
			deep: ea.watch !== "shallow"
		}) : sa()
	}
	return aa
}

function readRawCookies(ue = {}) {
	return parse$1(document.cookie, ue)
}

function serializeCookie(ue, Yi, ea = {}) {
	return Yi == null ? serialize(ue, Yi, {
		...ea,
		maxAge: -1
	}) : serialize(ue, Yi, ea)
}

function writeClientCookie(ue, Yi, ea = {}) {
	document.cookie = serializeCookie(ue, Yi, ea)
}
const MAX_TIMEOUT_DELAY = 2147483647;

function cookieRef(ue, Yi, ea) {
	let ta, na, ra = 0;
	const ia = ea ? ref$1(ue) : {
		value: ue
	};
	return getCurrentScope$1() && onScopeDispose(() => {
		na == null || na(), clearTimeout(ta)
	}), customRef((aa, oa) => {
		ea && (na = watch(ia, oa));

		function la() {
			ra = 0, clearTimeout(ta);
			const sa = Yi - ra,
				ca = sa < MAX_TIMEOUT_DELAY ? sa : MAX_TIMEOUT_DELAY;
			ta = setTimeout(() => {
				if (ra += ca, ra < Yi) return la();
				ia.value = void 0, oa()
			}, ca)
		}
		return {
			get() {
				return aa(), ia.value
			},
			set(sa) {
				la(), ia.value = sa, oa()
			}
		}
	})
}

function formatMessage(ue) {
	return NUXT_I18N_MODULE_ID + " " + ue
}

function callVueI18nInterfaces(ue, Yi, ...ea) {
	const ta = getI18nTarget(ue),
		[na, ra] = [ta, ta[Yi]];
	return Reflect.apply(ra, na, [...ea])
}

function getVueI18nPropertyValue(ue, Yi) {
	const ea = getI18nTarget(ue);
	return unref(ea[Yi])
}

function defineGetter(ue, Yi, ea) {
	Object.defineProperty(ue, Yi, {
		get: () => ea
	})
}

function wrapComposable(ue, Yi = initCommonComposableOptions()) {
	return (...ea) => ue(Yi, ...ea)
}

function getBrowserLocale() {
	let ue;
	return navigator.languages && (ue = findBrowserLocale(normalizedLocales, navigator.languages)), ue
}

function getI18nCookie() {
	const ue = runtimeDetectBrowserLanguage(),
		Yi = ue && ue.cookieKey || DEFAULT_COOKIE_KEY,
		ea = new Date,
		ta = {
			expires: new Date(ea.setDate(ea.getDate() + 365)),
			path: "/",
			sameSite: ue && ue.cookieCrossOrigin ? "none" : "lax",
			secure: ue && ue.cookieCrossOrigin || ue && ue.cookieSecure
		};
	return ue && ue.cookieDomain && (ta.domain = ue.cookieDomain), useCookie(Yi, ta)
}

function getLocaleCookie(ue, Yi, ea) {
	if (Yi === !1 || !Yi.useCookie) return;
	const ta = ue.value ?? void 0;
	if (ta != null) {
		if (localeCodes.includes(ta)) return ta;
		if (ea) return ue.value = ea, ea;
		ue.value = void 0
	}
}

function setLocaleCookie(ue, Yi, ea) {
	ea === !1 || !ea.useCookie || (ue.value = Yi)
}
var DetectFailure = (ue => (ue.NOT_FOUND = "not_found_match", ue.FIRST_ACCESS = "first_access_only", ue.NO_REDIRECT_ROOT = "not_redirect_on_root", ue.NO_REDIRECT_NO_PREFIX = "not_redirect_on_no_prefix", ue.SSG_IGNORE = "detect_ignore_on_ssg", ue))(DetectFailure || {});
const DefaultDetectBrowserLanguageFromResult = {
	locale: ""
};

function detectBrowserLanguage(ue, Yi, ea = "") {
	createLogger("detectBrowserLanguage");
	const ta = runtimeDetectBrowserLanguage();
	if (!ta) return DefaultDetectBrowserLanguageFromResult;
	const {
		strategy: na
	} = useRuntimeConfig().public.i18n, {
		ssg: ra,
		callType: ia,
		firstAccess: aa,
		localeCookie: oa
	} = Yi;
	if (!aa) return {
		locale: na === "no_prefix" ? ea : "",
		reason: "first_access_only"
	};
	const {
		redirectOn: la,
		alwaysRedirect: sa,
		useCookie: ca,
		fallbackLocale: ua
	} = ta, da = isString$1(ue) ? ue : ue.path;
	if (na !== "no_prefix") {
		if (la === "root" && da !== "/") return {
			locale: "",
			reason: "not_redirect_on_root"
		};
		if (la === "no prefix" && !sa && da.match(getLocalesRegex(localeCodes))) return {
			locale: "",
			reason: "not_redirect_on_no_prefix"
		}
	}
	let ha;
	const pa = ca && oa || void 0;
	ca && (ha = "cookie");
	const va = getBrowserLocale();
	pa || (ha = "navigator_or_header");
	const ba = pa || va,
		Ea = ba || ua || "";
	return !ba && ua && (ha = "fallback"), {
		locale: Ea,
		from: ha
	}
}

function getHost() {
	let ue;
	return ue = window.location.host, ue
}

function getLocaleDomain(ue, Yi, ea) {
	let ta = getHost() || "";
	if (ta) {
		let na;
		const ra = ue.filter(ia => {
			if (ia && ia.domain) {
				let aa = ia.domain;
				return hasProtocol(ia.domain) && (aa = ia.domain.replace(/(http|https):\/\//, "")), aa === ta
			} else if (Array.isArray(ia == null ? void 0 : ia.domains)) return ia.domains.includes(ta);
			return !1
		});
		if (ra.length === 1) na = ra[0];
		else if (ra.length > 1)
			if (Yi === "no_prefix") console.warn(formatMessage("Multiple matching domains found! This is not supported for no_prefix strategy in combination with differentDomains!")), na = ra[0];
			else {
				if (ea) {
					const ia = isObject(ea) ? ea.path : isString$1(ea) ? ea : "";
					if (ia && ia !== "") {
						const aa = ia.match(getLocalesRegex(ra.map(oa => oa.code)));
						aa && aa.length > 1 && (na = ra.find(oa => oa.code === aa[1]))
					}
				}
				na || (na = ra.find(ia => Array.isArray(ia.defaultForDomains) ? ia.defaultForDomains.includes(ta) : ia.domainDefault))
			} if (na) return na.code;
		ta = ""
	}
	return ta
}

function getDomainFromLocale(ue) {
	var ia, aa, oa, la, sa, ca;
	const Yi = useRuntimeConfig();
	useNuxtApp();
	const ea = getHost(),
		ta = Yi.public.i18n,
		na = normalizedLocales.find(ua => ua.code === ue),
		ra = ((aa = (ia = ta == null ? void 0 : ta.locales) == null ? void 0 : ia[ue]) == null ? void 0 : aa.domain) || (na == null ? void 0 : na.domain) || ((sa = (la = (oa = ta == null ? void 0 : ta.locales) == null ? void 0 : oa[ue]) == null ? void 0 : la.domains) == null ? void 0 : sa.find(ua => ua === ea)) || ((ca = na == null ? void 0 : na.domains) == null ? void 0 : ca.find(ua => ua === ea));
	if (ra) {
		if (hasProtocol(ra, {
				strict: !0
			})) return ra;
		let ua;
		return ua = new URL(window.location.origin).protocol, ua + "//" + ra
	}
	console.warn(formatMessage("Could not find domain name for locale " + ue))
}
const runtimeDetectBrowserLanguage = (ue = useRuntimeConfig().public.i18n) => (ue == null ? void 0 : ue.detectBrowserLanguage) === !1 ? !1 : ue == null ? void 0 : ue.detectBrowserLanguage;
/*!
 * message-compiler v9.14.0
 * (c) 2024 kazuya kawaguchi
 * Released under the MIT License.
 */
function createPosition(ue, Yi, ea) {
	return {
		line: ue,
		column: Yi,
		offset: ea
	}
}

function createLocation(ue, Yi, ea) {
	return {
		start: ue,
		end: Yi
	}
}
const CompileWarnCodes = {
	USE_MODULO_SYNTAX: 1,
	__EXTEND_POINT__: 2
};

function createCompileWarn(ue, Yi, ...ea) {
	const na = {
		message: String(ue),
		code: ue
	};
	return Yi && (na.location = Yi), na
}
const CompileErrorCodes = {
	EXPECTED_TOKEN: 1,
	INVALID_TOKEN_IN_PLACEHOLDER: 2,
	UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
	UNKNOWN_ESCAPE_SEQUENCE: 4,
	INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
	UNBALANCED_CLOSING_BRACE: 6,
	UNTERMINATED_CLOSING_BRACE: 7,
	EMPTY_PLACEHOLDER: 8,
	NOT_ALLOW_NEST_PLACEHOLDER: 9,
	INVALID_LINKED_FORMAT: 10,
	MUST_HAVE_MESSAGES_IN_PLURAL: 11,
	UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
	UNEXPECTED_EMPTY_LINKED_KEY: 13,
	UNEXPECTED_LEXICAL_ANALYSIS: 14,
	UNHANDLED_CODEGEN_NODE_TYPE: 15,
	UNHANDLED_MINIFIER_NODE_TYPE: 16,
	__EXTEND_POINT__: 17
};

function createCompileError(ue, Yi, ea = {}) {
	const {
		domain: ta,
		messages: na,
		args: ra
	} = ea, ia = ue, aa = new SyntaxError(String(ia));
	return aa.code = ue, Yi && (aa.location = Yi), aa.domain = ta, aa
}

function defaultOnError(ue) {
	throw ue
}
const CHAR_SP = " ",
	CHAR_CR = "\r",
	CHAR_LF = `
`,
	CHAR_LS = "\u2028",
	CHAR_PS = "\u2029";

function createScanner(ue) {
	const Yi = ue;
	let ea = 0,
		ta = 1,
		na = 1,
		ra = 0;
	const ia = ja => Yi[ja] === CHAR_CR && Yi[ja + 1] === CHAR_LF,
		aa = ja => Yi[ja] === CHAR_LF,
		oa = ja => Yi[ja] === CHAR_PS,
		la = ja => Yi[ja] === CHAR_LS,
		sa = ja => ia(ja) || aa(ja) || oa(ja) || la(ja),
		ca = () => ea,
		ua = () => ta,
		da = () => na,
		ha = () => ra,
		pa = ja => ia(ja) || oa(ja) || la(ja) ? CHAR_LF : Yi[ja],
		va = () => pa(ea),
		ba = () => pa(ea + ra);

	function Ea() {
		return ra = 0, sa(ea) && (ta++, na = 0), ia(ea) && ea++, ea++, na++, Yi[ea]
	}

	function Sa() {
		return ia(ea + ra) && ra++, ra++, Yi[ea + ra]
	}

	function Ca() {
		ea = 0, ta = 1, na = 1, ra = 0
	}

	function ka(ja = 0) {
		ra = ja
	}

	function Pa() {
		const ja = ea + ra;
		for (; ja !== ea;) Ea();
		ra = 0
	}
	return {
		index: ca,
		line: ua,
		column: da,
		peekOffset: ha,
		charAt: pa,
		currentChar: va,
		currentPeek: ba,
		next: Ea,
		peek: Sa,
		reset: Ca,
		resetPeek: ka,
		skipToPeek: Pa
	}
}
const EOF = void 0,
	DOT = ".",
	LITERAL_DELIMITER = "'",
	ERROR_DOMAIN$3 = "tokenizer";

function createTokenizer(ue, Yi = {}) {
	const ea = Yi.location !== !1,
		ta = createScanner(ue),
		na = () => ta.index(),
		ra = () => createPosition(ta.line(), ta.column(), ta.index()),
		ia = ra(),
		aa = na(),
		oa = {
			currentType: 14,
			offset: aa,
			startLoc: ia,
			endLoc: ia,
			lastType: 14,
			lastOffset: aa,
			lastStartLoc: ia,
			lastEndLoc: ia,
			braceNest: 0,
			inLinked: !1,
			text: ""
		},
		la = () => oa,
		{
			onError: sa
		} = Yi;

	function ca(Xa, to, ho, ...Eo) {
		const wo = la();
		if (to.column += ho, to.offset += ho, sa) {
			const Ao = ea ? createLocation(wo.startLoc, to) : null,
				_o = createCompileError(Xa, Ao, {
					domain: ERROR_DOMAIN$3,
					args: Eo
				});
			sa(_o)
		}
	}

	function ua(Xa, to, ho) {
		Xa.endLoc = ra(), Xa.currentType = to;
		const Eo = {
			type: to
		};
		return ea && (Eo.loc = createLocation(Xa.startLoc, Xa.endLoc)), ho != null && (Eo.value = ho), Eo
	}
	const da = Xa => ua(Xa, 14);

	function ha(Xa, to) {
		return Xa.currentChar() === to ? (Xa.next(), to) : (ca(CompileErrorCodes.EXPECTED_TOKEN, ra(), 0, to), "")
	}

	function pa(Xa) {
		let to = "";
		for (; Xa.currentPeek() === CHAR_SP || Xa.currentPeek() === CHAR_LF;) to += Xa.currentPeek(), Xa.peek();
		return to
	}

	function va(Xa) {
		const to = pa(Xa);
		return Xa.skipToPeek(), to
	}

	function ba(Xa) {
		if (Xa === EOF) return !1;
		const to = Xa.charCodeAt(0);
		return to >= 97 && to <= 122 || to >= 65 && to <= 90 || to === 95
	}

	function Ea(Xa) {
		if (Xa === EOF) return !1;
		const to = Xa.charCodeAt(0);
		return to >= 48 && to <= 57
	}

	function Sa(Xa, to) {
		const {
			currentType: ho
		} = to;
		if (ho !== 2) return !1;
		pa(Xa);
		const Eo = ba(Xa.currentPeek());
		return Xa.resetPeek(), Eo
	}

	function Ca(Xa, to) {
		const {
			currentType: ho
		} = to;
		if (ho !== 2) return !1;
		pa(Xa);
		const Eo = Xa.currentPeek() === "-" ? Xa.peek() : Xa.currentPeek(),
			wo = Ea(Eo);
		return Xa.resetPeek(), wo
	}

	function ka(Xa, to) {
		const {
			currentType: ho
		} = to;
		if (ho !== 2) return !1;
		pa(Xa);
		const Eo = Xa.currentPeek() === LITERAL_DELIMITER;
		return Xa.resetPeek(), Eo
	}

	function Pa(Xa, to) {
		const {
			currentType: ho
		} = to;
		if (ho !== 8) return !1;
		pa(Xa);
		const Eo = Xa.currentPeek() === ".";
		return Xa.resetPeek(), Eo
	}

	function ja(Xa, to) {
		const {
			currentType: ho
		} = to;
		if (ho !== 9) return !1;
		pa(Xa);
		const Eo = ba(Xa.currentPeek());
		return Xa.resetPeek(), Eo
	}

	function Za(Xa, to) {
		const {
			currentType: ho
		} = to;
		if (!(ho === 8 || ho === 12)) return !1;
		pa(Xa);
		const Eo = Xa.currentPeek() === ":";
		return Xa.resetPeek(), Eo
	}

	function Ga(Xa, to) {
		const {
			currentType: ho
		} = to;
		if (ho !== 10) return !1;
		const Eo = () => {
				const Ao = Xa.currentPeek();
				return Ao === "{" ? ba(Xa.peek()) : Ao === "@" || Ao === "%" || Ao === "|" || Ao === ":" || Ao === "." || Ao === CHAR_SP || !Ao ? !1 : Ao === CHAR_LF ? (Xa.peek(), Eo()) : xa(Xa, !1)
			},
			wo = Eo();
		return Xa.resetPeek(), wo
	}

	function Ja(Xa) {
		pa(Xa);
		const to = Xa.currentPeek() === "|";
		return Xa.resetPeek(), to
	}

	function Ua(Xa) {
		const to = pa(Xa),
			ho = Xa.currentPeek() === "%" && Xa.peek() === "{";
		return Xa.resetPeek(), {
			isModulo: ho,
			hasSpace: to.length > 0
		}
	}

	function xa(Xa, to = !0) {
		const ho = (wo = !1, Ao = "", _o = !1) => {
				const Lo = Xa.currentPeek();
				return Lo === "{" ? Ao === "%" ? !1 : wo : Lo === "@" || !Lo ? Ao === "%" ? !0 : wo : Lo === "%" ? (Xa.peek(), ho(wo, "%", !0)) : Lo === "|" ? Ao === "%" || _o ? !0 : !(Ao === CHAR_SP || Ao === CHAR_LF) : Lo === CHAR_SP ? (Xa.peek(), ho(!0, CHAR_SP, _o)) : Lo === CHAR_LF ? (Xa.peek(), ho(!0, CHAR_LF, _o)) : !0
			},
			Eo = ho();
		return to && Xa.resetPeek(), Eo
	}

	function ma(Xa, to) {
		const ho = Xa.currentChar();
		return ho === EOF ? EOF : to(ho) ? (Xa.next(), ho) : null
	}

	function fa(Xa) {
		const to = Xa.charCodeAt(0);
		return to >= 97 && to <= 122 || to >= 65 && to <= 90 || to >= 48 && to <= 57 || to === 95 || to === 36
	}

	function ga(Xa) {
		return ma(Xa, fa)
	}

	function wa(Xa) {
		const to = Xa.charCodeAt(0);
		return to >= 97 && to <= 122 || to >= 65 && to <= 90 || to >= 48 && to <= 57 || to === 95 || to === 36 || to === 45
	}

	function Ma(Xa) {
		return ma(Xa, wa)
	}

	function Aa(Xa) {
		const to = Xa.charCodeAt(0);
		return to >= 48 && to <= 57
	}

	function Ra(Xa) {
		return ma(Xa, Aa)
	}

	function Ta(Xa) {
		const to = Xa.charCodeAt(0);
		return to >= 48 && to <= 57 || to >= 65 && to <= 70 || to >= 97 && to <= 102
	}

	function La(Xa) {
		return ma(Xa, Ta)
	}

	function ya(Xa) {
		let to = "",
			ho = "";
		for (; to = Ra(Xa);) ho += to;
		return ho
	}

	function Ba(Xa) {
		va(Xa);
		const to = Xa.currentChar();
		return to !== "%" && ca(CompileErrorCodes.EXPECTED_TOKEN, ra(), 0, to), Xa.next(), "%"
	}

	function io(Xa) {
		let to = "";
		for (;;) {
			const ho = Xa.currentChar();
			if (ho === "{" || ho === "}" || ho === "@" || ho === "|" || !ho) break;
			if (ho === "%")
				if (xa(Xa)) to += ho, Xa.next();
				else break;
			else if (ho === CHAR_SP || ho === CHAR_LF)
				if (xa(Xa)) to += ho, Xa.next();
				else {
					if (Ja(Xa)) break;
					to += ho, Xa.next()
				}
			else to += ho, Xa.next()
		}
		return to
	}

	function oo(Xa) {
		va(Xa);
		let to = "",
			ho = "";
		for (; to = Ma(Xa);) ho += to;
		return Xa.currentChar() === EOF && ca(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, ra(), 0), ho
	}

	function ao(Xa) {
		va(Xa);
		let to = "";
		return Xa.currentChar() === "-" ? (Xa.next(), to += `-${ya(Xa)}`) : to += ya(Xa), Xa.currentChar() === EOF && ca(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, ra(), 0), to
	}

	function Ia(Xa) {
		return Xa !== LITERAL_DELIMITER && Xa !== CHAR_LF
	}

	function Na(Xa) {
		va(Xa), ha(Xa, "'");
		let to = "",
			ho = "";
		for (; to = ma(Xa, Ia);) to === "\\" ? ho += za(Xa) : ho += to;
		const Eo = Xa.currentChar();
		return Eo === CHAR_LF || Eo === EOF ? (ca(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, ra(), 0), Eo === CHAR_LF && (Xa.next(), ha(Xa, "'")), ho) : (ha(Xa, "'"), ho)
	}

	function za(Xa) {
		const to = Xa.currentChar();
		switch (to) {
			case "\\":
			case "'":
				return Xa.next(), `\\${to}`;
			case "u":
				return ro(Xa, to, 4);
			case "U":
				return ro(Xa, to, 6);
			default:
				return ca(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, ra(), 0, to), ""
		}
	}

	function ro(Xa, to, ho) {
		ha(Xa, to);
		let Eo = "";
		for (let wo = 0; wo < ho; wo++) {
			const Ao = La(Xa);
			if (!Ao) {
				ca(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, ra(), 0, `\\${to}${Eo}${Xa.currentChar()}`);
				break
			}
			Eo += Ao
		}
		return `\\${to}${Eo}`
	}

	function Va(Xa) {
		return Xa !== "{" && Xa !== "}" && Xa !== CHAR_SP && Xa !== CHAR_LF
	}

	function Wa(Xa) {
		va(Xa);
		let to = "",
			ho = "";
		for (; to = ma(Xa, Va);) ho += to;
		return ho
	}

	function qa(Xa) {
		let to = "",
			ho = "";
		for (; to = ga(Xa);) ho += to;
		return ho
	}

	function Ka(Xa) {
		const to = ho => {
			const Eo = Xa.currentChar();
			return Eo === "{" || Eo === "%" || Eo === "@" || Eo === "|" || Eo === "(" || Eo === ")" || !Eo || Eo === CHAR_SP ? ho : (ho += Eo, Xa.next(), to(ho))
		};
		return to("")
	}

	function lo(Xa) {
		va(Xa);
		const to = ha(Xa, "|");
		return va(Xa), to
	}

	function yo(Xa, to) {
		let ho = null;
		switch (Xa.currentChar()) {
			case "{":
				return to.braceNest >= 1 && ca(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, ra(), 0), Xa.next(), ho = ua(to, 2, "{"), va(Xa), to.braceNest++, ho;
			case "}":
				return to.braceNest > 0 && to.currentType === 2 && ca(CompileErrorCodes.EMPTY_PLACEHOLDER, ra(), 0), Xa.next(), ho = ua(to, 3, "}"), to.braceNest--, to.braceNest > 0 && va(Xa), to.inLinked && to.braceNest === 0 && (to.inLinked = !1), ho;
			case "@":
				return to.braceNest > 0 && ca(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, ra(), 0), ho = fo(Xa, to) || da(to), to.braceNest = 0, ho;
			default: {
				let wo = !0,
					Ao = !0,
					_o = !0;
				if (Ja(Xa)) return to.braceNest > 0 && ca(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, ra(), 0), ho = ua(to, 1, lo(Xa)), to.braceNest = 0, to.inLinked = !1, ho;
				if (to.braceNest > 0 && (to.currentType === 5 || to.currentType === 6 || to.currentType === 7)) return ca(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, ra(), 0), to.braceNest = 0, vo(Xa, to);
				if (wo = Sa(Xa, to)) return ho = ua(to, 5, oo(Xa)), va(Xa), ho;
				if (Ao = Ca(Xa, to)) return ho = ua(to, 6, ao(Xa)), va(Xa), ho;
				if (_o = ka(Xa, to)) return ho = ua(to, 7, Na(Xa)), va(Xa), ho;
				if (!wo && !Ao && !_o) return ho = ua(to, 13, Wa(Xa)), ca(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, ra(), 0, ho.value), va(Xa), ho;
				break
			}
		}
		return ho
	}

	function fo(Xa, to) {
		const {
			currentType: ho
		} = to;
		let Eo = null;
		const wo = Xa.currentChar();
		switch ((ho === 8 || ho === 9 || ho === 12 || ho === 10) && (wo === CHAR_LF || wo === CHAR_SP) && ca(CompileErrorCodes.INVALID_LINKED_FORMAT, ra(), 0), wo) {
			case "@":
				return Xa.next(), Eo = ua(to, 8, "@"), to.inLinked = !0, Eo;
			case ".":
				return va(Xa), Xa.next(), ua(to, 9, ".");
			case ":":
				return va(Xa), Xa.next(), ua(to, 10, ":");
			default:
				return Ja(Xa) ? (Eo = ua(to, 1, lo(Xa)), to.braceNest = 0, to.inLinked = !1, Eo) : Pa(Xa, to) || Za(Xa, to) ? (va(Xa), fo(Xa, to)) : ja(Xa, to) ? (va(Xa), ua(to, 12, qa(Xa))) : Ga(Xa, to) ? (va(Xa), wo === "{" ? yo(Xa, to) || Eo : ua(to, 11, Ka(Xa))) : (ho === 8 && ca(CompileErrorCodes.INVALID_LINKED_FORMAT, ra(), 0), to.braceNest = 0, to.inLinked = !1, vo(Xa, to))
		}
	}

	function vo(Xa, to) {
		let ho = {
			type: 14
		};
		if (to.braceNest > 0) return yo(Xa, to) || da(to);
		if (to.inLinked) return fo(Xa, to) || da(to);
		switch (Xa.currentChar()) {
			case "{":
				return yo(Xa, to) || da(to);
			case "}":
				return ca(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, ra(), 0), Xa.next(), ua(to, 3, "}");
			case "@":
				return fo(Xa, to) || da(to);
			default: {
				if (Ja(Xa)) return ho = ua(to, 1, lo(Xa)), to.braceNest = 0, to.inLinked = !1, ho;
				const {
					isModulo: wo,
					hasSpace: Ao
				} = Ua(Xa);
				if (wo) return Ao ? ua(to, 0, io(Xa)) : ua(to, 4, Ba(Xa));
				if (xa(Xa)) return ua(to, 0, io(Xa));
				break
			}
		}
		return ho
	}

	function so() {
		const {
			currentType: Xa,
			offset: to,
			startLoc: ho,
			endLoc: Eo
		} = oa;
		return oa.lastType = Xa, oa.lastOffset = to, oa.lastStartLoc = ho, oa.lastEndLoc = Eo, oa.offset = na(), oa.startLoc = ra(), ta.currentChar() === EOF ? ua(oa, 14) : vo(ta, oa)
	}
	return {
		nextToken: so,
		currentOffset: na,
		currentPosition: ra,
		context: la
	}
}
const ERROR_DOMAIN$2 = "parser",
	KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;

function fromEscapeSequence(ue, Yi, ea) {
	switch (ue) {
		case "\\\\":
			return "\\";
		case "\\'":
			return "'";
		default: {
			const ta = parseInt(Yi || ea, 16);
			return ta <= 55295 || ta >= 57344 ? String.fromCodePoint(ta) : "�"
		}
	}
}

function createParser(ue = {}) {
	const Yi = ue.location !== !1,
		{
			onError: ea,
			onWarn: ta
		} = ue;

	function na(Sa, Ca, ka, Pa, ...ja) {
		const Za = Sa.currentPosition();
		if (Za.offset += Pa, Za.column += Pa, ea) {
			const Ga = Yi ? createLocation(ka, Za) : null,
				Ja = createCompileError(Ca, Ga, {
					domain: ERROR_DOMAIN$2,
					args: ja
				});
			ea(Ja)
		}
	}

	function ra(Sa, Ca, ka, Pa, ...ja) {
		const Za = Sa.currentPosition();
		if (Za.offset += Pa, Za.column += Pa, ta) {
			const Ga = Yi ? createLocation(ka, Za) : null;
			ta(createCompileWarn(Ca, Ga, ja))
		}
	}

	function ia(Sa, Ca, ka) {
		const Pa = {
			type: Sa
		};
		return Yi && (Pa.start = Ca, Pa.end = Ca, Pa.loc = {
			start: ka,
			end: ka
		}), Pa
	}

	function aa(Sa, Ca, ka, Pa) {
		Yi && (Sa.end = Ca, Sa.loc && (Sa.loc.end = ka))
	}

	function oa(Sa, Ca) {
		const ka = Sa.context(),
			Pa = ia(3, ka.offset, ka.startLoc);
		return Pa.value = Ca, aa(Pa, Sa.currentOffset(), Sa.currentPosition()), Pa
	}

	function la(Sa, Ca) {
		const ka = Sa.context(),
			{
				lastOffset: Pa,
				lastStartLoc: ja
			} = ka,
			Za = ia(5, Pa, ja);
		return Za.index = parseInt(Ca, 10), Sa.nextToken(), aa(Za, Sa.currentOffset(), Sa.currentPosition()), Za
	}

	function sa(Sa, Ca, ka) {
		const Pa = Sa.context(),
			{
				lastOffset: ja,
				lastStartLoc: Za
			} = Pa,
			Ga = ia(4, ja, Za);
		return Ga.key = Ca, ka === !0 && (Ga.modulo = !0), Sa.nextToken(), aa(Ga, Sa.currentOffset(), Sa.currentPosition()), Ga
	}

	function ca(Sa, Ca) {
		const ka = Sa.context(),
			{
				lastOffset: Pa,
				lastStartLoc: ja
			} = ka,
			Za = ia(9, Pa, ja);
		return Za.value = Ca.replace(KNOWN_ESCAPES, fromEscapeSequence), Sa.nextToken(), aa(Za, Sa.currentOffset(), Sa.currentPosition()), Za
	}

	function ua(Sa) {
		const Ca = Sa.nextToken(),
			ka = Sa.context(),
			{
				lastOffset: Pa,
				lastStartLoc: ja
			} = ka,
			Za = ia(8, Pa, ja);
		return Ca.type !== 12 ? (na(Sa, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, ka.lastStartLoc, 0), Za.value = "", aa(Za, Pa, ja), {
			nextConsumeToken: Ca,
			node: Za
		}) : (Ca.value == null && na(Sa, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, ka.lastStartLoc, 0, getTokenCaption(Ca)), Za.value = Ca.value || "", aa(Za, Sa.currentOffset(), Sa.currentPosition()), {
			node: Za
		})
	}

	function da(Sa, Ca) {
		const ka = Sa.context(),
			Pa = ia(7, ka.offset, ka.startLoc);
		return Pa.value = Ca, aa(Pa, Sa.currentOffset(), Sa.currentPosition()), Pa
	}

	function ha(Sa) {
		const Ca = Sa.context(),
			ka = ia(6, Ca.offset, Ca.startLoc);
		let Pa = Sa.nextToken();
		if (Pa.type === 9) {
			const ja = ua(Sa);
			ka.modifier = ja.node, Pa = ja.nextConsumeToken || Sa.nextToken()
		}
		switch (Pa.type !== 10 && na(Sa, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, Ca.lastStartLoc, 0, getTokenCaption(Pa)), Pa = Sa.nextToken(), Pa.type === 2 && (Pa = Sa.nextToken()), Pa.type) {
			case 11:
				Pa.value == null && na(Sa, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, Ca.lastStartLoc, 0, getTokenCaption(Pa)), ka.key = da(Sa, Pa.value || "");
				break;
			case 5:
				Pa.value == null && na(Sa, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, Ca.lastStartLoc, 0, getTokenCaption(Pa)), ka.key = sa(Sa, Pa.value || "");
				break;
			case 6:
				Pa.value == null && na(Sa, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, Ca.lastStartLoc, 0, getTokenCaption(Pa)), ka.key = la(Sa, Pa.value || "");
				break;
			case 7:
				Pa.value == null && na(Sa, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, Ca.lastStartLoc, 0, getTokenCaption(Pa)), ka.key = ca(Sa, Pa.value || "");
				break;
			default: {
				na(Sa, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, Ca.lastStartLoc, 0);
				const ja = Sa.context(),
					Za = ia(7, ja.offset, ja.startLoc);
				return Za.value = "", aa(Za, ja.offset, ja.startLoc), ka.key = Za, aa(ka, ja.offset, ja.startLoc), {
					nextConsumeToken: Pa,
					node: ka
				}
			}
		}
		return aa(ka, Sa.currentOffset(), Sa.currentPosition()), {
			node: ka
		}
	}

	function pa(Sa) {
		const Ca = Sa.context(),
			ka = Ca.currentType === 1 ? Sa.currentOffset() : Ca.offset,
			Pa = Ca.currentType === 1 ? Ca.endLoc : Ca.startLoc,
			ja = ia(2, ka, Pa);
		ja.items = [];
		let Za = null,
			Ga = null;
		do {
			const xa = Za || Sa.nextToken();
			switch (Za = null, xa.type) {
				case 0:
					xa.value == null && na(Sa, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, Ca.lastStartLoc, 0, getTokenCaption(xa)), ja.items.push(oa(Sa, xa.value || ""));
					break;
				case 6:
					xa.value == null && na(Sa, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, Ca.lastStartLoc, 0, getTokenCaption(xa)), ja.items.push(la(Sa, xa.value || ""));
					break;
				case 4:
					Ga = !0;
					break;
				case 5:
					xa.value == null && na(Sa, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, Ca.lastStartLoc, 0, getTokenCaption(xa)), ja.items.push(sa(Sa, xa.value || "", !!Ga)), Ga && (ra(Sa, CompileWarnCodes.USE_MODULO_SYNTAX, Ca.lastStartLoc, 0, getTokenCaption(xa)), Ga = null);
					break;
				case 7:
					xa.value == null && na(Sa, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, Ca.lastStartLoc, 0, getTokenCaption(xa)), ja.items.push(ca(Sa, xa.value || ""));
					break;
				case 8: {
					const ma = ha(Sa);
					ja.items.push(ma.node), Za = ma.nextConsumeToken || null;
					break
				}
			}
		} while (Ca.currentType !== 14 && Ca.currentType !== 1);
		const Ja = Ca.currentType === 1 ? Ca.lastOffset : Sa.currentOffset(),
			Ua = Ca.currentType === 1 ? Ca.lastEndLoc : Sa.currentPosition();
		return aa(ja, Ja, Ua), ja
	}

	function va(Sa, Ca, ka, Pa) {
		const ja = Sa.context();
		let Za = Pa.items.length === 0;
		const Ga = ia(1, Ca, ka);
		Ga.cases = [], Ga.cases.push(Pa);
		do {
			const Ja = pa(Sa);
			Za || (Za = Ja.items.length === 0), Ga.cases.push(Ja)
		} while (ja.currentType !== 14);
		return Za && na(Sa, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, ka, 0), aa(Ga, Sa.currentOffset(), Sa.currentPosition()), Ga
	}

	function ba(Sa) {
		const Ca = Sa.context(),
			{
				offset: ka,
				startLoc: Pa
			} = Ca,
			ja = pa(Sa);
		return Ca.currentType === 14 ? ja : va(Sa, ka, Pa, ja)
	}

	function Ea(Sa) {
		const Ca = createTokenizer(Sa, assign({}, ue)),
			ka = Ca.context(),
			Pa = ia(0, ka.offset, ka.startLoc);
		return Yi && Pa.loc && (Pa.loc.source = Sa), Pa.body = ba(Ca), ue.onCacheKey && (Pa.cacheKey = ue.onCacheKey(Sa)), ka.currentType !== 14 && na(Ca, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, ka.lastStartLoc, 0, Sa[ka.offset] || ""), aa(Pa, Ca.currentOffset(), Ca.currentPosition()), Pa
	}
	return {
		parse: Ea
	}
}

function getTokenCaption(ue) {
	if (ue.type === 14) return "EOF";
	const Yi = (ue.value || "").replace(/\r?\n/gu, "\\n");
	return Yi.length > 10 ? Yi.slice(0, 9) + "…" : Yi
}

function createTransformer(ue, Yi = {}) {
	const ea = {
		ast: ue,
		helpers: new Set
	};
	return {
		context: () => ea,
		helper: ra => (ea.helpers.add(ra), ra)
	}
}

function traverseNodes(ue, Yi) {
	for (let ea = 0; ea < ue.length; ea++) traverseNode(ue[ea], Yi)
}

function traverseNode(ue, Yi) {
	switch (ue.type) {
		case 1:
			traverseNodes(ue.cases, Yi), Yi.helper("plural");
			break;
		case 2:
			traverseNodes(ue.items, Yi);
			break;
		case 6: {
			traverseNode(ue.key, Yi), Yi.helper("linked"), Yi.helper("type");
			break
		}
		case 5:
			Yi.helper("interpolate"), Yi.helper("list");
			break;
		case 4:
			Yi.helper("interpolate"), Yi.helper("named");
			break
	}
}

function transform(ue, Yi = {}) {
	const ea = createTransformer(ue);
	ea.helper("normalize"), ue.body && traverseNode(ue.body, ea);
	const ta = ea.context();
	ue.helpers = Array.from(ta.helpers)
}

function optimize(ue) {
	const Yi = ue.body;
	return Yi.type === 2 ? optimizeMessageNode(Yi) : Yi.cases.forEach(ea => optimizeMessageNode(ea)), ue
}

function optimizeMessageNode(ue) {
	if (ue.items.length === 1) {
		const Yi = ue.items[0];
		(Yi.type === 3 || Yi.type === 9) && (ue.static = Yi.value, delete Yi.value)
	} else {
		const Yi = [];
		for (let ea = 0; ea < ue.items.length; ea++) {
			const ta = ue.items[ea];
			if (!(ta.type === 3 || ta.type === 9) || ta.value == null) break;
			Yi.push(ta.value)
		}
		if (Yi.length === ue.items.length) {
			ue.static = join(Yi);
			for (let ea = 0; ea < ue.items.length; ea++) {
				const ta = ue.items[ea];
				(ta.type === 3 || ta.type === 9) && delete ta.value
			}
		}
	}
}

function minify(ue) {
	switch (ue.t = ue.type, ue.type) {
		case 0: {
			const Yi = ue;
			minify(Yi.body), Yi.b = Yi.body, delete Yi.body;
			break
		}
		case 1: {
			const Yi = ue,
				ea = Yi.cases;
			for (let ta = 0; ta < ea.length; ta++) minify(ea[ta]);
			Yi.c = ea, delete Yi.cases;
			break
		}
		case 2: {
			const Yi = ue,
				ea = Yi.items;
			for (let ta = 0; ta < ea.length; ta++) minify(ea[ta]);
			Yi.i = ea, delete Yi.items, Yi.static && (Yi.s = Yi.static, delete Yi.static);
			break
		}
		case 3:
		case 9:
		case 8:
		case 7: {
			const Yi = ue;
			Yi.value && (Yi.v = Yi.value, delete Yi.value);
			break
		}
		case 6: {
			const Yi = ue;
			minify(Yi.key), Yi.k = Yi.key, delete Yi.key, Yi.modifier && (minify(Yi.modifier), Yi.m = Yi.modifier, delete Yi.modifier);
			break
		}
		case 5: {
			const Yi = ue;
			Yi.i = Yi.index, delete Yi.index;
			break
		}
		case 4: {
			const Yi = ue;
			Yi.k = Yi.key, delete Yi.key;
			break
		}
	}
	delete ue.type
}

function createCodeGenerator(ue, Yi) {
	const {
		sourceMap: ea,
		filename: ta,
		breakLineCode: na,
		needIndent: ra
	} = Yi, ia = Yi.location !== !1, aa = {
		filename: ta,
		code: "",
		column: 1,
		line: 1,
		offset: 0,
		map: void 0,
		breakLineCode: na,
		needIndent: ra,
		indentLevel: 0
	};
	ia && ue.loc && (aa.source = ue.loc.source);
	const oa = () => aa;

	function la(va, ba) {
		aa.code += va
	}

	function sa(va, ba = !0) {
		const Ea = ba ? na : "";
		la(ra ? Ea + "  ".repeat(va) : Ea)
	}

	function ca(va = !0) {
		const ba = ++aa.indentLevel;
		va && sa(ba)
	}

	function ua(va = !0) {
		const ba = --aa.indentLevel;
		va && sa(ba)
	}

	function da() {
		sa(aa.indentLevel)
	}
	return {
		context: oa,
		push: la,
		indent: ca,
		deindent: ua,
		newline: da,
		helper: va => `_${va}`,
		needIndent: () => aa.needIndent
	}
}

function generateLinkedNode(ue, Yi) {
	const {
		helper: ea
	} = ue;
	ue.push(`${ea("linked")}(`), generateNode(ue, Yi.key), Yi.modifier ? (ue.push(", "), generateNode(ue, Yi.modifier), ue.push(", _type")) : ue.push(", undefined, _type"), ue.push(")")
}

function generateMessageNode(ue, Yi) {
	const {
		helper: ea,
		needIndent: ta
	} = ue;
	ue.push(`${ea("normalize")}([`), ue.indent(ta());
	const na = Yi.items.length;
	for (let ra = 0; ra < na && (generateNode(ue, Yi.items[ra]), ra !== na - 1); ra++) ue.push(", ");
	ue.deindent(ta()), ue.push("])")
}

function generatePluralNode(ue, Yi) {
	const {
		helper: ea,
		needIndent: ta
	} = ue;
	if (Yi.cases.length > 1) {
		ue.push(`${ea("plural")}([`), ue.indent(ta());
		const na = Yi.cases.length;
		for (let ra = 0; ra < na && (generateNode(ue, Yi.cases[ra]), ra !== na - 1); ra++) ue.push(", ");
		ue.deindent(ta()), ue.push("])")
	}
}

function generateResource(ue, Yi) {
	Yi.body ? generateNode(ue, Yi.body) : ue.push("null")
}

function generateNode(ue, Yi) {
	const {
		helper: ea
	} = ue;
	switch (Yi.type) {
		case 0:
			generateResource(ue, Yi);
			break;
		case 1:
			generatePluralNode(ue, Yi);
			break;
		case 2:
			generateMessageNode(ue, Yi);
			break;
		case 6:
			generateLinkedNode(ue, Yi);
			break;
		case 8:
			ue.push(JSON.stringify(Yi.value), Yi);
			break;
		case 7:
			ue.push(JSON.stringify(Yi.value), Yi);
			break;
		case 5:
			ue.push(`${ea("interpolate")}(${ea("list")}(${Yi.index}))`, Yi);
			break;
		case 4:
			ue.push(`${ea("interpolate")}(${ea("named")}(${JSON.stringify(Yi.key)}))`, Yi);
			break;
		case 9:
			ue.push(JSON.stringify(Yi.value), Yi);
			break;
		case 3:
			ue.push(JSON.stringify(Yi.value), Yi);
			break
	}
}
const generate = (ue, Yi = {}) => {
	const ea = isString$1(Yi.mode) ? Yi.mode : "normal",
		ta = isString$1(Yi.filename) ? Yi.filename : "message.intl",
		na = !!Yi.sourceMap,
		ra = Yi.breakLineCode != null ? Yi.breakLineCode : ea === "arrow" ? ";" : `
`,
		ia = Yi.needIndent ? Yi.needIndent : ea !== "arrow",
		aa = ue.helpers || [],
		oa = createCodeGenerator(ue, {
			mode: ea,
			filename: ta,
			sourceMap: na,
			breakLineCode: ra,
			needIndent: ia
		});
	oa.push(ea === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), oa.indent(ia), aa.length > 0 && (oa.push(`const { ${join(aa.map(ca=>`${ca}: _${ca}`),", ")} } = ctx`), oa.newline()), oa.push("return "), generateNode(oa, ue), oa.deindent(ia), oa.push("}"), delete ue.helpers;
	const {
		code: la,
		map: sa
	} = oa.context();
	return {
		ast: ue,
		code: la,
		map: sa ? sa.toJSON() : void 0
	}
};

function baseCompile$1(ue, Yi = {}) {
	const ea = assign({}, Yi),
		ta = !!ea.jit,
		na = !!ea.minify,
		ra = ea.optimize == null ? !0 : ea.optimize,
		aa = createParser(ea).parse(ue);
	return ta ? (ra && optimize(aa), na && minify(aa), {
		ast: aa,
		code: ""
	}) : (transform(aa, ea), generate(aa, ea))
}
/*!
 * core-base v9.14.0
 * (c) 2024 kazuya kawaguchi
 * Released under the MIT License.
 */
function initFeatureFlags$1() {
	typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = !1)
}
const pathStateMachine = [];
pathStateMachine[0] = {
	w: [0],
	i: [3, 0],
	"[": [4],
	o: [7]
};
pathStateMachine[1] = {
	w: [1],
	".": [2],
	"[": [4],
	o: [7]
};
pathStateMachine[2] = {
	w: [2],
	i: [3, 0],
	0: [3, 0]
};
pathStateMachine[3] = {
	i: [3, 0],
	0: [3, 0],
	w: [1, 1],
	".": [2, 1],
	"[": [4, 1],
	o: [7, 1]
};
pathStateMachine[4] = {
	"'": [5, 0],
	'"': [6, 0],
	"[": [4, 2],
	"]": [1, 3],
	o: 8,
	l: [4, 0]
};
pathStateMachine[5] = {
	"'": [4, 0],
	o: 8,
	l: [5, 0]
};
pathStateMachine[6] = {
	'"': [4, 0],
	o: 8,
	l: [6, 0]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;

function isLiteral(ue) {
	return literalValueRE.test(ue)
}

function stripQuotes(ue) {
	const Yi = ue.charCodeAt(0),
		ea = ue.charCodeAt(ue.length - 1);
	return Yi === ea && (Yi === 34 || Yi === 39) ? ue.slice(1, -1) : ue
}

function getPathCharType(ue) {
	if (ue == null) return "o";
	switch (ue.charCodeAt(0)) {
		case 91:
		case 93:
		case 46:
		case 34:
		case 39:
			return ue;
		case 95:
		case 36:
		case 45:
			return "i";
		case 9:
		case 10:
		case 13:
		case 160:
		case 65279:
		case 8232:
		case 8233:
			return "w"
	}
	return "i"
}

function formatSubPath(ue) {
	const Yi = ue.trim();
	return ue.charAt(0) === "0" && isNaN(parseInt(ue)) ? !1 : isLiteral(Yi) ? stripQuotes(Yi) : "*" + Yi
}

function parse(ue) {
	const Yi = [];
	let ea = -1,
		ta = 0,
		na = 0,
		ra, ia, aa, oa, la, sa, ca;
	const ua = [];
	ua[0] = () => {
		ia === void 0 ? ia = aa : ia += aa
	}, ua[1] = () => {
		ia !== void 0 && (Yi.push(ia), ia = void 0)
	}, ua[2] = () => {
		ua[0](), na++
	}, ua[3] = () => {
		if (na > 0) na--, ta = 4, ua[0]();
		else {
			if (na = 0, ia === void 0 || (ia = formatSubPath(ia), ia === !1)) return !1;
			ua[1]()
		}
	};

	function da() {
		const ha = ue[ea + 1];
		if (ta === 5 && ha === "'" || ta === 6 && ha === '"') return ea++, aa = "\\" + ha, ua[0](), !0
	}
	for (; ta !== null;)
		if (ea++, ra = ue[ea], !(ra === "\\" && da())) {
			if (oa = getPathCharType(ra), ca = pathStateMachine[ta], la = ca[oa] || ca.l || 8, la === 8 || (ta = la[0], la[1] !== void 0 && (sa = ua[la[1]], sa && (aa = ra, sa() === !1)))) return;
			if (ta === 7) return Yi
		}
}
const cache = new Map;

function resolveWithKeyValue(ue, Yi) {
	return isObject(ue) ? ue[Yi] : null
}

function resolveValue(ue, Yi) {
	if (!isObject(ue)) return null;
	let ea = cache.get(Yi);
	if (ea || (ea = parse(Yi), ea && cache.set(Yi, ea)), !ea) return null;
	const ta = ea.length;
	let na = ue,
		ra = 0;
	for (; ra < ta;) {
		const ia = na[ea[ra]];
		if (ia === void 0 || isFunction(na)) return null;
		na = ia, ra++
	}
	return na
}
const DEFAULT_MODIFIER = ue => ue,
	DEFAULT_MESSAGE = ue => "",
	DEFAULT_MESSAGE_DATA_TYPE = "text",
	DEFAULT_NORMALIZE = ue => ue.length === 0 ? "" : join(ue),
	DEFAULT_INTERPOLATE = toDisplayString;

function pluralDefault(ue, Yi) {
	return ue = Math.abs(ue), Yi === 2 ? ue ? ue > 1 ? 1 : 0 : 1 : ue ? Math.min(ue, 2) : 0
}

function getPluralIndex(ue) {
	const Yi = isNumber(ue.pluralIndex) ? ue.pluralIndex : -1;
	return ue.named && (isNumber(ue.named.count) || isNumber(ue.named.n)) ? isNumber(ue.named.count) ? ue.named.count : isNumber(ue.named.n) ? ue.named.n : Yi : Yi
}

function normalizeNamed(ue, Yi) {
	Yi.count || (Yi.count = ue), Yi.n || (Yi.n = ue)
}

function createMessageContext(ue = {}) {
	const Yi = ue.locale,
		ea = getPluralIndex(ue),
		ta = isObject(ue.pluralRules) && isString$1(Yi) && isFunction(ue.pluralRules[Yi]) ? ue.pluralRules[Yi] : pluralDefault,
		na = isObject(ue.pluralRules) && isString$1(Yi) && isFunction(ue.pluralRules[Yi]) ? pluralDefault : void 0,
		ra = ba => ba[ta(ea, ba.length, na)],
		ia = ue.list || [],
		aa = ba => ia[ba],
		oa = ue.named || {};
	isNumber(ue.pluralIndex) && normalizeNamed(ea, oa);
	const la = ba => oa[ba];

	function sa(ba) {
		const Ea = isFunction(ue.messages) ? ue.messages(ba) : isObject(ue.messages) ? ue.messages[ba] : !1;
		return Ea || (ue.parent ? ue.parent.message(ba) : DEFAULT_MESSAGE)
	}
	const ca = ba => ue.modifiers ? ue.modifiers[ba] : DEFAULT_MODIFIER,
		ua = isPlainObject$1(ue.processor) && isFunction(ue.processor.normalize) ? ue.processor.normalize : DEFAULT_NORMALIZE,
		da = isPlainObject$1(ue.processor) && isFunction(ue.processor.interpolate) ? ue.processor.interpolate : DEFAULT_INTERPOLATE,
		ha = isPlainObject$1(ue.processor) && isString$1(ue.processor.type) ? ue.processor.type : DEFAULT_MESSAGE_DATA_TYPE,
		va = {
			list: aa,
			named: la,
			plural: ra,
			linked: (ba, ...Ea) => {
				const [Sa, Ca] = Ea;
				let ka = "text",
					Pa = "";
				Ea.length === 1 ? isObject(Sa) ? (Pa = Sa.modifier || Pa, ka = Sa.type || ka) : isString$1(Sa) && (Pa = Sa || Pa) : Ea.length === 2 && (isString$1(Sa) && (Pa = Sa || Pa), isString$1(Ca) && (ka = Ca || ka));
				const ja = sa(ba)(va),
					Za = ka === "vnode" && isArray(ja) && Pa ? ja[0] : ja;
				return Pa ? ca(Pa)(Za, ka) : Za
			},
			message: sa,
			type: ha,
			interpolate: da,
			normalize: ua,
			values: assign({}, ia, oa)
		};
	return va
}
let devtools = null;

function setDevToolsHook(ue) {
	devtools = ue
}

function initI18nDevTools(ue, Yi, ea) {
	devtools && devtools.emit("i18n:init", {
		timestamp: Date.now(),
		i18n: ue,
		version: Yi,
		meta: ea
	})
}
const translateDevTools = createDevToolsHook("function:translate");

function createDevToolsHook(ue) {
	return Yi => devtools && devtools.emit(ue, Yi)
}
const code$1$1 = CompileWarnCodes.__EXTEND_POINT__,
	inc$1$1 = incrementer(code$1$1),
	CoreWarnCodes = {
		NOT_FOUND_KEY: code$1$1,
		FALLBACK_TO_TRANSLATE: inc$1$1(),
		CANNOT_FORMAT_NUMBER: inc$1$1(),
		FALLBACK_TO_NUMBER_FORMAT: inc$1$1(),
		CANNOT_FORMAT_DATE: inc$1$1(),
		FALLBACK_TO_DATE_FORMAT: inc$1$1(),
		EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1$1(),
		__EXTEND_POINT__: inc$1$1()
	},
	code$2 = CompileErrorCodes.__EXTEND_POINT__,
	inc$2 = incrementer(code$2),
	CoreErrorCodes = {
		INVALID_ARGUMENT: code$2,
		INVALID_DATE_ARGUMENT: inc$2(),
		INVALID_ISO_DATE_ARGUMENT: inc$2(),
		NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
		NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
		NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
		NOT_SUPPORT_LOCALE_TYPE: inc$2(),
		__EXTEND_POINT__: inc$2()
	};

function createCoreError(ue) {
	return createCompileError(ue, null, void 0)
}

function getLocale(ue, Yi) {
	return Yi.locale != null ? resolveLocale(Yi.locale) : resolveLocale(ue.locale)
}
let _resolveLocale;

function resolveLocale(ue) {
	if (isString$1(ue)) return ue;
	if (isFunction(ue)) {
		if (ue.resolvedOnce && _resolveLocale != null) return _resolveLocale;
		if (ue.constructor.name === "Function") {
			const Yi = ue();
			if (isPromise(Yi)) throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
			return _resolveLocale = Yi
		} else throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION)
	} else throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE)
}

function fallbackWithSimple(ue, Yi, ea) {
	return [...new Set([ea, ...isArray(Yi) ? Yi : isObject(Yi) ? Object.keys(Yi) : isString$1(Yi) ? [Yi] : [ea]])]
}

function fallbackWithLocaleChain(ue, Yi, ea) {
	const ta = isString$1(ea) ? ea : DEFAULT_LOCALE,
		na = ue;
	na.__localeChainCache || (na.__localeChainCache = new Map);
	let ra = na.__localeChainCache.get(ta);
	if (!ra) {
		ra = [];
		let ia = [ea];
		for (; isArray(ia);) ia = appendBlockToChain(ra, ia, Yi);
		const aa = isArray(Yi) || !isPlainObject$1(Yi) ? Yi : Yi.default ? Yi.default : null;
		ia = isString$1(aa) ? [aa] : aa, isArray(ia) && appendBlockToChain(ra, ia, !1), na.__localeChainCache.set(ta, ra)
	}
	return ra
}

function appendBlockToChain(ue, Yi, ea) {
	let ta = !0;
	for (let na = 0; na < Yi.length && isBoolean(ta); na++) {
		const ra = Yi[na];
		isString$1(ra) && (ta = appendLocaleToChain(ue, Yi[na], ea))
	}
	return ta
}

function appendLocaleToChain(ue, Yi, ea) {
	let ta;
	const na = Yi.split("-");
	do {
		const ra = na.join("-");
		ta = appendItemToChain(ue, ra, ea), na.splice(-1, 1)
	} while (na.length && ta === !0);
	return ta
}

function appendItemToChain(ue, Yi, ea) {
	let ta = !1;
	if (!ue.includes(Yi) && (ta = !0, Yi)) {
		ta = Yi[Yi.length - 1] !== "!";
		const na = Yi.replace(/!/g, "");
		ue.push(na), (isArray(ea) || isPlainObject$1(ea)) && ea[na] && (ta = ea[na])
	}
	return ta
}
const VERSION$1 = "9.14.0",
	NOT_REOSLVED = -1,
	DEFAULT_LOCALE = "en-US",
	MISSING_RESOLVE_VALUE = "",
	capitalize = ue => `${ue.charAt(0).toLocaleUpperCase()}${ue.substr(1)}`;

function getDefaultLinkedModifiers() {
	return {
		upper: (ue, Yi) => Yi === "text" && isString$1(ue) ? ue.toUpperCase() : Yi === "vnode" && isObject(ue) && "__v_isVNode" in ue ? ue.children.toUpperCase() : ue,
		lower: (ue, Yi) => Yi === "text" && isString$1(ue) ? ue.toLowerCase() : Yi === "vnode" && isObject(ue) && "__v_isVNode" in ue ? ue.children.toLowerCase() : ue,
		capitalize: (ue, Yi) => Yi === "text" && isString$1(ue) ? capitalize(ue) : Yi === "vnode" && isObject(ue) && "__v_isVNode" in ue ? capitalize(ue.children) : ue
	}
}
let _compiler;

function registerMessageCompiler(ue) {
	_compiler = ue
}
let _resolver;

function registerMessageResolver(ue) {
	_resolver = ue
}
let _fallbacker;

function registerLocaleFallbacker(ue) {
	_fallbacker = ue
}
let _additionalMeta = null;
const setAdditionalMeta = ue => {
		_additionalMeta = ue
	},
	getAdditionalMeta = () => _additionalMeta;
let _fallbackContext = null;
const setFallbackContext = ue => {
		_fallbackContext = ue
	},
	getFallbackContext = () => _fallbackContext;
let _cid = 0;

function createCoreContext(ue = {}) {
	const Yi = isFunction(ue.onWarn) ? ue.onWarn : warn,
		ea = isString$1(ue.version) ? ue.version : VERSION$1,
		ta = isString$1(ue.locale) || isFunction(ue.locale) ? ue.locale : DEFAULT_LOCALE,
		na = isFunction(ta) ? DEFAULT_LOCALE : ta,
		ra = isArray(ue.fallbackLocale) || isPlainObject$1(ue.fallbackLocale) || isString$1(ue.fallbackLocale) || ue.fallbackLocale === !1 ? ue.fallbackLocale : na,
		ia = isPlainObject$1(ue.messages) ? ue.messages : {
			[na]: {}
		},
		aa = isPlainObject$1(ue.datetimeFormats) ? ue.datetimeFormats : {
			[na]: {}
		},
		oa = isPlainObject$1(ue.numberFormats) ? ue.numberFormats : {
			[na]: {}
		},
		la = assign({}, ue.modifiers || {}, getDefaultLinkedModifiers()),
		sa = ue.pluralRules || {},
		ca = isFunction(ue.missing) ? ue.missing : null,
		ua = isBoolean(ue.missingWarn) || isRegExp$1(ue.missingWarn) ? ue.missingWarn : !0,
		da = isBoolean(ue.fallbackWarn) || isRegExp$1(ue.fallbackWarn) ? ue.fallbackWarn : !0,
		ha = !!ue.fallbackFormat,
		pa = !!ue.unresolving,
		va = isFunction(ue.postTranslation) ? ue.postTranslation : null,
		ba = isPlainObject$1(ue.processor) ? ue.processor : null,
		Ea = isBoolean(ue.warnHtmlMessage) ? ue.warnHtmlMessage : !0,
		Sa = !!ue.escapeParameter,
		Ca = isFunction(ue.messageCompiler) ? ue.messageCompiler : _compiler,
		ka = isFunction(ue.messageResolver) ? ue.messageResolver : _resolver || resolveWithKeyValue,
		Pa = isFunction(ue.localeFallbacker) ? ue.localeFallbacker : _fallbacker || fallbackWithSimple,
		ja = isObject(ue.fallbackContext) ? ue.fallbackContext : void 0,
		Za = ue,
		Ga = isObject(Za.__datetimeFormatters) ? Za.__datetimeFormatters : new Map,
		Ja = isObject(Za.__numberFormatters) ? Za.__numberFormatters : new Map,
		Ua = isObject(Za.__meta) ? Za.__meta : {};
	_cid++;
	const xa = {
		version: ea,
		cid: _cid,
		locale: ta,
		fallbackLocale: ra,
		messages: ia,
		modifiers: la,
		pluralRules: sa,
		missing: ca,
		missingWarn: ua,
		fallbackWarn: da,
		fallbackFormat: ha,
		unresolving: pa,
		postTranslation: va,
		processor: ba,
		warnHtmlMessage: Ea,
		escapeParameter: Sa,
		messageCompiler: Ca,
		messageResolver: ka,
		localeFallbacker: Pa,
		fallbackContext: ja,
		onWarn: Yi,
		__meta: Ua
	};
	return xa.datetimeFormats = aa, xa.numberFormats = oa, xa.__datetimeFormatters = Ga, xa.__numberFormatters = Ja, __INTLIFY_PROD_DEVTOOLS__ && initI18nDevTools(xa, ea, Ua), xa
}

function handleMissing(ue, Yi, ea, ta, na) {
	const {
		missing: ra,
		onWarn: ia
	} = ue;
	if (ra !== null) {
		const aa = ra(ue, ea, Yi, na);
		return isString$1(aa) ? aa : Yi
	} else return Yi
}

function updateFallbackLocale(ue, Yi, ea) {
	const ta = ue;
	ta.__localeChainCache = new Map, ue.localeFallbacker(ue, ea, Yi)
}

function isAlmostSameLocale(ue, Yi) {
	return ue === Yi ? !1 : ue.split("-")[0] === Yi.split("-")[0]
}

function isImplicitFallback(ue, Yi) {
	const ea = Yi.indexOf(ue);
	if (ea === -1) return !1;
	for (let ta = ea + 1; ta < Yi.length; ta++)
		if (isAlmostSameLocale(ue, Yi[ta])) return !0;
	return !1
}

function format(ue) {
	return ea => formatParts(ea, ue)
}

function formatParts(ue, Yi) {
	const ea = Yi.b || Yi.body;
	if ((ea.t || ea.type) === 1) {
		const ta = ea,
			na = ta.c || ta.cases;
		return ue.plural(na.reduce((ra, ia) => [...ra, formatMessageParts(ue, ia)], []))
	} else return formatMessageParts(ue, ea)
}

function formatMessageParts(ue, Yi) {
	const ea = Yi.s || Yi.static;
	if (ea) return ue.type === "text" ? ea : ue.normalize([ea]);
	{
		const ta = (Yi.i || Yi.items).reduce((na, ra) => [...na, formatMessagePart(ue, ra)], []);
		return ue.normalize(ta)
	}
}

function formatMessagePart(ue, Yi) {
	const ea = Yi.t || Yi.type;
	switch (ea) {
		case 3: {
			const ta = Yi;
			return ta.v || ta.value
		}
		case 9: {
			const ta = Yi;
			return ta.v || ta.value
		}
		case 4: {
			const ta = Yi;
			return ue.interpolate(ue.named(ta.k || ta.key))
		}
		case 5: {
			const ta = Yi;
			return ue.interpolate(ue.list(ta.i != null ? ta.i : ta.index))
		}
		case 6: {
			const ta = Yi,
				na = ta.m || ta.modifier;
			return ue.linked(formatMessagePart(ue, ta.k || ta.key), na ? formatMessagePart(ue, na) : void 0, ue.type)
		}
		case 7: {
			const ta = Yi;
			return ta.v || ta.value
		}
		case 8: {
			const ta = Yi;
			return ta.v || ta.value
		}
		default:
			throw new Error(`unhandled node type on format message part: ${ea}`)
	}
}
const defaultOnCacheKey = ue => ue;
let compileCache = Object.create(null);
const isMessageAST = ue => isObject(ue) && (ue.t === 0 || ue.type === 0) && ("b" in ue || "body" in ue);

function baseCompile(ue, Yi = {}) {
	let ea = !1;
	const ta = Yi.onError || defaultOnError;
	return Yi.onError = na => {
		ea = !0, ta(na)
	}, {
		...baseCompile$1(ue, Yi),
		detectError: ea
	}
}

function compile(ue, Yi) {
	if (isString$1(ue)) {
		isBoolean(Yi.warnHtmlMessage) && Yi.warnHtmlMessage;
		const ta = (Yi.onCacheKey || defaultOnCacheKey)(ue),
			na = compileCache[ta];
		if (na) return na;
		const {
			ast: ra,
			detectError: ia
		} = baseCompile(ue, {
			...Yi,
			location: !1,
			jit: !0
		}), aa = format(ra);
		return ia ? aa : compileCache[ta] = aa
	} else {
		const ea = ue.cacheKey;
		if (ea) {
			const ta = compileCache[ea];
			return ta || (compileCache[ea] = format(ue))
		} else return format(ue)
	}
}
const NOOP_MESSAGE_FUNCTION = () => "",
	isMessageFunction = ue => isFunction(ue);

function translate(ue, ...Yi) {
	const {
		fallbackFormat: ea,
		postTranslation: ta,
		unresolving: na,
		messageCompiler: ra,
		fallbackLocale: ia,
		messages: aa
	} = ue, [oa, la] = parseTranslateArgs(...Yi), sa = isBoolean(la.missingWarn) ? la.missingWarn : ue.missingWarn, ca = isBoolean(la.fallbackWarn) ? la.fallbackWarn : ue.fallbackWarn, ua = isBoolean(la.escapeParameter) ? la.escapeParameter : ue.escapeParameter, da = !!la.resolvedMessage, ha = isString$1(la.default) || isBoolean(la.default) ? isBoolean(la.default) ? ra ? oa : () => oa : la.default : ea ? ra ? oa : () => oa : "", pa = ea || ha !== "", va = getLocale(ue, la);
	ua && escapeParams(la);
	let [ba, Ea, Sa] = da ? [oa, va, aa[va] || {}] : resolveMessageFormat(ue, oa, va, ia, ca, sa), Ca = ba, ka = oa;
	if (!da && !(isString$1(Ca) || isMessageAST(Ca) || isMessageFunction(Ca)) && pa && (Ca = ha, ka = Ca), !da && (!(isString$1(Ca) || isMessageAST(Ca) || isMessageFunction(Ca)) || !isString$1(Ea))) return na ? NOT_REOSLVED : oa;
	let Pa = !1;
	const ja = () => {
			Pa = !0
		},
		Za = isMessageFunction(Ca) ? Ca : compileMessageFormat(ue, oa, Ea, Ca, ka, ja);
	if (Pa) return Ca;
	const Ga = getMessageContextOptions(ue, Ea, Sa, la),
		Ja = createMessageContext(Ga),
		Ua = evaluateMessage(ue, Za, Ja),
		xa = ta ? ta(Ua, oa) : Ua;
	if (__INTLIFY_PROD_DEVTOOLS__) {
		const ma = {
			timestamp: Date.now(),
			key: isString$1(oa) ? oa : isMessageFunction(Ca) ? Ca.key : "",
			locale: Ea || (isMessageFunction(Ca) ? Ca.locale : ""),
			format: isString$1(Ca) ? Ca : isMessageFunction(Ca) ? Ca.source : "",
			message: xa
		};
		ma.meta = assign({}, ue.__meta, getAdditionalMeta() || {}), translateDevTools(ma)
	}
	return xa
}

function escapeParams(ue) {
	isArray(ue.list) ? ue.list = ue.list.map(Yi => isString$1(Yi) ? escapeHtml(Yi) : Yi) : isObject(ue.named) && Object.keys(ue.named).forEach(Yi => {
		isString$1(ue.named[Yi]) && (ue.named[Yi] = escapeHtml(ue.named[Yi]))
	})
}

function resolveMessageFormat(ue, Yi, ea, ta, na, ra) {
	const {
		messages: ia,
		onWarn: aa,
		messageResolver: oa,
		localeFallbacker: la
	} = ue, sa = la(ue, ta, ea);
	let ca = {},
		ua, da = null;
	const ha = "translate";
	for (let pa = 0; pa < sa.length && (ua = sa[pa], ca = ia[ua] || {}, (da = oa(ca, Yi)) === null && (da = ca[Yi]), !(isString$1(da) || isMessageAST(da) || isMessageFunction(da))); pa++)
		if (!isImplicitFallback(ua, sa)) {
			const va = handleMissing(ue, Yi, ua, ra, ha);
			va !== Yi && (da = va)
		} return [da, ua, ca]
}

function compileMessageFormat(ue, Yi, ea, ta, na, ra) {
	const {
		messageCompiler: ia,
		warnHtmlMessage: aa
	} = ue;
	if (isMessageFunction(ta)) {
		const la = ta;
		return la.locale = la.locale || ea, la.key = la.key || Yi, la
	}
	if (ia == null) {
		const la = () => ta;
		return la.locale = ea, la.key = Yi, la
	}
	const oa = ia(ta, getCompileContext(ue, ea, na, ta, aa, ra));
	return oa.locale = ea, oa.key = Yi, oa.source = ta, oa
}

function evaluateMessage(ue, Yi, ea) {
	return Yi(ea)
}

function parseTranslateArgs(...ue) {
	const [Yi, ea, ta] = ue, na = {};
	if (!isString$1(Yi) && !isNumber(Yi) && !isMessageFunction(Yi) && !isMessageAST(Yi)) throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
	const ra = isNumber(Yi) ? String(Yi) : (isMessageFunction(Yi), Yi);
	return isNumber(ea) ? na.plural = ea : isString$1(ea) ? na.default = ea : isPlainObject$1(ea) && !isEmptyObject(ea) ? na.named = ea : isArray(ea) && (na.list = ea), isNumber(ta) ? na.plural = ta : isString$1(ta) ? na.default = ta : isPlainObject$1(ta) && assign(na, ta), [ra, na]
}

function getCompileContext(ue, Yi, ea, ta, na, ra) {
	return {
		locale: Yi,
		key: ea,
		warnHtmlMessage: na,
		onError: ia => {
			throw ra && ra(ia), ia
		},
		onCacheKey: ia => generateFormatCacheKey(Yi, ea, ia)
	}
}

function getMessageContextOptions(ue, Yi, ea, ta) {
	const {
		modifiers: na,
		pluralRules: ra,
		messageResolver: ia,
		fallbackLocale: aa,
		fallbackWarn: oa,
		missingWarn: la,
		fallbackContext: sa
	} = ue, ua = {
		locale: Yi,
		modifiers: na,
		pluralRules: ra,
		messages: da => {
			let ha = ia(ea, da);
			if (ha == null && sa) {
				const [, , pa] = resolveMessageFormat(sa, da, Yi, aa, oa, la);
				ha = ia(pa, da)
			}
			if (isString$1(ha) || isMessageAST(ha)) {
				let pa = !1;
				const ba = compileMessageFormat(ue, da, Yi, ha, da, () => {
					pa = !0
				});
				return pa ? NOOP_MESSAGE_FUNCTION : ba
			} else return isMessageFunction(ha) ? ha : NOOP_MESSAGE_FUNCTION
		}
	};
	return ue.processor && (ua.processor = ue.processor), ta.list && (ua.list = ta.list), ta.named && (ua.named = ta.named), isNumber(ta.plural) && (ua.pluralIndex = ta.plural), ua
}

function datetime(ue, ...Yi) {
	const {
		datetimeFormats: ea,
		unresolving: ta,
		fallbackLocale: na,
		onWarn: ra,
		localeFallbacker: ia
	} = ue, {
		__datetimeFormatters: aa
	} = ue, [oa, la, sa, ca] = parseDateTimeArgs(...Yi), ua = isBoolean(sa.missingWarn) ? sa.missingWarn : ue.missingWarn;
	isBoolean(sa.fallbackWarn) ? sa.fallbackWarn : ue.fallbackWarn;
	const da = !!sa.part,
		ha = getLocale(ue, sa),
		pa = ia(ue, na, ha);
	if (!isString$1(oa) || oa === "") return new Intl.DateTimeFormat(ha, ca).format(la);
	let va = {},
		ba, Ea = null;
	const Sa = "datetime format";
	for (let Pa = 0; Pa < pa.length && (ba = pa[Pa], va = ea[ba] || {}, Ea = va[oa], !isPlainObject$1(Ea)); Pa++) handleMissing(ue, oa, ba, ua, Sa);
	if (!isPlainObject$1(Ea) || !isString$1(ba)) return ta ? NOT_REOSLVED : oa;
	let Ca = `${ba}__${oa}`;
	isEmptyObject(ca) || (Ca = `${Ca}__${JSON.stringify(ca)}`);
	let ka = aa.get(Ca);
	return ka || (ka = new Intl.DateTimeFormat(ba, assign({}, Ea, ca)), aa.set(Ca, ka)), da ? ka.formatToParts(la) : ka.format(la)
}
const DATETIME_FORMAT_OPTIONS_KEYS = ["localeMatcher", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "formatMatcher", "hour12", "timeZone", "dateStyle", "timeStyle", "calendar", "dayPeriod", "numberingSystem", "hourCycle", "fractionalSecondDigits"];

function parseDateTimeArgs(...ue) {
	const [Yi, ea, ta, na] = ue, ra = {};
	let ia = {},
		aa;
	if (isString$1(Yi)) {
		const oa = Yi.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
		if (!oa) throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
		const la = oa[3] ? oa[3].trim().startsWith("T") ? `${oa[1].trim()}${oa[3].trim()}` : `${oa[1].trim()}T${oa[3].trim()}` : oa[1].trim();
		aa = new Date(la);
		try {
			aa.toISOString()
		} catch {
			throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT)
		}
	} else if (isDate$1(Yi)) {
		if (isNaN(Yi.getTime())) throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
		aa = Yi
	} else if (isNumber(Yi)) aa = Yi;
	else throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
	return isString$1(ea) ? ra.key = ea : isPlainObject$1(ea) && Object.keys(ea).forEach(oa => {
		DATETIME_FORMAT_OPTIONS_KEYS.includes(oa) ? ia[oa] = ea[oa] : ra[oa] = ea[oa]
	}), isString$1(ta) ? ra.locale = ta : isPlainObject$1(ta) && (ia = ta), isPlainObject$1(na) && (ia = na), [ra.key || "", aa, ra, ia]
}

function clearDateTimeFormat(ue, Yi, ea) {
	const ta = ue;
	for (const na in ea) {
		const ra = `${Yi}__${na}`;
		ta.__datetimeFormatters.has(ra) && ta.__datetimeFormatters.delete(ra)
	}
}

function number(ue, ...Yi) {
	const {
		numberFormats: ea,
		unresolving: ta,
		fallbackLocale: na,
		onWarn: ra,
		localeFallbacker: ia
	} = ue, {
		__numberFormatters: aa
	} = ue, [oa, la, sa, ca] = parseNumberArgs(...Yi), ua = isBoolean(sa.missingWarn) ? sa.missingWarn : ue.missingWarn;
	isBoolean(sa.fallbackWarn) ? sa.fallbackWarn : ue.fallbackWarn;
	const da = !!sa.part,
		ha = getLocale(ue, sa),
		pa = ia(ue, na, ha);
	if (!isString$1(oa) || oa === "") return new Intl.NumberFormat(ha, ca).format(la);
	let va = {},
		ba, Ea = null;
	const Sa = "number format";
	for (let Pa = 0; Pa < pa.length && (ba = pa[Pa], va = ea[ba] || {}, Ea = va[oa], !isPlainObject$1(Ea)); Pa++) handleMissing(ue, oa, ba, ua, Sa);
	if (!isPlainObject$1(Ea) || !isString$1(ba)) return ta ? NOT_REOSLVED : oa;
	let Ca = `${ba}__${oa}`;
	isEmptyObject(ca) || (Ca = `${Ca}__${JSON.stringify(ca)}`);
	let ka = aa.get(Ca);
	return ka || (ka = new Intl.NumberFormat(ba, assign({}, Ea, ca)), aa.set(Ca, ka)), da ? ka.formatToParts(la) : ka.format(la)
}
const NUMBER_FORMAT_OPTIONS_KEYS = ["localeMatcher", "style", "currency", "currencyDisplay", "currencySign", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "notation", "signDisplay", "unit", "unitDisplay", "roundingMode", "roundingPriority", "roundingIncrement", "trailingZeroDisplay"];

function parseNumberArgs(...ue) {
	const [Yi, ea, ta, na] = ue, ra = {};
	let ia = {};
	if (!isNumber(Yi)) throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
	const aa = Yi;
	return isString$1(ea) ? ra.key = ea : isPlainObject$1(ea) && Object.keys(ea).forEach(oa => {
		NUMBER_FORMAT_OPTIONS_KEYS.includes(oa) ? ia[oa] = ea[oa] : ra[oa] = ea[oa]
	}), isString$1(ta) ? ra.locale = ta : isPlainObject$1(ta) && (ia = ta), isPlainObject$1(na) && (ia = na), [ra.key || "", aa, ra, ia]
}

function clearNumberFormat(ue, Yi, ea) {
	const ta = ue;
	for (const na in ea) {
		const ra = `${Yi}__${na}`;
		ta.__numberFormatters.has(ra) && ta.__numberFormatters.delete(ra)
	}
}
initFeatureFlags$1();
/*!
 * vue-i18n v9.14.0
 * (c) 2024 kazuya kawaguchi
 * Released under the MIT License.
 */
const VERSION = "9.14.0";

function initFeatureFlags() {
	typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = !1)
}
const code$1 = CoreWarnCodes.__EXTEND_POINT__,
	inc$1 = incrementer(code$1);
inc$1(), inc$1(), inc$1(), inc$1(), inc$1(), inc$1(), inc$1(), inc$1(), inc$1();
const code = CoreErrorCodes.__EXTEND_POINT__,
	inc = incrementer(code),
	I18nErrorCodes = {
		UNEXPECTED_RETURN_TYPE: code,
		INVALID_ARGUMENT: inc(),
		MUST_BE_CALL_SETUP_TOP: inc(),
		NOT_INSTALLED: inc(),
		NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
		REQUIRED_VALUE: inc(),
		INVALID_VALUE: inc(),
		CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
		NOT_INSTALLED_WITH_PROVIDE: inc(),
		UNEXPECTED_ERROR: inc(),
		NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
		BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
		MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
		NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
		__EXTEND_POINT__: inc()
	};

function createI18nError(ue, ...Yi) {
	return createCompileError(ue, null, void 0)
}
const TranslateVNodeSymbol = makeSymbol("__translateVNode"),
	DatetimePartsSymbol = makeSymbol("__datetimeParts"),
	NumberPartsSymbol = makeSymbol("__numberParts"),
	SetPluralRulesSymbol = makeSymbol("__setPluralRules"),
	InejctWithOptionSymbol = makeSymbol("__injectWithOption"),
	DisposeSymbol = makeSymbol("__dispose");

function handleFlatJson(ue) {
	if (!isObject(ue)) return ue;
	for (const Yi in ue)
		if (hasOwn(ue, Yi))
			if (!Yi.includes(".")) isObject(ue[Yi]) && handleFlatJson(ue[Yi]);
			else {
				const ea = Yi.split("."),
					ta = ea.length - 1;
				let na = ue,
					ra = !1;
				for (let ia = 0; ia < ta; ia++) {
					if (ea[ia] in na || (na[ea[ia]] = {}), !isObject(na[ea[ia]])) {
						ra = !0;
						break
					}
					na = na[ea[ia]]
				}
				ra || (na[ea[ta]] = ue[Yi], delete ue[Yi]), isObject(na[ea[ta]]) && handleFlatJson(na[ea[ta]])
			} return ue
}

function getLocaleMessages(ue, Yi) {
	const {
		messages: ea,
		__i18n: ta,
		messageResolver: na,
		flatJson: ra
	} = Yi, ia = isPlainObject$1(ea) ? ea : isArray(ta) ? {} : {
		[ue]: {}
	};
	if (isArray(ta) && ta.forEach(aa => {
			if ("locale" in aa && "resource" in aa) {
				const {
					locale: oa,
					resource: la
				} = aa;
				oa ? (ia[oa] = ia[oa] || {}, deepCopy(la, ia[oa])) : deepCopy(la, ia)
			} else isString$1(aa) && deepCopy(JSON.parse(aa), ia)
		}), na == null && ra)
		for (const aa in ia) hasOwn(ia, aa) && handleFlatJson(ia[aa]);
	return ia
}

function getComponentOptions(ue) {
	return ue.type
}

function adjustI18nResources(ue, Yi, ea) {
	let ta = isObject(Yi.messages) ? Yi.messages : {};
	"__i18nGlobal" in ea && (ta = getLocaleMessages(ue.locale.value, {
		messages: ta,
		__i18n: ea.__i18nGlobal
	}));
	const na = Object.keys(ta);
	na.length && na.forEach(ra => {
		ue.mergeLocaleMessage(ra, ta[ra])
	});
	{
		if (isObject(Yi.datetimeFormats)) {
			const ra = Object.keys(Yi.datetimeFormats);
			ra.length && ra.forEach(ia => {
				ue.mergeDateTimeFormat(ia, Yi.datetimeFormats[ia])
			})
		}
		if (isObject(Yi.numberFormats)) {
			const ra = Object.keys(Yi.numberFormats);
			ra.length && ra.forEach(ia => {
				ue.mergeNumberFormat(ia, Yi.numberFormats[ia])
			})
		}
	}
}

function createTextNode(ue) {
	return createVNode(Text, null, ue, 0)
}
const DEVTOOLS_META = "__INTLIFY_META__",
	NOOP_RETURN_ARRAY = () => [],
	NOOP_RETURN_FALSE = () => !1;
let composerID = 0;

function defineCoreMissingHandler(ue) {
	return (Yi, ea, ta, na) => ue(ea, ta, getCurrentInstance() || void 0, na)
}
const getMetaInfo = () => {
	const ue = getCurrentInstance();
	let Yi = null;
	return ue && (Yi = getComponentOptions(ue)[DEVTOOLS_META]) ? {
		[DEVTOOLS_META]: Yi
	} : null
};

function createComposer(ue = {}, Yi) {
	const {
		__root: ea,
		__injectWithOption: ta
	} = ue, na = ea === void 0, ra = ue.flatJson, ia = inBrowser$1 ? ref$1 : shallowRef, aa = !!ue.translateExistCompatible;
	let oa = isBoolean(ue.inheritLocale) ? ue.inheritLocale : !0;
	const la = ia(ea && oa ? ea.locale.value : isString$1(ue.locale) ? ue.locale : DEFAULT_LOCALE),
		sa = ia(ea && oa ? ea.fallbackLocale.value : isString$1(ue.fallbackLocale) || isArray(ue.fallbackLocale) || isPlainObject$1(ue.fallbackLocale) || ue.fallbackLocale === !1 ? ue.fallbackLocale : la.value),
		ca = ia(getLocaleMessages(la.value, ue)),
		ua = ia(isPlainObject$1(ue.datetimeFormats) ? ue.datetimeFormats : {
			[la.value]: {}
		}),
		da = ia(isPlainObject$1(ue.numberFormats) ? ue.numberFormats : {
			[la.value]: {}
		});
	let ha = ea ? ea.missingWarn : isBoolean(ue.missingWarn) || isRegExp$1(ue.missingWarn) ? ue.missingWarn : !0,
		pa = ea ? ea.fallbackWarn : isBoolean(ue.fallbackWarn) || isRegExp$1(ue.fallbackWarn) ? ue.fallbackWarn : !0,
		va = ea ? ea.fallbackRoot : isBoolean(ue.fallbackRoot) ? ue.fallbackRoot : !0,
		ba = !!ue.fallbackFormat,
		Ea = isFunction(ue.missing) ? ue.missing : null,
		Sa = isFunction(ue.missing) ? defineCoreMissingHandler(ue.missing) : null,
		Ca = isFunction(ue.postTranslation) ? ue.postTranslation : null,
		ka = ea ? ea.warnHtmlMessage : isBoolean(ue.warnHtmlMessage) ? ue.warnHtmlMessage : !0,
		Pa = !!ue.escapeParameter;
	const ja = ea ? ea.modifiers : isPlainObject$1(ue.modifiers) ? ue.modifiers : {};
	let Za = ue.pluralRules || ea && ea.pluralRules,
		Ga;
	Ga = (() => {
		na && setFallbackContext(null);
		const _o = {
			version: VERSION,
			locale: la.value,
			fallbackLocale: sa.value,
			messages: ca.value,
			modifiers: ja,
			pluralRules: Za,
			missing: Sa === null ? void 0 : Sa,
			missingWarn: ha,
			fallbackWarn: pa,
			fallbackFormat: ba,
			unresolving: !0,
			postTranslation: Ca === null ? void 0 : Ca,
			warnHtmlMessage: ka,
			escapeParameter: Pa,
			messageResolver: ue.messageResolver,
			messageCompiler: ue.messageCompiler,
			__meta: {
				framework: "vue"
			}
		};
		_o.datetimeFormats = ua.value, _o.numberFormats = da.value, _o.__datetimeFormatters = isPlainObject$1(Ga) ? Ga.__datetimeFormatters : void 0, _o.__numberFormatters = isPlainObject$1(Ga) ? Ga.__numberFormatters : void 0;
		const Lo = createCoreContext(_o);
		return na && setFallbackContext(Lo), Lo
	})(), updateFallbackLocale(Ga, la.value, sa.value);

	function Ua() {
		return [la.value, sa.value, ca.value, ua.value, da.value]
	}
	const xa = computed({
			get: () => la.value,
			set: _o => {
				la.value = _o, Ga.locale = la.value
			}
		}),
		ma = computed({
			get: () => sa.value,
			set: _o => {
				sa.value = _o, Ga.fallbackLocale = sa.value, updateFallbackLocale(Ga, la.value, _o)
			}
		}),
		fa = computed(() => ca.value),
		ga = computed(() => ua.value),
		wa = computed(() => da.value);

	function Ma() {
		return isFunction(Ca) ? Ca : null
	}

	function Aa(_o) {
		Ca = _o, Ga.postTranslation = _o
	}

	function Ra() {
		return Ea
	}

	function Ta(_o) {
		_o !== null && (Sa = defineCoreMissingHandler(_o)), Ea = _o, Ga.missing = Sa
	}
	const La = (_o, Lo, Fo, jo, eo, Oa) => {
		Ua();
		let Da;
		try {
			__INTLIFY_PROD_DEVTOOLS__,
			na || (Ga.fallbackContext = ea ? getFallbackContext() : void 0),
			Da = _o(Ga)
		}
		finally {
			__INTLIFY_PROD_DEVTOOLS__,
			na || (Ga.fallbackContext = void 0)
		}
		if (Fo !== "translate exists" && isNumber(Da) && Da === NOT_REOSLVED || Fo === "translate exists" && !Da) {
			const [Qa, uo] = Lo();
			return ea && va ? jo(ea) : eo(Qa)
		} else {
			if (Oa(Da)) return Da;
			throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE)
		}
	};

	function ya(..._o) {
		return La(Lo => Reflect.apply(translate, null, [Lo, ..._o]), () => parseTranslateArgs(..._o), "translate", Lo => Reflect.apply(Lo.t, Lo, [..._o]), Lo => Lo, Lo => isString$1(Lo))
	}

	function Ba(..._o) {
		const [Lo, Fo, jo] = _o;
		if (jo && !isObject(jo)) throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
		return ya(Lo, Fo, assign({
			resolvedMessage: !0
		}, jo || {}))
	}

	function io(..._o) {
		return La(Lo => Reflect.apply(datetime, null, [Lo, ..._o]), () => parseDateTimeArgs(..._o), "datetime format", Lo => Reflect.apply(Lo.d, Lo, [..._o]), () => MISSING_RESOLVE_VALUE, Lo => isString$1(Lo))
	}

	function oo(..._o) {
		return La(Lo => Reflect.apply(number, null, [Lo, ..._o]), () => parseNumberArgs(..._o), "number format", Lo => Reflect.apply(Lo.n, Lo, [..._o]), () => MISSING_RESOLVE_VALUE, Lo => isString$1(Lo))
	}

	function ao(_o) {
		return _o.map(Lo => isString$1(Lo) || isNumber(Lo) || isBoolean(Lo) ? createTextNode(String(Lo)) : Lo)
	}
	const Na = {
		normalize: ao,
		interpolate: _o => _o,
		type: "vnode"
	};

	function za(..._o) {
		return La(Lo => {
			let Fo;
			const jo = Lo;
			try {
				jo.processor = Na, Fo = Reflect.apply(translate, null, [jo, ..._o])
			} finally {
				jo.processor = null
			}
			return Fo
		}, () => parseTranslateArgs(..._o), "translate", Lo => Lo[TranslateVNodeSymbol](..._o), Lo => [createTextNode(Lo)], Lo => isArray(Lo))
	}

	function ro(..._o) {
		return La(Lo => Reflect.apply(number, null, [Lo, ..._o]), () => parseNumberArgs(..._o), "number format", Lo => Lo[NumberPartsSymbol](..._o), NOOP_RETURN_ARRAY, Lo => isString$1(Lo) || isArray(Lo))
	}

	function Va(..._o) {
		return La(Lo => Reflect.apply(datetime, null, [Lo, ..._o]), () => parseDateTimeArgs(..._o), "datetime format", Lo => Lo[DatetimePartsSymbol](..._o), NOOP_RETURN_ARRAY, Lo => isString$1(Lo) || isArray(Lo))
	}

	function Wa(_o) {
		Za = _o, Ga.pluralRules = Za
	}

	function qa(_o, Lo) {
		return La(() => {
			if (!_o) return !1;
			const Fo = isString$1(Lo) ? Lo : la.value,
				jo = yo(Fo),
				eo = Ga.messageResolver(jo, _o);
			return aa ? eo != null : isMessageAST(eo) || isMessageFunction(eo) || isString$1(eo)
		}, () => [_o], "translate exists", Fo => Reflect.apply(Fo.te, Fo, [_o, Lo]), NOOP_RETURN_FALSE, Fo => isBoolean(Fo))
	}

	function Ka(_o) {
		let Lo = null;
		const Fo = fallbackWithLocaleChain(Ga, sa.value, la.value);
		for (let jo = 0; jo < Fo.length; jo++) {
			const eo = ca.value[Fo[jo]] || {},
				Oa = Ga.messageResolver(eo, _o);
			if (Oa != null) {
				Lo = Oa;
				break
			}
		}
		return Lo
	}

	function lo(_o) {
		const Lo = Ka(_o);
		return Lo ?? (ea ? ea.tm(_o) || {} : {})
	}

	function yo(_o) {
		return ca.value[_o] || {}
	}

	function fo(_o, Lo) {
		if (ra) {
			const Fo = {
				[_o]: Lo
			};
			for (const jo in Fo) hasOwn(Fo, jo) && handleFlatJson(Fo[jo]);
			Lo = Fo[_o]
		}
		ca.value[_o] = Lo, Ga.messages = ca.value
	}

	function vo(_o, Lo) {
		ca.value[_o] = ca.value[_o] || {};
		const Fo = {
			[_o]: Lo
		};
		if (ra)
			for (const jo in Fo) hasOwn(Fo, jo) && handleFlatJson(Fo[jo]);
		Lo = Fo[_o], deepCopy(Lo, ca.value[_o]), Ga.messages = ca.value
	}

	function so(_o) {
		return ua.value[_o] || {}
	}

	function Xa(_o, Lo) {
		ua.value[_o] = Lo, Ga.datetimeFormats = ua.value, clearDateTimeFormat(Ga, _o, Lo)
	}

	function to(_o, Lo) {
		ua.value[_o] = assign(ua.value[_o] || {}, Lo), Ga.datetimeFormats = ua.value, clearDateTimeFormat(Ga, _o, Lo)
	}

	function ho(_o) {
		return da.value[_o] || {}
	}

	function Eo(_o, Lo) {
		da.value[_o] = Lo, Ga.numberFormats = da.value, clearNumberFormat(Ga, _o, Lo)
	}

	function wo(_o, Lo) {
		da.value[_o] = assign(da.value[_o] || {}, Lo), Ga.numberFormats = da.value, clearNumberFormat(Ga, _o, Lo)
	}
	composerID++, ea && inBrowser$1 && (watch(ea.locale, _o => {
		oa && (la.value = _o, Ga.locale = _o, updateFallbackLocale(Ga, la.value, sa.value))
	}), watch(ea.fallbackLocale, _o => {
		oa && (sa.value = _o, Ga.fallbackLocale = _o, updateFallbackLocale(Ga, la.value, sa.value))
	}));
	const Ao = {
		id: composerID,
		locale: xa,
		fallbackLocale: ma,
		get inheritLocale() {
			return oa
		},
		set inheritLocale(_o) {
			oa = _o, _o && ea && (la.value = ea.locale.value, sa.value = ea.fallbackLocale.value, updateFallbackLocale(Ga, la.value, sa.value))
		},
		get availableLocales() {
			return Object.keys(ca.value).sort()
		},
		messages: fa,
		get modifiers() {
			return ja
		},
		get pluralRules() {
			return Za || {}
		},
		get isGlobal() {
			return na
		},
		get missingWarn() {
			return ha
		},
		set missingWarn(_o) {
			ha = _o, Ga.missingWarn = ha
		},
		get fallbackWarn() {
			return pa
		},
		set fallbackWarn(_o) {
			pa = _o, Ga.fallbackWarn = pa
		},
		get fallbackRoot() {
			return va
		},
		set fallbackRoot(_o) {
			va = _o
		},
		get fallbackFormat() {
			return ba
		},
		set fallbackFormat(_o) {
			ba = _o, Ga.fallbackFormat = ba
		},
		get warnHtmlMessage() {
			return ka
		},
		set warnHtmlMessage(_o) {
			ka = _o, Ga.warnHtmlMessage = _o
		},
		get escapeParameter() {
			return Pa
		},
		set escapeParameter(_o) {
			Pa = _o, Ga.escapeParameter = _o
		},
		t: ya,
		getLocaleMessage: yo,
		setLocaleMessage: fo,
		mergeLocaleMessage: vo,
		getPostTranslationHandler: Ma,
		setPostTranslationHandler: Aa,
		getMissingHandler: Ra,
		setMissingHandler: Ta,
		[SetPluralRulesSymbol]: Wa
	};
	return Ao.datetimeFormats = ga, Ao.numberFormats = wa, Ao.rt = Ba, Ao.te = qa, Ao.tm = lo, Ao.d = io, Ao.n = oo, Ao.getDateTimeFormat = so, Ao.setDateTimeFormat = Xa, Ao.mergeDateTimeFormat = to, Ao.getNumberFormat = ho, Ao.setNumberFormat = Eo, Ao.mergeNumberFormat = wo, Ao[InejctWithOptionSymbol] = ta, Ao[TranslateVNodeSymbol] = za, Ao[DatetimePartsSymbol] = Va, Ao[NumberPartsSymbol] = ro, Ao
}
const baseFormatProps = {
	tag: {
		type: [String, Object]
	},
	locale: {
		type: String
	},
	scope: {
		type: String,
		validator: ue => ue === "parent" || ue === "global",
		default: "parent"
	},
	i18n: {
		type: Object
	}
};

function getInterpolateArg({
	slots: ue
}, Yi) {
	return Yi.length === 1 && Yi[0] === "default" ? (ue.default ? ue.default() : []).reduce((ta, na) => [...ta, ...na.type === Fragment ? na.children : [na]], []) : Yi.reduce((ea, ta) => {
		const na = ue[ta];
		return na && (ea[ta] = na()), ea
	}, {})
}

function getFragmentableTag(ue) {
	return Fragment
}
const TranslationImpl = defineComponent({
		name: "i18n-t",
		props: assign({
			keypath: {
				type: String,
				required: !0
			},
			plural: {
				type: [Number, String],
				validator: ue => isNumber(ue) || !isNaN(ue)
			}
		}, baseFormatProps),
		setup(ue, Yi) {
			const {
				slots: ea,
				attrs: ta
			} = Yi, na = ue.i18n || useI18n({
				useScope: ue.scope,
				__useComponent: !0
			});
			return () => {
				const ra = Object.keys(ea).filter(ca => ca !== "_"),
					ia = {};
				ue.locale && (ia.locale = ue.locale), ue.plural !== void 0 && (ia.plural = isString$1(ue.plural) ? +ue.plural : ue.plural);
				const aa = getInterpolateArg(Yi, ra),
					oa = na[TranslateVNodeSymbol](ue.keypath, aa, ia),
					la = assign({}, ta),
					sa = isString$1(ue.tag) || isObject(ue.tag) ? ue.tag : getFragmentableTag();
				return h$2(sa, la, oa)
			}
		}
	}),
	Translation = TranslationImpl;

function isVNode(ue) {
	return isArray(ue) && !isString$1(ue[0])
}

function renderFormatter(ue, Yi, ea, ta) {
	const {
		slots: na,
		attrs: ra
	} = Yi;
	return () => {
		const ia = {
			part: !0
		};
		let aa = {};
		ue.locale && (ia.locale = ue.locale), isString$1(ue.format) ? ia.key = ue.format : isObject(ue.format) && (isString$1(ue.format.key) && (ia.key = ue.format.key), aa = Object.keys(ue.format).reduce((ua, da) => ea.includes(da) ? assign({}, ua, {
			[da]: ue.format[da]
		}) : ua, {}));
		const oa = ta(ue.value, ia, aa);
		let la = [ia.key];
		isArray(oa) ? la = oa.map((ua, da) => {
			const ha = na[ua.type],
				pa = ha ? ha({
					[ua.type]: ua.value,
					index: da,
					parts: oa
				}) : [ua.value];
			return isVNode(pa) && (pa[0].key = `${ua.type}-${da}`), pa
		}) : isString$1(oa) && (la = [oa]);
		const sa = assign({}, ra),
			ca = isString$1(ue.tag) || isObject(ue.tag) ? ue.tag : getFragmentableTag();
		return h$2(ca, sa, la)
	}
}
const NumberFormatImpl = defineComponent({
		name: "i18n-n",
		props: assign({
			value: {
				type: Number,
				required: !0
			},
			format: {
				type: [String, Object]
			}
		}, baseFormatProps),
		setup(ue, Yi) {
			const ea = ue.i18n || useI18n({
				useScope: ue.scope,
				__useComponent: !0
			});
			return renderFormatter(ue, Yi, NUMBER_FORMAT_OPTIONS_KEYS, (...ta) => ea[NumberPartsSymbol](...ta))
		}
	}),
	NumberFormat = NumberFormatImpl,
	DatetimeFormatImpl = defineComponent({
		name: "i18n-d",
		props: assign({
			value: {
				type: [Number, Date],
				required: !0
			},
			format: {
				type: [String, Object]
			}
		}, baseFormatProps),
		setup(ue, Yi) {
			const ea = ue.i18n || useI18n({
				useScope: ue.scope,
				__useComponent: !0
			});
			return renderFormatter(ue, Yi, DATETIME_FORMAT_OPTIONS_KEYS, (...ta) => ea[DatetimePartsSymbol](...ta))
		}
	}),
	DatetimeFormat = DatetimeFormatImpl;

function getComposer$2(ue, Yi) {
	const ea = ue;
	if (ue.mode === "composition") return ea.__getInstance(Yi) || ue.global;
	{
		const ta = ea.__getInstance(Yi);
		return ta != null ? ta.__composer : ue.global.__composer
	}
}

function vTDirective(ue) {
	const Yi = ia => {
		const {
			instance: aa,
			modifiers: oa,
			value: la
		} = ia;
		if (!aa || !aa.$) throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
		const sa = getComposer$2(ue, aa.$),
			ca = parseValue(la);
		return [Reflect.apply(sa.t, sa, [...makeParams(ca)]), sa]
	};
	return {
		created: (ia, aa) => {
			const [oa, la] = Yi(aa);
			inBrowser$1 && ue.global === la && (ia.__i18nWatcher = watch(la.locale, () => {
				aa.instance && aa.instance.$forceUpdate()
			})), ia.__composer = la, ia.textContent = oa
		},
		unmounted: ia => {
			inBrowser$1 && ia.__i18nWatcher && (ia.__i18nWatcher(), ia.__i18nWatcher = void 0, delete ia.__i18nWatcher), ia.__composer && (ia.__composer = void 0, delete ia.__composer)
		},
		beforeUpdate: (ia, {
			value: aa
		}) => {
			if (ia.__composer) {
				const oa = ia.__composer,
					la = parseValue(aa);
				ia.textContent = Reflect.apply(oa.t, oa, [...makeParams(la)])
			}
		},
		getSSRProps: ia => {
			const [aa] = Yi(ia);
			return {
				textContent: aa
			}
		}
	}
}

function parseValue(ue) {
	if (isString$1(ue)) return {
		path: ue
	};
	if (isPlainObject$1(ue)) {
		if (!("path" in ue)) throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
		return ue
	} else throw createI18nError(I18nErrorCodes.INVALID_VALUE)
}

function makeParams(ue) {
	const {
		path: Yi,
		locale: ea,
		args: ta,
		choice: na,
		plural: ra
	} = ue, ia = {}, aa = ta || {};
	return isString$1(ea) && (ia.locale = ea), isNumber(na) && (ia.plural = na), isNumber(ra) && (ia.plural = ra), [Yi, aa, ia]
}

function apply(ue, Yi, ...ea) {
	const ta = isPlainObject$1(ea[0]) ? ea[0] : {},
		na = !!ta.useI18nComponentName;
	(isBoolean(ta.globalInstall) ? ta.globalInstall : !0) && ([na ? "i18n" : Translation.name, "I18nT"].forEach(ia => ue.component(ia, Translation)), [NumberFormat.name, "I18nN"].forEach(ia => ue.component(ia, NumberFormat)), [DatetimeFormat.name, "I18nD"].forEach(ia => ue.component(ia, DatetimeFormat))), ue.directive("t", vTDirective(Yi))
}
const I18nInjectionKey = makeSymbol("global-vue-i18n");

function createI18n(ue = {}, Yi) {
	const ea = isBoolean(ue.globalInjection) ? ue.globalInjection : !0,
		ta = !0,
		na = new Map,
		[ra, ia] = createGlobal(ue),
		aa = makeSymbol("");

	function oa(ca) {
		return na.get(ca) || null
	}

	function la(ca, ua) {
		na.set(ca, ua)
	}

	function sa(ca) {
		na.delete(ca)
	} {
		const ca = {
			get mode() {
				return "composition"
			},
			get allowComposition() {
				return ta
			},
			async install(ua, ...da) {
				if (ua.__VUE_I18N_SYMBOL__ = aa, ua.provide(ua.__VUE_I18N_SYMBOL__, ca), isPlainObject$1(da[0])) {
					const va = da[0];
					ca.__composerExtend = va.__composerExtend, ca.__vueI18nExtend = va.__vueI18nExtend
				}
				let ha = null;
				ea && (ha = injectGlobalFields(ua, ca.global)), apply(ua, ca, ...da);
				const pa = ua.unmount;
				ua.unmount = () => {
					ha && ha(), ca.dispose(), pa()
				}
			},
			get global() {
				return ia
			},
			dispose() {
				ra.stop()
			},
			__instances: na,
			__getInstance: oa,
			__setInstance: la,
			__deleteInstance: sa
		};
		return ca
	}
}

function useI18n(ue = {}) {
	const Yi = getCurrentInstance();
	if (Yi == null) throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
	if (!Yi.isCE && Yi.appContext.app != null && !Yi.appContext.app.__VUE_I18N_SYMBOL__) throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
	const ea = getI18nInstance(Yi),
		ta = getGlobalComposer(ea),
		na = getComponentOptions(Yi),
		ra = getScope(ue, na);
	if (ra === "global") return adjustI18nResources(ta, ue, na), ta;
	if (ra === "parent") {
		let oa = getComposer(ea, Yi, ue.__useComponent);
		return oa == null && (oa = ta), oa
	}
	const ia = ea;
	let aa = ia.__getInstance(Yi);
	if (aa == null) {
		const oa = assign({}, ue);
		"__i18n" in na && (oa.__i18n = na.__i18n), ta && (oa.__root = ta), aa = createComposer(oa), ia.__composerExtend && (aa[DisposeSymbol] = ia.__composerExtend(aa)), setupLifeCycle(ia, Yi, aa), ia.__setInstance(Yi, aa)
	}
	return aa
}

function createGlobal(ue, Yi, ea) {
	const ta = effectScope();
	{
		const na = ta.run(() => createComposer(ue));
		if (na == null) throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
		return [ta, na]
	}
}

function getI18nInstance(ue) {
	{
		const Yi = inject(ue.isCE ? I18nInjectionKey : ue.appContext.app.__VUE_I18N_SYMBOL__);
		if (!Yi) throw createI18nError(ue.isCE ? I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE : I18nErrorCodes.UNEXPECTED_ERROR);
		return Yi
	}
}

function getScope(ue, Yi) {
	return isEmptyObject(ue) ? "__i18n" in Yi ? "local" : "global" : ue.useScope ? ue.useScope : "local"
}

function getGlobalComposer(ue) {
	return ue.mode === "composition" ? ue.global : ue.global.__composer
}

function getComposer(ue, Yi, ea = !1) {
	let ta = null;
	const na = Yi.root;
	let ra = getParentComponentInstance(Yi, ea);
	for (; ra != null;) {
		const ia = ue;
		if (ue.mode === "composition" && (ta = ia.__getInstance(ra)), ta != null || na === ra) break;
		ra = ra.parent
	}
	return ta
}

function getParentComponentInstance(ue, Yi = !1) {
	return ue == null ? null : Yi && ue.vnode.ctx || ue.parent
}

function setupLifeCycle(ue, Yi, ea) {
	onMounted(() => {}, Yi), onUnmounted(() => {
		const ta = ea;
		ue.__deleteInstance(Yi);
		const na = ta[DisposeSymbol];
		na && (na(), delete ta[DisposeSymbol])
	}, Yi)
}
const globalExportProps = ["locale", "fallbackLocale", "availableLocales"],
	globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];

function injectGlobalFields(ue, Yi) {
	const ea = Object.create(null);
	return globalExportProps.forEach(na => {
		const ra = Object.getOwnPropertyDescriptor(Yi, na);
		if (!ra) throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
		const ia = isRef(ra.value) ? {
			get() {
				return ra.value.value
			},
			set(aa) {
				ra.value.value = aa
			}
		} : {
			get() {
				return ra.get && ra.get()
			}
		};
		Object.defineProperty(ea, na, ia)
	}), ue.config.globalProperties.$i18n = ea, globalExportMethods.forEach(na => {
		const ra = Object.getOwnPropertyDescriptor(Yi, na);
		if (!ra || !ra.value) throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
		Object.defineProperty(ue.config.globalProperties, `$${na}`, ra)
	}), () => {
		delete ue.config.globalProperties.$i18n, globalExportMethods.forEach(na => {
			delete ue.config.globalProperties[`$${na}`]
		})
	}
}
initFeatureFlags();
registerMessageCompiler(compile);
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
if (__INTLIFY_PROD_DEVTOOLS__) {
	const ue = getGlobalThis();
	ue.__INTLIFY__ = !0, setDevToolsHook(ue.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__)
}

function useSwitchLocalePath() {
	return wrapComposable(switchLocalePath)
}
const switch_locale_path_ssr_5csfIgkrBP = defineNuxtPlugin({
	name: "i18n:plugin:switch-locale-path-ssr",
	dependsOn: ["i18n:plugin"],
	setup(ue) {
		if (ue.$config.public.i18n.experimental.switchLocalePathLinkSSR !== !0) return;
		const Yi = useSwitchLocalePath(),
			ea = new RegExp([`<!--${SWITCH_LOCALE_PATH_LINK_IDENTIFIER}-\\[(\\w+)\\]-->`, ".+?", `<!--/${SWITCH_LOCALE_PATH_LINK_IDENTIFIER}-->`].join(""), "g");
		ue.hook("app:rendered", ta => {
			var na;
			((na = ta.renderResult) == null ? void 0 : na.html) != null && (ta.renderResult.html = ta.renderResult.html.replaceAll(ea, (ra, ia) => ra.replace(/href="([^"]+)"/, `href="${encodeURI(Yi(ia??""))}"`)))
		})
	}
});

function extendI18n(ue, {
	locales: Yi = [],
	localeCodes: ea = [],
	baseUrl: ta = "",
	hooks: na = {},
	context: ra = {}
} = {}) {
	const ia = effectScope(),
		aa = ue.install;
	return ue.install = (oa, ...la) => {
		const sa = isPluginOptions(la[0]) ? assign({}, la[0]) : {
			inject: !0
		};
		sa.inject == null && (sa.inject = !0);
		const ca = sa.__composerExtend;
		if (sa.__composerExtend = pa => {
				const va = getComposer$1(ue);
				pa.locales = computed(() => va.locales.value), pa.localeCodes = computed(() => va.localeCodes.value), pa.baseUrl = computed(() => va.baseUrl.value);
				let ba;
				return isFunction(ca) && (ba = Reflect.apply(ca, sa, [pa])), () => {
					ba && ba()
				}
			}, ue.mode === "legacy") {
			const pa = sa.__vueI18nExtend;
			sa.__vueI18nExtend = va => {
				extendVueI18n(va, na.onExtendVueI18n);
				let ba;
				return isFunction(pa) && (ba = Reflect.apply(pa, sa, [va])), () => {
					ba && ba()
				}
			}
		}
		la[0] = sa, Reflect.apply(aa, ue, [oa, ...la]);
		const ua = getComposer$1(ue);
		ia.run(() => {
			extendComposer(ua, {
				locales: Yi,
				localeCodes: ea,
				baseUrl: ta,
				hooks: na,
				context: ra
			}), ue.mode === "legacy" && isVueI18n(ue.global) && extendVueI18n(ue.global, na.onExtendVueI18n)
		});
		const da = oa,
			ha = ue.mode === "composition" ? da.config.globalProperties.$i18n : null;
		if (ha && extendExportedGlobal(ha, ua, na.onExtendExportedGlobal), sa.inject) {
			const pa = initCommonComposableOptions(ue);
			oa.mixin({
				methods: {
					getRouteBaseName: wrapComposable(getRouteBaseName, pa),
					resolveRoute: wrapComposable(resolveRoute, pa),
					localePath: wrapComposable(localePath, pa),
					localeRoute: wrapComposable(localeRoute, pa),
					localeLocation: wrapComposable(localeLocation, pa),
					switchLocalePath: wrapComposable(switchLocalePath, pa),
					localeHead: wrapComposable(localeHead, pa)
				}
			})
		}
		if (da.unmount) {
			const pa = da.unmount;
			da.unmount = () => {
				ia.stop(), pa()
			}
		}
	}, ia
}

function extendComposer(ue, Yi) {
	const {
		locales: ea,
		localeCodes: ta,
		baseUrl: na,
		context: ra
	} = Yi, ia = ref$1(ea), aa = ref$1(ta), oa = ref$1("");
	ue.locales = computed(() => ia.value), ue.localeCodes = computed(() => aa.value), ue.baseUrl = computed(() => oa.value), inBrowser ? watch(ue.locale, () => {
		oa.value = resolveBaseUrl(na, ra)
	}, {
		immediate: !0
	}) : oa.value = resolveBaseUrl(na, ra), Yi.hooks && Yi.hooks.onExtendComposer && Yi.hooks.onExtendComposer(ue)
}

function extendPropertyDescriptors(ue, Yi, ea) {
	const ta = [{
		locales: {
			get() {
				return ue.locales.value
			}
		},
		localeCodes: {
			get() {
				return ue.localeCodes.value
			}
		},
		baseUrl: {
			get() {
				return ue.baseUrl.value
			}
		}
	}];
	ea && ta.push(ea(ue));
	for (const na of ta)
		for (const [ra, ia] of Object.entries(na)) Object.defineProperty(Yi, ra, ia)
}

function extendExportedGlobal(ue, Yi, ea) {
	extendPropertyDescriptors(Yi, ue, ea)
}

function extendVueI18n(ue, Yi) {
	const ea = getComposer$1(ue);
	extendPropertyDescriptors(ea, ue, Yi)
}

function isPluginOptions(ue) {
	return isObject(ue) && ("inject" in ue || "__composerExtend" in ue || "__vueI18nExtend" in ue)
}
const i18n_sq1MuCrqbC = defineNuxtPlugin({
	name: "i18n:plugin",
	parallel: parallelPlugin,
	async setup(ue) {
		let Yi, ea;
		const ta = useRoute(),
			{
				vueApp: na
			} = ue,
			ra = ue,
			ia = getHost(),
			{
				configLocales: aa,
				defaultLocale: oa,
				multiDomainLocales: la,
				strategy: sa
			} = ra.$config.public.i18n,
			ca = aa.some(Ga => typeof Ga != "string" && Array.isArray(Ga.defaultForDomains));
		let ua;
		if (oa) ua = oa;
		else if (ca) {
			const Ga = aa.find(Ja => typeof Ja == "string" || !Array.isArray(Ja.defaultForDomains) ? !1 : Ja.defaultForDomains.includes(ia ?? ""));
			ua = (Ga == null ? void 0 : Ga.code) ?? ""
		} else ua = "";
		if (la && (sa === "prefix_except_default" || sa === "prefix_and_default")) {
			const Ga = useRouter();
			Ga.getRoutes().forEach(Ja => {
				var Ua;
				if ((Ua = Ja.name) != null && Ua.toString().includes("___default"))
					if (Ja.name.toString().split("___")[1] !== ua) Ga.removeRoute(Ja.name);
					else {
						const ma = Ja.name.toString().replace("___default", "");
						Ja.name = ma
					}
			})
		}
		const da = {
			...ra.$config.public.i18n,
			defaultLocale: ua
		};
		da.baseUrl = extendBaseUrl();
		const ha = runtimeDetectBrowserLanguage(),
			pa = ([Yi, ea] = executeAsync(() => loadVueI18nOptions(vueI18nConfigs, useNuxtApp())), Yi = await Yi, ea(), Yi);
		pa.messages = pa.messages || {}, pa.fallbackLocale = pa.fallbackLocale ?? !1;
		const va = createLocaleFromRouteGetter(),
			ba = Ga => Ga || pa.locale || "en-US",
			Ea = getI18nCookie();
		let Sa = detectLocale(ta, va, ba(da.defaultLocale), {
			ssg: "normal",
			callType: "setup",
			firstAccess: !0,
			localeCookie: getLocaleCookie(Ea, ha, da.defaultLocale)
		}, da);
		pa.messages = ([Yi, ea] = executeAsync(() => loadInitialMessages(pa.messages, localeLoaders, {
			localeCodes,
			initialLocale: Sa,
			lazy: da.lazy,
			defaultLocale: da.defaultLocale,
			fallbackLocale: pa.fallbackLocale
		})), Yi = await Yi, ea(), Yi), Sa = ba(Sa);
		const Ca = createI18n({
			...pa,
			locale: Sa
		});
		let ka = !0;
		const Pa = Ga => Sa !== Ga && ka;
		extendI18n(Ca, {
			locales: da.configLocales,
			localeCodes,
			baseUrl: da.baseUrl,
			context: ra,
			hooks: {
				onExtendComposer(Ga) {
					Ga.strategy = da.strategy, Ga.localeProperties = computed(() => normalizedLocales.find(Ja => Ja.code === Ga.locale.value) || {
						code: Ga.locale.value
					}), Ga.setLocale = async Ja => {
						const Ua = Pa(Ja);
						await loadAndSetLocale(Ja, Ca, da, Ua) && Ua && (ka = !1);
						const ma = await ra.runWithContext(() => detectRedirect({
							route: {
								to: ta
							},
							targetLocale: Ja,
							routeLocaleGetter: va
						}));
						await ra.runWithContext(async () => await navigate({
							nuxtApp: ra,
							i18n: Ca,
							redirectPath: ma,
							locale: Ja,
							route: ta
						}, {
							enableNavigate: !0
						}))
					}, Ga.loadLocaleMessages = async Ja => {
						await loadLocale(Ja, localeLoaders, (xa, ma) => mergeLocaleMessage(Ca, xa, ma))
					}, Ga.differentDomains = da.differentDomains, Ga.defaultLocale = da.defaultLocale, Ga.getBrowserLocale = () => getBrowserLocale(), Ga.getLocaleCookie = () => getLocaleCookie(Ea, ha, da.defaultLocale), Ga.setLocaleCookie = Ja => setLocaleCookie(Ea, Ja, ha), Ga.onBeforeLanguageSwitch = (Ja, Ua, xa, ma) => ue.callHook("i18n:beforeLocaleSwitch", {
						oldLocale: Ja,
						newLocale: Ua,
						initialSetup: xa,
						context: ma
					}), Ga.onLanguageSwitched = (Ja, Ua) => ue.callHook("i18n:localeSwitched", {
						oldLocale: Ja,
						newLocale: Ua
					}), Ga.finalizePendingLocaleChange = async () => {
						Ca.__pendingLocale && (setLocale(Ca, Ca.__pendingLocale), Ca.__resolvePendingLocalePromise && await Ca.__resolvePendingLocalePromise(), Ca.__pendingLocale = void 0)
					}, Ga.waitForPendingLocaleChange = async () => {
						Ca.__pendingLocale && Ca.__pendingLocalePromise && await Ca.__pendingLocalePromise
					}
				},
				onExtendExportedGlobal(Ga) {
					return {
						strategy: {
							get() {
								return Ga.strategy
							}
						},
						localeProperties: {
							get() {
								return Ga.localeProperties.value
							}
						},
						setLocale: {
							get() {
								return async Ja => Reflect.apply(Ga.setLocale, Ga, [Ja])
							}
						},
						differentDomains: {
							get() {
								return Ga.differentDomains
							}
						},
						defaultLocale: {
							get() {
								return Ga.defaultLocale
							}
						},
						getBrowserLocale: {
							get() {
								return () => Reflect.apply(Ga.getBrowserLocale, Ga, [])
							}
						},
						getLocaleCookie: {
							get() {
								return () => Reflect.apply(Ga.getLocaleCookie, Ga, [])
							}
						},
						setLocaleCookie: {
							get() {
								return Ja => Reflect.apply(Ga.setLocaleCookie, Ga, [Ja])
							}
						},
						onBeforeLanguageSwitch: {
							get() {
								return (Ja, Ua, xa, ma) => Reflect.apply(Ga.onBeforeLanguageSwitch, Ga, [Ja, Ua, xa, ma])
							}
						},
						onLanguageSwitched: {
							get() {
								return (Ja, Ua) => Reflect.apply(Ga.onLanguageSwitched, Ga, [Ja, Ua])
							}
						},
						finalizePendingLocaleChange: {
							get() {
								return () => Reflect.apply(Ga.finalizePendingLocaleChange, Ga, [])
							}
						},
						waitForPendingLocaleChange: {
							get() {
								return () => Reflect.apply(Ga.waitForPendingLocaleChange, Ga, [])
							}
						}
					}
				},
				onExtendVueI18n(Ga) {
					return {
						strategy: {
							get() {
								return Ga.strategy
							}
						},
						localeProperties: {
							get() {
								return Ga.localeProperties.value
							}
						},
						setLocale: {
							get() {
								return async Ja => Reflect.apply(Ga.setLocale, Ga, [Ja])
							}
						},
						loadLocaleMessages: {
							get() {
								return async Ja => Reflect.apply(Ga.loadLocaleMessages, Ga, [Ja])
							}
						},
						differentDomains: {
							get() {
								return Ga.differentDomains
							}
						},
						defaultLocale: {
							get() {
								return Ga.defaultLocale
							}
						},
						getBrowserLocale: {
							get() {
								return () => Reflect.apply(Ga.getBrowserLocale, Ga, [])
							}
						},
						getLocaleCookie: {
							get() {
								return () => Reflect.apply(Ga.getLocaleCookie, Ga, [])
							}
						},
						setLocaleCookie: {
							get() {
								return Ja => Reflect.apply(Ga.setLocaleCookie, Ga, [Ja])
							}
						},
						onBeforeLanguageSwitch: {
							get() {
								return (Ja, Ua, xa, ma) => Reflect.apply(Ga.onBeforeLanguageSwitch, Ga, [Ja, Ua, xa, ma])
							}
						},
						onLanguageSwitched: {
							get() {
								return (Ja, Ua) => Reflect.apply(Ga.onLanguageSwitched, Ga, [Ja, Ua])
							}
						},
						finalizePendingLocaleChange: {
							get() {
								return () => Reflect.apply(Ga.finalizePendingLocaleChange, Ga, [])
							}
						},
						waitForPendingLocaleChange: {
							get() {
								return () => Reflect.apply(Ga.waitForPendingLocaleChange, Ga, [])
							}
						}
					}
				}
			}
		});
		const ja = {
			__composerExtend: Ga => {
				const Ja = getComposer$1(Ca);
				return Ga.strategy = Ja.strategy, Ga.localeProperties = computed(() => Ja.localeProperties.value), Ga.setLocale = Ja.setLocale, Ga.differentDomains = Ja.differentDomains, Ga.getBrowserLocale = Ja.getBrowserLocale, Ga.getLocaleCookie = Ja.getLocaleCookie, Ga.setLocaleCookie = Ja.setLocaleCookie, Ga.onBeforeLanguageSwitch = Ja.onBeforeLanguageSwitch, Ga.onLanguageSwitched = Ja.onLanguageSwitched, Ga.finalizePendingLocaleChange = Ja.finalizePendingLocaleChange, Ga.waitForPendingLocaleChange = Ja.waitForPendingLocaleChange, () => {}
			}
		};
		na.use(Ca, ja), injectNuxtHelpers(ra, Ca);
		let Za = 0;
		addRouteMiddleware("locale-changing", async (Ga, Ja) => {
			let Ua, xa;
			const ma = detectLocale(Ga, va, () => getLocale$1(Ca) || ba(da.defaultLocale), {
					ssg: "normal",
					callType: "routing",
					firstAccess: Za === 0,
					localeCookie: getLocaleCookie(Ea, ha, da.defaultLocale)
				}, da),
				fa = Pa(ma);
			([Ua, xa] = executeAsync(() => loadAndSetLocale(ma, Ca, da, fa)), Ua = await Ua, xa(), Ua) && fa && (ka = !1);
			const wa = ([Ua, xa] = executeAsync(() => ra.runWithContext(() => detectRedirect({
				route: {
					to: Ga,
					from: Ja
				},
				targetLocale: ma,
				routeLocaleGetter: da.strategy === "no_prefix" ? () => ma : va,
				calledWithRouting: !0
			}))), Ua = await Ua, xa(), Ua);
			return Za++, [Ua, xa] = executeAsync(() => ra.runWithContext(async () => navigate({
				nuxtApp: ra,
				i18n: Ca,
				redirectPath: wa,
				locale: ma,
				route: Ga
			}))), Ua = await Ua, xa(), Ua
		}, {
			global: !0
		})
	}
});
async function preloadRouteComponents(ue, Yi = useRouter()) {
	const {
		path: ea,
		matched: ta
	} = Yi.resolve(ue);
	if (!ta.length || (Yi._routePreloaded || (Yi._routePreloaded = new Set), Yi._routePreloaded.has(ea))) return;
	const na = Yi._preloadPromises = Yi._preloadPromises || [];
	if (na.length > 4) return Promise.all(na).then(() => preloadRouteComponents(ue, Yi));
	Yi._routePreloaded.add(ea);
	const ra = ta.map(ia => {
		var aa;
		return (aa = ia.components) == null ? void 0 : aa.default
	}).filter(ia => typeof ia == "function");
	for (const ia of ra) {
		const aa = Promise.resolve(ia()).catch(() => {}).finally(() => na.splice(na.indexOf(aa)));
		na.push(aa)
	}
	await Promise.all(na)
}
const firstNonUndefined = (...ue) => ue.find(Yi => Yi !== void 0);

function defineNuxtLink(ue) {
	const Yi = ue.componentName || "NuxtLink";

	function ea(na, ra) {
		if (!na || ue.trailingSlash !== "append" && ue.trailingSlash !== "remove") return na;
		if (typeof na == "string") return applyTrailingSlashBehavior(na, ue.trailingSlash);
		const ia = "path" in na && na.path !== void 0 ? na.path : ra(na).path;
		return {
			...na,
			name: void 0,
			path: applyTrailingSlashBehavior(ia, ue.trailingSlash)
		}
	}

	function ta(na) {
		const ra = useRouter(),
			ia = useRuntimeConfig(),
			aa = computed(() => !!na.target && na.target !== "_self"),
			oa = computed(() => {
				const pa = na.to || na.href || "";
				return typeof pa == "string" && hasProtocol(pa, {
					acceptRelative: !0
				})
			}),
			la = resolveComponent("RouterLink"),
			sa = la && typeof la != "string" ? la.useLink : void 0,
			ca = computed(() => {
				if (na.external) return !0;
				const pa = na.to || na.href || "";
				return typeof pa == "object" ? !1 : pa === "" || oa.value
			}),
			ua = computed(() => {
				const pa = na.to || na.href || "";
				return ca.value ? pa : ea(pa, ra.resolve)
			}),
			da = ca.value || sa == null ? void 0 : sa({
				...na,
				to: ua
			}),
			ha = computed(() => {
				var pa;
				if (!ua.value || oa.value) return ua.value;
				if (ca.value) {
					const va = typeof ua.value == "object" && "path" in ua.value ? resolveRouteObject(ua.value) : ua.value,
						ba = typeof va == "object" ? ra.resolve(va).href : va;
					return ea(ba, ra.resolve)
				}
				return typeof ua.value == "object" ? ((pa = ra.resolve(ua.value)) == null ? void 0 : pa.href) ?? null : ea(joinURL(ia.app.baseURL, ua.value), ra.resolve)
			});
		return {
			to: ua,
			hasTarget: aa,
			isAbsoluteUrl: oa,
			isExternal: ca,
			href: ha,
			isActive: (da == null ? void 0 : da.isActive) ?? computed(() => ua.value === ra.currentRoute.value.path),
			isExactActive: (da == null ? void 0 : da.isExactActive) ?? computed(() => ua.value === ra.currentRoute.value.path),
			route: (da == null ? void 0 : da.route) ?? computed(() => ra.resolve(ua.value)),
			async navigate() {
				await navigateTo(ha.value, {
					replace: na.replace,
					external: ca.value || aa.value
				})
			}
		}
	}
	return defineComponent({
		name: Yi,
		props: {
			to: {
				type: [String, Object],
				default: void 0,
				required: !1
			},
			href: {
				type: [String, Object],
				default: void 0,
				required: !1
			},
			target: {
				type: String,
				default: void 0,
				required: !1
			},
			rel: {
				type: String,
				default: void 0,
				required: !1
			},
			noRel: {
				type: Boolean,
				default: void 0,
				required: !1
			},
			prefetch: {
				type: Boolean,
				default: void 0,
				required: !1
			},
			prefetchOn: {
				type: [String, Object],
				default: void 0,
				required: !1
			},
			noPrefetch: {
				type: Boolean,
				default: void 0,
				required: !1
			},
			activeClass: {
				type: String,
				default: void 0,
				required: !1
			},
			exactActiveClass: {
				type: String,
				default: void 0,
				required: !1
			},
			prefetchedClass: {
				type: String,
				default: void 0,
				required: !1
			},
			replace: {
				type: Boolean,
				default: void 0,
				required: !1
			},
			ariaCurrentValue: {
				type: String,
				default: void 0,
				required: !1
			},
			external: {
				type: Boolean,
				default: void 0,
				required: !1
			},
			custom: {
				type: Boolean,
				default: void 0,
				required: !1
			}
		},
		useLink: ta,
		setup(na, {
			slots: ra
		}) {
			const ia = useRouter(),
				{
					to: aa,
					href: oa,
					navigate: la,
					isExternal: sa,
					hasTarget: ca,
					isAbsoluteUrl: ua
				} = ta(na),
				da = ref$1(!1),
				ha = ref$1(null),
				pa = Ea => {
					var Sa;
					ha.value = na.custom ? (Sa = Ea == null ? void 0 : Ea.$el) == null ? void 0 : Sa.nextElementSibling : Ea == null ? void 0 : Ea.$el
				};

			function va(Ea) {
				var Sa, Ca;
				return !da.value && (typeof na.prefetchOn == "string" ? na.prefetchOn === Ea : ((Sa = na.prefetchOn) == null ? void 0 : Sa[Ea]) ?? ((Ca = ue.prefetchOn) == null ? void 0 : Ca[Ea])) && (na.prefetch ?? ue.prefetch) !== !1 && na.noPrefetch !== !0 && na.target !== "_blank" && !isSlowConnection()
			}
			async function ba(Ea = useNuxtApp()) {
				if (da.value) return;
				da.value = !0;
				const Sa = typeof aa.value == "string" ? aa.value : sa.value ? resolveRouteObject(aa.value) : ia.resolve(aa.value).fullPath;
				await Promise.all([Ea.hooks.callHook("link:prefetch", Sa).catch(() => {}), !sa.value && !ca.value && preloadRouteComponents(aa.value, ia).catch(() => {})])
			}
			if (va("visibility")) {
				const Ea = useNuxtApp();
				let Sa, Ca = null;
				onMounted(() => {
					const ka = useObserver();
					onNuxtReady(() => {
						Sa = requestIdleCallback(() => {
							var Pa;
							(Pa = ha == null ? void 0 : ha.value) != null && Pa.tagName && (Ca = ka.observe(ha.value, async () => {
								Ca == null || Ca(), Ca = null, await ba(Ea)
							}))
						})
					})
				}), onBeforeUnmount(() => {
					Sa && cancelIdleCallback(Sa), Ca == null || Ca(), Ca = null
				})
			}
			return () => {
				var Ca;
				if (!sa.value && !ca.value) {
					const ka = {
						ref: pa,
						to: aa.value,
						activeClass: na.activeClass || ue.activeClass,
						exactActiveClass: na.exactActiveClass || ue.exactActiveClass,
						replace: na.replace,
						ariaCurrentValue: na.ariaCurrentValue,
						custom: na.custom
					};
					return na.custom || (va("interaction") && (ka.onPointerenter = ba.bind(null, void 0), ka.onFocus = ba.bind(null, void 0)), da.value && (ka.class = na.prefetchedClass || ue.prefetchedClass), ka.rel = na.rel || void 0), h$2(resolveComponent("RouterLink"), ka, ra.default)
				}
				const Ea = na.target || null,
					Sa = firstNonUndefined(na.noRel ? "" : na.rel, ue.externalRelAttribute, ua.value || ca.value ? "noopener noreferrer" : "") || null;
				return na.custom ? ra.default ? ra.default({
					href: oa.value,
					navigate: la,
					prefetch: ba,
					get route() {
						if (!oa.value) return;
						const ka = new URL(oa.value, window.location.href);
						return {
							path: ka.pathname,
							fullPath: ka.pathname,
							get query() {
								return parseQuery$1(ka.search)
							},
							hash: ka.hash,
							params: {},
							name: void 0,
							matched: [],
							redirectedFrom: void 0,
							meta: {},
							href: oa.value
						}
					},
					rel: Sa,
					target: Ea,
					isExternal: sa.value || ca.value,
					isActive: !1,
					isExactActive: !1
				}) : null : h$2("a", {
					ref: ha,
					href: oa.value || null,
					rel: Sa,
					target: Ea
				}, (Ca = ra.default) == null ? void 0 : Ca.call(ra))
			}
		}
	})
}
const __nuxt_component_0$1 = defineNuxtLink(nuxtLinkDefaults);

function applyTrailingSlashBehavior(ue, Yi) {
	const ea = Yi === "append" ? withTrailingSlash : withoutTrailingSlash;
	return hasProtocol(ue) && !ue.startsWith("http") ? ue : ea(ue, !0)
}

function useObserver() {
	const ue = useNuxtApp();
	if (ue._observer) return ue._observer;
	let Yi = null;
	const ea = new Map,
		ta = (ra, ia) => (Yi || (Yi = new IntersectionObserver(aa => {
			for (const oa of aa) {
				const la = ea.get(oa.target);
				(oa.isIntersecting || oa.intersectionRatio > 0) && la && la()
			}
		})), ea.set(ra, ia), Yi.observe(ra), () => {
			ea.delete(ra), Yi.unobserve(ra), ea.size === 0 && (Yi.disconnect(), Yi = null)
		});
	return ue._observer = {
		observe: ta
	}
}

function isSlowConnection() {
	const ue = navigator.connection;
	return !!(ue && (ue.saveData || /2g/.test(ue.effectiveType)))
}
const plugin_client_UYiXMU8ZyN = defineNuxtPlugin({
	parallel: !0,
	setup() {
		const ue = useRuntimeConfig().public.gtag,
			Yi = resolveTags(ue);
		if (!Yi.length || (initGtag({
				tags: Yi
			}), ue.initMode === "manual")) return;
		const ea = ue.loadingStrategy === "async" ? "async" : "defer";
		useHead({
			script: [{
				src: withQuery(ue.url, {
					id: Yi[0].id
				}),
				[ea]: !0,
				"data-gtag": ""
			}]
		})
	}
});
(function(ue, Yi) {
	"defineProperty" in Object && function() {
		try {
			var Ia = {};
			return Object.defineProperty(Ia, "test", {
				value: 42
			}), !0
		} catch {
			return !1
		}
	}() || function(Ia) {
		var Na = Object.prototype.hasOwnProperty.call(Object.prototype, "__defineGetter__"),
			za = "A property cannot both have accessors and be writable or have a value";
		Object.defineProperty = function(Va, Wa, qa) {
			if (Ia && (Va === window || Va === document || Va === Element.prototype || Va instanceof Element)) return Ia(Va, Wa, qa);
			if (Va === null || !(Va instanceof Object || typeof Va == "object")) throw new TypeError("Object.defineProperty called on non-object");
			if (!(qa instanceof Object)) throw new TypeError("Property description must be an object");
			var Ka = String(Wa),
				lo = "value" in qa || "writable" in qa,
				yo = "get" in qa && typeof qa.get,
				fo = "set" in qa && typeof qa.set;
			if (yo) {
				if (yo === Yi) return Va;
				if (yo !== "function") throw new TypeError("Getter must be a function");
				if (!Na) throw new TypeError("Getters & setters cannot be defined on this javascript engine");
				if (lo) throw new TypeError(za);
				Object.__defineGetter__.call(Va, Ka, qa.get)
			} else Va[Ka] = qa.value;
			if (fo) {
				if (fo === Yi) return Va;
				if (fo !== "function") throw new TypeError("Setter must be a function");
				if (!Na) throw new TypeError("Getters & setters cannot be defined on this javascript engine");
				if (lo) throw new TypeError(za);
				Object.__defineSetter__.call(Va, Ka, qa.set)
			}
			return "value" in qa && (Va[Ka] = qa.value), Va
		}
	}(Object.defineProperty);

	function ea(Ia) {
		if (1 / Ia == -1 / 0 && (Ia = 0), Ia > Math.pow(2, 32) - 1) throw new RangeError("Invalid array length");
		var Na = [];
		return Na.length = Ia, Na
	}

	function ta(Ia, Na) {
		var za = arguments.length > 2 ? arguments[2] : [];
		if (ca(Ia) === !1) throw new TypeError(Object.prototype.toString.call(Ia) + "is not a function.");
		return Ia.apply(Na, za)
	}

	function na(Ia, Na, za) {
		var ro = {
			value: za,
			writable: !0,
			enumerable: !0,
			configurable: !0
		};
		try {
			return Object.defineProperty(Ia, Na, ro), !0
		} catch {
			return !1
		}
	}

	function ra(Ia, Na, za) {
		var ro = na(Ia, Na, za);
		if (!ro) throw new TypeError("Cannot assign value `" + Object.prototype.toString.call(za) + "` to property `" + Object.prototype.toString.call(Na) + "` on object `" + Object.prototype.toString.call(Ia) + "`");
		return ro
	}

	function ia(Ia, Na, za) {
		var ro = {
			value: za,
			writable: !0,
			enumerable: !1,
			configurable: !0
		};
		Object.defineProperty(Ia, Na, ro)
	}
	"freeze" in Object || ia(Object, "freeze", function(Na) {
		return Na
	}), "getPrototypeOf" in Object || ia(Object, "getPrototypeOf", function(Na) {
		if (Na !== Object(Na)) throw new TypeError("Object.getPrototypeOf called on non-object");
		var za = Na.__proto__;
		return za || za === null ? za : typeof Na.constructor == "function" && Na instanceof Na.constructor ? Na.constructor.prototype : Na instanceof Object ? Object.prototype : null
	}), "keys" in Object && function() {
		return Object.keys(arguments).length === 2
	}(1, 2) && function() {
		try {
			return Object.keys(""), !0
		} catch {
			return !1
		}
	}() || ia(Object, "keys", function() {
		function Ia() {
			var so;
			try {
				so = Object.create({})
			} catch {
				return !0
			}
			return Va.call(so, "__proto__")
		}

		function Na(so) {
			var Xa = ro.call(so),
				to = Xa === "[object Arguments]";
			return to || (to = Xa !== "[object Array]" && so !== null && typeof so == "object" && typeof so.length == "number" && so.length >= 0 && ro.call(so.callee) === "[object Function]"), to
		}
		var za = Object.prototype.hasOwnProperty,
			ro = Object.prototype.toString,
			Va = Object.prototype.propertyIsEnumerable,
			Wa = !Va.call({
				toString: null
			}, "toString"),
			qa = Va.call(function() {}, "prototype"),
			Ka = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
			lo = function(so) {
				var Xa = so.constructor;
				return Xa && Xa.prototype === so
			},
			yo = {
				$console: !0,
				$external: !0,
				$frame: !0,
				$frameElement: !0,
				$frames: !0,
				$innerHeight: !0,
				$innerWidth: !0,
				$outerHeight: !0,
				$outerWidth: !0,
				$pageXOffset: !0,
				$pageYOffset: !0,
				$parent: !0,
				$scrollLeft: !0,
				$scrollTop: !0,
				$scrollX: !0,
				$scrollY: !0,
				$self: !0,
				$webkitIndexedDB: !0,
				$webkitStorageInfo: !0,
				$window: !0
			},
			fo = function() {
				if (typeof window > "u") return !1;
				for (var so in window) try {
					if (!yo["$" + so] && za.call(window, so) && window[so] !== null && typeof window[so] == "object") try {
						lo(window[so])
					} catch {
						return !0
					}
				} catch {
					return !0
				}
				return !1
			}(),
			vo = function(so) {
				if (typeof window > "u" || !fo) return lo(so);
				try {
					return lo(so)
				} catch {
					return !1
				}
			};
		return function(Xa) {
			var to = ro.call(Xa) === "[object Function]",
				ho = Na(Xa),
				Eo = ro.call(Xa) === "[object String]",
				wo = [];
			if (Xa === Yi || Xa === null) throw new TypeError("Cannot convert undefined or null to object");
			var Ao = qa && to;
			if (Eo && Xa.length > 0 && !za.call(Xa, 0))
				for (var _o = 0; _o < Xa.length; ++_o) wo.push(String(_o));
			if (ho && Xa.length > 0)
				for (var Lo = 0; Lo < Xa.length; ++Lo) wo.push(String(Lo));
			else
				for (var Fo in Xa) Ia() && Fo === "__proto__" || Ao && Fo === "prototype" || !za.call(Xa, Fo) || wo.push(String(Fo));
			if (Wa)
				for (var jo = vo(Xa), eo = 0; eo < Ka.length; ++eo) jo && Ka[eo] === "constructor" || !za.call(Xa, Ka[eo]) || wo.push(Ka[eo]);
			return wo
		}
	}());

	function aa(Ia, Na) {
		return Ia[Na]
	}

	function oa(Ia, Na) {
		return Object.prototype.hasOwnProperty.call(Ia, Na)
	}

	function la(Ia, Na) {
		return Na in Ia
	}

	function sa(Ia) {
		return Object.prototype.toString.call(Ia) === "[object Array]"
	}

	function ca(Ia) {
		return typeof Ia == "function"
	}
	"bind" in Function.prototype || ia(Function.prototype, "bind", function(Na) {
		var za = Array,
			ro = Object,
			Va = za.prototype,
			Wa = function() {},
			qa = Va.slice,
			Ka = Va.concat,
			lo = Va.push,
			yo = Math.max,
			fo = this;
		if (!ca(fo)) throw new TypeError("Function.prototype.bind called on incompatible " + fo);
		for (var vo, so = qa.call(arguments, 1), Xa = function() {
				if (this instanceof vo) {
					var wo = fo.apply(this, Ka.call(so, qa.call(arguments)));
					return ro(wo) === wo ? wo : this
				}
				return fo.apply(Na, Ka.call(so, qa.call(arguments)))
			}, to = yo(0, fo.length - so.length), ho = [], Eo = 0; Eo < to; Eo++) lo.call(ho, "$" + Eo);
		return vo = Function("binder", "return function (" + ho.join(",") + "){ return binder.apply(this, arguments); }")(Xa), fo.prototype && (Wa.prototype = fo.prototype, vo.prototype = new Wa, Wa.prototype = null), vo
	});

	function ua(Ia) {
		if (Ia === null || Ia === Yi) throw TypeError(Object.prototype.toString.call(Ia) + " is not coercible to Object.");
		return Ia
	}

	function da(Ia, Na) {
		return Ia === Na
	}

	function ha(Ia) {
		return !!Ia
	}

	function pa(Ia) {
		if (Ia === null || Ia === Yi) throw TypeError();
		return Object(Ia)
	}

	function va(Ia, Na) {
		return pa(Ia)[Na]
	}

	function ba(Ia, Na) {
		var za = va(Ia, Na);
		if (za === null || za === Yi) return Yi;
		if (ca(za) === !1) throw new TypeError("Method not callable: " + Na);
		return za
	}

	function Ea(Ia) {
		switch (typeof Ia) {
			case "undefined":
				return "undefined";
			case "boolean":
				return "boolean";
			case "number":
				return "number";
			case "string":
				return "string";
			case "symbol":
				return "symbol";
			default:
				return Ia === null ? "null" : "Symbol" in ue && (Ia instanceof ue.Symbol || Ia.constructor === ue.Symbol) ? "symbol" : "object"
		}
	}
	"flags" in RegExp.prototype || Object.defineProperty(RegExp.prototype, "flags", {
		configurable: !0,
		enumerable: !1,
		get: function() {
			var Ia = this;
			if (Ea(Ia) !== "object") throw new TypeError("Method called on incompatible type: must be an object.");
			var Na = "";
			return ha(aa(Ia, "global")) && (Na += "g"), ha(aa(Ia, "ignoreCase")) && (Na += "i"), ha(aa(Ia, "multiline")) && (Na += "m"), ha(aa(Ia, "unicode")) && (Na += "u"), ha(aa(Ia, "sticky")) && (Na += "y"), Na
		}
	});

	function Sa(Ia, Na) {
		var za = aa(Ia, "prototype");
		return Ea(za) !== "object" && (za = Na), za
	}
	var Ca = function() {
		function Ia(Na) {
			return /^[0-9]$/.test(Na)
		}
		return function(za, ro, Va, Wa, qa, Ka) {
			for (var lo = za.length, yo = ro.length, fo = Va + lo, vo = Wa.length, so = "", Xa = 0; Xa < Ka.length; Xa += 1) {
				var to = Ka.charAt(Xa),
					ho = Xa + 1 >= Ka.length,
					Eo = Xa + 2 >= Ka.length;
				if (to !== "$" || ho) so += Ka.charAt(Xa);
				else {
					var wo = Ka.charAt(Xa + 1);
					if (wo === "$") so += "$", Xa += 1;
					else if (wo === "&") so += za, Xa += 1;
					else if (wo === "`") so += Va === 0 ? "" : ro.slice(0, Va - 1), Xa += 1;
					else if (wo === "'") so += fo >= yo ? "" : ro.slice(fo), Xa += 1;
					else {
						var Ao = Eo ? null : Ka.charAt(Xa + 2);
						if (!Ia(wo) || wo === "0" || !Eo && Ia(Ao))
							if (Ia(wo) && (Eo || Ia(Ao))) {
								var _o = wo + Ao,
									Lo = parseInt(_o, 10) - 1;
								so += _o <= vo && Ea(Wa[Lo]) === "Undefined" ? "" : Wa[Lo], Xa += 2
							} else so += "$";
						else {
							var Fo = parseInt(wo, 10);
							so += Fo <= vo && Ea(Wa[Fo - 1]) === "Undefined" ? "" : Wa[Fo - 1], Xa += 1
						}
					}
				}
			}
			return so
		}
	}();

	function ka(Ia) {
		return Ea(Ia) === "object" && typeof Ia == "function" && !!Ia.prototype
	}

	function Pa(Ia) {
		if (Ea(Ia) !== "object") return !1;
		var Na = "Symbol" in ue && "match" in ue.Symbol ? aa(Ia, ue.Symbol.match) : Yi;
		if (Na !== Yi) return ha(Na);
		try {
			var za = Ia.lastIndex;
			return Ia.lastIndex = 0, RegExp.prototype.exec.call(Ia), !0
		} catch {} finally {
			Ia.lastIndex = za
		}
		return !1
	}

	function ja(Ia, Na) {
		if (Ea(Ia["[[Iterator]]"]) !== "object") throw new Error(Object.prototype.toString.call(Ia["[[Iterator]]"]) + "is not an Object.");
		var za = Ia["[[Iterator]]"],
			ro = ba(za, "return");
		if (ro === Yi) return Na;
		try {
			var Va = ta(ro, za)
		} catch (qa) {
			var Wa = qa
		}
		if (Na) return Na;
		if (Wa) throw Wa;
		if (Ea(Va) !== "object") throw new TypeError("Iterator's return method returned a non-object.");
		return Na
	}

	function Za(Ia) {
		if (Ea(Ia) !== "object") throw new Error(Object.prototype.toString.call(Ia) + "is not an Object.");
		return ha(aa(Ia, "done"))
	}

	function Ga(Ia) {
		if (arguments.length < 2) var Na = ta(Ia["[[NextMethod]]"], Ia["[[Iterator]]"]);
		else Na = ta(Ia["[[NextMethod]]"], Ia["[[Iterator]]"], [arguments[1]]);
		if (Ea(Na) !== "object") throw new TypeError("bad iterator");
		return Na
	}

	function Ja(Ia) {
		var Na = Ga(Ia);
		return Za(Na) !== !0 && Na
	}

	function Ua(Ia) {
		if (Ea(Ia) !== "object") throw new Error(Object.prototype.toString.call(Ia) + "is not an Object.");
		return aa(Ia, "value")
	}

	function xa(Ia, Na) {
		if (Na === "string") var za = ["toString", "valueOf"];
		else za = ["valueOf", "toString"];
		for (var ro = 0; ro < za.length; ++ro) {
			var Va = za[ro],
				Wa = aa(Ia, Va);
			if (ca(Wa)) {
				var qa = ta(Wa, Ia);
				if (Ea(qa) !== "object") return qa
			}
		}
		throw new TypeError("Cannot convert to primitive.")
	}

	function ma(Ia, Na) {
		return Ea(Ia) === Ea(Na) && (Ea(Ia) === "number" ? !(!isNaN(Ia) || !isNaN(Na)) || 1 / Ia === 1 / 0 && 1 / Na == -1 / 0 || 1 / Ia == -1 / 0 && 1 / Na === 1 / 0 || Ia === Na : da(Ia, Na))
	}

	function fa(Ia, Na, za) {
		var ro = Ia.length;
		if (Na === "" && za <= ro) return za;
		for (var Va = Na.length, Wa = za, qa = -1; Wa + Va <= ro;) {
			for (var Ka = !0, lo = 0; lo < Va; lo += 1)
				if (Ia[Wa + lo] !== Na[lo]) {
					Ka = !1;
					break
				} if (Ka) {
				qa = Wa;
				break
			}
			Wa += 1
		}
		return qa
	}

	function ga(Ia) {
		if (Ea(Ia) === "symbol") throw new TypeError("Cannot convert a Symbol value to a number");
		var Na = Number(Ia);
		return isNaN(Na) ? 0 : 1 / Na === 1 / 0 || 1 / Na == -1 / 0 || Na === 1 / 0 || Na === -1 / 0 ? Na : (Na < 0 ? -1 : 1) * Math.floor(Math.abs(Na))
	}

	function wa(Ia) {
		var Na = ga(Ia);
		return Na <= 0 ? 0 : Math.min(Na, Math.pow(2, 53) - 1)
	}

	function Ma(Ia) {
		var Na = arguments.length > 1 ? arguments[1] : Yi;
		if (Ea(Ia) === "object") {
			if (arguments.length < 2) var za = "default";
			else Na === String ? za = "string" : Na === Number && (za = "number");
			var ro = typeof ue.Symbol == "function" && typeof ue.Symbol.toPrimitive == "symbol" ? ba(Ia, ue.Symbol.toPrimitive) : Yi;
			if (ro !== Yi) {
				var Va = ta(ro, Ia, [za]);
				if (Ea(Va) !== "object") return Va;
				throw new TypeError("Cannot convert exotic object to primitive.")
			}
			return za === "default" && (za = "number"), xa(Ia, za)
		}
		return Ia
	}

	function Aa(Ia) {
		switch (Ea(Ia)) {
			case "symbol":
				throw new TypeError("Cannot convert a Symbol value to a string");
			case "object":
				return Aa(Ma(Ia, String));
			default:
				return String(Ia)
		}
	}
	"forEach" in Array.prototype || ia(Array.prototype, "forEach", function(Na) {
		var za = pa(this),
			ro = za instanceof String ? za.split("") : za,
			Va = wa(aa(za, "length"));
		if (ca(Na) === !1) throw new TypeError(Na + " is not a function");
		for (var Wa = arguments.length > 1 ? arguments[1] : Yi, qa = 0; qa < Va;) {
			var Ka = Aa(qa);
			if (la(ro, Ka)) {
				var lo = aa(ro, Ka);
				ta(Na, Wa, [lo, qa, za])
			}
			qa += 1
		}
		return Yi
	}), "includes" in Array.prototype || ia(Array.prototype, "includes", function(Na) {
		var za = pa(this),
			ro = wa(aa(za, "length"));
		if (ro === 0) return !1;
		var Va = ga(arguments[1]);
		if (Va >= 0) var Wa = Va;
		else(Wa = ro + Va) < 0 && (Wa = 0);
		for (; Wa < ro;) {
			var qa = aa(za, Aa(Wa));
			if (ma(Na, qa)) return !0;
			Wa += 1
		}
		return !1
	}), "indexOf" in Array.prototype || ia(Array.prototype, "indexOf", function(Na) {
		var za = pa(this),
			ro = wa(aa(za, "length"));
		if (ro === 0) return -1;
		var Va = ga(arguments[1]);
		if (Va >= ro) return -1;
		if (Va >= 0) var Wa = 1 / Va == -1 / 0 ? 0 : Va;
		else(Wa = ro + Va) < 0 && (Wa = 0);
		for (; Wa < ro;) {
			if (la(za, Aa(Wa)) && Na === aa(za, Aa(Wa))) return Wa;
			Wa += 1
		}
		return -1
	}), "getOwnPropertyNames" in Object && function() {
		try {
			return Object.getOwnPropertyNames(1), !0
		} catch {
			return !1
		}
	}() || function() {
		var Ia = {}.toString,
			Na = "".split,
			za = [].concat,
			ro = Object.prototype.hasOwnProperty,
			Va = Object.getOwnPropertyNames || Object.keys,
			Wa = typeof ue == "object" ? Va(ue) : [];
		ia(Object, "getOwnPropertyNames", function(Ka) {
			var lo = pa(Ka);
			if (Ia.call(lo) === "[object Window]") try {
				return Va(lo)
			} catch {
				return za.call([], Wa)
			}
			lo = Ia.call(lo) == "[object String]" ? Na.call(lo, "") : Object(lo);
			for (var yo = Va(lo), fo = ["length", "prototype"], vo = 0; vo < fo.length; vo++) {
				var so = fo[vo];
				ro.call(lo, so) && !yo.includes(so) && yo.push(so)
			}
			if (yo.includes("__proto__")) {
				var Xa = yo.indexOf("__proto__");
				yo.splice(Xa, 1)
			}
			return yo
		})
	}(), "includes" in String.prototype || ia(String.prototype, "includes", function(Na) {
		var za = arguments.length > 1 ? arguments[1] : Yi,
			ro = ua(this),
			Va = Aa(ro);
		if (Pa(Na)) throw new TypeError("First argument to String.prototype.includes must not be a regular expression");
		var Wa = Aa(Na),
			qa = ga(za),
			Ka = Va.length,
			lo = Math.min(Math.max(qa, 0), Ka);
		return String.prototype.indexOf.call(Va, Wa, lo) !== -1
	});

	function Ra(Ia) {
		var Na = Ma(Ia, String);
		return Ea(Na) === "symbol" ? Na : Aa(Na)
	}
	"getOwnPropertyDescriptor" in Object && typeof Object.getOwnPropertyDescriptor == "function" && function() {
		try {
			return Object.getOwnPropertyDescriptor("13.7", 1).value === "3"
		} catch {
			return !1
		}
	}() || function() {
		var Ia = Object.getOwnPropertyDescriptor,
			Na = function() {
				try {
					return Object.defineProperty(document.createElement("div"), "one", {
						get: function() {
							return 1
						}
					}).one === 1
				} catch {
					return !1
				}
			},
			za = {}.toString,
			ro = "".split;
		ia(Object, "getOwnPropertyDescriptor", function(Wa, qa) {
			var Ka = pa(Wa);
			Ka = (Ea(Ka) === "string" || Ka instanceof String) && za.call(Wa) == "[object String]" ? ro.call(Wa, "") : Object(Wa);
			var lo = Ra(qa);
			if (Na) try {
				return Ia(Ka, lo)
			} catch {}
			if (oa(Ka, lo)) return {
				enumerable: !0,
				configurable: !0,
				writable: !0,
				value: Ka[lo]
			}
		})
	}(), "assign" in Object || ia(Object, "assign", function(Na, za) {
		var ro = pa(Na);
		if (arguments.length === 1) return ro;
		var Va, Wa, qa, Ka, lo = Array.prototype.slice.call(arguments, 1);
		for (Va = 0; Va < lo.length; Va++) {
			var yo = lo[Va];
			for (yo === Yi || yo === null ? qa = [] : (Ka = Object.prototype.toString.call(yo) === "[object String]" ? String(yo).split("") : pa(yo), qa = Object.keys(Ka)), Wa = 0; Wa < qa.length; Wa++) {
				var fo, vo = qa[Wa];
				try {
					var so = Object.getOwnPropertyDescriptor(Ka, vo);
					fo = so !== Yi && so.enumerable === !0
				} catch {
					fo = Object.prototype.propertyIsEnumerable.call(Ka, vo)
				}
				if (fo) {
					var Xa = aa(Ka, vo);
					ro[vo] = Xa
				}
			}
		}
		return ro
	}), "defineProperties" in Object || ia(Object, "defineProperties", function(Na, za) {
		if (Ea(Na) !== "object") throw new TypeError("Object.defineProperties called on non-object");
		for (var ro = pa(za), Va = Object.keys(ro), Wa = [], qa = 0; qa < Va.length; qa++) {
			var Ka = Va[qa],
				lo = Object.getOwnPropertyDescriptor(ro, Ka);
			if (lo !== Yi && lo.enumerable) {
				var yo = aa(ro, Ka),
					fo = yo;
				Wa.push([Ka, fo])
			}
		}
		for (var vo = 0; vo < Wa.length; vo++) {
			var so = Wa[vo][0];
			fo = Wa[vo][1], Object.defineProperty(Na, so, fo)
		}
		return Na
	}), "create" in Object || function() {
		function Ia() {}
		if ({
				__proto__: null
			}
			instanceof Object) Na = function() {
			var za = document.createElement("iframe");
			za.style.display = "none";
			var ro = document.body || document.documentElement;
			ro.appendChild(za), za.src = "javascript:";
			var Va = za.contentWindow.Object.prototype;
			ro.removeChild(za), za = null, delete Va.constructor, delete Va.hasOwnProperty, delete Va.propertyIsEnumerable, delete Va.isPrototypeOf, delete Va.toLocaleString, delete Va.toString, delete Va.valueOf;
			var Wa = function() {};
			return Wa.prototype = Va, Na = function() {
				return new Wa
			}, new Wa
		};
		else var Na = function() {
			return {
				__proto__: null
			}
		};
		ia(Object, "create", function(ro, Va) {
			if (Ea(ro) !== "object" && Ea(ro) !== "null") throw new TypeError("Object prototype may only be an Object or null");
			if (Ea(ro) === "null") var Wa = Na();
			else Ia.prototype = ro, Wa = new Ia, Wa.__proto__ = ro, Wa.constructor.prototype = ro, Wa.__proto__ = ro;
			return 1 in arguments ? Object.defineProperties(Wa, Va) : Wa
		})
	}();

	function Ta(Ia, Na) {
		var za = arguments[2] || {},
			ro = Sa(Ia, Na),
			Va = Object.create(ro);
		for (var Wa in za) Object.prototype.hasOwnProperty.call(za, Wa) && Object.defineProperty(Va, Wa, {
			configurable: !0,
			enumerable: !1,
			writable: !0,
			value: za[Wa]
		});
		return Va
	}

	function La(Ia) {
		var Na = arguments.length > 2 ? arguments[2] : Ia,
			za = arguments.length > 1 ? arguments[1] : [];
		if (!ka(Ia)) throw new TypeError("F must be a constructor.");
		if (!ka(Na)) throw new TypeError("newTarget must be a constructor.");
		if (Na === Ia) return new(Function.prototype.bind.apply(Ia, [null].concat(za)));
		var ro = Ta(Na, Object.prototype);
		return ta(Ia, ro, za)
	}

	function ya(Ia, Na) {
		if (Na === 0 && 1 / Na == -1 / 0 && (Na = 0), sa(Ia) === !1) return ea(Na);
		var za = aa(Ia, "constructor");
		if (Ea(za) === "object" && (za = "Symbol" in ue && "species" in ue.Symbol ? aa(za, ue.Symbol.species) : Yi) === null && (za = Yi), za === Yi) return ea(Na);
		if (!ka(za)) throw new TypeError("C must be a constructor");
		return La(za, [Na])
	}
	"filter" in Array.prototype || ia(Array.prototype, "filter", function(Na) {
		var za = pa(this),
			ro = wa(aa(za, "length"));
		if (ca(Na) === !1) throw new TypeError(Na + " is not a function");
		for (var Va = arguments.length > 1 ? arguments[1] : Yi, Wa = ya(za, 0), qa = 0, Ka = 0; qa < ro;) {
			var lo = Aa(qa);
			if (la(za, lo)) {
				var yo = aa(za, lo);
				ha(ta(Na, Va, [yo, qa, za])) && (ra(Wa, Aa(Ka), yo), Ka += 1)
			}
			qa += 1
		}
		return Wa
	}), "map" in Array.prototype || ia(Array.prototype, "map", function(Na) {
		var za = pa(this),
			ro = wa(aa(za, "length"));
		if (ca(Na) === !1) throw new TypeError(Na + " is not a function");
		for (var Va = arguments.length > 1 ? arguments[1] : Yi, Wa = ya(za, ro), qa = 0; qa < ro;) {
			var Ka = Aa(qa);
			if (la(za, Ka)) {
				var lo = aa(za, Ka),
					yo = ta(Na, Va, [lo, qa, za]);
				ra(Wa, Ka, yo)
			}
			qa += 1
		}
		return Wa
	}), "setPrototypeOf" in Object || function() {
		if (!Object.setPrototypeOf) {
			var Ia, Na, za = Object.getOwnPropertyNames,
				ro = Object.getOwnPropertyDescriptor,
				Va = Object.create,
				Wa = Object.defineProperty,
				qa = Object.getPrototypeOf,
				Ka = Object.prototype,
				lo = function(fo, vo) {
					return za(vo).forEach(function(so) {
						Wa(fo, so, ro(vo, so))
					}), fo
				},
				yo = function(vo, so) {
					return lo(Va(so), vo)
				};
			try {
				Ia = ro(Ka, "__proto__").set, Ia.call({}, null), Na = function(vo, so) {
					return Ia.call(vo, so), vo
				}
			} catch {
				Ia = {
					__proto__: null
				}, Ia instanceof Object ? Na = yo : (Ia.__proto__ = Ka, Na = Ia instanceof Object ? function(so, Xa) {
					return so.__proto__ = Xa, so
				} : function(so, Xa) {
					return qa(so) ? (so.__proto__ = Xa, so) : yo(so, Xa)
				})
			}
			ia(Object, "setPrototypeOf", Na)
		}
	}(), "Symbol" in ue && ue.Symbol.length === 0 || function(Ia, Na, za) {
		function ro(co) {
			if (Ea(co) === "symbol") return co;
			throw TypeError(co + " is not a symbol")
		}
		var Va, Wa = function() {
				try {
					var co = {};
					return Ia.defineProperty(co, "t", {
						configurable: !0,
						enumerable: !1,
						get: function() {
							return !0
						},
						set: Yi
					}), !!co.t
				} catch {
					return !1
				}
			}(),
			qa = 0,
			Ka = "" + Math.random(),
			lo = "__symbol:",
			yo = lo.length,
			fo = "__symbol@@" + Ka,
			vo = {},
			so = "defineProperty",
			Xa = "defineProperties",
			to = "getOwnPropertyNames",
			ho = "getOwnPropertyDescriptor",
			Eo = "propertyIsEnumerable",
			wo = Ia.prototype,
			Ao = wo.hasOwnProperty,
			_o = wo[Eo],
			Lo = wo.toString,
			Fo = Array.prototype.concat,
			jo = Ia.getOwnPropertyNames ? Ia.getOwnPropertyNames(ue) : [],
			eo = Ia[to],
			Oa = function(mo) {
				if (Lo.call(mo) === "[object Window]") try {
					return eo(mo)
				} catch {
					return Fo.call([], jo)
				}
				return eo(mo)
			},
			Da = Ia[ho],
			Qa = Ia.create,
			uo = Ia.keys,
			bo = Ia.freeze || Ia,
			So = Ia[so],
			Wo = Ia[Xa],
			Po = Da(Ia, to),
			Ro = function(co, mo, xo) {
				if (!Ao.call(co, fo)) try {
					So(co, fo, {
						enumerable: !1,
						configurable: !1,
						writable: !1,
						value: {}
					})
				} catch {
					co[fo] = {}
				}
				co[fo]["@@" + mo] = xo
			},
			Ho = function(co, mo) {
				var xo = Qa(co);
				return Oa(mo).forEach(function(ko) {
					Go.call(mo, ko) && go(xo, ko, mo[ko])
				}), xo
			},
			Oo = function(co) {
				var mo = Qa(co);
				return mo.enumerable = !1, mo
			},
			No = function() {},
			ps = function(co) {
				return co != fo && !Ao.call(Es, co)
			},
			Ko = function(co) {
				return co != fo && Ao.call(Es, co)
			},
			Go = function(mo) {
				var xo = "" + mo;
				return Ko(xo) ? Ao.call(this, xo) && this[fo] && this[fo]["@@" + xo] : _o.call(this, mo)
			},
			bs = function(co) {
				var mo = {
					enumerable: !1,
					configurable: !0,
					get: No,
					set: function(ko) {
						Va(this, co, {
							enumerable: !1,
							configurable: !0,
							writable: !0,
							value: ko
						}), Ro(this, co, !0)
					}
				};
				try {
					So(wo, co, mo)
				} catch {
					wo[co] = mo.value
				}
				Es[co] = So(Ia(co), "constructor", ws);
				var xo = Da(ls.prototype, "description");
				return xo && So(Es[co], "description", xo), bo(Es[co])
			},
			vs = function(co) {
				var mo = ro(co);
				if (Co) {
					var xo = $a(mo);
					if (xo !== "") return xo.slice(1, -1)
				}
				if (vo[mo] !== Yi) return vo[mo];
				var ko = mo.toString(),
					$o = ko.lastIndexOf("0.");
				return ko = ko.slice(10, $o), ko === "" ? Yi : ko
			},
			ls = function co() {
				var mo = arguments[0];
				if (this instanceof co) throw new TypeError("Symbol is not a constructor");
				var xo = lo.concat(mo || "", Ka, ++qa);
				mo === Yi || mo !== null && !isNaN(mo) && String(mo) !== "" || (vo[xo] = String(mo));
				var ko = bs(xo);
				return Wa || Ia.defineProperty(ko, "description", {
					configurable: !0,
					enumerable: !1,
					value: vs(ko)
				}), ko
			},
			Es = Qa(null),
			ws = {
				value: ls
			},
			as = function(co) {
				return Es[co]
			},
			go = function(mo, xo, ko) {
				var $o = "" + xo;
				return Ko($o) ? (Va(mo, $o, ko.enumerable ? Oo(ko) : ko), Ro(mo, $o, !!ko.enumerable)) : So(mo, xo, ko), mo
			},
			Ha = function(co) {
				return function(mo) {
					return Ao.call(co, fo) && Ao.call(co[fo], "@@" + mo)
				}
			},
			Fa = function(mo) {
				return Oa(mo).filter(mo === wo ? Ha(mo) : Ko).map(as)
			};
		Po.value = go, So(Ia, so, Po), Po.value = Fa, So(Ia, "getOwnPropertySymbols", Po), Po.value = function(mo) {
			return Oa(mo).filter(ps)
		}, So(Ia, to, Po), Po.value = function(mo, xo) {
			var ko = Fa(xo);
			return ko.length ? uo(xo).concat(ko).forEach(function($o) {
				Go.call(xo, $o) && go(mo, $o, xo[$o])
			}) : Wo(mo, xo), mo
		}, So(Ia, Xa, Po), Po.value = Go, So(wo, Eo, Po), Po.value = ls, So(za, "Symbol", Po), Po.value = function(co) {
			var mo = lo.concat(lo, co, Ka);
			return mo in wo ? Es[mo] : bs(mo)
		}, So(ls, "for", Po), Po.value = function(co) {
			if (ps(co)) throw new TypeError(co + " is not a symbol");
			return Ao.call(Es, co) ? co.slice(2 * yo, -Ka.length) : void 0
		}, So(ls, "keyFor", Po), Po.value = function(mo, xo) {
			var ko = Da(mo, xo);
			return ko && Ko(xo) && (ko.enumerable = Go.call(mo, xo)), ko
		}, So(Ia, ho, Po), Po.value = function(mo, xo) {
			return arguments.length === 1 || xo === void 0 ? Qa(mo) : Ho(mo, xo)
		}, So(Ia, "create", Po);
		var Ya = (function() {
			return this
		}).call(null) === null;
		if (Po.value = Ya ? function() {
				var co = Lo.call(this);
				return co === "[object String]" && Ko(this) ? "[object Symbol]" : co
			} : function() {
				if (this === window) return "[object Null]";
				var co = Lo.call(this);
				return co === "[object String]" && Ko(this) ? "[object Symbol]" : co
			}, So(wo, "toString", Po), Va = function(co, mo, xo) {
				var ko = Da(wo, mo);
				delete wo[mo], So(co, mo, xo), co !== wo && So(wo, mo, ko)
			}, function() {
				try {
					var co = {};
					return Ia.defineProperty(co, "t", {
						configurable: !0,
						enumerable: !1,
						get: function() {
							return !0
						},
						set: Yi
					}), !!co.t
				} catch {
					return !1
				}
			}()) {
			var $a;
			try {
				$a = Function("s", "var v = s.valueOf(); return { [v]() {} }[v].name;")
			} catch {}
			var no = function() {},
				Co = $a && no.name === "inferred" ? $a : null;
			Ia.defineProperty(za.Symbol.prototype, "description", {
				configurable: !0,
				enumerable: !1,
				get: function() {
					return vs(this)
				}
			})
		}
	}(Object, 0, ue), "Symbol" in ue && "iterator" in ue.Symbol || Object.defineProperty(ue.Symbol, "iterator", {
		value: ue.Symbol("iterator")
	});

	function Ba(Ia) {
		var Na = arguments.length > 1 ? arguments[1] : ba(Ia, Symbol.iterator),
			za = ta(Na, Ia);
		if (Ea(za) !== "object") throw new TypeError("bad iterator");
		var ro = va(za, "next"),
			Va = Object.create(null);
		return Va["[[Iterator]]"] = za, Va["[[NextMethod]]"] = ro, Va["[[Done]]"] = !1, Va
	}
	var io = function() {
		var Ia = {}.toString,
			Na = "".split;
		return function(ro, Va, Wa) {
			if (ca(Wa) === !1) throw new TypeError("adder is not callable.");
			for (var qa = Ba(Va);;) {
				var Ka = Ja(qa);
				if (Ka === !1) return ro;
				var lo = Ua(Ka);
				if (Ea(lo) !== "object") {
					var yo = new TypeError("nextItem is not an object");
					throw ja(qa, yo), yo
				}
				lo = (Ea(lo) === "string" || lo instanceof String) && Ia.call(lo) == "[object String]" ? Na.call(lo, "") : lo;
				var fo;
				try {
					fo = aa(lo, "0")
				} catch (so) {
					return ja(qa, so)
				}
				var vo;
				try {
					vo = aa(lo, "1")
				} catch (so) {
					return ja(qa, so)
				}
				try {
					ta(Wa, ro, [fo, vo])
				} catch (so) {
					return ja(qa, so)
				}
			}
		}
	}();
	"Symbol" in ue && "replace" in ue.Symbol || Object.defineProperty(Symbol, "replace", {
		value: Symbol("replace")
	}), "replaceAll" in String.prototype || ia(String.prototype, "replaceAll", function(Na, za) {
		var ro = ua(this);
		if (Na !== Yi && Na !== null) {
			if (Pa(Na)) {
				var Va = aa(Na, "flags");
				if (!("flags" in RegExp.prototype || Na.global === !0) || "flags" in RegExp.prototype && (ua(Va), Aa(Va).indexOf("g") === -1)) throw TypeError("")
			}
			var Wa = "Symbol" in ue && "replace" in ue.Symbol ? ba(Na, ue.Symbol.replace) : Yi;
			if (Wa !== Yi) return ta(Wa, Na, [ro, za])
		}
		var qa = Aa(ro),
			Ka = Aa(Na),
			lo = ca(za);
		lo === !1 && (za = Aa(za));
		for (var yo = Ka.length, fo = Math.max(1, yo), vo = [], so = fa(qa, Ka, 0); so !== -1;) vo.push(so), so = fa(qa, Ka, so + fo);
		for (var Xa = 0, to = "", ho = 0; ho < vo.length; ho++) {
			var Eo = qa.substring(Xa, vo[ho]);
			if (lo) var wo = Aa(ta(za, Yi, [Ka, vo[ho], qa]));
			else {
				var Ao = [];
				wo = Ca(Ka, qa, vo[ho], Ao, Yi, za)
			}
			to = to + Eo + wo, Xa = vo[ho] + yo
		}
		return Xa < qa.length && (to += qa.substring(Xa)), to
	}), "Symbol" in ue && "toStringTag" in ue.Symbol || Object.defineProperty(Symbol, "toStringTag", {
		value: Symbol("toStringTag")
	});
	var oo = function() {
			var Ia = function() {
					return this.length = 0, this
				},
				Na = function(ro) {
					if (typeof ro != "function") throw new TypeError(ro + " is not a function");
					return ro
				},
				za = function(ro, Va) {
					if (!(this instanceof za)) return new za(ro, Va);
					Object.defineProperties(this, {
						__list__: {
							writable: !0,
							value: ro
						},
						__context__: {
							writable: !0,
							value: Va
						},
						__nextIndex__: {
							writable: !0,
							value: 0
						}
					}), Va && (Na(Va.on), Va.on("_add", this._onAdd.bind(this)), Va.on("_delete", this._onDelete.bind(this)), Va.on("_clear", this._onClear.bind(this)))
				};
			return Object.defineProperties(za.prototype, Object.assign({
				constructor: {
					value: za,
					configurable: !0,
					enumerable: !1,
					writable: !0
				},
				_next: {
					value: function() {
						var ro;
						if (this.__list__) return this.__redo__ && (ro = this.__redo__.shift()) !== Yi ? ro : this.__nextIndex__ < this.__list__.length ? this.__nextIndex__++ : void this._unBind()
					},
					configurable: !0,
					enumerable: !1,
					writable: !0
				},
				next: {
					value: function() {
						return this._createResult(this._next())
					},
					configurable: !0,
					enumerable: !1,
					writable: !0
				},
				_createResult: {
					value: function(ro) {
						return ro === Yi ? {
							done: !0,
							value: Yi
						} : {
							done: !1,
							value: this._resolve(ro)
						}
					},
					configurable: !0,
					enumerable: !1,
					writable: !0
				},
				_resolve: {
					value: function(ro) {
						return this.__list__[ro]
					},
					configurable: !0,
					enumerable: !1,
					writable: !0
				},
				_unBind: {
					value: function() {
						this.__list__ = null, delete this.__redo__, this.__context__ && (this.__context__.off("_add", this._onAdd.bind(this)), this.__context__.off("_delete", this._onDelete.bind(this)), this.__context__.off("_clear", this._onClear.bind(this)), this.__context__ = null)
					},
					configurable: !0,
					enumerable: !1,
					writable: !0
				},
				toString: {
					value: function() {
						return "[object Iterator]"
					},
					configurable: !0,
					enumerable: !1,
					writable: !0
				}
			}, {
				_onAdd: {
					value: function(ro) {
						if (!(ro >= this.__nextIndex__)) {
							if (++this.__nextIndex__, !this.__redo__) return void Object.defineProperty(this, "__redo__", {
								value: [ro],
								configurable: !0,
								enumerable: !1,
								writable: !1
							});
							this.__redo__.forEach(function(Va, Wa) {
								Va >= ro && (this.__redo__[Wa] = ++Va)
							}, this), this.__redo__.push(ro)
						}
					},
					configurable: !0,
					enumerable: !1,
					writable: !0
				},
				_onDelete: {
					value: function(ro) {
						var Va;
						ro >= this.__nextIndex__ || (--this.__nextIndex__, this.__redo__ && (Va = this.__redo__.indexOf(ro), Va !== -1 && this.__redo__.splice(Va, 1), this.__redo__.forEach(function(Wa, qa) {
							Wa > ro && (this.__redo__[qa] = --Wa)
						}, this)))
					},
					configurable: !0,
					enumerable: !1,
					writable: !0
				},
				_onClear: {
					value: function() {
						this.__redo__ && Ia.call(this.__redo__), this.__nextIndex__ = 0
					},
					configurable: !0,
					enumerable: !1,
					writable: !0
				}
			})), Object.defineProperty(za.prototype, Symbol.iterator, {
				value: function() {
					return this
				},
				configurable: !0,
				enumerable: !1,
				writable: !0
			}), Object.defineProperty(za.prototype, Symbol.toStringTag, {
				value: "Iterator",
				configurable: !1,
				enumerable: !1,
				writable: !0
			}), za
		}(),
		ao = function() {
			var Ia = function(Na, za) {
				if (!(this instanceof Ia)) return new Ia(Na, za);
				oo.call(this, Na), za = za ? String.prototype.includes.call(za, "key+value") ? "key+value" : String.prototype.includes.call(za, "key") ? "key" : "value" : "value", Object.defineProperty(this, "__kind__", {
					value: za,
					configurable: !1,
					enumerable: !1,
					writable: !1
				})
			};
			return Object.setPrototypeOf && Object.setPrototypeOf(Ia, oo.prototype), Ia.prototype = Object.create(oo.prototype, {
				constructor: {
					value: Ia,
					configurable: !0,
					enumerable: !1,
					writable: !0
				},
				_resolve: {
					value: function(Na) {
						return this.__kind__ === "value" ? this.__list__[Na] : this.__kind__ === "key+value" ? [Na, this.__list__[Na]] : Na
					},
					configurable: !0,
					enumerable: !1,
					writable: !0
				},
				toString: {
					value: function() {
						return "[object Array Iterator]"
					},
					configurable: !0,
					enumerable: !1,
					writable: !0
				}
			}), Ia
		}();
	"values" in Array.prototype || ("Symbol" in ue && "iterator" in Symbol && typeof Array.prototype[Symbol.iterator] == "function" ? ia(Array.prototype, "values", Array.prototype[Symbol.iterator]) : ia(Array.prototype, "values", function() {
		var Na = pa(this);
		return new ao(Na, "value")
	})), "Symbol" in ue && "iterator" in ue.Symbol && Array.prototype[ue.Symbol.iterator] || ia(Array.prototype, Symbol.iterator, Array.prototype.values), "fromEntries" in Object || ia(Object, "fromEntries", function(Na) {
		ua(Na);
		var za = {},
			ro = function(Va, Wa) {
				var qa = this,
					Ka = Ra(Va);
				ra(qa, Ka, Wa)
			};
		return io(za, Na, ro)
	})
})(typeof window == "object" && window || typeof self == "object" && self || typeof global$1 == "object" && global$1 || {});
const objectToString = Object.prototype.toString;

function isError(ue) {
	switch (objectToString.call(ue)) {
		case "[object Error]":
		case "[object Exception]":
		case "[object DOMException]":
			return !0;
		default:
			return isInstanceOf(ue, Error)
	}
}

function isBuiltin(ue, Yi) {
	return objectToString.call(ue) === `[object ${Yi}]`
}

function isErrorEvent$2(ue) {
	return isBuiltin(ue, "ErrorEvent")
}

function isDOMError(ue) {
	return isBuiltin(ue, "DOMError")
}

function isDOMException(ue) {
	return isBuiltin(ue, "DOMException")
}

function isString(ue) {
	return isBuiltin(ue, "String")
}

function isParameterizedString(ue) {
	return typeof ue == "object" && ue !== null && "__sentry_template_string__" in ue && "__sentry_template_values__" in ue
}

function isPrimitive(ue) {
	return ue === null || isParameterizedString(ue) || typeof ue != "object" && typeof ue != "function"
}

function isPlainObject(ue) {
	return isBuiltin(ue, "Object")
}

function isEvent(ue) {
	return typeof Event < "u" && isInstanceOf(ue, Event)
}

function isElement$2(ue) {
	return typeof Element < "u" && isInstanceOf(ue, Element)
}

function isRegExp(ue) {
	return isBuiltin(ue, "RegExp")
}

function isThenable(ue) {
	return !!(ue && ue.then && typeof ue.then == "function")
}

function isSyntheticEvent(ue) {
	return isPlainObject(ue) && "nativeEvent" in ue && "preventDefault" in ue && "stopPropagation" in ue
}

function isNaN$1(ue) {
	return typeof ue == "number" && ue !== ue
}

function isInstanceOf(ue, Yi) {
	try {
		return ue instanceof Yi
	} catch {
		return !1
	}
}

function isVueViewModel(ue) {
	return !!(typeof ue == "object" && ue !== null && (ue.__isVue || ue._isVue))
}

function truncate(ue, Yi = 0) {
	return typeof ue != "string" || Yi === 0 || ue.length <= Yi ? ue : `${ue.slice(0,Yi)}...`
}

function safeJoin(ue, Yi) {
	if (!Array.isArray(ue)) return "";
	const ea = [];
	for (let ta = 0; ta < ue.length; ta++) {
		const na = ue[ta];
		try {
			isVueViewModel(na) ? ea.push("[VueViewModel]") : ea.push(String(na))
		} catch {
			ea.push("[value cannot be serialized]")
		}
	}
	return ea.join(Yi)
}

function isMatchingPattern(ue, Yi, ea = !1) {
	return isString(ue) ? isRegExp(Yi) ? Yi.test(ue) : isString(Yi) ? ea ? ue === Yi : ue.includes(Yi) : !1 : !1
}

function stringMatchesSomePattern(ue, Yi = [], ea = !1) {
	return Yi.some(ta => isMatchingPattern(ue, ta, ea))
}

function applyAggregateErrorsToEvent(ue, Yi, ea = 250, ta, na, ra, ia) {
	if (!ra.exception || !ra.exception.values || !ia || !isInstanceOf(ia.originalException, Error)) return;
	const aa = ra.exception.values.length > 0 ? ra.exception.values[ra.exception.values.length - 1] : void 0;
	aa && (ra.exception.values = truncateAggregateExceptions(aggregateExceptionsFromError(ue, Yi, na, ia.originalException, ta, ra.exception.values, aa, 0), ea))
}

function aggregateExceptionsFromError(ue, Yi, ea, ta, na, ra, ia, aa) {
	if (ra.length >= ea + 1) return ra;
	let oa = [...ra];
	if (isInstanceOf(ta[na], Error)) {
		applyExceptionGroupFieldsForParentException(ia, aa);
		const la = ue(Yi, ta[na]),
			sa = oa.length;
		applyExceptionGroupFieldsForChildException(la, na, sa, aa), oa = aggregateExceptionsFromError(ue, Yi, ea, ta[na], na, [la, ...oa], la, sa)
	}
	return Array.isArray(ta.errors) && ta.errors.forEach((la, sa) => {
		if (isInstanceOf(la, Error)) {
			applyExceptionGroupFieldsForParentException(ia, aa);
			const ca = ue(Yi, la),
				ua = oa.length;
			applyExceptionGroupFieldsForChildException(ca, `errors[${sa}]`, ua, aa), oa = aggregateExceptionsFromError(ue, Yi, ea, la, na, [ca, ...oa], ca, ua)
		}
	}), oa
}

function applyExceptionGroupFieldsForParentException(ue, Yi) {
	ue.mechanism = ue.mechanism || {
		type: "generic",
		handled: !0
	}, ue.mechanism = {
		...ue.mechanism,
		...ue.type === "AggregateError" && {
			is_exception_group: !0
		},
		exception_id: Yi
	}
}

function applyExceptionGroupFieldsForChildException(ue, Yi, ea, ta) {
	ue.mechanism = ue.mechanism || {
		type: "generic",
		handled: !0
	}, ue.mechanism = {
		...ue.mechanism,
		type: "chained",
		source: Yi,
		exception_id: ea,
		parent_id: ta
	}
}

function truncateAggregateExceptions(ue, Yi) {
	return ue.map(ea => (ea.value && (ea.value = truncate(ea.value, Yi)), ea))
}

function isGlobalObj(ue) {
	return ue && ue.Math == Math ? ue : void 0
}
const GLOBAL_OBJ = typeof globalThis == "object" && isGlobalObj(globalThis) || typeof window == "object" && isGlobalObj(window) || typeof self == "object" && isGlobalObj(self) || typeof global$1 == "object" && isGlobalObj(global$1) || function() {
	return this
}() || {};

function getGlobalObject() {
	return GLOBAL_OBJ
}

function getGlobalSingleton(ue, Yi, ea) {
	const ta = ea || GLOBAL_OBJ,
		na = ta.__SENTRY__ = ta.__SENTRY__ || {};
	return na[ue] || (na[ue] = Yi())
}
const WINDOW$9 = getGlobalObject(),
	DEFAULT_MAX_STRING_LENGTH = 80;

function htmlTreeAsString(ue, Yi = {}) {
	if (!ue) return "<unknown>";
	try {
		let ea = ue;
		const ta = 5,
			na = [];
		let ra = 0,
			ia = 0;
		const aa = " > ",
			oa = aa.length;
		let la;
		const sa = Array.isArray(Yi) ? Yi : Yi.keyAttrs,
			ca = !Array.isArray(Yi) && Yi.maxStringLength || DEFAULT_MAX_STRING_LENGTH;
		for (; ea && ra++ < ta && (la = _htmlElementAsString(ea, sa), !(la === "html" || ra > 1 && ia + na.length * oa + la.length >= ca));) na.push(la), ia += la.length, ea = ea.parentNode;
		return na.reverse().join(aa)
	} catch {
		return "<unknown>"
	}
}

function _htmlElementAsString(ue, Yi) {
	const ea = ue,
		ta = [];
	let na, ra, ia, aa, oa;
	if (!ea || !ea.tagName) return "";
	if (WINDOW$9.HTMLElement && ea instanceof HTMLElement && ea.dataset && ea.dataset.sentryComponent) return ea.dataset.sentryComponent;
	ta.push(ea.tagName.toLowerCase());
	const la = Yi && Yi.length ? Yi.filter(ca => ea.getAttribute(ca)).map(ca => [ca, ea.getAttribute(ca)]) : null;
	if (la && la.length) la.forEach(ca => {
		ta.push(`[${ca[0]}="${ca[1]}"]`)
	});
	else if (ea.id && ta.push(`#${ea.id}`), na = ea.className, na && isString(na))
		for (ra = na.split(/\s+/), oa = 0; oa < ra.length; oa++) ta.push(`.${ra[oa]}`);
	const sa = ["aria-label", "type", "name", "title", "alt"];
	for (oa = 0; oa < sa.length; oa++) ia = sa[oa], aa = ea.getAttribute(ia), aa && ta.push(`[${ia}="${aa}"]`);
	return ta.join("")
}

function getLocationHref() {
	try {
		return WINDOW$9.document.location.href
	} catch {
		return ""
	}
}

function getDomElement(ue) {
	return WINDOW$9.document && WINDOW$9.document.querySelector ? WINDOW$9.document.querySelector(ue) : null
}

function getComponentName(ue) {
	if (!WINDOW$9.HTMLElement) return null;
	let Yi = ue;
	const ea = 5;
	for (let ta = 0; ta < ea; ta++) {
		if (!Yi) return null;
		if (Yi instanceof HTMLElement && Yi.dataset.sentryComponent) return Yi.dataset.sentryComponent;
		Yi = Yi.parentNode
	}
	return null
}
const DEBUG_BUILD$6 = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
	PREFIX = "Sentry Logger ",
	CONSOLE_LEVELS = ["debug", "info", "warn", "error", "log", "assert", "trace"],
	originalConsoleMethods = {};

function consoleSandbox(ue) {
	if (!("console" in GLOBAL_OBJ)) return ue();
	const Yi = GLOBAL_OBJ.console,
		ea = {},
		ta = Object.keys(originalConsoleMethods);
	ta.forEach(na => {
		const ra = originalConsoleMethods[na];
		ea[na] = Yi[na], Yi[na] = ra
	});
	try {
		return ue()
	} finally {
		ta.forEach(na => {
			Yi[na] = ea[na]
		})
	}
}

function makeLogger() {
	let ue = !1;
	const Yi = {
		enable: () => {
			ue = !0
		},
		disable: () => {
			ue = !1
		},
		isEnabled: () => ue
	};
	return DEBUG_BUILD$6 ? CONSOLE_LEVELS.forEach(ea => {
		Yi[ea] = (...ta) => {
			ue && consoleSandbox(() => {
				GLOBAL_OBJ.console[ea](`${PREFIX}[${ea}]:`, ...ta)
			})
		}
	}) : CONSOLE_LEVELS.forEach(ea => {
		Yi[ea] = () => {}
	}), Yi
}
const logger = makeLogger(),
	DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;

function isValidProtocol(ue) {
	return ue === "http" || ue === "https"
}

function dsnToString(ue, Yi = !1) {
	const {
		host: ea,
		path: ta,
		pass: na,
		port: ra,
		projectId: ia,
		protocol: aa,
		publicKey: oa
	} = ue;
	return `${aa}://${oa}${Yi&&na?`:${na}`:""}@${ea}${ra?`:${ra}`:""}/${ta&&`${ta}/`}${ia}`
}

function dsnFromString(ue) {
	const Yi = DSN_REGEX.exec(ue);
	if (!Yi) {
		consoleSandbox(() => {
			console.error(`Invalid Sentry Dsn: ${ue}`)
		});
		return
	}
	const [ea, ta, na = "", ra, ia = "", aa] = Yi.slice(1);
	let oa = "",
		la = aa;
	const sa = la.split("/");
	if (sa.length > 1 && (oa = sa.slice(0, -1).join("/"), la = sa.pop()), la) {
		const ca = la.match(/^\d+/);
		ca && (la = ca[0])
	}
	return dsnFromComponents({
		host: ra,
		pass: na,
		path: oa,
		projectId: la,
		port: ia,
		protocol: ea,
		publicKey: ta
	})
}

function dsnFromComponents(ue) {
	return {
		protocol: ue.protocol,
		publicKey: ue.publicKey || "",
		pass: ue.pass || "",
		host: ue.host,
		port: ue.port || "",
		path: ue.path || "",
		projectId: ue.projectId
	}
}

function validateDsn(ue) {
	if (!DEBUG_BUILD$6) return !0;
	const {
		port: Yi,
		projectId: ea,
		protocol: ta
	} = ue;
	return ["protocol", "publicKey", "host", "projectId"].find(ia => ue[ia] ? !1 : (logger.error(`Invalid Sentry Dsn: ${ia} missing`), !0)) ? !1 : ea.match(/^\d+$/) ? isValidProtocol(ta) ? Yi && isNaN(parseInt(Yi, 10)) ? (logger.error(`Invalid Sentry Dsn: Invalid port ${Yi}`), !1) : !0 : (logger.error(`Invalid Sentry Dsn: Invalid protocol ${ta}`), !1) : (logger.error(`Invalid Sentry Dsn: Invalid projectId ${ea}`), !1)
}

function makeDsn(ue) {
	const Yi = typeof ue == "string" ? dsnFromString(ue) : dsnFromComponents(ue);
	if (!(!Yi || !validateDsn(Yi))) return Yi
}
class SentryError extends Error {
	constructor(Yi, ea = "warn") {
		super(Yi), this.message = Yi, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = ea
	}
}

function fill(ue, Yi, ea) {
	if (!(Yi in ue)) return;
	const ta = ue[Yi],
		na = ea(ta);
	typeof na == "function" && markFunctionWrapped(na, ta), ue[Yi] = na
}

function addNonEnumerableProperty(ue, Yi, ea) {
	try {
		Object.defineProperty(ue, Yi, {
			value: ea,
			writable: !0,
			configurable: !0
		})
	} catch {
		DEBUG_BUILD$6 && logger.log(`Failed to add non-enumerable property "${Yi}" to object`, ue)
	}
}

function markFunctionWrapped(ue, Yi) {
	try {
		const ea = Yi.prototype || {};
		ue.prototype = Yi.prototype = ea, addNonEnumerableProperty(ue, "__sentry_original__", Yi)
	} catch {}
}

function getOriginalFunction(ue) {
	return ue.__sentry_original__
}

function urlEncode(ue) {
	return Object.keys(ue).map(Yi => `${encodeURIComponent(Yi)}=${encodeURIComponent(ue[Yi])}`).join("&")
}

function convertToPlainObject(ue) {
	if (isError(ue)) return {
		message: ue.message,
		name: ue.name,
		stack: ue.stack,
		...getOwnProperties(ue)
	};
	if (isEvent(ue)) {
		const Yi = {
			type: ue.type,
			target: serializeEventTarget(ue.target),
			currentTarget: serializeEventTarget(ue.currentTarget),
			...getOwnProperties(ue)
		};
		return typeof CustomEvent < "u" && isInstanceOf(ue, CustomEvent) && (Yi.detail = ue.detail), Yi
	} else return ue
}

function serializeEventTarget(ue) {
	try {
		return isElement$2(ue) ? htmlTreeAsString(ue) : Object.prototype.toString.call(ue)
	} catch {
		return "<unknown>"
	}
}

function getOwnProperties(ue) {
	if (typeof ue == "object" && ue !== null) {
		const Yi = {};
		for (const ea in ue) Object.prototype.hasOwnProperty.call(ue, ea) && (Yi[ea] = ue[ea]);
		return Yi
	} else return {}
}

function extractExceptionKeysForMessage(ue, Yi = 40) {
	const ea = Object.keys(convertToPlainObject(ue));
	if (ea.sort(), !ea.length) return "[object has no keys]";
	if (ea[0].length >= Yi) return truncate(ea[0], Yi);
	for (let ta = ea.length; ta > 0; ta--) {
		const na = ea.slice(0, ta).join(", ");
		if (!(na.length > Yi)) return ta === ea.length ? na : truncate(na, Yi)
	}
	return ""
}

function dropUndefinedKeys(ue) {
	return _dropUndefinedKeys(ue, new Map)
}

function _dropUndefinedKeys(ue, Yi) {
	if (isPojo(ue)) {
		const ea = Yi.get(ue);
		if (ea !== void 0) return ea;
		const ta = {};
		Yi.set(ue, ta);
		for (const na of Object.keys(ue)) typeof ue[na] < "u" && (ta[na] = _dropUndefinedKeys(ue[na], Yi));
		return ta
	}
	if (Array.isArray(ue)) {
		const ea = Yi.get(ue);
		if (ea !== void 0) return ea;
		const ta = [];
		return Yi.set(ue, ta), ue.forEach(na => {
			ta.push(_dropUndefinedKeys(na, Yi))
		}), ta
	}
	return ue
}

function isPojo(ue) {
	if (!isPlainObject(ue)) return !1;
	try {
		const Yi = Object.getPrototypeOf(ue).constructor.name;
		return !Yi || Yi === "Object"
	} catch {
		return !0
	}
}
const STACKTRACE_FRAME_LIMIT = 50,
	WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/,
	STRIP_FRAME_REGEXP = /captureMessage|captureException/;

function createStackParser(...ue) {
	const Yi = ue.sort((ea, ta) => ea[0] - ta[0]).map(ea => ea[1]);
	return (ea, ta = 0) => {
		const na = [],
			ra = ea.split(`
`);
		for (let ia = ta; ia < ra.length; ia++) {
			const aa = ra[ia];
			if (aa.length > 1024) continue;
			const oa = WEBPACK_ERROR_REGEXP.test(aa) ? aa.replace(WEBPACK_ERROR_REGEXP, "$1") : aa;
			if (!oa.match(/\S*Error: /)) {
				for (const la of Yi) {
					const sa = la(oa);
					if (sa) {
						na.push(sa);
						break
					}
				}
				if (na.length >= STACKTRACE_FRAME_LIMIT) break
			}
		}
		return stripSentryFramesAndReverse(na)
	}
}

function stackParserFromStackParserOptions(ue) {
	return Array.isArray(ue) ? createStackParser(...ue) : ue
}

function stripSentryFramesAndReverse(ue) {
	if (!ue.length) return [];
	const Yi = Array.from(ue);
	return /sentryWrapped/.test(Yi[Yi.length - 1].function || "") && Yi.pop(), Yi.reverse(), STRIP_FRAME_REGEXP.test(Yi[Yi.length - 1].function || "") && (Yi.pop(), STRIP_FRAME_REGEXP.test(Yi[Yi.length - 1].function || "") && Yi.pop()), Yi.slice(0, STACKTRACE_FRAME_LIMIT).map(ea => ({
		...ea,
		filename: ea.filename || Yi[Yi.length - 1].filename,
		function: ea.function || "?"
	}))
}
const defaultFunctionName = "<anonymous>";

function getFunctionName(ue) {
	try {
		return !ue || typeof ue != "function" ? defaultFunctionName : ue.name || defaultFunctionName
	} catch {
		return defaultFunctionName
	}
}
const handlers$2 = {},
	instrumented$1 = {};

function addHandler$1(ue, Yi) {
	handlers$2[ue] = handlers$2[ue] || [], handlers$2[ue].push(Yi)
}

function maybeInstrument(ue, Yi) {
	instrumented$1[ue] || (Yi(), instrumented$1[ue] = !0)
}

function triggerHandlers$1(ue, Yi) {
	const ea = ue && handlers$2[ue];
	if (ea)
		for (const ta of ea) try {
			ta(Yi)
		} catch (na) {
			DEBUG_BUILD$6 && logger.error(`Error while triggering instrumentation handler.
Type: ${ue}
Name: ${getFunctionName(ta)}
Error:`, na)
		}
}

function addConsoleInstrumentationHandler(ue) {
	const Yi = "console";
	addHandler$1(Yi, ue), maybeInstrument(Yi, instrumentConsole)
}

function instrumentConsole() {
	"console" in GLOBAL_OBJ && CONSOLE_LEVELS.forEach(function(ue) {
		ue in GLOBAL_OBJ.console && fill(GLOBAL_OBJ.console, ue, function(Yi) {
			return originalConsoleMethods[ue] = Yi,
				function(...ea) {
					triggerHandlers$1("console", {
						args: ea,
						level: ue
					});
					const na = originalConsoleMethods[ue];
					na && na.apply(GLOBAL_OBJ.console, ea)
				}
		})
	})
}

function uuid4() {
	const ue = GLOBAL_OBJ,
		Yi = ue.crypto || ue.msCrypto;
	let ea = () => Math.random() * 16;
	try {
		if (Yi && Yi.randomUUID) return Yi.randomUUID().replace(/-/g, "");
		Yi && Yi.getRandomValues && (ea = () => {
			const ta = new Uint8Array(1);
			return Yi.getRandomValues(ta), ta[0]
		})
	} catch {}
	return ("10000000100040008000" + 1e11).replace(/[018]/g, ta => (ta ^ (ea() & 15) >> ta / 4).toString(16))
}

function getFirstException(ue) {
	return ue.exception && ue.exception.values ? ue.exception.values[0] : void 0
}

function getEventDescription(ue) {
	const {
		message: Yi,
		event_id: ea
	} = ue;
	if (Yi) return Yi;
	const ta = getFirstException(ue);
	return ta ? ta.type && ta.value ? `${ta.type}: ${ta.value}` : ta.type || ta.value || ea || "<unknown>" : ea || "<unknown>"
}

function addExceptionTypeValue(ue, Yi, ea) {
	const ta = ue.exception = ue.exception || {},
		na = ta.values = ta.values || [],
		ra = na[0] = na[0] || {};
	ra.value || (ra.value = Yi || ""), ra.type || (ra.type = "Error")
}

function addExceptionMechanism(ue, Yi) {
	const ea = getFirstException(ue);
	if (!ea) return;
	const ta = {
			type: "generic",
			handled: !0
		},
		na = ea.mechanism;
	if (ea.mechanism = {
			...ta,
			...na,
			...Yi
		}, Yi && "data" in Yi) {
		const ra = {
			...na && na.data,
			...Yi.data
		};
		ea.mechanism.data = ra
	}
}

function checkOrSetAlreadyCaught(ue) {
	if (ue && ue.__sentry_captured__) return !0;
	try {
		addNonEnumerableProperty(ue, "__sentry_captured__", !0)
	} catch {}
	return !1
}

function arrayify(ue) {
	return Array.isArray(ue) ? ue : [ue]
}
const WINDOW$8 = GLOBAL_OBJ,
	DEBOUNCE_DURATION = 1e3;
let debounceTimerID, lastCapturedEventType, lastCapturedEventTargetId;

function addClickKeypressInstrumentationHandler(ue) {
	const Yi = "dom";
	addHandler$1(Yi, ue), maybeInstrument(Yi, instrumentDOM)
}

function instrumentDOM() {
	if (!WINDOW$8.document) return;
	const ue = triggerHandlers$1.bind(null, "dom"),
		Yi = makeDOMEventHandler(ue, !0);
	WINDOW$8.document.addEventListener("click", Yi, !1), WINDOW$8.document.addEventListener("keypress", Yi, !1), ["EventTarget", "Node"].forEach(ea => {
		const ta = WINDOW$8[ea] && WINDOW$8[ea].prototype;
		!ta || !ta.hasOwnProperty || !ta.hasOwnProperty("addEventListener") || (fill(ta, "addEventListener", function(na) {
			return function(ra, ia, aa) {
				if (ra === "click" || ra == "keypress") try {
					const oa = this,
						la = oa.__sentry_instrumentation_handlers__ = oa.__sentry_instrumentation_handlers__ || {},
						sa = la[ra] = la[ra] || {
							refCount: 0
						};
					if (!sa.handler) {
						const ca = makeDOMEventHandler(ue);
						sa.handler = ca, na.call(this, ra, ca, aa)
					}
					sa.refCount++
				} catch {}
				return na.call(this, ra, ia, aa)
			}
		}), fill(ta, "removeEventListener", function(na) {
			return function(ra, ia, aa) {
				if (ra === "click" || ra == "keypress") try {
					const oa = this,
						la = oa.__sentry_instrumentation_handlers__ || {},
						sa = la[ra];
					sa && (sa.refCount--, sa.refCount <= 0 && (na.call(this, ra, sa.handler, aa), sa.handler = void 0, delete la[ra]), Object.keys(la).length === 0 && delete oa.__sentry_instrumentation_handlers__)
				} catch {}
				return na.call(this, ra, ia, aa)
			}
		}))
	})
}

function isSimilarToLastCapturedEvent(ue) {
	if (ue.type !== lastCapturedEventType) return !1;
	try {
		if (!ue.target || ue.target._sentryId !== lastCapturedEventTargetId) return !1
	} catch {}
	return !0
}

function shouldSkipDOMEvent(ue, Yi) {
	return ue !== "keypress" ? !1 : !Yi || !Yi.tagName ? !0 : !(Yi.tagName === "INPUT" || Yi.tagName === "TEXTAREA" || Yi.isContentEditable)
}

function makeDOMEventHandler(ue, Yi = !1) {
	return ea => {
		if (!ea || ea._sentryCaptured) return;
		const ta = getEventTarget$1(ea);
		if (shouldSkipDOMEvent(ea.type, ta)) return;
		addNonEnumerableProperty(ea, "_sentryCaptured", !0), ta && !ta._sentryId && addNonEnumerableProperty(ta, "_sentryId", uuid4());
		const na = ea.type === "keypress" ? "input" : ea.type;
		isSimilarToLastCapturedEvent(ea) || (ue({
			event: ea,
			name: na,
			global: Yi
		}), lastCapturedEventType = ea.type, lastCapturedEventTargetId = ta ? ta._sentryId : void 0), clearTimeout(debounceTimerID), debounceTimerID = WINDOW$8.setTimeout(() => {
			lastCapturedEventTargetId = void 0, lastCapturedEventType = void 0
		}, DEBOUNCE_DURATION)
	}
}

function getEventTarget$1(ue) {
	try {
		return ue.target
	} catch {
		return null
	}
}
const WINDOW$7 = getGlobalObject();

function supportsFetch() {
	if (!("fetch" in WINDOW$7)) return !1;
	try {
		return new Headers, new Request("http://www.example.com"), new Response, !0
	} catch {
		return !1
	}
}

function isNativeFetch(ue) {
	return ue && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(ue.toString())
}

function supportsNativeFetch() {
	if (typeof EdgeRuntime == "string") return !0;
	if (!supportsFetch()) return !1;
	if (isNativeFetch(WINDOW$7.fetch)) return !0;
	let ue = !1;
	const Yi = WINDOW$7.document;
	if (Yi && typeof Yi.createElement == "function") try {
		const ea = Yi.createElement("iframe");
		ea.hidden = !0, Yi.head.appendChild(ea), ea.contentWindow && ea.contentWindow.fetch && (ue = isNativeFetch(ea.contentWindow.fetch)), Yi.head.removeChild(ea)
	} catch (ea) {
		DEBUG_BUILD$6 && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", ea)
	}
	return ue
}

function addFetchInstrumentationHandler(ue) {
	const Yi = "fetch";
	addHandler$1(Yi, ue), maybeInstrument(Yi, instrumentFetch)
}

function instrumentFetch() {
	supportsNativeFetch() && fill(GLOBAL_OBJ, "fetch", function(ue) {
		return function(...Yi) {
			const {
				method: ea,
				url: ta
			} = parseFetchArgs(Yi), na = {
				args: Yi,
				fetchData: {
					method: ea,
					url: ta
				},
				startTimestamp: Date.now()
			};
			return triggerHandlers$1("fetch", {
				...na
			}), ue.apply(GLOBAL_OBJ, Yi).then(ra => {
				const ia = {
					...na,
					endTimestamp: Date.now(),
					response: ra
				};
				return triggerHandlers$1("fetch", ia), ra
			}, ra => {
				const ia = {
					...na,
					endTimestamp: Date.now(),
					error: ra
				};
				throw triggerHandlers$1("fetch", ia), ra
			})
		}
	})
}

function hasProp(ue, Yi) {
	return !!ue && typeof ue == "object" && !!ue[Yi]
}

function getUrlFromResource(ue) {
	return typeof ue == "string" ? ue : ue ? hasProp(ue, "url") ? ue.url : ue.toString ? ue.toString() : "" : ""
}

function parseFetchArgs(ue) {
	if (ue.length === 0) return {
		method: "GET",
		url: ""
	};
	if (ue.length === 2) {
		const [ea, ta] = ue;
		return {
			url: getUrlFromResource(ea),
			method: hasProp(ta, "method") ? String(ta.method).toUpperCase() : "GET"
		}
	}
	const Yi = ue[0];
	return {
		url: getUrlFromResource(Yi),
		method: hasProp(Yi, "method") ? String(Yi.method).toUpperCase() : "GET"
	}
}
let _oldOnErrorHandler = null;

function addGlobalErrorInstrumentationHandler(ue) {
	const Yi = "error";
	addHandler$1(Yi, ue), maybeInstrument(Yi, instrumentError)
}

function instrumentError() {
	_oldOnErrorHandler = GLOBAL_OBJ.onerror, GLOBAL_OBJ.onerror = function(ue, Yi, ea, ta, na) {
		return triggerHandlers$1("error", {
			column: ta,
			error: na,
			line: ea,
			msg: ue,
			url: Yi
		}), _oldOnErrorHandler && !_oldOnErrorHandler.__SENTRY_LOADER__ ? _oldOnErrorHandler.apply(this, arguments) : !1
	}, GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = !0
}
let _oldOnUnhandledRejectionHandler = null;

function addGlobalUnhandledRejectionInstrumentationHandler(ue) {
	const Yi = "unhandledrejection";
	addHandler$1(Yi, ue), maybeInstrument(Yi, instrumentUnhandledRejection)
}

function instrumentUnhandledRejection() {
	_oldOnUnhandledRejectionHandler = GLOBAL_OBJ.onunhandledrejection, GLOBAL_OBJ.onunhandledrejection = function(ue) {
		return triggerHandlers$1("unhandledrejection", ue), _oldOnUnhandledRejectionHandler && !_oldOnUnhandledRejectionHandler.__SENTRY_LOADER__ ? _oldOnUnhandledRejectionHandler.apply(this, arguments) : !0
	}, GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
}
const WINDOW$6 = getGlobalObject();

function supportsHistory() {
	const ue = WINDOW$6.chrome,
		Yi = ue && ue.app && ue.app.runtime,
		ea = "history" in WINDOW$6 && !!WINDOW$6.history.pushState && !!WINDOW$6.history.replaceState;
	return !Yi && ea
}
const WINDOW$5 = GLOBAL_OBJ;
let lastHref;

function addHistoryInstrumentationHandler(ue) {
	const Yi = "history";
	addHandler$1(Yi, ue), maybeInstrument(Yi, instrumentHistory)
}

function instrumentHistory() {
	if (!supportsHistory()) return;
	const ue = WINDOW$5.onpopstate;
	WINDOW$5.onpopstate = function(...ea) {
		const ta = WINDOW$5.location.href,
			na = lastHref;
		if (lastHref = ta, triggerHandlers$1("history", {
				from: na,
				to: ta
			}), ue) try {
			return ue.apply(this, ea)
		} catch {}
	};

	function Yi(ea) {
		return function(...ta) {
			const na = ta.length > 2 ? ta[2] : void 0;
			if (na) {
				const ra = lastHref,
					ia = String(na);
				lastHref = ia, triggerHandlers$1("history", {
					from: ra,
					to: ia
				})
			}
			return ea.apply(this, ta)
		}
	}
	fill(WINDOW$5.history, "pushState", Yi), fill(WINDOW$5.history, "replaceState", Yi)
}
const WINDOW$4 = GLOBAL_OBJ,
	SENTRY_XHR_DATA_KEY = "__sentry_xhr_v3__";

function addXhrInstrumentationHandler(ue) {
	const Yi = "xhr";
	addHandler$1(Yi, ue), maybeInstrument(Yi, instrumentXHR)
}

function instrumentXHR() {
	if (!WINDOW$4.XMLHttpRequest) return;
	const ue = XMLHttpRequest.prototype;
	fill(ue, "open", function(Yi) {
		return function(...ea) {
			const ta = Date.now(),
				na = isString(ea[0]) ? ea[0].toUpperCase() : void 0,
				ra = parseUrl$1(ea[1]);
			if (!na || !ra) return Yi.apply(this, ea);
			this[SENTRY_XHR_DATA_KEY] = {
				method: na,
				url: ra,
				request_headers: {}
			}, na === "POST" && ra.match(/sentry_key/) && (this.__sentry_own_request__ = !0);
			const ia = () => {
				const aa = this[SENTRY_XHR_DATA_KEY];
				if (aa && this.readyState === 4) {
					try {
						aa.status_code = this.status
					} catch {}
					const oa = {
						args: [na, ra],
						endTimestamp: Date.now(),
						startTimestamp: ta,
						xhr: this
					};
					triggerHandlers$1("xhr", oa)
				}
			};
			return "onreadystatechange" in this && typeof this.onreadystatechange == "function" ? fill(this, "onreadystatechange", function(aa) {
				return function(...oa) {
					return ia(), aa.apply(this, oa)
				}
			}) : this.addEventListener("readystatechange", ia), fill(this, "setRequestHeader", function(aa) {
				return function(...oa) {
					const [la, sa] = oa, ca = this[SENTRY_XHR_DATA_KEY];
					return ca && isString(la) && isString(sa) && (ca.request_headers[la.toLowerCase()] = sa), aa.apply(this, oa)
				}
			}), Yi.apply(this, ea)
		}
	}), fill(ue, "send", function(Yi) {
		return function(...ea) {
			const ta = this[SENTRY_XHR_DATA_KEY];
			if (!ta) return Yi.apply(this, ea);
			ea[0] !== void 0 && (ta.body = ea[0]);
			const na = {
				args: [ta.method, ta.url],
				startTimestamp: Date.now(),
				xhr: this
			};
			return triggerHandlers$1("xhr", na), Yi.apply(this, ea)
		}
	})
}

function parseUrl$1(ue) {
	if (isString(ue)) return ue;
	try {
		return ue.toString()
	} catch {}
}

function isBrowserBundle() {
	return typeof __SENTRY_BROWSER_BUNDLE__ < "u" && !!__SENTRY_BROWSER_BUNDLE__
}

function getSDKSource() {
	return "npm"
}

function isNodeEnv() {
	return !isBrowserBundle() && Object.prototype.toString.call(typeof process$1 < "u" ? process$1 : 0) === "[object process]"
}

function isBrowser() {
	return typeof window < "u" && (!isNodeEnv() || isElectronNodeRenderer())
}

function isElectronNodeRenderer() {
	return GLOBAL_OBJ.process !== void 0 && GLOBAL_OBJ.process.type === "renderer"
}

function memoBuilder() {
	const ue = typeof WeakSet == "function",
		Yi = ue ? new WeakSet : [];

	function ea(na) {
		if (ue) return Yi.has(na) ? !0 : (Yi.add(na), !1);
		for (let ra = 0; ra < Yi.length; ra++)
			if (Yi[ra] === na) return !0;
		return Yi.push(na), !1
	}

	function ta(na) {
		if (ue) Yi.delete(na);
		else
			for (let ra = 0; ra < Yi.length; ra++)
				if (Yi[ra] === na) {
					Yi.splice(ra, 1);
					break
				}
	}
	return [ea, ta]
}

function normalize(ue, Yi = 100, ea = 1 / 0) {
	try {
		return visit("", ue, Yi, ea)
	} catch (ta) {
		return {
			ERROR: `**non-serializable** (${ta})`
		}
	}
}

function normalizeToSize(ue, Yi = 3, ea = 100 * 1024) {
	const ta = normalize(ue, Yi);
	return jsonSize(ta) > ea ? normalizeToSize(ue, Yi - 1, ea) : ta
}

function visit(ue, Yi, ea = 1 / 0, ta = 1 / 0, na = memoBuilder()) {
	const [ra, ia] = na;
	if (Yi == null || ["number", "boolean", "string"].includes(typeof Yi) && !isNaN$1(Yi)) return Yi;
	const aa = stringifyValue(ue, Yi);
	if (!aa.startsWith("[object ")) return aa;
	if (Yi.__sentry_skip_normalization__) return Yi;
	const oa = typeof Yi.__sentry_override_normalization_depth__ == "number" ? Yi.__sentry_override_normalization_depth__ : ea;
	if (oa === 0) return aa.replace("object ", "");
	if (ra(Yi)) return "[Circular ~]";
	const la = Yi;
	if (la && typeof la.toJSON == "function") try {
		const da = la.toJSON();
		return visit("", da, oa - 1, ta, na)
	} catch {}
	const sa = Array.isArray(Yi) ? [] : {};
	let ca = 0;
	const ua = convertToPlainObject(Yi);
	for (const da in ua) {
		if (!Object.prototype.hasOwnProperty.call(ua, da)) continue;
		if (ca >= ta) {
			sa[da] = "[MaxProperties ~]";
			break
		}
		const ha = ua[da];
		sa[da] = visit(da, ha, oa - 1, ta, na), ca++
	}
	return ia(Yi), sa
}

function stringifyValue(ue, Yi) {
	try {
		if (ue === "domain" && Yi && typeof Yi == "object" && Yi._events) return "[Domain]";
		if (ue === "domainEmitter") return "[DomainEmitter]";
		if (typeof global$1 < "u" && Yi === global$1) return "[Global]";
		if (typeof window < "u" && Yi === window) return "[Window]";
		if (typeof document < "u" && Yi === document) return "[Document]";
		if (isVueViewModel(Yi)) return "[VueViewModel]";
		if (isSyntheticEvent(Yi)) return "[SyntheticEvent]";
		if (typeof Yi == "number" && Yi !== Yi) return "[NaN]";
		if (typeof Yi == "function") return `[Function: ${getFunctionName(Yi)}]`;
		if (typeof Yi == "symbol") return `[${String(Yi)}]`;
		if (typeof Yi == "bigint") return `[BigInt: ${String(Yi)}]`;
		const ea = getConstructorName(Yi);
		return /^HTML(\w*)Element$/.test(ea) ? `[HTMLElement: ${ea}]` : `[object ${ea}]`
	} catch (ea) {
		return `**non-serializable** (${ea})`
	}
}

function getConstructorName(ue) {
	const Yi = Object.getPrototypeOf(ue);
	return Yi ? Yi.constructor.name : "null prototype"
}

function utf8Length(ue) {
	return ~-encodeURI(ue).split(/%..|./).length
}

function jsonSize(ue) {
	return utf8Length(JSON.stringify(ue))
}
var States;
(function(ue) {
	ue[ue.PENDING = 0] = "PENDING";
	const ea = 1;
	ue[ue.RESOLVED = ea] = "RESOLVED";
	const ta = 2;
	ue[ue.REJECTED = ta] = "REJECTED"
})(States || (States = {}));

function resolvedSyncPromise(ue) {
	return new SyncPromise(Yi => {
		Yi(ue)
	})
}

function rejectedSyncPromise(ue) {
	return new SyncPromise((Yi, ea) => {
		ea(ue)
	})
}
class SyncPromise {
	constructor(Yi) {
		SyncPromise.prototype.__init.call(this), SyncPromise.prototype.__init2.call(this), SyncPromise.prototype.__init3.call(this), SyncPromise.prototype.__init4.call(this), this._state = States.PENDING, this._handlers = [];
		try {
			Yi(this._resolve, this._reject)
		} catch (ea) {
			this._reject(ea)
		}
	}
	then(Yi, ea) {
		return new SyncPromise((ta, na) => {
			this._handlers.push([!1, ra => {
				if (!Yi) ta(ra);
				else try {
					ta(Yi(ra))
				} catch (ia) {
					na(ia)
				}
			}, ra => {
				if (!ea) na(ra);
				else try {
					ta(ea(ra))
				} catch (ia) {
					na(ia)
				}
			}]), this._executeHandlers()
		})
	} catch (Yi) {
		return this.then(ea => ea, Yi)
	} finally(Yi) {
		return new SyncPromise((ea, ta) => {
			let na, ra;
			return this.then(ia => {
				ra = !1, na = ia, Yi && Yi()
			}, ia => {
				ra = !0, na = ia, Yi && Yi()
			}).then(() => {
				if (ra) {
					ta(na);
					return
				}
				ea(na)
			})
		})
	}
	__init() {
		this._resolve = Yi => {
			this._setResult(States.RESOLVED, Yi)
		}
	}
	__init2() {
		this._reject = Yi => {
			this._setResult(States.REJECTED, Yi)
		}
	}
	__init3() {
		this._setResult = (Yi, ea) => {
			if (this._state === States.PENDING) {
				if (isThenable(ea)) {
					ea.then(this._resolve, this._reject);
					return
				}
				this._state = Yi, this._value = ea, this._executeHandlers()
			}
		}
	}
	__init4() {
		this._executeHandlers = () => {
			if (this._state === States.PENDING) return;
			const Yi = this._handlers.slice();
			this._handlers = [], Yi.forEach(ea => {
				ea[0] || (this._state === States.RESOLVED && ea[1](this._value), this._state === States.REJECTED && ea[2](this._value), ea[0] = !0)
			})
		}
	}
}

function makePromiseBuffer(ue) {
	const Yi = [];

	function ea() {
		return ue === void 0 || Yi.length < ue
	}

	function ta(ia) {
		return Yi.splice(Yi.indexOf(ia), 1)[0]
	}

	function na(ia) {
		if (!ea()) return rejectedSyncPromise(new SentryError("Not adding Promise because buffer limit was reached."));
		const aa = ia();
		return Yi.indexOf(aa) === -1 && Yi.push(aa), aa.then(() => ta(aa)).then(null, () => ta(aa).then(null, () => {})), aa
	}

	function ra(ia) {
		return new SyncPromise((aa, oa) => {
			let la = Yi.length;
			if (!la) return aa(!0);
			const sa = setTimeout(() => {
				ia && ia > 0 && aa(!1)
			}, ia);
			Yi.forEach(ca => {
				resolvedSyncPromise(ca).then(() => {
					--la || (clearTimeout(sa), aa(!0))
				}, oa)
			})
		})
	}
	return {
		$: Yi,
		add: na,
		drain: ra
	}
}

function parseUrl(ue) {
	if (!ue) return {};
	const Yi = ue.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
	if (!Yi) return {};
	const ea = Yi[6] || "",
		ta = Yi[8] || "";
	return {
		host: Yi[4],
		path: Yi[5],
		protocol: Yi[2],
		search: ea,
		hash: ta,
		relative: Yi[5] + ea + ta
	}
}
const validSeverityLevels = ["fatal", "error", "warning", "log", "info", "debug"];

function severityLevelFromString(ue) {
	return ue === "warn" ? "warning" : validSeverityLevels.includes(ue) ? ue : "log"
}
const ONE_SECOND_IN_MS = 1e3;

function dateTimestampInSeconds() {
	return Date.now() / ONE_SECOND_IN_MS
}

function createUnixTimestampInSecondsFunc() {
	const {
		performance: ue
	} = GLOBAL_OBJ;
	if (!ue || !ue.now) return dateTimestampInSeconds;
	const Yi = Date.now() - ue.now(),
		ea = ue.timeOrigin == null ? Yi : ue.timeOrigin;
	return () => (ea + ue.now()) / ONE_SECOND_IN_MS
}
const timestampInSeconds = createUnixTimestampInSecondsFunc(),
	browserPerformanceTimeOrigin = (() => {
		const {
			performance: ue
		} = GLOBAL_OBJ;
		if (!ue || !ue.now) return;
		const Yi = 3600 * 1e3,
			ea = ue.now(),
			ta = Date.now(),
			na = ue.timeOrigin ? Math.abs(ue.timeOrigin + ea - ta) : Yi,
			ra = na < Yi,
			ia = ue.timing && ue.timing.navigationStart,
			oa = typeof ia == "number" ? Math.abs(ia + ea - ta) : Yi,
			la = oa < Yi;
		return ra || la ? na <= oa ? ue.timeOrigin : ia : ta
	})(),
	BAGGAGE_HEADER_NAME = "baggage",
	SENTRY_BAGGAGE_KEY_PREFIX = "sentry-",
	SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/,
	MAX_BAGGAGE_STRING_LENGTH = 8192;

function baggageHeaderToDynamicSamplingContext(ue) {
	if (!isString(ue) && !Array.isArray(ue)) return;
	let Yi = {};
	if (Array.isArray(ue)) Yi = ue.reduce((ta, na) => {
		const ra = baggageHeaderToObject(na);
		for (const ia of Object.keys(ra)) ta[ia] = ra[ia];
		return ta
	}, {});
	else {
		if (!ue) return;
		Yi = baggageHeaderToObject(ue)
	}
	const ea = Object.entries(Yi).reduce((ta, [na, ra]) => {
		if (na.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {
			const ia = na.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);
			ta[ia] = ra
		}
		return ta
	}, {});
	if (Object.keys(ea).length > 0) return ea
}

function dynamicSamplingContextToSentryBaggageHeader(ue) {
	if (!ue) return;
	const Yi = Object.entries(ue).reduce((ea, [ta, na]) => (na && (ea[`${SENTRY_BAGGAGE_KEY_PREFIX}${ta}`] = na), ea), {});
	return objectToBaggageHeader(Yi)
}

function baggageHeaderToObject(ue) {
	return ue.split(",").map(Yi => Yi.split("=").map(ea => decodeURIComponent(ea.trim()))).reduce((Yi, [ea, ta]) => (Yi[ea] = ta, Yi), {})
}

function objectToBaggageHeader(ue) {
	if (Object.keys(ue).length !== 0) return Object.entries(ue).reduce((Yi, [ea, ta], na) => {
		const ra = `${encodeURIComponent(ea)}=${encodeURIComponent(ta)}`,
			ia = na === 0 ? ra : `${Yi},${ra}`;
		return ia.length > MAX_BAGGAGE_STRING_LENGTH ? (DEBUG_BUILD$6 && logger.warn(`Not adding key: ${ea} with val: ${ta} to baggage header due to exceeding baggage size limits.`), Yi) : ia
	}, "")
}
const TRACEPARENT_REGEXP = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");

function extractTraceparentData$1(ue) {
	if (!ue) return;
	const Yi = ue.match(TRACEPARENT_REGEXP);
	if (!Yi) return;
	let ea;
	return Yi[3] === "1" ? ea = !0 : Yi[3] === "0" && (ea = !1), {
		traceId: Yi[1],
		parentSampled: ea,
		parentSpanId: Yi[2]
	}
}

function tracingContextFromHeaders(ue, Yi) {
	const ea = extractTraceparentData$1(ue),
		ta = baggageHeaderToDynamicSamplingContext(Yi),
		{
			traceId: na,
			parentSpanId: ra,
			parentSampled: ia
		} = ea || {};
	return ea ? {
		traceparentData: ea,
		dynamicSamplingContext: ta || {},
		propagationContext: {
			traceId: na || uuid4(),
			parentSpanId: ra || uuid4().substring(16),
			spanId: uuid4().substring(16),
			sampled: ia,
			dsc: ta || {}
		}
	} : {
		traceparentData: ea,
		dynamicSamplingContext: void 0,
		propagationContext: {
			traceId: na || uuid4(),
			spanId: uuid4().substring(16)
		}
	}
}

function propagationContextFromHeaders(ue, Yi) {
	const ea = extractTraceparentData$1(ue),
		ta = baggageHeaderToDynamicSamplingContext(Yi),
		{
			traceId: na,
			parentSpanId: ra,
			parentSampled: ia
		} = ea || {};
	return ea ? {
		traceId: na || uuid4(),
		parentSpanId: ra || uuid4().substring(16),
		spanId: uuid4().substring(16),
		sampled: ia,
		dsc: ta || {}
	} : {
		traceId: na || uuid4(),
		spanId: uuid4().substring(16)
	}
}

function generateSentryTraceHeader(ue = uuid4(), Yi = uuid4().substring(16), ea) {
	let ta = "";
	return ea !== void 0 && (ta = ea ? "-1" : "-0"), `${ue}-${Yi}${ta}`
}

function createEnvelope(ue, Yi = []) {
	return [ue, Yi]
}

function addItemToEnvelope(ue, Yi) {
	const [ea, ta] = ue;
	return [ea, [...ta, Yi]]
}

function forEachEnvelopeItem(ue, Yi) {
	const ea = ue[1];
	for (const ta of ea) {
		const na = ta[0].type;
		if (Yi(ta, na)) return !0
	}
	return !1
}

function envelopeContainsItemType(ue, Yi) {
	return forEachEnvelopeItem(ue, (ea, ta) => Yi.includes(ta))
}

function encodeUTF8(ue, Yi) {
	return (Yi || new TextEncoder).encode(ue)
}

function serializeEnvelope(ue, Yi) {
	const [ea, ta] = ue;
	let na = JSON.stringify(ea);

	function ra(ia) {
		typeof na == "string" ? na = typeof ia == "string" ? na + ia : [encodeUTF8(na, Yi), ia] : na.push(typeof ia == "string" ? encodeUTF8(ia, Yi) : ia)
	}
	for (const ia of ta) {
		const [aa, oa] = ia;
		if (ra(`
${JSON.stringify(aa)}
`), typeof oa == "string" || oa instanceof Uint8Array) ra(oa);
		else {
			let la;
			try {
				la = JSON.stringify(oa)
			} catch {
				la = JSON.stringify(normalize(oa))
			}
			ra(la)
		}
	}
	return typeof na == "string" ? na : concatBuffers(na)
}

function concatBuffers(ue) {
	const Yi = ue.reduce((na, ra) => na + ra.length, 0),
		ea = new Uint8Array(Yi);
	let ta = 0;
	for (const na of ue) ea.set(na, ta), ta += na.length;
	return ea
}

function parseEnvelope(ue, Yi, ea) {
	let ta = typeof ue == "string" ? Yi.encode(ue) : ue;

	function na(oa) {
		const la = ta.subarray(0, oa);
		return ta = ta.subarray(oa + 1), la
	}

	function ra() {
		let oa = ta.indexOf(10);
		return oa < 0 && (oa = ta.length), JSON.parse(ea.decode(na(oa)))
	}
	const ia = ra(),
		aa = [];
	for (; ta.length;) {
		const oa = ra(),
			la = typeof oa.length == "number" ? oa.length : void 0;
		aa.push([oa, la ? na(la) : ra()])
	}
	return [ia, aa]
}

function createAttachmentEnvelopeItem(ue, Yi) {
	const ea = typeof ue.data == "string" ? encodeUTF8(ue.data, Yi) : ue.data;
	return [dropUndefinedKeys({
		type: "attachment",
		length: ea.length,
		filename: ue.filename,
		content_type: ue.contentType,
		attachment_type: ue.attachmentType
	}), ea]
}
const ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
	session: "session",
	sessions: "session",
	attachment: "attachment",
	transaction: "transaction",
	event: "error",
	client_report: "internal",
	user_report: "default",
	profile: "profile",
	replay_event: "replay",
	replay_recording: "replay",
	check_in: "monitor",
	feedback: "feedback",
	span: "span",
	statsd: "metric_bucket"
};

function envelopeItemTypeToDataCategory(ue) {
	return ITEM_TYPE_TO_DATA_CATEGORY_MAP[ue]
}

function getSdkMetadataForEnvelopeHeader(ue) {
	if (!ue || !ue.sdk) return;
	const {
		name: Yi,
		version: ea
	} = ue.sdk;
	return {
		name: Yi,
		version: ea
	}
}

function createEventEnvelopeHeaders(ue, Yi, ea, ta) {
	const na = ue.sdkProcessingMetadata && ue.sdkProcessingMetadata.dynamicSamplingContext;
	return {
		event_id: ue.event_id,
		sent_at: new Date().toISOString(),
		...Yi && {
			sdk: Yi
		},
		...!!ea && ta && {
			dsn: dsnToString(ta)
		},
		...na && {
			trace: dropUndefinedKeys({
				...na
			})
		}
	}
}

function createClientReportEnvelope(ue, Yi, ea) {
	const ta = [{
		type: "client_report"
	}, {
		timestamp: dateTimestampInSeconds(),
		discarded_events: ue
	}];
	return createEnvelope(Yi ? {
		dsn: Yi
	} : {}, [ta])
}
const DEFAULT_RETRY_AFTER = 60 * 1e3;

function parseRetryAfterHeader(ue, Yi = Date.now()) {
	const ea = parseInt(`${ue}`, 10);
	if (!isNaN(ea)) return ea * 1e3;
	const ta = Date.parse(`${ue}`);
	return isNaN(ta) ? DEFAULT_RETRY_AFTER : ta - Yi
}

function disabledUntil(ue, Yi) {
	return ue[Yi] || ue.all || 0
}

function isRateLimited(ue, Yi, ea = Date.now()) {
	return disabledUntil(ue, Yi) > ea
}

function updateRateLimits(ue, {
	statusCode: Yi,
	headers: ea
}, ta = Date.now()) {
	const na = {
			...ue
		},
		ra = ea && ea["x-sentry-rate-limits"],
		ia = ea && ea["retry-after"];
	if (ra)
		for (const aa of ra.trim().split(",")) {
			const [oa, la, , , sa] = aa.split(":", 5), ca = parseInt(oa, 10), ua = (isNaN(ca) ? 60 : ca) * 1e3;
			if (!la) na.all = ta + ua;
			else
				for (const da of la.split(";")) da === "metric_bucket" ? (!sa || sa.split(";").includes("custom")) && (na[da] = ta + ua) : na[da] = ta + ua
		} else ia ? na.all = ta + parseRetryAfterHeader(ia, ta) : Yi === 429 && (na.all = ta + 60 * 1e3);
	return na
}

function parseStackFrames$1(ue, Yi) {
	return ue(Yi.stack || "", 1)
}

function exceptionFromError$1(ue, Yi) {
	const ea = {
			type: Yi.name || Yi.constructor.name,
			value: Yi.message
		},
		ta = parseStackFrames$1(ue, Yi);
	return ta.length && (ea.stacktrace = {
		frames: ta
	}), ea
}

function _nullishCoalesce(ue, Yi) {
	return ue ?? Yi()
}

function _optionalChain(ue) {
	let Yi, ea = ue[0],
		ta = 1;
	for (; ta < ue.length;) {
		const na = ue[ta],
			ra = ue[ta + 1];
		if (ta += 2, (na === "optionalAccess" || na === "optionalCall") && ea == null) return;
		na === "access" || na === "optionalAccess" ? (Yi = ea, ea = ra(ea)) : (na === "call" || na === "optionalCall") && (ea = ra((...ia) => ea.call(Yi, ...ia)), Yi = void 0)
	}
	return ea
}
const DEBUG_BUILD$5 = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
	DEFAULT_ENVIRONMENT = "production";

function getGlobalEventProcessors() {
	return getGlobalSingleton("globalEventProcessors", () => [])
}

function addGlobalEventProcessor(ue) {
	getGlobalEventProcessors().push(ue)
}

function notifyEventProcessors(ue, Yi, ea, ta = 0) {
	return new SyncPromise((na, ra) => {
		const ia = ue[ta];
		if (Yi === null || typeof ia != "function") na(Yi);
		else {
			const aa = ia({
				...Yi
			}, ea);
			DEBUG_BUILD$5 && ia.id && aa === null && logger.log(`Event processor "${ia.id}" dropped event`), isThenable(aa) ? aa.then(oa => notifyEventProcessors(ue, oa, ea, ta + 1).then(na)).then(null, ra) : notifyEventProcessors(ue, aa, ea, ta + 1).then(na).then(null, ra)
		}
	})
}

function makeSession$1(ue) {
	const Yi = timestampInSeconds(),
		ea = {
			sid: uuid4(),
			init: !0,
			timestamp: Yi,
			started: Yi,
			duration: 0,
			status: "ok",
			errors: 0,
			ignoreDuration: !1,
			toJSON: () => sessionToJSON(ea)
		};
	return ue && updateSession(ea, ue), ea
}

function updateSession(ue, Yi = {}) {
	if (Yi.user && (!ue.ipAddress && Yi.user.ip_address && (ue.ipAddress = Yi.user.ip_address), !ue.did && !Yi.did && (ue.did = Yi.user.id || Yi.user.email || Yi.user.username)), ue.timestamp = Yi.timestamp || timestampInSeconds(), Yi.abnormal_mechanism && (ue.abnormal_mechanism = Yi.abnormal_mechanism), Yi.ignoreDuration && (ue.ignoreDuration = Yi.ignoreDuration), Yi.sid && (ue.sid = Yi.sid.length === 32 ? Yi.sid : uuid4()), Yi.init !== void 0 && (ue.init = Yi.init), !ue.did && Yi.did && (ue.did = `${Yi.did}`), typeof Yi.started == "number" && (ue.started = Yi.started), ue.ignoreDuration) ue.duration = void 0;
	else if (typeof Yi.duration == "number") ue.duration = Yi.duration;
	else {
		const ea = ue.timestamp - ue.started;
		ue.duration = ea >= 0 ? ea : 0
	}
	Yi.release && (ue.release = Yi.release), Yi.environment && (ue.environment = Yi.environment), !ue.ipAddress && Yi.ipAddress && (ue.ipAddress = Yi.ipAddress), !ue.userAgent && Yi.userAgent && (ue.userAgent = Yi.userAgent), typeof Yi.errors == "number" && (ue.errors = Yi.errors), Yi.status && (ue.status = Yi.status)
}

function closeSession(ue, Yi) {
	let ea = {};
	ue.status === "ok" && (ea = {
		status: "exited"
	}), updateSession(ue, ea)
}

function sessionToJSON(ue) {
	return dropUndefinedKeys({
		sid: `${ue.sid}`,
		init: ue.init,
		started: new Date(ue.started * 1e3).toISOString(),
		timestamp: new Date(ue.timestamp * 1e3).toISOString(),
		status: ue.status,
		errors: ue.errors,
		did: typeof ue.did == "number" || typeof ue.did == "string" ? `${ue.did}` : void 0,
		duration: ue.duration,
		abnormal_mechanism: ue.abnormal_mechanism,
		attrs: {
			release: ue.release,
			environment: ue.environment,
			ip_address: ue.ipAddress,
			user_agent: ue.userAgent
		}
	})
}
const TRACE_FLAG_NONE = 0,
	TRACE_FLAG_SAMPLED = 1;

function spanToTraceContext(ue) {
	const {
		spanId: Yi,
		traceId: ea
	} = ue.spanContext(), {
		data: ta,
		op: na,
		parent_span_id: ra,
		status: ia,
		tags: aa,
		origin: oa
	} = spanToJSON(ue);
	return dropUndefinedKeys({
		data: ta,
		op: na,
		parent_span_id: ra,
		span_id: Yi,
		status: ia,
		tags: aa,
		trace_id: ea,
		origin: oa
	})
}

function spanToTraceHeader(ue) {
	const {
		traceId: Yi,
		spanId: ea
	} = ue.spanContext(), ta = spanIsSampled(ue);
	return generateSentryTraceHeader(Yi, ea, ta)
}

function spanTimeInputToSeconds(ue) {
	return typeof ue == "number" ? ensureTimestampInSeconds(ue) : Array.isArray(ue) ? ue[0] + ue[1] / 1e9 : ue instanceof Date ? ensureTimestampInSeconds(ue.getTime()) : timestampInSeconds()
}

function ensureTimestampInSeconds(ue) {
	return ue > 9999999999 ? ue / 1e3 : ue
}

function spanToJSON(ue) {
	return spanIsSpanClass(ue) ? ue.getSpanJSON() : typeof ue.toJSON == "function" ? ue.toJSON() : {}
}

function spanIsSpanClass(ue) {
	return typeof ue.getSpanJSON == "function"
}

function spanIsSampled(ue) {
	const {
		traceFlags: Yi
	} = ue.spanContext();
	return !!(Yi & TRACE_FLAG_SAMPLED)
}

function prepareEvent(ue, Yi, ea, ta, na, ra) {
	const {
		normalizeDepth: ia = 3,
		normalizeMaxBreadth: aa = 1e3
	} = ue, oa = {
		...Yi,
		event_id: Yi.event_id || ea.event_id || uuid4(),
		timestamp: Yi.timestamp || dateTimestampInSeconds()
	}, la = ea.integrations || ue.integrations.map(va => va.name);
	applyClientOptions(oa, ue), applyIntegrationsMetadata(oa, la), Yi.type === void 0 && applyDebugIds(oa, ue.stackParser);
	const sa = getFinalScope(ta, ea.captureContext);
	ea.mechanism && addExceptionMechanism(oa, ea.mechanism);
	const ca = na && na.getEventProcessors ? na.getEventProcessors() : [],
		ua = getGlobalScope().getScopeData();
	if (ra) {
		const va = ra.getScopeData();
		mergeScopeData(ua, va)
	}
	if (sa) {
		const va = sa.getScopeData();
		mergeScopeData(ua, va)
	}
	const da = [...ea.attachments || [], ...ua.attachments];
	da.length && (ea.attachments = da), applyScopeDataToEvent(oa, ua);
	const ha = [...ca, ...getGlobalEventProcessors(), ...ua.eventProcessors];
	return notifyEventProcessors(ha, oa, ea).then(va => (va && applyDebugMeta(va), typeof ia == "number" && ia > 0 ? normalizeEvent(va, ia, aa) : va))
}

function applyClientOptions(ue, Yi) {
	const {
		environment: ea,
		release: ta,
		dist: na,
		maxValueLength: ra = 250
	} = Yi;
	"environment" in ue || (ue.environment = "environment" in Yi ? ea : DEFAULT_ENVIRONMENT), ue.release === void 0 && ta !== void 0 && (ue.release = ta), ue.dist === void 0 && na !== void 0 && (ue.dist = na), ue.message && (ue.message = truncate(ue.message, ra));
	const ia = ue.exception && ue.exception.values && ue.exception.values[0];
	ia && ia.value && (ia.value = truncate(ia.value, ra));
	const aa = ue.request;
	aa && aa.url && (aa.url = truncate(aa.url, ra))
}
const debugIdStackParserCache$1 = new WeakMap;

function applyDebugIds(ue, Yi) {
	const ea = GLOBAL_OBJ._sentryDebugIds;
	if (!ea) return;
	let ta;
	const na = debugIdStackParserCache$1.get(Yi);
	na ? ta = na : (ta = new Map, debugIdStackParserCache$1.set(Yi, ta));
	const ra = Object.keys(ea).reduce((ia, aa) => {
		let oa;
		const la = ta.get(aa);
		la ? oa = la : (oa = Yi(aa), ta.set(aa, oa));
		for (let sa = oa.length - 1; sa >= 0; sa--) {
			const ca = oa[sa];
			if (ca.filename) {
				ia[ca.filename] = ea[aa];
				break
			}
		}
		return ia
	}, {});
	try {
		ue.exception.values.forEach(ia => {
			ia.stacktrace.frames.forEach(aa => {
				aa.filename && (aa.debug_id = ra[aa.filename])
			})
		})
	} catch {}
}

function applyDebugMeta(ue) {
	const Yi = {};
	try {
		ue.exception.values.forEach(ta => {
			ta.stacktrace.frames.forEach(na => {
				na.debug_id && (na.abs_path ? Yi[na.abs_path] = na.debug_id : na.filename && (Yi[na.filename] = na.debug_id), delete na.debug_id)
			})
		})
	} catch {}
	if (Object.keys(Yi).length === 0) return;
	ue.debug_meta = ue.debug_meta || {}, ue.debug_meta.images = ue.debug_meta.images || [];
	const ea = ue.debug_meta.images;
	Object.keys(Yi).forEach(ta => {
		ea.push({
			type: "sourcemap",
			code_file: ta,
			debug_id: Yi[ta]
		})
	})
}

function applyIntegrationsMetadata(ue, Yi) {
	Yi.length > 0 && (ue.sdk = ue.sdk || {}, ue.sdk.integrations = [...ue.sdk.integrations || [], ...Yi])
}

function normalizeEvent(ue, Yi, ea) {
	if (!ue) return null;
	const ta = {
		...ue,
		...ue.breadcrumbs && {
			breadcrumbs: ue.breadcrumbs.map(na => ({
				...na,
				...na.data && {
					data: normalize(na.data, Yi, ea)
				}
			}))
		},
		...ue.user && {
			user: normalize(ue.user, Yi, ea)
		},
		...ue.contexts && {
			contexts: normalize(ue.contexts, Yi, ea)
		},
		...ue.extra && {
			extra: normalize(ue.extra, Yi, ea)
		}
	};
	return ue.contexts && ue.contexts.trace && ta.contexts && (ta.contexts.trace = ue.contexts.trace, ue.contexts.trace.data && (ta.contexts.trace.data = normalize(ue.contexts.trace.data, Yi, ea))), ue.spans && (ta.spans = ue.spans.map(na => {
		const ra = spanToJSON(na).data;
		return ra && (na.data = normalize(ra, Yi, ea)), na
	})), ta
}

function getFinalScope(ue, Yi) {
	if (!Yi) return ue;
	const ea = ue ? ue.clone() : new Scope;
	return ea.update(Yi), ea
}

function parseEventHintOrCaptureContext(ue) {
	if (ue) return hintIsScopeOrFunction(ue) ? {
		captureContext: ue
	} : hintIsScopeContext(ue) ? {
		captureContext: ue
	} : ue
}

function hintIsScopeOrFunction(ue) {
	return ue instanceof Scope || typeof ue == "function"
}
const captureContextKeys = ["user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext"];

function hintIsScopeContext(ue) {
	return Object.keys(ue).some(Yi => captureContextKeys.includes(Yi))
}

function captureException(ue, Yi) {
	return getCurrentHub().captureException(ue, parseEventHintOrCaptureContext(Yi))
}

function captureMessage(ue, Yi) {
	const ea = typeof Yi == "string" ? Yi : void 0,
		ta = typeof Yi != "string" ? {
			captureContext: Yi
		} : void 0;
	return getCurrentHub().captureMessage(ue, ea, ta)
}

function captureEvent(ue, Yi) {
	return getCurrentHub().captureEvent(ue, Yi)
}

function configureScope(ue) {
	getCurrentHub().configureScope(ue)
}

function addBreadcrumb(ue, Yi) {
	getCurrentHub().addBreadcrumb(ue, Yi)
}

function setContext(ue, Yi) {
	getCurrentHub().setContext(ue, Yi)
}

function setExtras(ue) {
	getCurrentHub().setExtras(ue)
}

function setExtra(ue, Yi) {
	getCurrentHub().setExtra(ue, Yi)
}

function setTags(ue) {
	getCurrentHub().setTags(ue)
}

function setTag(ue, Yi) {
	getCurrentHub().setTag(ue, Yi)
}

function setUser(ue) {
	getCurrentHub().setUser(ue)
}

function withScope(...ue) {
	const Yi = getCurrentHub();
	if (ue.length === 2) {
		const [ea, ta] = ue;
		return ea ? Yi.withScope(() => (Yi.getStackTop().scope = ea, ta(ea))) : Yi.withScope(ta)
	}
	return Yi.withScope(ue[0])
}

function withIsolationScope(ue) {
	return runWithAsyncContext(() => ue(getIsolationScope()))
}

function withActiveSpan(ue, Yi) {
	return withScope(ea => (ea.setSpan(ue), Yi(ea)))
}

function startTransaction(ue, Yi) {
	return getCurrentHub().startTransaction({
		...ue
	}, Yi)
}
async function flush(ue) {
	const Yi = getClient();
	return Yi ? Yi.flush(ue) : (DEBUG_BUILD$5 && logger.warn("Cannot flush events. No client defined."), Promise.resolve(!1))
}
async function close(ue) {
	const Yi = getClient();
	return Yi ? Yi.close(ue) : (DEBUG_BUILD$5 && logger.warn("Cannot flush events and disable SDK. No client defined."), Promise.resolve(!1))
}

function lastEventId() {
	return getCurrentHub().lastEventId()
}

function getClient() {
	return getCurrentHub().getClient()
}

function isInitialized() {
	return !!getClient()
}

function getCurrentScope() {
	return getCurrentHub().getScope()
}

function startSession(ue) {
	const Yi = getClient(),
		ea = getIsolationScope(),
		ta = getCurrentScope(),
		{
			release: na,
			environment: ra = DEFAULT_ENVIRONMENT
		} = Yi && Yi.getOptions() || {},
		{
			userAgent: ia
		} = GLOBAL_OBJ.navigator || {},
		aa = makeSession$1({
			release: na,
			environment: ra,
			user: ta.getUser() || ea.getUser(),
			...ia && {
				userAgent: ia
			},
			...ue
		}),
		oa = ea.getSession();
	return oa && oa.status === "ok" && updateSession(oa, {
		status: "exited"
	}), endSession(), ea.setSession(aa), ta.setSession(aa), aa
}

function endSession() {
	const ue = getIsolationScope(),
		Yi = getCurrentScope(),
		ea = Yi.getSession() || ue.getSession();
	ea && closeSession(ea), _sendSessionUpdate(), ue.setSession(), Yi.setSession()
}

function _sendSessionUpdate() {
	const ue = getIsolationScope(),
		Yi = getCurrentScope(),
		ea = getClient(),
		ta = Yi.getSession() || ue.getSession();
	ta && ea && ea.captureSession && ea.captureSession(ta)
}

function captureSession(ue = !1) {
	if (ue) {
		endSession();
		return
	}
	_sendSessionUpdate()
}

function getRootSpan(ue) {
	return ue.transaction
}

function getDynamicSamplingContextFromClient(ue, Yi, ea) {
	const ta = Yi.getOptions(),
		{
			publicKey: na
		} = Yi.getDsn() || {},
		{
			segment: ra
		} = ea && ea.getUser() || {},
		ia = dropUndefinedKeys({
			environment: ta.environment || DEFAULT_ENVIRONMENT,
			release: ta.release,
			user_segment: ra,
			public_key: na,
			trace_id: ue
		});
	return Yi.emit && Yi.emit("createDsc", ia), ia
}

function getDynamicSamplingContextFromSpan(ue) {
	const Yi = getClient();
	if (!Yi) return {};
	const ea = getDynamicSamplingContextFromClient(spanToJSON(ue).trace_id || "", Yi, getCurrentScope()),
		ta = getRootSpan(ue);
	if (!ta) return ea;
	const na = ta && ta._frozenDynamicSamplingContext;
	if (na) return na;
	const {
		sampleRate: ra,
		source: ia
	} = ta.metadata;
	ra != null && (ea.sample_rate = `${ra}`);
	const aa = spanToJSON(ta);
	return ia && ia !== "url" && (ea.transaction = aa.description), ea.sampled = String(spanIsSampled(ta)), Yi.emit && Yi.emit("createDsc", ea), ea
}

function applyScopeDataToEvent(ue, Yi) {
	const {
		fingerprint: ea,
		span: ta,
		breadcrumbs: na,
		sdkProcessingMetadata: ra
	} = Yi;
	applyDataToEvent(ue, Yi), ta && applySpanToEvent(ue, ta), applyFingerprintToEvent(ue, ea), applyBreadcrumbsToEvent(ue, na), applySdkMetadataToEvent(ue, ra)
}

function mergeScopeData(ue, Yi) {
	const {
		extra: ea,
		tags: ta,
		user: na,
		contexts: ra,
		level: ia,
		sdkProcessingMetadata: aa,
		breadcrumbs: oa,
		fingerprint: la,
		eventProcessors: sa,
		attachments: ca,
		propagationContext: ua,
		transactionName: da,
		span: ha
	} = Yi;
	mergeAndOverwriteScopeData(ue, "extra", ea), mergeAndOverwriteScopeData(ue, "tags", ta), mergeAndOverwriteScopeData(ue, "user", na), mergeAndOverwriteScopeData(ue, "contexts", ra), mergeAndOverwriteScopeData(ue, "sdkProcessingMetadata", aa), ia && (ue.level = ia), da && (ue.transactionName = da), ha && (ue.span = ha), oa.length && (ue.breadcrumbs = [...ue.breadcrumbs, ...oa]), la.length && (ue.fingerprint = [...ue.fingerprint, ...la]), sa.length && (ue.eventProcessors = [...ue.eventProcessors, ...sa]), ca.length && (ue.attachments = [...ue.attachments, ...ca]), ue.propagationContext = {
		...ue.propagationContext,
		...ua
	}
}

function mergeAndOverwriteScopeData(ue, Yi, ea) {
	if (ea && Object.keys(ea).length) {
		ue[Yi] = {
			...ue[Yi]
		};
		for (const ta in ea) Object.prototype.hasOwnProperty.call(ea, ta) && (ue[Yi][ta] = ea[ta])
	}
}

function applyDataToEvent(ue, Yi) {
	const {
		extra: ea,
		tags: ta,
		user: na,
		contexts: ra,
		level: ia,
		transactionName: aa
	} = Yi, oa = dropUndefinedKeys(ea);
	oa && Object.keys(oa).length && (ue.extra = {
		...oa,
		...ue.extra
	});
	const la = dropUndefinedKeys(ta);
	la && Object.keys(la).length && (ue.tags = {
		...la,
		...ue.tags
	});
	const sa = dropUndefinedKeys(na);
	sa && Object.keys(sa).length && (ue.user = {
		...sa,
		...ue.user
	});
	const ca = dropUndefinedKeys(ra);
	ca && Object.keys(ca).length && (ue.contexts = {
		...ca,
		...ue.contexts
	}), ia && (ue.level = ia), aa && (ue.transaction = aa)
}

function applyBreadcrumbsToEvent(ue, Yi) {
	const ea = [...ue.breadcrumbs || [], ...Yi];
	ue.breadcrumbs = ea.length ? ea : void 0
}

function applySdkMetadataToEvent(ue, Yi) {
	ue.sdkProcessingMetadata = {
		...ue.sdkProcessingMetadata,
		...Yi
	}
}

function applySpanToEvent(ue, Yi) {
	ue.contexts = {
		trace: spanToTraceContext(Yi),
		...ue.contexts
	};
	const ea = getRootSpan(Yi);
	if (ea) {
		ue.sdkProcessingMetadata = {
			dynamicSamplingContext: getDynamicSamplingContextFromSpan(Yi),
			...ue.sdkProcessingMetadata
		};
		const ta = spanToJSON(ea).description;
		ta && (ue.tags = {
			transaction: ta,
			...ue.tags
		})
	}
}

function applyFingerprintToEvent(ue, Yi) {
	ue.fingerprint = ue.fingerprint ? arrayify(ue.fingerprint) : [], Yi && (ue.fingerprint = ue.fingerprint.concat(Yi)), ue.fingerprint && !ue.fingerprint.length && delete ue.fingerprint
}
const DEFAULT_MAX_BREADCRUMBS = 100;
let globalScope;
class Scope {
	constructor() {
		this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = generatePropagationContext()
	}
	static clone(Yi) {
		return Yi ? Yi.clone() : new Scope
	}
	clone() {
		const Yi = new Scope;
		return Yi._breadcrumbs = [...this._breadcrumbs], Yi._tags = {
			...this._tags
		}, Yi._extra = {
			...this._extra
		}, Yi._contexts = {
			...this._contexts
		}, Yi._user = this._user, Yi._level = this._level, Yi._span = this._span, Yi._session = this._session, Yi._transactionName = this._transactionName, Yi._fingerprint = this._fingerprint, Yi._eventProcessors = [...this._eventProcessors], Yi._requestSession = this._requestSession, Yi._attachments = [...this._attachments], Yi._sdkProcessingMetadata = {
			...this._sdkProcessingMetadata
		}, Yi._propagationContext = {
			...this._propagationContext
		}, Yi._client = this._client, Yi
	}
	setClient(Yi) {
		this._client = Yi
	}
	getClient() {
		return this._client
	}
	addScopeListener(Yi) {
		this._scopeListeners.push(Yi)
	}
	addEventProcessor(Yi) {
		return this._eventProcessors.push(Yi), this
	}
	setUser(Yi) {
		return this._user = Yi || {
			email: void 0,
			id: void 0,
			ip_address: void 0,
			segment: void 0,
			username: void 0
		}, this._session && updateSession(this._session, {
			user: Yi
		}), this._notifyScopeListeners(), this
	}
	getUser() {
		return this._user
	}
	getRequestSession() {
		return this._requestSession
	}
	setRequestSession(Yi) {
		return this._requestSession = Yi, this
	}
	setTags(Yi) {
		return this._tags = {
			...this._tags,
			...Yi
		}, this._notifyScopeListeners(), this
	}
	setTag(Yi, ea) {
		return this._tags = {
			...this._tags,
			[Yi]: ea
		}, this._notifyScopeListeners(), this
	}
	setExtras(Yi) {
		return this._extra = {
			...this._extra,
			...Yi
		}, this._notifyScopeListeners(), this
	}
	setExtra(Yi, ea) {
		return this._extra = {
			...this._extra,
			[Yi]: ea
		}, this._notifyScopeListeners(), this
	}
	setFingerprint(Yi) {
		return this._fingerprint = Yi, this._notifyScopeListeners(), this
	}
	setLevel(Yi) {
		return this._level = Yi, this._notifyScopeListeners(), this
	}
	setTransactionName(Yi) {
		return this._transactionName = Yi, this._notifyScopeListeners(), this
	}
	setContext(Yi, ea) {
		return ea === null ? delete this._contexts[Yi] : this._contexts[Yi] = ea, this._notifyScopeListeners(), this
	}
	setSpan(Yi) {
		return this._span = Yi, this._notifyScopeListeners(), this
	}
	getSpan() {
		return this._span
	}
	getTransaction() {
		const Yi = this._span;
		return Yi && Yi.transaction
	}
	setSession(Yi) {
		return Yi ? this._session = Yi : delete this._session, this._notifyScopeListeners(), this
	}
	getSession() {
		return this._session
	}
	update(Yi) {
		if (!Yi) return this;
		const ea = typeof Yi == "function" ? Yi(this) : Yi;
		if (ea instanceof Scope) {
			const ta = ea.getScopeData();
			this._tags = {
				...this._tags,
				...ta.tags
			}, this._extra = {
				...this._extra,
				...ta.extra
			}, this._contexts = {
				...this._contexts,
				...ta.contexts
			}, ta.user && Object.keys(ta.user).length && (this._user = ta.user), ta.level && (this._level = ta.level), ta.fingerprint.length && (this._fingerprint = ta.fingerprint), ea.getRequestSession() && (this._requestSession = ea.getRequestSession()), ta.propagationContext && (this._propagationContext = ta.propagationContext)
		} else if (isPlainObject(ea)) {
			const ta = Yi;
			this._tags = {
				...this._tags,
				...ta.tags
			}, this._extra = {
				...this._extra,
				...ta.extra
			}, this._contexts = {
				...this._contexts,
				...ta.contexts
			}, ta.user && (this._user = ta.user), ta.level && (this._level = ta.level), ta.fingerprint && (this._fingerprint = ta.fingerprint), ta.requestSession && (this._requestSession = ta.requestSession), ta.propagationContext && (this._propagationContext = ta.propagationContext)
		}
		return this
	}
	clear() {
		return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._span = void 0, this._session = void 0, this._notifyScopeListeners(), this._attachments = [], this._propagationContext = generatePropagationContext(), this
	}
	addBreadcrumb(Yi, ea) {
		const ta = typeof ea == "number" ? ea : DEFAULT_MAX_BREADCRUMBS;
		if (ta <= 0) return this;
		const na = {
				timestamp: dateTimestampInSeconds(),
				...Yi
			},
			ra = this._breadcrumbs;
		return ra.push(na), this._breadcrumbs = ra.length > ta ? ra.slice(-ta) : ra, this._notifyScopeListeners(), this
	}
	getLastBreadcrumb() {
		return this._breadcrumbs[this._breadcrumbs.length - 1]
	}
	clearBreadcrumbs() {
		return this._breadcrumbs = [], this._notifyScopeListeners(), this
	}
	addAttachment(Yi) {
		return this._attachments.push(Yi), this
	}
	getAttachments() {
		return this.getScopeData().attachments
	}
	clearAttachments() {
		return this._attachments = [], this
	}
	getScopeData() {
		const {
			_breadcrumbs: Yi,
			_attachments: ea,
			_contexts: ta,
			_tags: na,
			_extra: ra,
			_user: ia,
			_level: aa,
			_fingerprint: oa,
			_eventProcessors: la,
			_propagationContext: sa,
			_sdkProcessingMetadata: ca,
			_transactionName: ua,
			_span: da
		} = this;
		return {
			breadcrumbs: Yi,
			attachments: ea,
			contexts: ta,
			tags: na,
			extra: ra,
			user: ia,
			level: aa,
			fingerprint: oa || [],
			eventProcessors: la,
			propagationContext: sa,
			sdkProcessingMetadata: ca,
			transactionName: ua,
			span: da
		}
	}
	applyToEvent(Yi, ea = {}, ta = []) {
		applyScopeDataToEvent(Yi, this.getScopeData());
		const na = [...ta, ...getGlobalEventProcessors(), ...this._eventProcessors];
		return notifyEventProcessors(na, Yi, ea)
	}
	setSDKProcessingMetadata(Yi) {
		return this._sdkProcessingMetadata = {
			...this._sdkProcessingMetadata,
			...Yi
		}, this
	}
	setPropagationContext(Yi) {
		return this._propagationContext = Yi, this
	}
	getPropagationContext() {
		return this._propagationContext
	}
	captureException(Yi, ea) {
		const ta = ea && ea.event_id ? ea.event_id : uuid4();
		if (!this._client) return logger.warn("No client configured on scope - will not capture exception!"), ta;
		const na = new Error("Sentry syntheticException");
		return this._client.captureException(Yi, {
			originalException: Yi,
			syntheticException: na,
			...ea,
			event_id: ta
		}, this), ta
	}
	captureMessage(Yi, ea, ta) {
		const na = ta && ta.event_id ? ta.event_id : uuid4();
		if (!this._client) return logger.warn("No client configured on scope - will not capture message!"), na;
		const ra = new Error(Yi);
		return this._client.captureMessage(Yi, ea, {
			originalException: Yi,
			syntheticException: ra,
			...ta,
			event_id: na
		}, this), na
	}
	captureEvent(Yi, ea) {
		const ta = ea && ea.event_id ? ea.event_id : uuid4();
		return this._client ? (this._client.captureEvent(Yi, {
			...ea,
			event_id: ta
		}, this), ta) : (logger.warn("No client configured on scope - will not capture event!"), ta)
	}
	_notifyScopeListeners() {
		this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach(Yi => {
			Yi(this)
		}), this._notifyingListeners = !1)
	}
}

function getGlobalScope() {
	return globalScope || (globalScope = new Scope), globalScope
}

function generatePropagationContext() {
	return {
		traceId: uuid4(),
		spanId: uuid4().substring(16)
	}
}
const SDK_VERSION = "7.110.1",
	API_VERSION = parseFloat(SDK_VERSION),
	DEFAULT_BREADCRUMBS = 100;
class Hub {
	constructor(Yi, ea, ta, na = API_VERSION) {
		this._version = na;
		let ra;
		ea ? ra = ea : (ra = new Scope, ra.setClient(Yi));
		let ia;
		ta ? ia = ta : (ia = new Scope, ia.setClient(Yi)), this._stack = [{
			scope: ra
		}], Yi && this.bindClient(Yi), this._isolationScope = ia
	}
	isOlderThan(Yi) {
		return this._version < Yi
	}
	bindClient(Yi) {
		const ea = this.getStackTop();
		ea.client = Yi, ea.scope.setClient(Yi), Yi && Yi.setupIntegrations && Yi.setupIntegrations()
	}
	pushScope() {
		const Yi = this.getScope().clone();
		return this.getStack().push({
			client: this.getClient(),
			scope: Yi
		}), Yi
	}
	popScope() {
		return this.getStack().length <= 1 ? !1 : !!this.getStack().pop()
	}
	withScope(Yi) {
		const ea = this.pushScope();
		let ta;
		try {
			ta = Yi(ea)
		} catch (na) {
			throw this.popScope(), na
		}
		return isThenable(ta) ? ta.then(na => (this.popScope(), na), na => {
			throw this.popScope(), na
		}) : (this.popScope(), ta)
	}
	getClient() {
		return this.getStackTop().client
	}
	getScope() {
		return this.getStackTop().scope
	}
	getIsolationScope() {
		return this._isolationScope
	}
	getStack() {
		return this._stack
	}
	getStackTop() {
		return this._stack[this._stack.length - 1]
	}
	captureException(Yi, ea) {
		const ta = this._lastEventId = ea && ea.event_id ? ea.event_id : uuid4(),
			na = new Error("Sentry syntheticException");
		return this.getScope().captureException(Yi, {
			originalException: Yi,
			syntheticException: na,
			...ea,
			event_id: ta
		}), ta
	}
	captureMessage(Yi, ea, ta) {
		const na = this._lastEventId = ta && ta.event_id ? ta.event_id : uuid4(),
			ra = new Error(Yi);
		return this.getScope().captureMessage(Yi, ea, {
			originalException: Yi,
			syntheticException: ra,
			...ta,
			event_id: na
		}), na
	}
	captureEvent(Yi, ea) {
		const ta = ea && ea.event_id ? ea.event_id : uuid4();
		return Yi.type || (this._lastEventId = ta), this.getScope().captureEvent(Yi, {
			...ea,
			event_id: ta
		}), ta
	}
	lastEventId() {
		return this._lastEventId
	}
	addBreadcrumb(Yi, ea) {
		const {
			scope: ta,
			client: na
		} = this.getStackTop();
		if (!na) return;
		const {
			beforeBreadcrumb: ra = null,
			maxBreadcrumbs: ia = DEFAULT_BREADCRUMBS
		} = na.getOptions && na.getOptions() || {};
		if (ia <= 0) return;
		const oa = {
				timestamp: dateTimestampInSeconds(),
				...Yi
			},
			la = ra ? consoleSandbox(() => ra(oa, ea)) : oa;
		la !== null && (na.emit && na.emit("beforeAddBreadcrumb", la, ea), ta.addBreadcrumb(la, ia))
	}
	setUser(Yi) {
		this.getScope().setUser(Yi), this.getIsolationScope().setUser(Yi)
	}
	setTags(Yi) {
		this.getScope().setTags(Yi), this.getIsolationScope().setTags(Yi)
	}
	setExtras(Yi) {
		this.getScope().setExtras(Yi), this.getIsolationScope().setExtras(Yi)
	}
	setTag(Yi, ea) {
		this.getScope().setTag(Yi, ea), this.getIsolationScope().setTag(Yi, ea)
	}
	setExtra(Yi, ea) {
		this.getScope().setExtra(Yi, ea), this.getIsolationScope().setExtra(Yi, ea)
	}
	setContext(Yi, ea) {
		this.getScope().setContext(Yi, ea), this.getIsolationScope().setContext(Yi, ea)
	}
	configureScope(Yi) {
		const {
			scope: ea,
			client: ta
		} = this.getStackTop();
		ta && Yi(ea)
	}
	run(Yi) {
		const ea = makeMain(this);
		try {
			Yi(this)
		} finally {
			makeMain(ea)
		}
	}
	getIntegration(Yi) {
		const ea = this.getClient();
		if (!ea) return null;
		try {
			return ea.getIntegration(Yi)
		} catch {
			return DEBUG_BUILD$5 && logger.warn(`Cannot retrieve integration ${Yi.id} from the current Hub`), null
		}
	}
	startTransaction(Yi, ea) {
		const ta = this._callExtensionMethod("startTransaction", Yi, ea);
		return DEBUG_BUILD$5 && !ta && (this.getClient() ? logger.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`) : logger.warn("Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'")), ta
	}
	traceHeaders() {
		return this._callExtensionMethod("traceHeaders")
	}
	captureSession(Yi = !1) {
		if (Yi) return this.endSession();
		this._sendSessionUpdate()
	}
	endSession() {
		const ea = this.getStackTop().scope,
			ta = ea.getSession();
		ta && closeSession(ta), this._sendSessionUpdate(), ea.setSession()
	}
	startSession(Yi) {
		const {
			scope: ea,
			client: ta
		} = this.getStackTop(), {
			release: na,
			environment: ra = DEFAULT_ENVIRONMENT
		} = ta && ta.getOptions() || {}, {
			userAgent: ia
		} = GLOBAL_OBJ.navigator || {}, aa = makeSession$1({
			release: na,
			environment: ra,
			user: ea.getUser(),
			...ia && {
				userAgent: ia
			},
			...Yi
		}), oa = ea.getSession && ea.getSession();
		return oa && oa.status === "ok" && updateSession(oa, {
			status: "exited"
		}), this.endSession(), ea.setSession(aa), aa
	}
	shouldSendDefaultPii() {
		const Yi = this.getClient(),
			ea = Yi && Yi.getOptions();
		return !!(ea && ea.sendDefaultPii)
	}
	_sendSessionUpdate() {
		const {
			scope: Yi,
			client: ea
		} = this.getStackTop(), ta = Yi.getSession();
		ta && ea && ea.captureSession && ea.captureSession(ta)
	}
	_callExtensionMethod(Yi, ...ea) {
		const na = getMainCarrier().__SENTRY__;
		if (na && na.extensions && typeof na.extensions[Yi] == "function") return na.extensions[Yi].apply(this, ea);
		DEBUG_BUILD$5 && logger.warn(`Extension method ${Yi} couldn't be found, doing nothing.`)
	}
}

function getMainCarrier() {
	return GLOBAL_OBJ.__SENTRY__ = GLOBAL_OBJ.__SENTRY__ || {
		extensions: {},
		hub: void 0
	}, GLOBAL_OBJ
}

function makeMain(ue) {
	const Yi = getMainCarrier(),
		ea = getHubFromCarrier(Yi);
	return setHubOnCarrier(Yi, ue), ea
}

function getCurrentHub() {
	const ue = getMainCarrier();
	if (ue.__SENTRY__ && ue.__SENTRY__.acs) {
		const Yi = ue.__SENTRY__.acs.getCurrentHub();
		if (Yi) return Yi
	}
	return getGlobalHub(ue)
}

function getIsolationScope() {
	return getCurrentHub().getIsolationScope()
}

function getGlobalHub(ue = getMainCarrier()) {
	return (!hasHubOnCarrier(ue) || getHubFromCarrier(ue).isOlderThan(API_VERSION)) && setHubOnCarrier(ue, new Hub), getHubFromCarrier(ue)
}

function runWithAsyncContext(ue, Yi = {}) {
	const ea = getMainCarrier();
	return ea.__SENTRY__ && ea.__SENTRY__.acs ? ea.__SENTRY__.acs.runWithAsyncContext(ue, Yi) : ue()
}

function hasHubOnCarrier(ue) {
	return !!(ue && ue.__SENTRY__ && ue.__SENTRY__.hub)
}

function getHubFromCarrier(ue) {
	return getGlobalSingleton("hub", () => new Hub, ue)
}

function setHubOnCarrier(ue, Yi) {
	if (!ue) return !1;
	const ea = ue.__SENTRY__ = ue.__SENTRY__ || {};
	return ea.hub = Yi, !0
}

function getActiveTransaction$1(ue) {
	return (ue || getCurrentHub()).getScope().getTransaction()
}
const extractTraceparentData = extractTraceparentData$1;
let errorsInstrumented = !1;

function registerErrorInstrumentation() {
	errorsInstrumented || (errorsInstrumented = !0, addGlobalErrorInstrumentationHandler(errorCallback), addGlobalUnhandledRejectionInstrumentationHandler(errorCallback))
}

function errorCallback() {
	const ue = getActiveTransaction$1();
	if (ue) {
		const Yi = "internal_error";
		DEBUG_BUILD$5 && logger.log(`[Tracing] Transaction: ${Yi} -> Global error occured`), ue.setStatus(Yi)
	}
}
errorCallback.tag = "sentry_tracingErrorCallback";
var SpanStatus;
(function(ue) {
	const Yi = "ok";
	ue.Ok = Yi;
	const ea = "deadline_exceeded";
	ue.DeadlineExceeded = ea;
	const ta = "unauthenticated";
	ue.Unauthenticated = ta;
	const na = "permission_denied";
	ue.PermissionDenied = na;
	const ra = "not_found";
	ue.NotFound = ra;
	const ia = "resource_exhausted";
	ue.ResourceExhausted = ia;
	const aa = "invalid_argument";
	ue.InvalidArgument = aa;
	const oa = "unimplemented";
	ue.Unimplemented = oa;
	const la = "unavailable";
	ue.Unavailable = la;
	const sa = "internal_error";
	ue.InternalError = sa;
	const ca = "unknown_error";
	ue.UnknownError = ca;
	const ua = "cancelled";
	ue.Cancelled = ua;
	const da = "already_exists";
	ue.AlreadyExists = da;
	const ha = "failed_precondition";
	ue.FailedPrecondition = ha;
	const pa = "aborted";
	ue.Aborted = pa;
	const va = "out_of_range";
	ue.OutOfRange = va;
	const ba = "data_loss";
	ue.DataLoss = ba
})(SpanStatus || (SpanStatus = {}));

function getSpanStatusFromHttpCode(ue) {
	if (ue < 400 && ue >= 100) return "ok";
	if (ue >= 400 && ue < 500) switch (ue) {
		case 401:
			return "unauthenticated";
		case 403:
			return "permission_denied";
		case 404:
			return "not_found";
		case 409:
			return "already_exists";
		case 413:
			return "failed_precondition";
		case 429:
			return "resource_exhausted";
		default:
			return "invalid_argument"
	}
	if (ue >= 500 && ue < 600) switch (ue) {
		case 501:
			return "unimplemented";
		case 503:
			return "unavailable";
		case 504:
			return "deadline_exceeded";
		default:
			return "internal_error"
	}
	return "unknown_error"
}
const spanStatusfromHttpCode = getSpanStatusFromHttpCode;

function setHttpStatus(ue, Yi) {
	ue.setTag("http.status_code", String(Yi)), ue.setData("http.response.status_code", Yi);
	const ea = getSpanStatusFromHttpCode(Yi);
	ea !== "unknown_error" && ue.setStatus(ea)
}

function handleCallbackErrors(ue, Yi, ea = () => {}) {
	let ta;
	try {
		ta = ue()
	} catch (na) {
		throw Yi(na), ea(), na
	}
	return maybeHandlePromiseRejection(ta, Yi, ea)
}

function maybeHandlePromiseRejection(ue, Yi, ea) {
	return isThenable(ue) ? ue.then(ta => (ea(), ta), ta => {
		throw Yi(ta), ea(), ta
	}) : (ea(), ue)
}

function hasTracingEnabled(ue) {
	if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__) return !1;
	const Yi = getClient(),
		ea = ue || Yi && Yi.getOptions();
	return !!ea && (ea.enableTracing || "tracesSampleRate" in ea || "tracesSampler" in ea)
}

function trace(ue, Yi, ea = () => {}, ta = () => {}) {
	const na = getCurrentHub(),
		ra = getCurrentScope(),
		ia = ra.getSpan(),
		aa = normalizeContext(ue),
		oa = createChildSpanOrTransaction(na, {
			parentSpan: ia,
			spanContext: aa,
			forceTransaction: !1,
			scope: ra
		});
	return ra.setSpan(oa), handleCallbackErrors(() => Yi(oa), la => {
		oa && oa.setStatus("internal_error"), ea(la, oa)
	}, () => {
		oa && oa.end(), ra.setSpan(ia), ta()
	})
}

function startSpan(ue, Yi) {
	const ea = normalizeContext(ue);
	return runWithAsyncContext(() => withScope(ue.scope, ta => {
		const na = getCurrentHub(),
			ra = ta.getSpan(),
			aa = ue.onlyIfParent && !ra ? void 0 : createChildSpanOrTransaction(na, {
				parentSpan: ra,
				spanContext: ea,
				forceTransaction: ue.forceTransaction,
				scope: ta
			});
		return handleCallbackErrors(() => Yi(aa), () => {
			if (aa) {
				const {
					status: oa
				} = spanToJSON(aa);
				(!oa || oa === "ok") && aa.setStatus("internal_error")
			}
		}, () => aa && aa.end())
	}))
}

function startSpanManual(ue, Yi) {
	const ea = normalizeContext(ue);
	return runWithAsyncContext(() => withScope(ue.scope, ta => {
		const na = getCurrentHub(),
			ra = ta.getSpan(),
			aa = ue.onlyIfParent && !ra ? void 0 : createChildSpanOrTransaction(na, {
				parentSpan: ra,
				spanContext: ea,
				forceTransaction: ue.forceTransaction,
				scope: ta
			});

		function oa() {
			aa && aa.end()
		}
		return handleCallbackErrors(() => Yi(aa, oa), () => {
			if (aa && aa.isRecording()) {
				const {
					status: la
				} = spanToJSON(aa);
				(!la || la === "ok") && aa.setStatus("internal_error")
			}
		})
	}))
}

function startInactiveSpan(ue) {
	if (!hasTracingEnabled()) return;
	const Yi = normalizeContext(ue),
		ea = getCurrentHub(),
		ta = ue.scope ? ue.scope.getSpan() : getActiveSpan();
	if (ue.onlyIfParent && !ta) return;
	const ia = (ue.scope || getCurrentScope()).clone();
	return createChildSpanOrTransaction(ea, {
		parentSpan: ta,
		spanContext: Yi,
		forceTransaction: ue.forceTransaction,
		scope: ia
	})
}

function getActiveSpan() {
	return getCurrentScope().getSpan()
}
const continueTrace = ({
	sentryTrace: ue,
	baggage: Yi
}, ea) => {
	const ta = getCurrentScope(),
		{
			traceparentData: na,
			dynamicSamplingContext: ra,
			propagationContext: ia
		} = tracingContextFromHeaders(ue, Yi);
	ta.setPropagationContext(ia), DEBUG_BUILD$5 && na && logger.log(`[Tracing] Continuing trace ${na.traceId}.`);
	const aa = {
		...na,
		metadata: dropUndefinedKeys({
			dynamicSamplingContext: ra
		})
	};
	return ea ? runWithAsyncContext(() => ea(aa)) : aa
};

function createChildSpanOrTransaction(ue, {
	parentSpan: Yi,
	spanContext: ea,
	forceTransaction: ta,
	scope: na
}) {
	if (!hasTracingEnabled()) return;
	const ra = getIsolationScope();
	let ia;
	if (Yi && !ta) ia = Yi.startChild(ea);
	else if (Yi) {
		const aa = getDynamicSamplingContextFromSpan(Yi),
			{
				traceId: oa,
				spanId: la
			} = Yi.spanContext(),
			sa = spanIsSampled(Yi);
		ia = ue.startTransaction({
			traceId: oa,
			parentSpanId: la,
			parentSampled: sa,
			...ea,
			metadata: {
				dynamicSamplingContext: aa,
				...ea.metadata
			}
		})
	} else {
		const {
			traceId: aa,
			dsc: oa,
			parentSpanId: la,
			sampled: sa
		} = {
			...ra.getPropagationContext(),
			...na.getPropagationContext()
		};
		ia = ue.startTransaction({
			traceId: aa,
			parentSpanId: la,
			parentSampled: sa,
			...ea,
			metadata: {
				dynamicSamplingContext: oa,
				...ea.metadata
			}
		})
	}
	return na.setSpan(ia), setCapturedScopesOnSpan(ia, na, ra), ia
}

function normalizeContext(ue) {
	if (ue.startTime) {
		const Yi = {
			...ue
		};
		return Yi.startTimestamp = spanTimeInputToSeconds(ue.startTime), delete Yi.startTime, Yi
	}
	return ue
}
const SCOPE_ON_START_SPAN_FIELD = "_sentryScope",
	ISOLATION_SCOPE_ON_START_SPAN_FIELD = "_sentryIsolationScope";

function setCapturedScopesOnSpan(ue, Yi, ea) {
	ue && (addNonEnumerableProperty(ue, ISOLATION_SCOPE_ON_START_SPAN_FIELD, ea), addNonEnumerableProperty(ue, SCOPE_ON_START_SPAN_FIELD, Yi))
}

function getCapturedScopesOnSpan(ue) {
	return {
		scope: ue[SCOPE_ON_START_SPAN_FIELD],
		isolationScope: ue[ISOLATION_SCOPE_ON_START_SPAN_FIELD]
	}
}
let SPAN_METRIC_SUMMARY;

function getMetricStorageForSpan(ue) {
	return SPAN_METRIC_SUMMARY ? SPAN_METRIC_SUMMARY.get(ue) : void 0
}

function getMetricSummaryJsonForSpan(ue) {
	const Yi = getMetricStorageForSpan(ue);
	if (!Yi) return;
	const ea = {};
	for (const [, [ta, na]] of Yi) ea[ta] || (ea[ta] = []), ea[ta].push(dropUndefinedKeys(na));
	return ea
}

function updateMetricSummaryOnActiveSpan(ue, Yi, ea, ta, na, ra) {
	const ia = getActiveSpan();
	if (ia) {
		const aa = getMetricStorageForSpan(ia) || new Map,
			oa = `${ue}:${Yi}@${ta}`,
			la = aa.get(ra);
		if (la) {
			const [, sa] = la;
			aa.set(ra, [oa, {
				min: Math.min(sa.min, ea),
				max: Math.max(sa.max, ea),
				count: sa.count += 1,
				sum: sa.sum += ea,
				tags: sa.tags
			}])
		} else aa.set(ra, [oa, {
			min: ea,
			max: ea,
			count: 1,
			sum: ea,
			tags: na
		}]);
		SPAN_METRIC_SUMMARY || (SPAN_METRIC_SUMMARY = new WeakMap), SPAN_METRIC_SUMMARY.set(ia, aa)
	}
}
const SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = "sentry.source",
	SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = "sentry.sample_rate",
	SEMANTIC_ATTRIBUTE_SENTRY_OP = "sentry.op",
	SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = "sentry.origin",
	SEMANTIC_ATTRIBUTE_PROFILE_ID = "profile_id";
class SpanRecorder {
	constructor(Yi = 1e3) {
		this._maxlen = Yi, this.spans = []
	}
	add(Yi) {
		this.spans.length > this._maxlen ? Yi.spanRecorder = void 0 : this.spans.push(Yi)
	}
}
class Span {
	constructor(Yi = {}) {
		this._traceId = Yi.traceId || uuid4(), this._spanId = Yi.spanId || uuid4().substring(16), this._startTime = Yi.startTimestamp || timestampInSeconds(), this.tags = Yi.tags ? {
			...Yi.tags
		} : {}, this.data = Yi.data ? {
			...Yi.data
		} : {}, this.instrumenter = Yi.instrumenter || "sentry", this._attributes = {}, this.setAttributes({
			[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: Yi.origin || "manual",
			[SEMANTIC_ATTRIBUTE_SENTRY_OP]: Yi.op,
			...Yi.attributes
		}), this._name = Yi.name || Yi.description, Yi.parentSpanId && (this._parentSpanId = Yi.parentSpanId), "sampled" in Yi && (this._sampled = Yi.sampled), Yi.status && (this._status = Yi.status), Yi.endTimestamp && (this._endTime = Yi.endTimestamp), Yi.exclusiveTime !== void 0 && (this._exclusiveTime = Yi.exclusiveTime), this._measurements = Yi.measurements ? {
			...Yi.measurements
		} : {}
	}
	get name() {
		return this._name || ""
	}
	set name(Yi) {
		this.updateName(Yi)
	}
	get description() {
		return this._name
	}
	set description(Yi) {
		this._name = Yi
	}
	get traceId() {
		return this._traceId
	}
	set traceId(Yi) {
		this._traceId = Yi
	}
	get spanId() {
		return this._spanId
	}
	set spanId(Yi) {
		this._spanId = Yi
	}
	set parentSpanId(Yi) {
		this._parentSpanId = Yi
	}
	get parentSpanId() {
		return this._parentSpanId
	}
	get sampled() {
		return this._sampled
	}
	set sampled(Yi) {
		this._sampled = Yi
	}
	get attributes() {
		return this._attributes
	}
	set attributes(Yi) {
		this._attributes = Yi
	}
	get startTimestamp() {
		return this._startTime
	}
	set startTimestamp(Yi) {
		this._startTime = Yi
	}
	get endTimestamp() {
		return this._endTime
	}
	set endTimestamp(Yi) {
		this._endTime = Yi
	}
	get status() {
		return this._status
	}
	set status(Yi) {
		this._status = Yi
	}
	get op() {
		return this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP]
	}
	set op(Yi) {
		this.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, Yi)
	}
	get origin() {
		return this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]
	}
	set origin(Yi) {
		this.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, Yi)
	}
	spanContext() {
		const {
			_spanId: Yi,
			_traceId: ea,
			_sampled: ta
		} = this;
		return {
			spanId: Yi,
			traceId: ea,
			traceFlags: ta ? TRACE_FLAG_SAMPLED : TRACE_FLAG_NONE
		}
	}
	startChild(Yi) {
		const ea = new Span({
			...Yi,
			parentSpanId: this._spanId,
			sampled: this._sampled,
			traceId: this._traceId
		});
		ea.spanRecorder = this.spanRecorder, ea.spanRecorder && ea.spanRecorder.add(ea);
		const ta = getRootSpan(this);
		if (ea.transaction = ta, DEBUG_BUILD$5 && ta) {
			const na = Yi && Yi.op || "< unknown op >",
				ra = spanToJSON(ea).description || "< unknown name >",
				ia = ta.spanContext().spanId,
				aa = `[Tracing] Starting '${na}' span on transaction '${ra}' (${ia}).`;
			logger.log(aa), this._logMessage = aa
		}
		return ea
	}
	setTag(Yi, ea) {
		return this.tags = {
			...this.tags,
			[Yi]: ea
		}, this
	}
	setData(Yi, ea) {
		return this.data = {
			...this.data,
			[Yi]: ea
		}, this
	}
	setAttribute(Yi, ea) {
		ea === void 0 ? delete this._attributes[Yi] : this._attributes[Yi] = ea
	}
	setAttributes(Yi) {
		Object.keys(Yi).forEach(ea => this.setAttribute(ea, Yi[ea]))
	}
	setStatus(Yi) {
		return this._status = Yi, this
	}
	setHttpStatus(Yi) {
		return setHttpStatus(this, Yi), this
	}
	setName(Yi) {
		this.updateName(Yi)
	}
	updateName(Yi) {
		return this._name = Yi, this
	}
	isSuccess() {
		return this._status === "ok"
	}
	finish(Yi) {
		return this.end(Yi)
	}
	end(Yi) {
		if (this._endTime) return;
		const ea = getRootSpan(this);
		if (DEBUG_BUILD$5 && ea && ea.spanContext().spanId !== this._spanId) {
			const ta = this._logMessage;
			ta && logger.log(ta.replace("Starting", "Finishing"))
		}
		this._endTime = spanTimeInputToSeconds(Yi)
	}
	toTraceparent() {
		return spanToTraceHeader(this)
	}
	toContext() {
		return dropUndefinedKeys({
			data: this._getData(),
			description: this._name,
			endTimestamp: this._endTime,
			op: this.op,
			parentSpanId: this._parentSpanId,
			sampled: this._sampled,
			spanId: this._spanId,
			startTimestamp: this._startTime,
			status: this._status,
			tags: this.tags,
			traceId: this._traceId
		})
	}
	updateWithContext(Yi) {
		return this.data = Yi.data || {}, this._name = Yi.name || Yi.description, this._endTime = Yi.endTimestamp, this.op = Yi.op, this._parentSpanId = Yi.parentSpanId, this._sampled = Yi.sampled, this._spanId = Yi.spanId || this._spanId, this._startTime = Yi.startTimestamp || this._startTime, this._status = Yi.status, this.tags = Yi.tags || {}, this._traceId = Yi.traceId || this._traceId, this
	}
	getTraceContext() {
		return spanToTraceContext(this)
	}
	getSpanJSON() {
		return dropUndefinedKeys({
			data: this._getData(),
			description: this._name,
			op: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],
			parent_span_id: this._parentSpanId,
			span_id: this._spanId,
			start_timestamp: this._startTime,
			status: this._status,
			tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
			timestamp: this._endTime,
			trace_id: this._traceId,
			origin: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
			_metrics_summary: getMetricSummaryJsonForSpan(this),
			profile_id: this._attributes[SEMANTIC_ATTRIBUTE_PROFILE_ID],
			exclusive_time: this._exclusiveTime,
			measurements: Object.keys(this._measurements).length > 0 ? this._measurements : void 0
		})
	}
	isRecording() {
		return !this._endTime && !!this._sampled
	}
	toJSON() {
		return this.getSpanJSON()
	}
	_getData() {
		const {
			data: Yi,
			_attributes: ea
		} = this, ta = Object.keys(Yi).length > 0, na = Object.keys(ea).length > 0;
		if (!(!ta && !na)) return ta && na ? {
			...Yi,
			...ea
		} : ta ? Yi : ea
	}
}
class Transaction extends Span {
	constructor(Yi, ea) {
		super(Yi), this._contexts = {}, this._hub = ea || getCurrentHub(), this._name = Yi.name || "", this._metadata = {
			...Yi.metadata
		}, this._trimEnd = Yi.trimEnd, this.transaction = this;
		const ta = this._metadata.dynamicSamplingContext;
		ta && (this._frozenDynamicSamplingContext = {
			...ta
		})
	}
	get name() {
		return this._name
	}
	set name(Yi) {
		this.setName(Yi)
	}
	get metadata() {
		return {
			source: "custom",
			spanMetadata: {},
			...this._metadata,
			...this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] && {
				source: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]
			},
			...this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] && {
				sampleRate: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]
			}
		}
	}
	set metadata(Yi) {
		this._metadata = Yi
	}
	setName(Yi, ea = "custom") {
		this._name = Yi, this.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, ea)
	}
	updateName(Yi) {
		return this._name = Yi, this
	}
	initSpanRecorder(Yi = 1e3) {
		this.spanRecorder || (this.spanRecorder = new SpanRecorder(Yi)), this.spanRecorder.add(this)
	}
	setContext(Yi, ea) {
		ea === null ? delete this._contexts[Yi] : this._contexts[Yi] = ea
	}
	setMeasurement(Yi, ea, ta = "") {
		this._measurements[Yi] = {
			value: ea,
			unit: ta
		}
	}
	setMetadata(Yi) {
		this._metadata = {
			...this._metadata,
			...Yi
		}
	}
	end(Yi) {
		const ea = spanTimeInputToSeconds(Yi),
			ta = this._finishTransaction(ea);
		if (ta) return this._hub.captureEvent(ta)
	}
	toContext() {
		const Yi = super.toContext();
		return dropUndefinedKeys({
			...Yi,
			name: this._name,
			trimEnd: this._trimEnd
		})
	}
	updateWithContext(Yi) {
		return super.updateWithContext(Yi), this._name = Yi.name || "", this._trimEnd = Yi.trimEnd, this
	}
	getDynamicSamplingContext() {
		return getDynamicSamplingContextFromSpan(this)
	}
	setHub(Yi) {
		this._hub = Yi
	}
	getProfileId() {
		if (this._contexts !== void 0 && this._contexts.profile !== void 0) return this._contexts.profile.profile_id
	}
	_finishTransaction(Yi) {
		if (this._endTime !== void 0) return;
		this._name || (DEBUG_BUILD$5 && logger.warn("Transaction has no name, falling back to `<unlabeled transaction>`."), this._name = "<unlabeled transaction>"), super.end(Yi);
		const ea = this._hub.getClient();
		if (ea && ea.emit && ea.emit("finishTransaction", this), this._sampled !== !0) {
			DEBUG_BUILD$5 && logger.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."), ea && ea.recordDroppedEvent("sample_rate", "transaction");
			return
		}
		const ta = this.spanRecorder ? this.spanRecorder.spans.filter(sa => sa !== this && spanToJSON(sa).timestamp) : [];
		if (this._trimEnd && ta.length > 0) {
			const sa = ta.map(ca => spanToJSON(ca).timestamp).filter(Boolean);
			this._endTime = sa.reduce((ca, ua) => ca > ua ? ca : ua)
		}
		const {
			scope: na,
			isolationScope: ra
		} = getCapturedScopesOnSpan(this), {
			metadata: ia
		} = this, {
			source: aa
		} = ia, oa = {
			contexts: {
				...this._contexts,
				trace: spanToTraceContext(this)
			},
			spans: ta,
			start_timestamp: this._startTime,
			tags: this.tags,
			timestamp: this._endTime,
			transaction: this._name,
			type: "transaction",
			sdkProcessingMetadata: {
				...ia,
				capturedSpanScope: na,
				capturedSpanIsolationScope: ra,
				...dropUndefinedKeys({
					dynamicSamplingContext: getDynamicSamplingContextFromSpan(this)
				})
			},
			_metrics_summary: getMetricSummaryJsonForSpan(this),
			...aa && {
				transaction_info: {
					source: aa
				}
			}
		};
		return Object.keys(this._measurements).length > 0 && (DEBUG_BUILD$5 && logger.log("[Measurements] Adding measurements to transaction", JSON.stringify(this._measurements, void 0, 2)), oa.measurements = this._measurements), DEBUG_BUILD$5 && logger.log(`[Tracing] Finishing ${this.op} transaction: ${this._name}.`), oa
	}
}
const TRACING_DEFAULTS = {
		idleTimeout: 1e3,
		finalTimeout: 3e4,
		heartbeatInterval: 5e3
	},
	FINISH_REASON_TAG = "finishReason",
	IDLE_TRANSACTION_FINISH_REASONS = ["heartbeatFailed", "idleTimeout", "documentHidden", "finalTimeout", "externalFinish", "cancelled"];
class IdleTransactionSpanRecorder extends SpanRecorder {
	constructor(Yi, ea, ta, na) {
		super(na), this._pushActivity = Yi, this._popActivity = ea, this.transactionSpanId = ta
	}
	add(Yi) {
		if (Yi.spanContext().spanId !== this.transactionSpanId) {
			const ea = Yi.end;
			Yi.end = (...ta) => (this._popActivity(Yi.spanContext().spanId), ea.apply(Yi, ta)), spanToJSON(Yi).timestamp === void 0 && this._pushActivity(Yi.spanContext().spanId)
		}
		super.add(Yi)
	}
}
class IdleTransaction extends Transaction {
	constructor(Yi, ea, ta = TRACING_DEFAULTS.idleTimeout, na = TRACING_DEFAULTS.finalTimeout, ra = TRACING_DEFAULTS.heartbeatInterval, ia = !1, aa = !1) {
		super(Yi, ea), this._idleHub = ea, this._idleTimeout = ta, this._finalTimeout = na, this._heartbeatInterval = ra, this._onScope = ia, this.activities = {}, this._heartbeatCounter = 0, this._finished = !1, this._idleTimeoutCanceledPermanently = !1, this._beforeFinishCallbacks = [], this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[4], this._autoFinishAllowed = !aa, ia && (DEBUG_BUILD$5 && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanContext().spanId}`), ea.getScope().setSpan(this)), aa || this._restartIdleTimeout(), setTimeout(() => {
			this._finished || (this.setStatus("deadline_exceeded"), this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[3], this.end())
		}, this._finalTimeout)
	}
	end(Yi) {
		const ea = spanTimeInputToSeconds(Yi);
		if (this._finished = !0, this.activities = {}, this.op === "ui.action.click" && this.setAttribute(FINISH_REASON_TAG, this._finishReason), this.spanRecorder) {
			DEBUG_BUILD$5 && logger.log("[Tracing] finishing IdleTransaction", new Date(ea * 1e3).toISOString(), this.op);
			for (const ta of this._beforeFinishCallbacks) ta(this, ea);
			this.spanRecorder.spans = this.spanRecorder.spans.filter(ta => {
				if (ta.spanContext().spanId === this.spanContext().spanId) return !0;
				spanToJSON(ta).timestamp || (ta.setStatus("cancelled"), ta.end(ea), DEBUG_BUILD$5 && logger.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(ta, void 0, 2)));
				const {
					start_timestamp: na,
					timestamp: ra
				} = spanToJSON(ta), ia = na && na < ea, aa = (this._finalTimeout + this._idleTimeout) / 1e3, oa = ra && na && ra - na < aa;
				if (DEBUG_BUILD$5) {
					const la = JSON.stringify(ta, void 0, 2);
					ia ? oa || logger.log("[Tracing] discarding Span since it finished after Transaction final timeout", la) : logger.log("[Tracing] discarding Span since it happened after Transaction was finished", la)
				}
				return ia && oa
			}), DEBUG_BUILD$5 && logger.log("[Tracing] flushing IdleTransaction")
		} else DEBUG_BUILD$5 && logger.log("[Tracing] No active IdleTransaction");
		if (this._onScope) {
			const ta = this._idleHub.getScope();
			ta.getTransaction() === this && ta.setSpan(void 0)
		}
		return super.end(Yi)
	}
	registerBeforeFinishCallback(Yi) {
		this._beforeFinishCallbacks.push(Yi)
	}
	initSpanRecorder(Yi) {
		if (!this.spanRecorder) {
			const ea = na => {
					this._finished || this._pushActivity(na)
				},
				ta = na => {
					this._finished || this._popActivity(na)
				};
			this.spanRecorder = new IdleTransactionSpanRecorder(ea, ta, this.spanContext().spanId, Yi), DEBUG_BUILD$5 && logger.log("Starting heartbeat"), this._pingHeartbeat()
		}
		this.spanRecorder.add(this)
	}
	cancelIdleTimeout(Yi, {
		restartOnChildSpanChange: ea
	} = {
		restartOnChildSpanChange: !0
	}) {
		this._idleTimeoutCanceledPermanently = ea === !1, this._idleTimeoutID && (clearTimeout(this._idleTimeoutID), this._idleTimeoutID = void 0, Object.keys(this.activities).length === 0 && this._idleTimeoutCanceledPermanently && (this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5], this.end(Yi)))
	}
	setFinishReason(Yi) {
		this._finishReason = Yi
	}
	sendAutoFinishSignal() {
		this._autoFinishAllowed || (DEBUG_BUILD$5 && logger.log("[Tracing] Received finish signal for idle transaction."), this._restartIdleTimeout(), this._autoFinishAllowed = !0)
	}
	_restartIdleTimeout(Yi) {
		this.cancelIdleTimeout(), this._idleTimeoutID = setTimeout(() => {
			!this._finished && Object.keys(this.activities).length === 0 && (this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[1], this.end(Yi))
		}, this._idleTimeout)
	}
	_pushActivity(Yi) {
		this.cancelIdleTimeout(void 0, {
			restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently
		}), DEBUG_BUILD$5 && logger.log(`[Tracing] pushActivity: ${Yi}`), this.activities[Yi] = !0, DEBUG_BUILD$5 && logger.log("[Tracing] new activities count", Object.keys(this.activities).length)
	}
	_popActivity(Yi) {
		if (this.activities[Yi] && (DEBUG_BUILD$5 && logger.log(`[Tracing] popActivity ${Yi}`), delete this.activities[Yi], DEBUG_BUILD$5 && logger.log("[Tracing] new activities count", Object.keys(this.activities).length)), Object.keys(this.activities).length === 0) {
			const ea = timestampInSeconds();
			this._idleTimeoutCanceledPermanently ? this._autoFinishAllowed && (this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[5], this.end(ea)) : this._restartIdleTimeout(ea + this._idleTimeout / 1e3)
		}
	}
	_beat() {
		if (this._finished) return;
		const Yi = Object.keys(this.activities).join("");
		Yi === this._prevHeartbeatString ? this._heartbeatCounter++ : this._heartbeatCounter = 1, this._prevHeartbeatString = Yi, this._heartbeatCounter >= 3 ? this._autoFinishAllowed && (DEBUG_BUILD$5 && logger.log("[Tracing] Transaction finished because of no change for 3 heart beats"), this.setStatus("deadline_exceeded"), this._finishReason = IDLE_TRANSACTION_FINISH_REASONS[0], this.end()) : this._pingHeartbeat()
	}
	_pingHeartbeat() {
		DEBUG_BUILD$5 && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`), setTimeout(() => {
			this._beat()
		}, this._heartbeatInterval)
	}
}

function sampleTransaction(ue, Yi, ea) {
	if (!hasTracingEnabled(Yi)) return ue.sampled = !1, ue;
	if (ue.sampled !== void 0) return ue.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, Number(ue.sampled)), ue;
	let ta;
	return typeof Yi.tracesSampler == "function" ? (ta = Yi.tracesSampler(ea), ue.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, Number(ta))) : ea.parentSampled !== void 0 ? ta = ea.parentSampled : typeof Yi.tracesSampleRate < "u" ? (ta = Yi.tracesSampleRate, ue.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, Number(ta))) : (ta = 1, ue.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, ta)), isValidSampleRate$1(ta) ? ta ? (ue.sampled = Math.random() < ta, ue.sampled ? (DEBUG_BUILD$5 && logger.log(`[Tracing] starting ${ue.op} transaction - ${spanToJSON(ue).description}`), ue) : (DEBUG_BUILD$5 && logger.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(ta)})`), ue)) : (DEBUG_BUILD$5 && logger.log(`[Tracing] Discarding transaction because ${typeof Yi.tracesSampler=="function"?"tracesSampler returned 0 or false":"a negative sampling decision was inherited or tracesSampleRate is set to 0"}`), ue.sampled = !1, ue) : (DEBUG_BUILD$5 && logger.warn("[Tracing] Discarding transaction because of invalid sample rate."), ue.sampled = !1, ue)
}

function isValidSampleRate$1(ue) {
	return isNaN$1(ue) || !(typeof ue == "number" || typeof ue == "boolean") ? (DEBUG_BUILD$5 && logger.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(ue)} of type ${JSON.stringify(typeof ue)}.`), !1) : ue < 0 || ue > 1 ? (DEBUG_BUILD$5 && logger.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${ue}.`), !1) : !0
}

function traceHeaders() {
	const Yi = this.getScope().getSpan();
	return Yi ? {
		"sentry-trace": spanToTraceHeader(Yi)
	} : {}
}

function _startTransaction(ue, Yi) {
	const ea = this.getClient(),
		ta = ea && ea.getOptions() || {},
		na = ta.instrumenter || "sentry",
		ra = ue.instrumenter || "sentry";
	na !== ra && (DEBUG_BUILD$5 && logger.error(`A transaction was started with instrumenter=\`${ra}\`, but the SDK is configured with the \`${na}\` instrumenter.
The transaction will not be sampled. Please use the ${na} instrumentation to start transactions.`), ue.sampled = !1);
	let ia = new Transaction(ue, this);
	return ia = sampleTransaction(ia, ta, {
		name: ue.name,
		parentSampled: ue.parentSampled,
		transactionContext: ue,
		attributes: {
			...ue.data,
			...ue.attributes
		},
		...Yi
	}), ia.isRecording() && ia.initSpanRecorder(ta._experiments && ta._experiments.maxSpans), ea && ea.emit && ea.emit("startTransaction", ia), ia
}

function startIdleTransaction(ue, Yi, ea, ta, na, ra, ia, aa = !1) {
	const oa = ue.getClient(),
		la = oa && oa.getOptions() || {};
	let sa = new IdleTransaction(Yi, ue, ea, ta, ia, na, aa);
	return sa = sampleTransaction(sa, la, {
		name: Yi.name,
		parentSampled: Yi.parentSampled,
		transactionContext: Yi,
		attributes: {
			...Yi.data,
			...Yi.attributes
		},
		...ra
	}), sa.isRecording() && sa.initSpanRecorder(la._experiments && la._experiments.maxSpans), oa && oa.emit && oa.emit("startTransaction", sa), sa
}

function addTracingExtensions() {
	const ue = getMainCarrier();
	ue.__SENTRY__ && (ue.__SENTRY__.extensions = ue.__SENTRY__.extensions || {}, ue.__SENTRY__.extensions.startTransaction || (ue.__SENTRY__.extensions.startTransaction = _startTransaction), ue.__SENTRY__.extensions.traceHeaders || (ue.__SENTRY__.extensions.traceHeaders = traceHeaders), registerErrorInstrumentation())
}

function setMeasurement(ue, Yi, ea) {
	const ta = getActiveTransaction$1();
	ta && ta.setMeasurement(ue, Yi, ea)
}

function enhanceEventWithSdkInfo(ue, Yi) {
	return Yi && (ue.sdk = ue.sdk || {}, ue.sdk.name = ue.sdk.name || Yi.name, ue.sdk.version = ue.sdk.version || Yi.version, ue.sdk.integrations = [...ue.sdk.integrations || [], ...Yi.integrations || []], ue.sdk.packages = [...ue.sdk.packages || [], ...Yi.packages || []]), ue
}

function createSessionEnvelope(ue, Yi, ea, ta) {
	const na = getSdkMetadataForEnvelopeHeader(ea),
		ra = {
			sent_at: new Date().toISOString(),
			...na && {
				sdk: na
			},
			...!!ta && Yi && {
				dsn: dsnToString(Yi)
			}
		},
		ia = "aggregates" in ue ? [{
			type: "sessions"
		}, ue] : [{
			type: "session"
		}, ue.toJSON()];
	return createEnvelope(ra, [ia])
}

function createEventEnvelope(ue, Yi, ea, ta) {
	const na = getSdkMetadataForEnvelopeHeader(ea),
		ra = ue.type && ue.type !== "replay_event" ? ue.type : "event";
	enhanceEventWithSdkInfo(ue, ea && ea.sdk);
	const ia = createEventEnvelopeHeaders(ue, na, ta, Yi);
	return delete ue.sdkProcessingMetadata, createEnvelope(ia, [
		[{
			type: ra
		}, ue]
	])
}
const SENTRY_API_VERSION = "7";

function getBaseApiEndpoint(ue) {
	const Yi = ue.protocol ? `${ue.protocol}:` : "",
		ea = ue.port ? `:${ue.port}` : "";
	return `${Yi}//${ue.host}${ea}${ue.path?`/${ue.path}`:""}/api/`
}

function _getIngestEndpoint(ue) {
	return `${getBaseApiEndpoint(ue)}${ue.projectId}/envelope/`
}

function _encodedAuth(ue, Yi) {
	return urlEncode({
		sentry_key: ue.publicKey,
		sentry_version: SENTRY_API_VERSION,
		...Yi && {
			sentry_client: `${Yi.name}/${Yi.version}`
		}
	})
}

function getEnvelopeEndpointWithUrlEncodedAuth(ue, Yi = {}) {
	const ea = typeof Yi == "string" ? Yi : Yi.tunnel,
		ta = typeof Yi == "string" || !Yi._metadata ? void 0 : Yi._metadata.sdk;
	return ea || `${_getIngestEndpoint(ue)}?${_encodedAuth(ue,ta)}`
}

function getReportDialogEndpoint(ue, Yi) {
	const ea = makeDsn(ue);
	if (!ea) return "";
	const ta = `${getBaseApiEndpoint(ea)}embed/error-page/`;
	let na = `dsn=${dsnToString(ea)}`;
	for (const ra in Yi)
		if (ra !== "dsn" && ra !== "onClose")
			if (ra === "user") {
				const ia = Yi.user;
				if (!ia) continue;
				ia.name && (na += `&name=${encodeURIComponent(ia.name)}`), ia.email && (na += `&email=${encodeURIComponent(ia.email)}`)
			} else na += `&${encodeURIComponent(ra)}=${encodeURIComponent(Yi[ra])}`;
	return `${ta}?${na}`
}
const installedIntegrations = [];

function filterDuplicates(ue) {
	const Yi = {};
	return ue.forEach(ea => {
		const {
			name: ta
		} = ea, na = Yi[ta];
		na && !na.isDefaultInstance && ea.isDefaultInstance || (Yi[ta] = ea)
	}), Object.keys(Yi).map(ea => Yi[ea])
}

function getIntegrationsToSetup(ue) {
	const Yi = ue.defaultIntegrations || [],
		ea = ue.integrations;
	Yi.forEach(ia => {
		ia.isDefaultInstance = !0
	});
	let ta;
	Array.isArray(ea) ? ta = [...Yi, ...ea] : typeof ea == "function" ? ta = arrayify(ea(Yi)) : ta = Yi;
	const na = filterDuplicates(ta),
		ra = findIndex(na, ia => ia.name === "Debug");
	if (ra !== -1) {
		const [ia] = na.splice(ra, 1);
		na.push(ia)
	}
	return na
}

function setupIntegrations(ue, Yi) {
	const ea = {};
	return Yi.forEach(ta => {
		ta && setupIntegration(ue, ta, ea)
	}), ea
}

function afterSetupIntegrations(ue, Yi) {
	for (const ea of Yi) ea && ea.afterAllSetup && ea.afterAllSetup(ue)
}

function setupIntegration(ue, Yi, ea) {
	if (ea[Yi.name]) {
		DEBUG_BUILD$5 && logger.log(`Integration skipped because it was already installed: ${Yi.name}`);
		return
	}
	if (ea[Yi.name] = Yi, installedIntegrations.indexOf(Yi.name) === -1 && (Yi.setupOnce(addGlobalEventProcessor, getCurrentHub), installedIntegrations.push(Yi.name)), Yi.setup && typeof Yi.setup == "function" && Yi.setup(ue), ue.on && typeof Yi.preprocessEvent == "function") {
		const ta = Yi.preprocessEvent.bind(Yi);
		ue.on("preprocessEvent", (na, ra) => ta(na, ra, ue))
	}
	if (ue.addEventProcessor && typeof Yi.processEvent == "function") {
		const ta = Yi.processEvent.bind(Yi),
			na = Object.assign((ra, ia) => ta(ra, ia, ue), {
				id: Yi.name
			});
		ue.addEventProcessor(na)
	}
	DEBUG_BUILD$5 && logger.log(`Integration installed: ${Yi.name}`)
}

function addIntegration(ue) {
	const Yi = getClient();
	if (!Yi || !Yi.addIntegration) {
		DEBUG_BUILD$5 && logger.warn(`Cannot add integration "${ue.name}" because no SDK Client is available.`);
		return
	}
	Yi.addIntegration(ue)
}

function findIndex(ue, Yi) {
	for (let ea = 0; ea < ue.length; ea++)
		if (Yi(ue[ea]) === !0) return ea;
	return -1
}

function convertIntegrationFnToClass(ue, Yi) {
	return Object.assign(function(...ta) {
		return Yi(...ta)
	}, {
		id: ue
	})
}

function defineIntegration(ue) {
	return ue
}

function getBucketKey(ue, Yi, ea, ta) {
	const na = Object.entries(dropUndefinedKeys(ta)).sort((ra, ia) => ra[0].localeCompare(ia[0]));
	return `${ue}${Yi}${ea}${na}`
}

function simpleHash(ue) {
	let Yi = 0;
	for (let ea = 0; ea < ue.length; ea++) {
		const ta = ue.charCodeAt(ea);
		Yi = (Yi << 5) - Yi + ta, Yi &= Yi
	}
	return Yi >>> 0
}

function serializeMetricBuckets(ue) {
	let Yi = "";
	for (const ea of ue) {
		const ta = Object.entries(ea.tags),
			na = ta.length > 0 ? `|#${ta.map(([ra,ia])=>`${ra}:${ia}`).join(",")}` : "";
		Yi += `${ea.name}@${ea.unit}:${ea.metric}|${ea.metricType}${na}|T${ea.timestamp}
`
	}
	return Yi
}

function sanitizeUnit(ue) {
	return ue.replace(/[^\w]+/gi, "_")
}

function sanitizeMetricKey(ue) {
	return ue.replace(/[^\w\-.]+/gi, "_")
}

function sanitizeTagKey(ue) {
	return ue.replace(/[^\w\-./]+/gi, "")
}
const tagValueReplacements = [
	[`
`, "\\n"],
	["\r", "\\r"],
	["	", "\\t"],
	["\\", "\\\\"],
	["|", "\\u{7c}"],
	[",", "\\u{2c}"]
];

function getCharOrReplacement(ue) {
	for (const [Yi, ea] of tagValueReplacements)
		if (ue === Yi) return ea;
	return ue
}

function sanitizeTagValue(ue) {
	return [...ue].reduce((Yi, ea) => Yi + getCharOrReplacement(ea), "")
}

function sanitizeTags(ue) {
	const Yi = {};
	for (const ea in ue)
		if (Object.prototype.hasOwnProperty.call(ue, ea)) {
			const ta = sanitizeTagKey(ea);
			Yi[ta] = sanitizeTagValue(String(ue[ea]))
		} return Yi
}

function createMetricEnvelope(ue, Yi, ea, ta) {
	const na = {
		sent_at: new Date().toISOString()
	};
	ea && ea.sdk && (na.sdk = {
		name: ea.sdk.name,
		version: ea.sdk.version
	}), ta && Yi && (na.dsn = dsnToString(Yi));
	const ra = createMetricEnvelopeItem(ue);
	return createEnvelope(na, [ra])
}

function createMetricEnvelopeItem(ue) {
	const Yi = serializeMetricBuckets(ue);
	return [{
		type: "statsd",
		length: Yi.length
	}, Yi]
}
const ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
class BaseClient {
	constructor(Yi) {
		if (this._options = Yi, this._integrations = {}, this._integrationsInitialized = !1, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], Yi.dsn ? this._dsn = makeDsn(Yi.dsn) : DEBUG_BUILD$5 && logger.warn("No DSN provided, client will not send events."), this._dsn) {
			const ea = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, Yi);
			this._transport = Yi.transport({
				recordDroppedEvent: this.recordDroppedEvent.bind(this),
				...Yi.transportOptions,
				url: ea
			})
		}
	}
	captureException(Yi, ea, ta) {
		if (checkOrSetAlreadyCaught(Yi)) {
			DEBUG_BUILD$5 && logger.log(ALREADY_SEEN_ERROR);
			return
		}
		let na = ea && ea.event_id;
		return this._process(this.eventFromException(Yi, ea).then(ra => this._captureEvent(ra, ea, ta)).then(ra => {
			na = ra
		})), na
	}
	captureMessage(Yi, ea, ta, na) {
		let ra = ta && ta.event_id;
		const ia = isParameterizedString(Yi) ? Yi : String(Yi),
			aa = isPrimitive(Yi) ? this.eventFromMessage(ia, ea, ta) : this.eventFromException(Yi, ta);
		return this._process(aa.then(oa => this._captureEvent(oa, ta, na)).then(oa => {
			ra = oa
		})), ra
	}
	captureEvent(Yi, ea, ta) {
		if (ea && ea.originalException && checkOrSetAlreadyCaught(ea.originalException)) {
			DEBUG_BUILD$5 && logger.log(ALREADY_SEEN_ERROR);
			return
		}
		let na = ea && ea.event_id;
		const ia = (Yi.sdkProcessingMetadata || {}).capturedSpanScope;
		return this._process(this._captureEvent(Yi, ea, ia || ta).then(aa => {
			na = aa
		})), na
	}
	captureSession(Yi) {
		typeof Yi.release != "string" ? DEBUG_BUILD$5 && logger.warn("Discarded session because of missing or non-string release") : (this.sendSession(Yi), updateSession(Yi, {
			init: !1
		}))
	}
	getDsn() {
		return this._dsn
	}
	getOptions() {
		return this._options
	}
	getSdkMetadata() {
		return this._options._metadata
	}
	getTransport() {
		return this._transport
	}
	flush(Yi) {
		const ea = this._transport;
		return ea ? (this.metricsAggregator && this.metricsAggregator.flush(), this._isClientDoneProcessing(Yi).then(ta => ea.flush(Yi).then(na => ta && na))) : resolvedSyncPromise(!0)
	}
	close(Yi) {
		return this.flush(Yi).then(ea => (this.getOptions().enabled = !1, this.metricsAggregator && this.metricsAggregator.close(), ea))
	}
	getEventProcessors() {
		return this._eventProcessors
	}
	addEventProcessor(Yi) {
		this._eventProcessors.push(Yi)
	}
	setupIntegrations(Yi) {
		(Yi && !this._integrationsInitialized || this._isEnabled() && !this._integrationsInitialized) && this._setupIntegrations()
	}
	init() {
		this._isEnabled() && this._setupIntegrations()
	}
	getIntegrationById(Yi) {
		return this.getIntegrationByName(Yi)
	}
	getIntegrationByName(Yi) {
		return this._integrations[Yi]
	}
	getIntegration(Yi) {
		try {
			return this._integrations[Yi.id] || null
		} catch {
			return DEBUG_BUILD$5 && logger.warn(`Cannot retrieve integration ${Yi.id} from the current Client`), null
		}
	}
	addIntegration(Yi) {
		const ea = this._integrations[Yi.name];
		setupIntegration(this, Yi, this._integrations), ea || afterSetupIntegrations(this, [Yi])
	}
	sendEvent(Yi, ea = {}) {
		this.emit("beforeSendEvent", Yi, ea);
		let ta = createEventEnvelope(Yi, this._dsn, this._options._metadata, this._options.tunnel);
		for (const ra of ea.attachments || []) ta = addItemToEnvelope(ta, createAttachmentEnvelopeItem(ra, this._options.transportOptions && this._options.transportOptions.textEncoder));
		const na = this._sendEnvelope(ta);
		na && na.then(ra => this.emit("afterSendEvent", Yi, ra), null)
	}
	sendSession(Yi) {
		const ea = createSessionEnvelope(Yi, this._dsn, this._options._metadata, this._options.tunnel);
		this._sendEnvelope(ea)
	}
	recordDroppedEvent(Yi, ea, ta) {
		if (this._options.sendClientReports) {
			const na = `${Yi}:${ea}`;
			DEBUG_BUILD$5 && logger.log(`Adding outcome: "${na}"`), this._outcomes[na] = this._outcomes[na] + 1 || 1
		}
	}
	captureAggregateMetrics(Yi) {
		DEBUG_BUILD$5 && logger.log(`Flushing aggregated metrics, number of metrics: ${Yi.length}`);
		const ea = createMetricEnvelope(Yi, this._dsn, this._options._metadata, this._options.tunnel);
		this._sendEnvelope(ea)
	}
	on(Yi, ea) {
		this._hooks[Yi] || (this._hooks[Yi] = []), this._hooks[Yi].push(ea)
	}
	emit(Yi, ...ea) {
		this._hooks[Yi] && this._hooks[Yi].forEach(ta => ta(...ea))
	}
	_setupIntegrations() {
		const {
			integrations: Yi
		} = this._options;
		this._integrations = setupIntegrations(this, Yi), afterSetupIntegrations(this, Yi), this._integrationsInitialized = !0
	}
	_updateSessionFromEvent(Yi, ea) {
		let ta = !1,
			na = !1;
		const ra = ea.exception && ea.exception.values;
		if (ra) {
			na = !0;
			for (const oa of ra) {
				const la = oa.mechanism;
				if (la && la.handled === !1) {
					ta = !0;
					break
				}
			}
		}
		const ia = Yi.status === "ok";
		(ia && Yi.errors === 0 || ia && ta) && (updateSession(Yi, {
			...ta && {
				status: "crashed"
			},
			errors: Yi.errors || Number(na || ta)
		}), this.captureSession(Yi))
	}
	_isClientDoneProcessing(Yi) {
		return new SyncPromise(ea => {
			let ta = 0;
			const na = 1,
				ra = setInterval(() => {
					this._numProcessing == 0 ? (clearInterval(ra), ea(!0)) : (ta += na, Yi && ta >= Yi && (clearInterval(ra), ea(!1)))
				}, na)
		})
	}
	_isEnabled() {
		return this.getOptions().enabled !== !1 && this._transport !== void 0
	}
	_prepareEvent(Yi, ea, ta, na = getIsolationScope()) {
		const ra = this.getOptions(),
			ia = Object.keys(this._integrations);
		return !ea.integrations && ia.length > 0 && (ea.integrations = ia), this.emit("preprocessEvent", Yi, ea), prepareEvent(ra, Yi, ea, ta, this, na).then(aa => {
			if (aa === null) return aa;
			const oa = {
				...na.getPropagationContext(),
				...ta ? ta.getPropagationContext() : void 0
			};
			if (!(aa.contexts && aa.contexts.trace) && oa) {
				const {
					traceId: sa,
					spanId: ca,
					parentSpanId: ua,
					dsc: da
				} = oa;
				aa.contexts = {
					trace: {
						trace_id: sa,
						span_id: ca,
						parent_span_id: ua
					},
					...aa.contexts
				};
				const ha = da || getDynamicSamplingContextFromClient(sa, this, ta);
				aa.sdkProcessingMetadata = {
					dynamicSamplingContext: ha,
					...aa.sdkProcessingMetadata
				}
			}
			return aa
		})
	}
	_captureEvent(Yi, ea = {}, ta) {
		return this._processEvent(Yi, ea, ta).then(na => na.event_id, na => {
			if (DEBUG_BUILD$5) {
				const ra = na;
				ra.logLevel === "log" ? logger.log(ra.message) : logger.warn(ra)
			}
		})
	}
	_processEvent(Yi, ea, ta) {
		const na = this.getOptions(),
			{
				sampleRate: ra
			} = na,
			ia = isTransactionEvent$1(Yi),
			aa = isErrorEvent$1(Yi),
			oa = Yi.type || "error",
			la = `before send for type \`${oa}\``;
		if (aa && typeof ra == "number" && Math.random() > ra) return this.recordDroppedEvent("sample_rate", "error", Yi), rejectedSyncPromise(new SentryError(`Discarding event because it's not included in the random sample (sampling rate = ${ra})`, "log"));
		const sa = oa === "replay_event" ? "replay" : oa,
			ua = (Yi.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
		return this._prepareEvent(Yi, ea, ta, ua).then(da => {
			if (da === null) throw this.recordDroppedEvent("event_processor", sa, Yi), new SentryError("An event processor returned `null`, will not send event.", "log");
			if (ea.data && ea.data.__sentry__ === !0) return da;
			const pa = processBeforeSend(na, da, ea);
			return _validateBeforeSendResult(pa, la)
		}).then(da => {
			if (da === null) throw this.recordDroppedEvent("before_send", sa, Yi), new SentryError(`${la} returned \`null\`, will not send event.`, "log");
			const ha = ta && ta.getSession();
			!ia && ha && this._updateSessionFromEvent(ha, da);
			const pa = da.transaction_info;
			if (ia && pa && da.transaction !== Yi.transaction) {
				const va = "custom";
				da.transaction_info = {
					...pa,
					source: va
				}
			}
			return this.sendEvent(da, ea), da
		}).then(null, da => {
			throw da instanceof SentryError ? da : (this.captureException(da, {
				data: {
					__sentry__: !0
				},
				originalException: da
			}), new SentryError(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${da}`))
		})
	}
	_process(Yi) {
		this._numProcessing++, Yi.then(ea => (this._numProcessing--, ea), ea => (this._numProcessing--, ea))
	}
	_sendEnvelope(Yi) {
		if (this.emit("beforeEnvelope", Yi), this._isEnabled() && this._transport) return this._transport.send(Yi).then(null, ea => {
			DEBUG_BUILD$5 && logger.error("Error while sending event:", ea)
		});
		DEBUG_BUILD$5 && logger.error("Transport disabled")
	}
	_clearOutcomes() {
		const Yi = this._outcomes;
		return this._outcomes = {}, Object.keys(Yi).map(ea => {
			const [ta, na] = ea.split(":");
			return {
				reason: ta,
				category: na,
				quantity: Yi[ea]
			}
		})
	}
}

function _validateBeforeSendResult(ue, Yi) {
	const ea = `${Yi} must return \`null\` or a valid event.`;
	if (isThenable(ue)) return ue.then(ta => {
		if (!isPlainObject(ta) && ta !== null) throw new SentryError(ea);
		return ta
	}, ta => {
		throw new SentryError(`${Yi} rejected with ${ta}`)
	});
	if (!isPlainObject(ue) && ue !== null) throw new SentryError(ea);
	return ue
}

function processBeforeSend(ue, Yi, ea) {
	const {
		beforeSend: ta,
		beforeSendTransaction: na
	} = ue;
	return isErrorEvent$1(Yi) && ta ? ta(Yi, ea) : isTransactionEvent$1(Yi) && na ? na(Yi, ea) : Yi
}

function isErrorEvent$1(ue) {
	return ue.type === void 0
}

function isTransactionEvent$1(ue) {
	return ue.type === "transaction"
}

function addEventProcessor(ue) {
	const Yi = getClient();
	!Yi || !Yi.addEventProcessor || Yi.addEventProcessor(ue)
}
const COUNTER_METRIC_TYPE = "c",
	GAUGE_METRIC_TYPE = "g",
	SET_METRIC_TYPE = "s",
	DISTRIBUTION_METRIC_TYPE = "d",
	DEFAULT_BROWSER_FLUSH_INTERVAL = 5e3;
class CounterMetric {
	constructor(Yi) {
		this._value = Yi
	}
	get weight() {
		return 1
	}
	add(Yi) {
		this._value += Yi
	}
	toString() {
		return `${this._value}`
	}
}
class GaugeMetric {
	constructor(Yi) {
		this._last = Yi, this._min = Yi, this._max = Yi, this._sum = Yi, this._count = 1
	}
	get weight() {
		return 5
	}
	add(Yi) {
		this._last = Yi, Yi < this._min && (this._min = Yi), Yi > this._max && (this._max = Yi), this._sum += Yi, this._count++
	}
	toString() {
		return `${this._last}:${this._min}:${this._max}:${this._sum}:${this._count}`
	}
}
class DistributionMetric {
	constructor(Yi) {
		this._value = [Yi]
	}
	get weight() {
		return this._value.length
	}
	add(Yi) {
		this._value.push(Yi)
	}
	toString() {
		return this._value.join(":")
	}
}
class SetMetric {
	constructor(Yi) {
		this.first = Yi, this._value = new Set([Yi])
	}
	get weight() {
		return this._value.size
	}
	add(Yi) {
		this._value.add(Yi)
	}
	toString() {
		return Array.from(this._value).map(Yi => typeof Yi == "string" ? simpleHash(Yi) : Yi).join(":")
	}
}
const METRIC_MAP = {
	[COUNTER_METRIC_TYPE]: CounterMetric,
	[GAUGE_METRIC_TYPE]: GaugeMetric,
	[DISTRIBUTION_METRIC_TYPE]: DistributionMetric,
	[SET_METRIC_TYPE]: SetMetric
};

function initAndBind(ue, Yi) {
	Yi.debug === !0 && (DEBUG_BUILD$5 ? logger.enable() : consoleSandbox(() => {
		console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.")
	})), getCurrentScope().update(Yi.initialScope);
	const ta = new ue(Yi);
	setCurrentClient(ta), initializeClient(ta)
}

function setCurrentClient(ue) {
	const ea = getCurrentHub().getStackTop();
	ea.client = ue, ea.scope.setClient(ue)
}

function initializeClient(ue) {
	ue.init ? ue.init() : ue.setupIntegrations && ue.setupIntegrations()
}
const DEFAULT_TRANSPORT_BUFFER_SIZE = 30;

function createTransport(ue, Yi, ea = makePromiseBuffer(ue.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE)) {
	let ta = {};
	const na = ia => ea.drain(ia);

	function ra(ia) {
		const aa = [];
		if (forEachEnvelopeItem(ia, (ca, ua) => {
				const da = envelopeItemTypeToDataCategory(ua);
				if (isRateLimited(ta, da)) {
					const ha = getEventForEnvelopeItem(ca, ua);
					ue.recordDroppedEvent("ratelimit_backoff", da, ha)
				} else aa.push(ca)
			}), aa.length === 0) return resolvedSyncPromise();
		const oa = createEnvelope(ia[0], aa),
			la = ca => {
				forEachEnvelopeItem(oa, (ua, da) => {
					const ha = getEventForEnvelopeItem(ua, da);
					ue.recordDroppedEvent(ca, envelopeItemTypeToDataCategory(da), ha)
				})
			},
			sa = () => Yi({
				body: serializeEnvelope(oa, ue.textEncoder)
			}).then(ca => (ca.statusCode !== void 0 && (ca.statusCode < 200 || ca.statusCode >= 300) && DEBUG_BUILD$5 && logger.warn(`Sentry responded with status code ${ca.statusCode} to sent event.`), ta = updateRateLimits(ta, ca), ca), ca => {
				throw la("network_error"), ca
			});
		return ea.add(sa).then(ca => ca, ca => {
			if (ca instanceof SentryError) return DEBUG_BUILD$5 && logger.error("Skipped sending event because buffer is full."), la("queue_overflow"), resolvedSyncPromise();
			throw ca
		})
	}
	return ra.__sentry__baseTransport__ = !0, {
		send: ra,
		flush: na
	}
}

function getEventForEnvelopeItem(ue, Yi) {
	if (!(Yi !== "event" && Yi !== "transaction")) return Array.isArray(ue) ? ue[1] : void 0
}
const MIN_DELAY = 100,
	START_DELAY = 5e3,
	MAX_DELAY = 36e5;

function log(ue, Yi) {
	DEBUG_BUILD$5 && logger.info(`[Offline]: ${ue}`, Yi)
}

function makeOfflineTransport(ue) {
	return Yi => {
		const ea = ue(Yi),
			ta = Yi.createStore ? Yi.createStore(Yi) : void 0;
		let na = START_DELAY,
			ra;

		function ia(sa, ca, ua) {
			return envelopeContainsItemType(sa, ["replay_event", "replay_recording", "client_report"]) ? !1 : Yi.shouldStore ? Yi.shouldStore(sa, ca, ua) : !0
		}

		function aa(sa) {
			ta && (ra && clearTimeout(ra), ra = setTimeout(async () => {
				ra = void 0;
				const ca = await ta.pop();
				ca && (log("Attempting to send previously queued event"), la(ca).catch(ua => {
					log("Failed to retry sending", ua)
				}))
			}, sa), typeof ra != "number" && ra.unref && ra.unref())
		}

		function oa() {
			ra || (aa(na), na = Math.min(na * 2, MAX_DELAY))
		}
		async function la(sa) {
			try {
				const ca = await ea.send(sa);
				let ua = MIN_DELAY;
				if (ca) {
					if (ca.headers && ca.headers["retry-after"]) ua = parseRetryAfterHeader(ca.headers["retry-after"]);
					else if ((ca.statusCode || 0) >= 400) return ca
				}
				return aa(ua), na = START_DELAY, ca
			} catch (ca) {
				if (ta && await ia(sa, ca, na)) return await ta.insert(sa), oa(), log("Error sending. Event queued", ca), {};
				throw ca
			}
		}
		return Yi.flushAtStartup && oa(), {
			send: la,
			flush: sa => ea.flush(sa)
		}
	}
}

function eventFromEnvelope(ue, Yi) {
	let ea;
	return forEachEnvelopeItem(ue, (ta, na) => (Yi.includes(na) && (ea = Array.isArray(ta) ? ta[1] : void 0), !!ea)), ea
}

function makeOverrideReleaseTransport(ue, Yi) {
	return ea => {
		const ta = ue(ea);
		return {
			send: async na => {
				const ra = eventFromEnvelope(na, ["event", "transaction", "profile", "replay_event"]);
				return ra && (ra.release = Yi), ta.send(na)
			},
			flush: na => ta.flush(na)
		}
	}
}

function makeMultiplexedTransport(ue, Yi) {
	return ea => {
		const ta = ue(ea),
			na = {};

		function ra(oa, la) {
			const sa = la ? `${oa}:${la}` : oa;
			if (!na[sa]) {
				const ca = dsnFromString(oa);
				if (!ca) return;
				const ua = getEnvelopeEndpointWithUrlEncodedAuth(ca);
				na[sa] = la ? makeOverrideReleaseTransport(ue, la)({
					...ea,
					url: ua
				}) : ue({
					...ea,
					url: ua
				})
			}
			return na[sa]
		}
		async function ia(oa) {
			function la(ua) {
				const da = ua && ua.length ? ua : ["event"];
				return eventFromEnvelope(oa, da)
			}
			const sa = Yi({
				envelope: oa,
				getEvent: la
			}).map(ua => typeof ua == "string" ? ra(ua, void 0) : ra(ua.dsn, ua.release)).filter(ua => !!ua);
			return sa.length === 0 && sa.push(ta), (await Promise.all(sa.map(ua => ua.send(oa))))[0]
		}
		async function aa(oa) {
			const la = [...Object.keys(na).map(ca => na[ca]), ta];
			return (await Promise.all(la.map(ca => ca.flush(oa)))).every(ca => ca)
		}
		return {
			send: ia,
			flush: aa
		}
	}
}

function createSpanEnvelope(ue, Yi) {
	const ea = {
		sent_at: new Date().toISOString()
	};
	Yi && (ea.dsn = dsnToString(Yi));
	const ta = ue.map(createSpanItem);
	return createEnvelope(ea, ta)
}

function createSpanItem(ue) {
	return [{
		type: "span"
	}, ue]
}

function isSentryRequestUrl(ue, Yi) {
	const ea = Yi && isHub(Yi) ? Yi.getClient() : Yi,
		ta = ea && ea.getDsn(),
		na = ea && ea.getOptions().tunnel;
	return checkDsn(ue, ta) || checkTunnel(ue, na)
}

function checkTunnel(ue, Yi) {
	return Yi ? removeTrailingSlash(ue) === removeTrailingSlash(Yi) : !1
}

function checkDsn(ue, Yi) {
	return Yi ? ue.includes(Yi.host) : !1
}

function removeTrailingSlash(ue) {
	return ue[ue.length - 1] === "/" ? ue.slice(0, -1) : ue
}

function isHub(ue) {
	return ue.getClient !== void 0
}

function parameterize(ue, ...Yi) {
	const ea = new String(String.raw(ue, ...Yi));
	return ea.__sentry_template_string__ = ue.join("\0").replace(/%/g, "%%").replace(/\0/g, "%s"), ea.__sentry_template_values__ = Yi, ea
}

function applySdkMetadata(ue, Yi, ea = [Yi], ta = "npm") {
	const na = ue._metadata || {};
	na.sdk || (na.sdk = {
		name: `sentry.javascript.${Yi}`,
		packages: ea.map(ra => ({
			name: `${ta}:@sentry/${ra}`,
			version: SDK_VERSION
		})),
		version: SDK_VERSION
	}), ue._metadata = na
}
const filenameMetadataMap = new Map,
	parsedStacks = new Set;

function ensureMetadataStacksAreParsed(ue) {
	if (GLOBAL_OBJ._sentryModuleMetadata)
		for (const Yi of Object.keys(GLOBAL_OBJ._sentryModuleMetadata)) {
			const ea = GLOBAL_OBJ._sentryModuleMetadata[Yi];
			if (parsedStacks.has(Yi)) continue;
			parsedStacks.add(Yi);
			const ta = ue(Yi);
			for (const na of ta.reverse())
				if (na.filename) {
					filenameMetadataMap.set(na.filename, ea);
					break
				}
		}
}

function getMetadataForUrl(ue, Yi) {
	return ensureMetadataStacksAreParsed(ue), filenameMetadataMap.get(Yi)
}

function addMetadataToStackFrames(ue, Yi) {
	try {
		Yi.exception.values.forEach(ea => {
			if (ea.stacktrace)
				for (const ta of ea.stacktrace.frames || []) {
					if (!ta.filename) continue;
					const na = getMetadataForUrl(ue, ta.filename);
					na && (ta.module_metadata = na)
				}
		})
	} catch {}
}

function stripMetadataFromStackFrames(ue) {
	try {
		ue.exception.values.forEach(Yi => {
			if (Yi.stacktrace)
				for (const ea of Yi.stacktrace.frames || []) delete ea.module_metadata
		})
	} catch {}
}
const INTEGRATION_NAME$d = "ModuleMetadata",
	_moduleMetadataIntegration = () => ({
		name: INTEGRATION_NAME$d,
		setupOnce() {},
		setup(ue) {
			typeof ue.on == "function" && ue.on("beforeEnvelope", Yi => {
				forEachEnvelopeItem(Yi, (ea, ta) => {
					if (ta === "event") {
						const na = Array.isArray(ea) ? ea[1] : void 0;
						na && (stripMetadataFromStackFrames(na), ea[1] = na)
					}
				})
			})
		},
		processEvent(ue, Yi, ea) {
			const ta = ea.getOptions().stackParser;
			return addMetadataToStackFrames(ta, ue), ue
		}
	}),
	moduleMetadataIntegration = _moduleMetadataIntegration,
	ModuleMetadata = convertIntegrationFnToClass(INTEGRATION_NAME$d, moduleMetadataIntegration),
	DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/],
	DEFAULT_IGNORE_TRANSACTIONS = [/^.*\/healthcheck$/, /^.*\/healthy$/, /^.*\/live$/, /^.*\/ready$/, /^.*\/heartbeat$/, /^.*\/health$/, /^.*\/healthz$/],
	INTEGRATION_NAME$c = "InboundFilters",
	_inboundFiltersIntegration = (ue = {}) => ({
		name: INTEGRATION_NAME$c,
		setupOnce() {},
		processEvent(Yi, ea, ta) {
			const na = ta.getOptions(),
				ra = _mergeOptions(ue, na);
			return _shouldDropEvent$1(Yi, ra) ? null : Yi
		}
	}),
	inboundFiltersIntegration = _inboundFiltersIntegration,
	InboundFilters = convertIntegrationFnToClass(INTEGRATION_NAME$c, inboundFiltersIntegration);

function _mergeOptions(ue = {}, Yi = {}) {
	return {
		allowUrls: [...ue.allowUrls || [], ...Yi.allowUrls || []],
		denyUrls: [...ue.denyUrls || [], ...Yi.denyUrls || []],
		ignoreErrors: [...ue.ignoreErrors || [], ...Yi.ignoreErrors || [], ...ue.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS],
		ignoreTransactions: [...ue.ignoreTransactions || [], ...Yi.ignoreTransactions || [], ...ue.disableTransactionDefaults ? [] : DEFAULT_IGNORE_TRANSACTIONS],
		ignoreInternal: ue.ignoreInternal !== void 0 ? ue.ignoreInternal : !0
	}
}

function _shouldDropEvent$1(ue, Yi) {
	return Yi.ignoreInternal && _isSentryError(ue) ? (DEBUG_BUILD$5 && logger.warn(`Event dropped due to being internal Sentry Error.
Event: ${getEventDescription(ue)}`), !0) : _isIgnoredError(ue, Yi.ignoreErrors) ? (DEBUG_BUILD$5 && logger.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${getEventDescription(ue)}`), !0) : _isIgnoredTransaction(ue, Yi.ignoreTransactions) ? (DEBUG_BUILD$5 && logger.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${getEventDescription(ue)}`), !0) : _isDeniedUrl(ue, Yi.denyUrls) ? (DEBUG_BUILD$5 && logger.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${getEventDescription(ue)}.
Url: ${_getEventFilterUrl(ue)}`), !0) : _isAllowedUrl(ue, Yi.allowUrls) ? !1 : (DEBUG_BUILD$5 && logger.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${getEventDescription(ue)}.
Url: ${_getEventFilterUrl(ue)}`), !0)
}

function _isIgnoredError(ue, Yi) {
	return ue.type || !Yi || !Yi.length ? !1 : _getPossibleEventMessages(ue).some(ea => stringMatchesSomePattern(ea, Yi))
}

function _isIgnoredTransaction(ue, Yi) {
	if (ue.type !== "transaction" || !Yi || !Yi.length) return !1;
	const ea = ue.transaction;
	return ea ? stringMatchesSomePattern(ea, Yi) : !1
}

function _isDeniedUrl(ue, Yi) {
	if (!Yi || !Yi.length) return !1;
	const ea = _getEventFilterUrl(ue);
	return ea ? stringMatchesSomePattern(ea, Yi) : !1
}

function _isAllowedUrl(ue, Yi) {
	if (!Yi || !Yi.length) return !0;
	const ea = _getEventFilterUrl(ue);
	return ea ? stringMatchesSomePattern(ea, Yi) : !0
}

function _getPossibleEventMessages(ue) {
	const Yi = [];
	ue.message && Yi.push(ue.message);
	let ea;
	try {
		ea = ue.exception.values[ue.exception.values.length - 1]
	} catch {}
	return ea && ea.value && (Yi.push(ea.value), ea.type && Yi.push(`${ea.type}: ${ea.value}`)), DEBUG_BUILD$5 && Yi.length === 0 && logger.error(`Could not extract message for event ${getEventDescription(ue)}`), Yi
}

function _isSentryError(ue) {
	try {
		return ue.exception.values[0].type === "SentryError"
	} catch {}
	return !1
}

function _getLastValidUrl(ue = []) {
	for (let Yi = ue.length - 1; Yi >= 0; Yi--) {
		const ea = ue[Yi];
		if (ea && ea.filename !== "<anonymous>" && ea.filename !== "[native code]") return ea.filename || null
	}
	return null
}

function _getEventFilterUrl(ue) {
	try {
		let Yi;
		try {
			Yi = ue.exception.values[0].stacktrace.frames
		} catch {}
		return Yi ? _getLastValidUrl(Yi) : null
	} catch {
		return DEBUG_BUILD$5 && logger.error(`Cannot extract url for event ${getEventDescription(ue)}`), null
	}
}
let originalFunctionToString;
const INTEGRATION_NAME$b = "FunctionToString",
	SETUP_CLIENTS = new WeakMap,
	_functionToStringIntegration = () => ({
		name: INTEGRATION_NAME$b,
		setupOnce() {
			originalFunctionToString = Function.prototype.toString;
			try {
				Function.prototype.toString = function(...ue) {
					const Yi = getOriginalFunction(this),
						ea = SETUP_CLIENTS.has(getClient()) && Yi !== void 0 ? Yi : this;
					return originalFunctionToString.apply(ea, ue)
				}
			} catch {}
		},
		setup(ue) {
			SETUP_CLIENTS.set(ue, !0)
		}
	}),
	functionToStringIntegration = _functionToStringIntegration,
	FunctionToString = convertIntegrationFnToClass(INTEGRATION_NAME$b, functionToStringIntegration),
	DEFAULT_KEY$1 = "cause",
	DEFAULT_LIMIT$1 = 5,
	INTEGRATION_NAME$a = "LinkedErrors",
	_linkedErrorsIntegration$1 = (ue = {}) => {
		const Yi = ue.limit || DEFAULT_LIMIT$1,
			ea = ue.key || DEFAULT_KEY$1;
		return {
			name: INTEGRATION_NAME$a,
			setupOnce() {},
			preprocessEvent(ta, na, ra) {
				const ia = ra.getOptions();
				applyAggregateErrorsToEvent(exceptionFromError$1, ia.stackParser, ia.maxValueLength, ea, Yi, ta, na)
			}
		}
	},
	linkedErrorsIntegration$1 = _linkedErrorsIntegration$1,
	LinkedErrors$1 = convertIntegrationFnToClass(INTEGRATION_NAME$a, linkedErrorsIntegration$1),
	index$1 = Object.freeze(Object.defineProperty({
		__proto__: null,
		FunctionToString,
		InboundFilters,
		LinkedErrors: LinkedErrors$1
	}, Symbol.toStringTag, {
		value: "Module"
	}));
class BrowserMetricsAggregator {
	constructor(Yi) {
		this._client = Yi, this._buckets = new Map, this._interval = setInterval(() => this.flush(), DEFAULT_BROWSER_FLUSH_INTERVAL)
	}
	add(Yi, ea, ta, na = "none", ra = {}, ia = timestampInSeconds()) {
		const aa = Math.floor(ia),
			oa = sanitizeMetricKey(ea),
			la = sanitizeTags(ra),
			sa = sanitizeUnit(na),
			ca = getBucketKey(Yi, oa, sa, la);
		let ua = this._buckets.get(ca);
		const da = ua && Yi === SET_METRIC_TYPE ? ua.metric.weight : 0;
		ua ? (ua.metric.add(ta), ua.timestamp < aa && (ua.timestamp = aa)) : (ua = {
			metric: new METRIC_MAP[Yi](ta),
			timestamp: aa,
			metricType: Yi,
			name: oa,
			unit: sa,
			tags: la
		}, this._buckets.set(ca, ua));
		const ha = typeof ta == "string" ? ua.metric.weight - da : ta;
		updateMetricSummaryOnActiveSpan(Yi, oa, ha, sa, ra, ca)
	}
	flush() {
		if (this._buckets.size !== 0) {
			if (this._client.captureAggregateMetrics) {
				const Yi = Array.from(this._buckets).map(([, ea]) => ea);
				this._client.captureAggregateMetrics(Yi)
			}
			this._buckets.clear()
		}
	}
	close() {
		clearInterval(this._interval), this.flush()
	}
}
const INTEGRATION_NAME$9 = "MetricsAggregator",
	_metricsAggregatorIntegration = () => ({
		name: INTEGRATION_NAME$9,
		setupOnce() {},
		setup(ue) {
			ue.metricsAggregator = new BrowserMetricsAggregator(ue)
		}
	}),
	metricsAggregatorIntegration = _metricsAggregatorIntegration,
	MetricsAggregator = convertIntegrationFnToClass(INTEGRATION_NAME$9, metricsAggregatorIntegration);

function addToMetricsAggregator(ue, Yi, ea, ta = {}) {
	const na = getClient(),
		ra = getCurrentScope();
	if (na) {
		if (!na.metricsAggregator) {
			DEBUG_BUILD$5 && logger.warn("No metrics aggregator enabled. Please add the MetricsAggregator integration to use metrics APIs");
			return
		}
		const {
			unit: ia,
			tags: aa,
			timestamp: oa
		} = ta, {
			release: la,
			environment: sa
		} = na.getOptions(), ca = ra.getTransaction(), ua = {};
		la && (ua.release = la), sa && (ua.environment = sa), ca && (ua.transaction = spanToJSON(ca).description || ""), DEBUG_BUILD$5 && logger.log(`Adding value of ${ea} to ${ue} metric ${Yi}`), na.metricsAggregator.add(ue, Yi, ea, ia, {
			...ua,
			...aa
		}, oa)
	}
}

function increment(ue, Yi = 1, ea) {
	addToMetricsAggregator(COUNTER_METRIC_TYPE, ue, Yi, ea)
}

function distribution(ue, Yi, ea) {
	addToMetricsAggregator(DISTRIBUTION_METRIC_TYPE, ue, Yi, ea)
}

function set(ue, Yi, ea) {
	addToMetricsAggregator(SET_METRIC_TYPE, ue, Yi, ea)
}

function gauge(ue, Yi, ea) {
	addToMetricsAggregator(GAUGE_METRIC_TYPE, ue, Yi, ea)
}
const metrics = {
		increment,
		distribution,
		set,
		gauge,
		MetricsAggregator,
		metricsAggregatorIntegration
	},
	Integrations = index$1,
	DEBUG_BUILD$4 = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
	WINDOW$3 = GLOBAL_OBJ;

function registerBackgroundTabDetection() {
	WINDOW$3 && WINDOW$3.document ? WINDOW$3.document.addEventListener("visibilitychange", () => {
		const ue = getActiveTransaction$1();
		if (WINDOW$3.document.hidden && ue) {
			const Yi = "cancelled",
				{
					op: ea,
					status: ta
				} = spanToJSON(ue);
			DEBUG_BUILD$4 && logger.log(`[Tracing] Transaction: ${Yi} -> since tab moved to the background, op: ${ea}`), ta || ue.setStatus(Yi), ue.setTag("visibilitychange", "document.hidden"), ue.end()
		}
	}) : DEBUG_BUILD$4 && logger.warn("[Tracing] Could not set up background tab detection due to lack of global document")
}
const bindReporter = (ue, Yi, ea) => {
		let ta, na;
		return ra => {
			Yi.value >= 0 && (ra || ea) && (na = Yi.value - (ta || 0), (na || ta === void 0) && (ta = Yi.value, Yi.delta = na, ue(Yi)))
		}
	},
	generateUniqueID = () => `v3-${Date.now()}-${Math.floor(Math.random()*(9e12-1))+1e12}`,
	getNavigationEntryFromPerformanceTiming = () => {
		const ue = WINDOW$3.performance.timing,
			Yi = WINDOW$3.performance.navigation.type,
			ea = {
				entryType: "navigation",
				startTime: 0,
				type: Yi == 2 ? "back_forward" : Yi === 1 ? "reload" : "navigate"
			};
		for (const ta in ue) ta !== "navigationStart" && ta !== "toJSON" && (ea[ta] = Math.max(ue[ta] - ue.navigationStart, 0));
		return ea
	},
	getNavigationEntry = () => WINDOW$3.__WEB_VITALS_POLYFILL__ ? WINDOW$3.performance && (performance.getEntriesByType && performance.getEntriesByType("navigation")[0] || getNavigationEntryFromPerformanceTiming()) : WINDOW$3.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0],
	getActivationStart = () => {
		const ue = getNavigationEntry();
		return ue && ue.activationStart || 0
	},
	initMetric = (ue, Yi) => {
		const ea = getNavigationEntry();
		let ta = "navigate";
		return ea && (WINDOW$3.document.prerendering || getActivationStart() > 0 ? ta = "prerender" : ta = ea.type.replace(/_/g, "-")), {
			name: ue,
			value: typeof Yi > "u" ? -1 : Yi,
			rating: "good",
			delta: 0,
			entries: [],
			id: generateUniqueID(),
			navigationType: ta
		}
	},
	observe = (ue, Yi, ea) => {
		try {
			if (PerformanceObserver.supportedEntryTypes.includes(ue)) {
				const ta = new PerformanceObserver(na => {
					Yi(na.getEntries())
				});
				return ta.observe(Object.assign({
					type: ue,
					buffered: !0
				}, ea || {})), ta
			}
		} catch {}
	},
	onHidden = (ue, Yi) => {
		const ea = ta => {
			(ta.type === "pagehide" || WINDOW$3.document.visibilityState === "hidden") && (ue(ta), Yi && (removeEventListener("visibilitychange", ea, !0), removeEventListener("pagehide", ea, !0)))
		};
		addEventListener("visibilitychange", ea, !0), addEventListener("pagehide", ea, !0)
	},
	onCLS = ue => {
		const Yi = initMetric("CLS", 0);
		let ea, ta = 0,
			na = [];
		const ra = aa => {
				aa.forEach(oa => {
					if (!oa.hadRecentInput) {
						const la = na[0],
							sa = na[na.length - 1];
						ta && na.length !== 0 && oa.startTime - sa.startTime < 1e3 && oa.startTime - la.startTime < 5e3 ? (ta += oa.value, na.push(oa)) : (ta = oa.value, na = [oa]), ta > Yi.value && (Yi.value = ta, Yi.entries = na, ea && ea())
					}
				})
			},
			ia = observe("layout-shift", ra);
		if (ia) {
			ea = bindReporter(ue, Yi);
			const aa = () => {
				ra(ia.takeRecords()), ea(!0)
			};
			return onHidden(aa), aa
		}
	};
let firstHiddenTime = -1;
const initHiddenTime = () => WINDOW$3.document.visibilityState === "hidden" && !WINDOW$3.document.prerendering ? 0 : 1 / 0,
	trackChanges = () => {
		onHidden(({
			timeStamp: ue
		}) => {
			firstHiddenTime = ue
		}, !0)
	},
	getVisibilityWatcher = () => (firstHiddenTime < 0 && (firstHiddenTime = initHiddenTime(), trackChanges()), {
		get firstHiddenTime() {
			return firstHiddenTime
		}
	}),
	onFID = ue => {
		const Yi = getVisibilityWatcher(),
			ea = initMetric("FID");
		let ta;
		const na = aa => {
				aa.startTime < Yi.firstHiddenTime && (ea.value = aa.processingStart - aa.startTime, ea.entries.push(aa), ta(!0))
			},
			ra = aa => {
				aa.forEach(na)
			},
			ia = observe("first-input", ra);
		ta = bindReporter(ue, ea), ia && onHidden(() => {
			ra(ia.takeRecords()), ia.disconnect()
		}, !0)
	};
let interactionCountEstimate = 0,
	minKnownInteractionId = 1 / 0,
	maxKnownInteractionId = 0;
const updateEstimate = ue => {
	ue.forEach(Yi => {
		Yi.interactionId && (minKnownInteractionId = Math.min(minKnownInteractionId, Yi.interactionId), maxKnownInteractionId = Math.max(maxKnownInteractionId, Yi.interactionId), interactionCountEstimate = maxKnownInteractionId ? (maxKnownInteractionId - minKnownInteractionId) / 7 + 1 : 0)
	})
};
let po;
const getInteractionCount = () => po ? interactionCountEstimate : performance.interactionCount || 0,
	initInteractionCountPolyfill = () => {
		"interactionCount" in performance || po || (po = observe("event", updateEstimate, {
			type: "event",
			buffered: !0,
			durationThreshold: 0
		}))
	},
	getInteractionCountForNavigation = () => getInteractionCount(),
	MAX_INTERACTIONS_TO_CONSIDER = 10,
	longestInteractionList = [],
	longestInteractionMap = {},
	processEntry = ue => {
		const Yi = longestInteractionList[longestInteractionList.length - 1],
			ea = longestInteractionMap[ue.interactionId];
		if (ea || longestInteractionList.length < MAX_INTERACTIONS_TO_CONSIDER || ue.duration > Yi.latency) {
			if (ea) ea.entries.push(ue), ea.latency = Math.max(ea.latency, ue.duration);
			else {
				const ta = {
					id: ue.interactionId,
					latency: ue.duration,
					entries: [ue]
				};
				longestInteractionMap[ta.id] = ta, longestInteractionList.push(ta)
			}
			longestInteractionList.sort((ta, na) => na.latency - ta.latency), longestInteractionList.splice(MAX_INTERACTIONS_TO_CONSIDER).forEach(ta => {
				delete longestInteractionMap[ta.id]
			})
		}
	},
	estimateP98LongestInteraction = () => {
		const ue = Math.min(longestInteractionList.length - 1, Math.floor(getInteractionCountForNavigation() / 50));
		return longestInteractionList[ue]
	},
	onINP = (ue, Yi) => {
		Yi = Yi || {}, initInteractionCountPolyfill();
		const ea = initMetric("INP");
		let ta;
		const na = ia => {
				ia.forEach(oa => {
					oa.interactionId && processEntry(oa), oa.entryType === "first-input" && !longestInteractionList.some(sa => sa.entries.some(ca => oa.duration === ca.duration && oa.startTime === ca.startTime)) && processEntry(oa)
				});
				const aa = estimateP98LongestInteraction();
				aa && aa.latency !== ea.value && (ea.value = aa.latency, ea.entries = aa.entries, ta())
			},
			ra = observe("event", na, {
				durationThreshold: Yi.durationThreshold || 40
			});
		ta = bindReporter(ue, ea, Yi.reportAllChanges), ra && (ra.observe({
			type: "first-input",
			buffered: !0
		}), onHidden(() => {
			na(ra.takeRecords()), ea.value < 0 && getInteractionCountForNavigation() > 0 && (ea.value = 0, ea.entries = []), ta(!0)
		}))
	},
	reportedMetricIDs = {},
	onLCP = ue => {
		const Yi = getVisibilityWatcher(),
			ea = initMetric("LCP");
		let ta;
		const na = ia => {
				const aa = ia[ia.length - 1];
				if (aa) {
					const oa = Math.max(aa.startTime - getActivationStart(), 0);
					oa < Yi.firstHiddenTime && (ea.value = oa, ea.entries = [aa], ta())
				}
			},
			ra = observe("largest-contentful-paint", na);
		if (ra) {
			ta = bindReporter(ue, ea);
			const ia = () => {
				reportedMetricIDs[ea.id] || (na(ra.takeRecords()), ra.disconnect(), reportedMetricIDs[ea.id] = !0, ta(!0))
			};
			return ["keydown", "click"].forEach(aa => {
				addEventListener(aa, ia, {
					once: !0,
					capture: !0
				})
			}), onHidden(ia, !0), ia
		}
	},
	whenReady = ue => {
		WINDOW$3.document && (WINDOW$3.document.prerendering ? addEventListener("prerenderingchange", () => whenReady(ue), !0) : WINDOW$3.document.readyState !== "complete" ? addEventListener("load", () => whenReady(ue), !0) : setTimeout(ue, 0))
	},
	onTTFB = (ue, Yi) => {
		Yi = Yi || {};
		const ea = initMetric("TTFB"),
			ta = bindReporter(ue, ea, Yi.reportAllChanges);
		whenReady(() => {
			const na = getNavigationEntry();
			if (na) {
				if (ea.value = Math.max(na.responseStart - getActivationStart(), 0), ea.value < 0 || ea.value > performance.now()) return;
				ea.entries = [na], ta(!0)
			}
		})
	},
	handlers$1 = {},
	instrumented = {};
let _previousCls, _previousFid, _previousLcp, _previousTtfb, _previousInp;

function addClsInstrumentationHandler(ue, Yi = !1) {
	return addMetricObserver("cls", ue, instrumentCls, _previousCls, Yi)
}

function addLcpInstrumentationHandler(ue, Yi = !1) {
	return addMetricObserver("lcp", ue, instrumentLcp, _previousLcp, Yi)
}

function addTtfbInstrumentationHandler(ue) {
	return addMetricObserver("ttfb", ue, instrumentTtfb, _previousTtfb)
}

function addFidInstrumentationHandler(ue) {
	return addMetricObserver("fid", ue, instrumentFid, _previousFid)
}

function addInpInstrumentationHandler(ue) {
	return addMetricObserver("inp", ue, instrumentInp, _previousInp)
}

function addPerformanceInstrumentationHandler(ue, Yi) {
	return addHandler(ue, Yi), instrumented[ue] || (instrumentPerformanceObserver(ue), instrumented[ue] = !0), getCleanupCallback(ue, Yi)
}

function triggerHandlers(ue, Yi) {
	const ea = handlers$1[ue];
	if (!(!ea || !ea.length))
		for (const ta of ea) try {
			ta(Yi)
		} catch (na) {
			DEBUG_BUILD$4 && logger.error(`Error while triggering instrumentation handler.
Type: ${ue}
Name: ${getFunctionName(ta)}
Error:`, na)
		}
}

function instrumentCls() {
	return onCLS(ue => {
		triggerHandlers("cls", {
			metric: ue
		}), _previousCls = ue
	})
}

function instrumentFid() {
	return onFID(ue => {
		triggerHandlers("fid", {
			metric: ue
		}), _previousFid = ue
	})
}

function instrumentLcp() {
	return onLCP(ue => {
		triggerHandlers("lcp", {
			metric: ue
		}), _previousLcp = ue
	})
}

function instrumentTtfb() {
	return onTTFB(ue => {
		triggerHandlers("ttfb", {
			metric: ue
		}), _previousTtfb = ue
	})
}

function instrumentInp() {
	return onINP(ue => {
		triggerHandlers("inp", {
			metric: ue
		}), _previousInp = ue
	})
}

function addMetricObserver(ue, Yi, ea, ta, na = !1) {
	addHandler(ue, Yi);
	let ra;
	return instrumented[ue] || (ra = ea(), instrumented[ue] = !0), ta && Yi({
		metric: ta
	}), getCleanupCallback(ue, Yi, na ? ra : void 0)
}

function instrumentPerformanceObserver(ue) {
	const Yi = {};
	ue === "event" && (Yi.durationThreshold = 0), observe(ue, ea => {
		triggerHandlers(ue, {
			entries: ea
		})
	}, Yi)
}

function addHandler(ue, Yi) {
	handlers$1[ue] = handlers$1[ue] || [], handlers$1[ue].push(Yi)
}

function getCleanupCallback(ue, Yi, ea) {
	return () => {
		ea && ea();
		const ta = handlers$1[ue];
		if (!ta) return;
		const na = ta.indexOf(Yi);
		na !== -1 && ta.splice(na, 1)
	}
}

function isMeasurementValue(ue) {
	return typeof ue == "number" && isFinite(ue)
}

function _startChild(ue, {
	startTimestamp: Yi,
	...ea
}) {
	return Yi && ue.startTimestamp > Yi && (ue.startTimestamp = Yi), ue.startChild({
		startTimestamp: Yi,
		...ea
	})
}
const MAX_INT_AS_BYTES = 2147483647;

function msToSec(ue) {
	return ue / 1e3
}

function getBrowserPerformanceAPI() {
	return WINDOW$3 && WINDOW$3.addEventListener && WINDOW$3.performance
}
let _performanceCursor = 0,
	_measurements = {},
	_lcpEntry, _clsEntry;

function startTrackingWebVitals() {
	const ue = getBrowserPerformanceAPI();
	if (ue && browserPerformanceTimeOrigin) {
		ue.mark && WINDOW$3.performance.mark("sentry-tracing-init");
		const Yi = _trackFID(),
			ea = _trackCLS(),
			ta = _trackLCP(),
			na = _trackTtfb();
		return () => {
			Yi(), ea(), ta(), na()
		}
	}
	return () => {}
}

function startTrackingLongTasks() {
	addPerformanceInstrumentationHandler("longtask", ({
		entries: ue
	}) => {
		for (const Yi of ue) {
			const ea = getActiveTransaction$1();
			if (!ea) return;
			const ta = msToSec(browserPerformanceTimeOrigin + Yi.startTime),
				na = msToSec(Yi.duration);
			ea.startChild({
				description: "Main UI thread blocked",
				op: "ui.long-task",
				origin: "auto.ui.browser.metrics",
				startTimestamp: ta,
				endTimestamp: ta + na
			})
		}
	})
}

function startTrackingInteractions() {
	addPerformanceInstrumentationHandler("event", ({
		entries: ue
	}) => {
		for (const Yi of ue) {
			const ea = getActiveTransaction$1();
			if (!ea) return;
			if (Yi.name === "click") {
				const ta = msToSec(browserPerformanceTimeOrigin + Yi.startTime),
					na = msToSec(Yi.duration),
					ra = {
						description: htmlTreeAsString(Yi.target),
						op: `ui.interaction.${Yi.name}`,
						origin: "auto.ui.browser.metrics",
						startTimestamp: ta,
						endTimestamp: ta + na
					},
					ia = getComponentName(Yi.target);
				ia && (ra.attributes = {
					"ui.component_name": ia
				}), ea.startChild(ra)
			}
		}
	})
}

function startTrackingINP(ue, Yi) {
	if (getBrowserPerformanceAPI() && browserPerformanceTimeOrigin) {
		const ta = _trackINP(ue, Yi);
		return () => {
			ta()
		}
	}
	return () => {}
}

function _trackCLS() {
	return addClsInstrumentationHandler(({
		metric: ue
	}) => {
		const Yi = ue.entries[ue.entries.length - 1];
		Yi && (DEBUG_BUILD$4 && logger.log("[Measurements] Adding CLS"), _measurements.cls = {
			value: ue.value,
			unit: ""
		}, _clsEntry = Yi)
	}, !0)
}

function _trackLCP() {
	return addLcpInstrumentationHandler(({
		metric: ue
	}) => {
		const Yi = ue.entries[ue.entries.length - 1];
		Yi && (DEBUG_BUILD$4 && logger.log("[Measurements] Adding LCP"), _measurements.lcp = {
			value: ue.value,
			unit: "millisecond"
		}, _lcpEntry = Yi)
	}, !0)
}

function _trackFID() {
	return addFidInstrumentationHandler(({
		metric: ue
	}) => {
		const Yi = ue.entries[ue.entries.length - 1];
		if (!Yi) return;
		const ea = msToSec(browserPerformanceTimeOrigin),
			ta = msToSec(Yi.startTime);
		DEBUG_BUILD$4 && logger.log("[Measurements] Adding FID"), _measurements.fid = {
			value: ue.value,
			unit: "millisecond"
		}, _measurements["mark.fid"] = {
			value: ea + ta,
			unit: "second"
		}
	})
}

function _trackTtfb() {
	return addTtfbInstrumentationHandler(({
		metric: ue
	}) => {
		ue.entries[ue.entries.length - 1] && (DEBUG_BUILD$4 && logger.log("[Measurements] Adding TTFB"), _measurements.ttfb = {
			value: ue.value,
			unit: "millisecond"
		})
	})
}
const INP_ENTRY_MAP = {
	click: "click",
	pointerdown: "click",
	pointerup: "click",
	mousedown: "click",
	mouseup: "click",
	touchstart: "click",
	touchend: "click",
	mouseover: "hover",
	mouseout: "hover",
	mouseenter: "hover",
	mouseleave: "hover",
	pointerover: "hover",
	pointerout: "hover",
	pointerenter: "hover",
	pointerleave: "hover",
	dragstart: "drag",
	dragend: "drag",
	drag: "drag",
	dragenter: "drag",
	dragleave: "drag",
	dragover: "drag",
	drop: "drag",
	keydown: "press",
	keyup: "press",
	keypress: "press",
	input: "press"
};

function _trackINP(ue, Yi) {
	return addInpInstrumentationHandler(({
		metric: ea
	}) => {
		if (ea.value === void 0) return;
		const ta = ea.entries.find(Sa => Sa.duration === ea.value && INP_ENTRY_MAP[Sa.name] !== void 0),
			na = getClient();
		if (!ta || !na) return;
		const ra = INP_ENTRY_MAP[ta.name],
			ia = na.getOptions(),
			aa = msToSec(browserPerformanceTimeOrigin + ta.startTime),
			oa = msToSec(ea.value),
			la = ta.interactionId !== void 0 ? ue[ta.interactionId] : void 0;
		if (la === void 0) return;
		const {
			routeName: sa,
			parentContext: ca,
			activeTransaction: ua,
			user: da,
			replayId: ha
		} = la, pa = da !== void 0 ? da.email || da.id || da.ip_address : void 0, va = ua !== void 0 ? ua.getProfileId() : void 0, ba = new Span({
			startTimestamp: aa,
			endTimestamp: aa + oa,
			op: `ui.interaction.${ra}`,
			name: htmlTreeAsString(ta.target),
			attributes: {
				release: ia.release,
				environment: ia.environment,
				transaction: sa,
				...pa !== void 0 && pa !== "" ? {
					user: pa
				} : {},
				...va !== void 0 ? {
					profile_id: va
				} : {},
				...ha !== void 0 ? {
					replay_id: ha
				} : {}
			},
			exclusiveTime: ea.value,
			measurements: {
				inp: {
					value: ea.value,
					unit: "millisecond"
				}
			}
		}), Ea = getSampleRate(ca, ia, Yi);
		if (Ea && Math.random() < Ea) {
			const Sa = ba ? createSpanEnvelope([ba], na.getDsn()) : void 0,
				Ca = na && na.getTransport();
			Ca && Sa && Ca.send(Sa).then(null, ka => {
				DEBUG_BUILD$4 && logger.error("Error while sending interaction:", ka)
			});
			return
		}
	})
}

function addPerformanceEntries(ue) {
	const Yi = getBrowserPerformanceAPI();
	if (!Yi || !WINDOW$3.performance.getEntries || !browserPerformanceTimeOrigin) return;
	DEBUG_BUILD$4 && logger.log("[Tracing] Adding & adjusting spans using Performance API");
	const ea = msToSec(browserPerformanceTimeOrigin),
		ta = Yi.getEntries(),
		{
			op: na,
			start_timestamp: ra
		} = spanToJSON(ue);
	if (ta.slice(_performanceCursor).forEach(ia => {
			const aa = msToSec(ia.startTime),
				oa = msToSec(ia.duration);
			if (!(ue.op === "navigation" && ra && ea + aa < ra)) switch (ia.entryType) {
				case "navigation": {
					_addNavigationSpans(ue, ia, ea);
					break
				}
				case "mark":
				case "paint":
				case "measure": {
					_addMeasureSpans(ue, ia, aa, oa, ea);
					const la = getVisibilityWatcher(),
						sa = ia.startTime < la.firstHiddenTime;
					ia.name === "first-paint" && sa && (DEBUG_BUILD$4 && logger.log("[Measurements] Adding FP"), _measurements.fp = {
						value: ia.startTime,
						unit: "millisecond"
					}), ia.name === "first-contentful-paint" && sa && (DEBUG_BUILD$4 && logger.log("[Measurements] Adding FCP"), _measurements.fcp = {
						value: ia.startTime,
						unit: "millisecond"
					});
					break
				}
				case "resource": {
					_addResourceSpans(ue, ia, ia.name, aa, oa, ea);
					break
				}
			}
		}), _performanceCursor = Math.max(ta.length - 1, 0), _trackNavigator(ue), na === "pageload") {
		_addTtfbRequestTimeToMeasurements(_measurements), ["fcp", "fp", "lcp"].forEach(aa => {
			if (!_measurements[aa] || !ra || ea >= ra) return;
			const oa = _measurements[aa].value,
				la = ea + msToSec(oa),
				sa = Math.abs((la - ra) * 1e3),
				ca = sa - oa;
			DEBUG_BUILD$4 && logger.log(`[Measurements] Normalized ${aa} from ${oa} to ${sa} (${ca})`), _measurements[aa].value = sa
		});
		const ia = _measurements["mark.fid"];
		ia && _measurements.fid && (_startChild(ue, {
			description: "first input delay",
			endTimestamp: ia.value + msToSec(_measurements.fid.value),
			op: "ui.action",
			origin: "auto.ui.browser.metrics",
			startTimestamp: ia.value
		}), delete _measurements["mark.fid"]), "fcp" in _measurements || delete _measurements.cls, Object.keys(_measurements).forEach(aa => {
			setMeasurement(aa, _measurements[aa].value, _measurements[aa].unit)
		}), _tagMetricInfo(ue)
	}
	_lcpEntry = void 0, _clsEntry = void 0, _measurements = {}
}

function _addMeasureSpans(ue, Yi, ea, ta, na) {
	const ra = na + ea,
		ia = ra + ta;
	return _startChild(ue, {
		description: Yi.name,
		endTimestamp: ia,
		op: Yi.entryType,
		origin: "auto.resource.browser.metrics",
		startTimestamp: ra
	}), ra
}

function _addNavigationSpans(ue, Yi, ea) {
	["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach(ta => {
		_addPerformanceNavigationTiming(ue, Yi, ta, ea)
	}), _addPerformanceNavigationTiming(ue, Yi, "secureConnection", ea, "TLS/SSL", "connectEnd"), _addPerformanceNavigationTiming(ue, Yi, "fetch", ea, "cache", "domainLookupStart"), _addPerformanceNavigationTiming(ue, Yi, "domainLookup", ea, "DNS"), _addRequest(ue, Yi, ea)
}

function _addPerformanceNavigationTiming(ue, Yi, ea, ta, na, ra) {
	const ia = ra ? Yi[ra] : Yi[`${ea}End`],
		aa = Yi[`${ea}Start`];
	!aa || !ia || _startChild(ue, {
		op: "browser",
		origin: "auto.browser.browser.metrics",
		description: na || ea,
		startTimestamp: ta + msToSec(aa),
		endTimestamp: ta + msToSec(ia)
	})
}

function _addRequest(ue, Yi, ea) {
	Yi.responseEnd && (_startChild(ue, {
		op: "browser",
		origin: "auto.browser.browser.metrics",
		description: "request",
		startTimestamp: ea + msToSec(Yi.requestStart),
		endTimestamp: ea + msToSec(Yi.responseEnd)
	}), _startChild(ue, {
		op: "browser",
		origin: "auto.browser.browser.metrics",
		description: "response",
		startTimestamp: ea + msToSec(Yi.responseStart),
		endTimestamp: ea + msToSec(Yi.responseEnd)
	}))
}

function _addResourceSpans(ue, Yi, ea, ta, na, ra) {
	if (Yi.initiatorType === "xmlhttprequest" || Yi.initiatorType === "fetch") return;
	const ia = parseUrl(ea),
		aa = {};
	setResourceEntrySizeData(aa, Yi, "transferSize", "http.response_transfer_size"), setResourceEntrySizeData(aa, Yi, "encodedBodySize", "http.response_content_length"), setResourceEntrySizeData(aa, Yi, "decodedBodySize", "http.decoded_response_content_length"), "renderBlockingStatus" in Yi && (aa["resource.render_blocking_status"] = Yi.renderBlockingStatus), ia.protocol && (aa["url.scheme"] = ia.protocol.split(":").pop()), ia.host && (aa["server.address"] = ia.host), aa["url.same_origin"] = ea.includes(WINDOW$3.location.origin);
	const oa = ra + ta,
		la = oa + na;
	_startChild(ue, {
		description: ea.replace(WINDOW$3.location.origin, ""),
		endTimestamp: la,
		op: Yi.initiatorType ? `resource.${Yi.initiatorType}` : "resource.other",
		origin: "auto.resource.browser.metrics",
		startTimestamp: oa,
		data: aa
	})
}

function _trackNavigator(ue) {
	const Yi = WINDOW$3.navigator;
	if (!Yi) return;
	const ea = Yi.connection;
	ea && (ea.effectiveType && ue.setTag("effectiveConnectionType", ea.effectiveType), ea.type && ue.setTag("connectionType", ea.type), isMeasurementValue(ea.rtt) && (_measurements["connection.rtt"] = {
		value: ea.rtt,
		unit: "millisecond"
	})), isMeasurementValue(Yi.deviceMemory) && ue.setTag("deviceMemory", `${Yi.deviceMemory} GB`), isMeasurementValue(Yi.hardwareConcurrency) && ue.setTag("hardwareConcurrency", String(Yi.hardwareConcurrency))
}

function _tagMetricInfo(ue) {
	_lcpEntry && (DEBUG_BUILD$4 && logger.log("[Measurements] Adding LCP Data"), _lcpEntry.element && ue.setTag("lcp.element", htmlTreeAsString(_lcpEntry.element)), _lcpEntry.id && ue.setTag("lcp.id", _lcpEntry.id), _lcpEntry.url && ue.setTag("lcp.url", _lcpEntry.url.trim().slice(0, 200)), ue.setTag("lcp.size", _lcpEntry.size)), _clsEntry && _clsEntry.sources && (DEBUG_BUILD$4 && logger.log("[Measurements] Adding CLS Data"), _clsEntry.sources.forEach((Yi, ea) => ue.setTag(`cls.source.${ea+1}`, htmlTreeAsString(Yi.node))))
}

function setResourceEntrySizeData(ue, Yi, ea, ta) {
	const na = Yi[ea];
	na != null && na < MAX_INT_AS_BYTES && (ue[ta] = na)
}

function _addTtfbRequestTimeToMeasurements(ue) {
	const Yi = getNavigationEntry();
	if (!Yi) return;
	const {
		responseStart: ea,
		requestStart: ta
	} = Yi;
	ta <= ea && (DEBUG_BUILD$4 && logger.log("[Measurements] Adding TTFB Request Time"), ue["ttfb.requestTime"] = {
		value: ea - ta,
		unit: "millisecond"
	})
}

function getSampleRate(ue, Yi, ea) {
	if (!hasTracingEnabled(Yi)) return !1;
	let ta;
	return ue !== void 0 && typeof Yi.tracesSampler == "function" ? ta = Yi.tracesSampler({
		transactionContext: ue,
		name: ue.name,
		parentSampled: ue.parentSampled,
		attributes: {
			...ue.data,
			...ue.attributes
		},
		location: WINDOW$3.location
	}) : ue !== void 0 && ue.sampled !== void 0 ? ta = ue.sampled : typeof Yi.tracesSampleRate < "u" ? ta = Yi.tracesSampleRate : ta = 1, isValidSampleRate$1(ta) ? ta === !0 ? ea : ta === !1 ? 0 : ta * ea : (DEBUG_BUILD$4 && logger.warn("[Tracing] Discarding interaction span because of invalid sample rate."), !1)
}

function instrumentFetchRequest(ue, Yi, ea, ta, na = "auto.http.browser") {
	if (!hasTracingEnabled() || !ue.fetchData) return;
	const ra = Yi(ue.fetchData.url);
	if (ue.endTimestamp && ra) {
		const ca = ue.fetchData.__span;
		if (!ca) return;
		const ua = ta[ca];
		if (ua) {
			if (ue.response) {
				setHttpStatus(ua, ue.response.status);
				const da = ue.response && ue.response.headers && ue.response.headers.get("content-length");
				if (da) {
					const ha = parseInt(da);
					ha > 0 && ua.setAttribute("http.response_content_length", ha)
				}
			} else ue.error && ua.setStatus("internal_error");
			ua.end(), delete ta[ca]
		}
		return
	}
	const ia = getCurrentScope(),
		aa = getClient(),
		{
			method: oa,
			url: la
		} = ue.fetchData,
		sa = ra ? startInactiveSpan({
			name: `${oa} ${la}`,
			onlyIfParent: !0,
			attributes: {
				url: la,
				type: "fetch",
				"http.method": oa,
				[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: na
			},
			op: "http.client"
		}) : void 0;
	if (sa && (ue.fetchData.__span = sa.spanContext().spanId, ta[sa.spanContext().spanId] = sa), ea(ue.fetchData.url) && aa) {
		const ca = ue.args[0];
		ue.args[1] = ue.args[1] || {};
		const ua = ue.args[1];
		ua.headers = addTracingHeadersToFetchRequest(ca, aa, ia, ua, sa)
	}
	return sa
}

function addTracingHeadersToFetchRequest(ue, Yi, ea, ta, na) {
	const ra = na || ea.getSpan(),
		ia = getIsolationScope(),
		{
			traceId: aa,
			spanId: oa,
			sampled: la,
			dsc: sa
		} = {
			...ia.getPropagationContext(),
			...ea.getPropagationContext()
		},
		ca = ra ? spanToTraceHeader(ra) : generateSentryTraceHeader(aa, oa, la),
		ua = dynamicSamplingContextToSentryBaggageHeader(sa || (ra ? getDynamicSamplingContextFromSpan(ra) : getDynamicSamplingContextFromClient(aa, Yi, ea))),
		da = ta.headers || (typeof Request < "u" && isInstanceOf(ue, Request) ? ue.headers : void 0);
	if (da)
		if (typeof Headers < "u" && isInstanceOf(da, Headers)) {
			const ha = new Headers(da);
			return ha.append("sentry-trace", ca), ua && ha.append(BAGGAGE_HEADER_NAME, ua), ha
		} else if (Array.isArray(da)) {
		const ha = [...da, ["sentry-trace", ca]];
		return ua && ha.push([BAGGAGE_HEADER_NAME, ua]), ha
	} else {
		const ha = "baggage" in da ? da.baggage : void 0,
			pa = [];
		return Array.isArray(ha) ? pa.push(...ha) : ha && pa.push(ha), ua && pa.push(ua), {
			...da,
			"sentry-trace": ca,
			baggage: pa.length > 0 ? pa.join(",") : void 0
		}
	} else return {
		"sentry-trace": ca,
		baggage: ua
	}
}
const DEFAULT_TRACE_PROPAGATION_TARGETS = ["localhost", /^\/(?!\/)/],
	defaultRequestInstrumentationOptions = {
		traceFetch: !0,
		traceXHR: !0,
		enableHTTPTimings: !0,
		tracingOrigins: DEFAULT_TRACE_PROPAGATION_TARGETS,
		tracePropagationTargets: DEFAULT_TRACE_PROPAGATION_TARGETS
	};

function instrumentOutgoingRequests(ue) {
	const {
		traceFetch: Yi,
		traceXHR: ea,
		tracePropagationTargets: ta,
		tracingOrigins: na,
		shouldCreateSpanForRequest: ra,
		enableHTTPTimings: ia
	} = {
		traceFetch: defaultRequestInstrumentationOptions.traceFetch,
		traceXHR: defaultRequestInstrumentationOptions.traceXHR,
		...ue
	}, aa = typeof ra == "function" ? ra : sa => !0, oa = sa => shouldAttachHeaders(sa, ta || na), la = {};
	Yi && addFetchInstrumentationHandler(sa => {
		const ca = instrumentFetchRequest(sa, aa, oa, la);
		ia && ca && addHTTPTimings(ca)
	}), ea && addXhrInstrumentationHandler(sa => {
		const ca = xhrCallback(sa, aa, oa, la);
		ia && ca && addHTTPTimings(ca)
	})
}

function isPerformanceResourceTiming(ue) {
	return ue.entryType === "resource" && "initiatorType" in ue && typeof ue.nextHopProtocol == "string" && (ue.initiatorType === "fetch" || ue.initiatorType === "xmlhttprequest")
}

function addHTTPTimings(ue) {
	const {
		url: Yi
	} = spanToJSON(ue).data || {};
	if (!Yi || typeof Yi != "string") return;
	const ea = addPerformanceInstrumentationHandler("resource", ({
		entries: ta
	}) => {
		ta.forEach(na => {
			isPerformanceResourceTiming(na) && na.name.endsWith(Yi) && (resourceTimingEntryToSpanData(na).forEach(ia => ue.setAttribute(...ia)), setTimeout(ea))
		})
	})
}

function extractNetworkProtocol(ue) {
	let Yi = "unknown",
		ea = "unknown",
		ta = "";
	for (const na of ue) {
		if (na === "/") {
			[Yi, ea] = ue.split("/");
			break
		}
		if (!isNaN(Number(na))) {
			Yi = ta === "h" ? "http" : ta, ea = ue.split(ta)[1];
			break
		}
		ta += na
	}
	return ta === ue && (Yi = ta), {
		name: Yi,
		version: ea
	}
}

function getAbsoluteTime$1(ue = 0) {
	return ((browserPerformanceTimeOrigin || performance.timeOrigin) + ue) / 1e3
}

function resourceTimingEntryToSpanData(ue) {
	const {
		name: Yi,
		version: ea
	} = extractNetworkProtocol(ue.nextHopProtocol), ta = [];
	return ta.push(["network.protocol.version", ea], ["network.protocol.name", Yi]), browserPerformanceTimeOrigin ? [...ta, ["http.request.redirect_start", getAbsoluteTime$1(ue.redirectStart)],
		["http.request.fetch_start", getAbsoluteTime$1(ue.fetchStart)],
		["http.request.domain_lookup_start", getAbsoluteTime$1(ue.domainLookupStart)],
		["http.request.domain_lookup_end", getAbsoluteTime$1(ue.domainLookupEnd)],
		["http.request.connect_start", getAbsoluteTime$1(ue.connectStart)],
		["http.request.secure_connection_start", getAbsoluteTime$1(ue.secureConnectionStart)],
		["http.request.connection_end", getAbsoluteTime$1(ue.connectEnd)],
		["http.request.request_start", getAbsoluteTime$1(ue.requestStart)],
		["http.request.response_start", getAbsoluteTime$1(ue.responseStart)],
		["http.request.response_end", getAbsoluteTime$1(ue.responseEnd)]
	] : ta
}

function shouldAttachHeaders(ue, Yi) {
	return stringMatchesSomePattern(ue, Yi || DEFAULT_TRACE_PROPAGATION_TARGETS)
}

function xhrCallback(ue, Yi, ea, ta) {
	const na = ue.xhr,
		ra = na && na[SENTRY_XHR_DATA_KEY];
	if (!hasTracingEnabled() || !na || na.__sentry_own_request__ || !ra) return;
	const ia = Yi(ra.url);
	if (ue.endTimestamp && ia) {
		const ca = na.__sentry_xhr_span_id__;
		if (!ca) return;
		const ua = ta[ca];
		ua && ra.status_code !== void 0 && (setHttpStatus(ua, ra.status_code), ua.end(), delete ta[ca]);
		return
	}
	const aa = getCurrentScope(),
		oa = getIsolationScope(),
		la = ia ? startInactiveSpan({
			name: `${ra.method} ${ra.url}`,
			onlyIfParent: !0,
			attributes: {
				type: "xhr",
				"http.method": ra.method,
				url: ra.url,
				[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.http.browser"
			},
			op: "http.client"
		}) : void 0;
	la && (na.__sentry_xhr_span_id__ = la.spanContext().spanId, ta[na.__sentry_xhr_span_id__] = la);
	const sa = getClient();
	if (na.setRequestHeader && ea(ra.url) && sa) {
		const {
			traceId: ca,
			spanId: ua,
			sampled: da,
			dsc: ha
		} = {
			...oa.getPropagationContext(),
			...aa.getPropagationContext()
		}, pa = la ? spanToTraceHeader(la) : generateSentryTraceHeader(ca, ua, da), va = dynamicSamplingContextToSentryBaggageHeader(ha || (la ? getDynamicSamplingContextFromSpan(la) : getDynamicSamplingContextFromClient(ca, sa, aa)));
		setHeaderOnXhr(na, pa, va)
	}
	return la
}

function setHeaderOnXhr(ue, Yi, ea) {
	try {
		ue.setRequestHeader("sentry-trace", Yi), ea && ue.setRequestHeader(BAGGAGE_HEADER_NAME, ea)
	} catch {}
}

function instrumentRoutingWithDefaults(ue, Yi = !0, ea = !0) {
	if (!WINDOW$3 || !WINDOW$3.location) {
		DEBUG_BUILD$4 && logger.warn("Could not initialize routing instrumentation due to invalid location");
		return
	}
	let ta = WINDOW$3.location.href,
		na;
	Yi && (na = ue({
		name: WINDOW$3.location.pathname,
		startTimestamp: browserPerformanceTimeOrigin ? browserPerformanceTimeOrigin / 1e3 : void 0,
		op: "pageload",
		origin: "auto.pageload.browser",
		metadata: {
			source: "url"
		}
	})), ea && addHistoryInstrumentationHandler(({
		to: ra,
		from: ia
	}) => {
		if (ia === void 0 && ta && ta.indexOf(ra) !== -1) {
			ta = void 0;
			return
		}
		ia !== ra && (ta = void 0, na && (DEBUG_BUILD$4 && logger.log(`[Tracing] Finishing current transaction with op: ${na.op}`), na.end()), na = ue({
			name: WINDOW$3.location.pathname,
			op: "navigation",
			origin: "auto.navigation.browser",
			metadata: {
				source: "url"
			}
		}))
	})
}
const BROWSER_TRACING_INTEGRATION_ID$1 = "BrowserTracing",
	DEFAULT_BROWSER_TRACING_OPTIONS$1 = {
		...TRACING_DEFAULTS,
		markBackgroundTransactions: !0,
		routingInstrumentation: instrumentRoutingWithDefaults,
		startTransactionOnLocationChange: !0,
		startTransactionOnPageLoad: !0,
		enableLongTask: !0,
		enableInp: !1,
		interactionsSampleRate: 1,
		_experiments: {},
		...defaultRequestInstrumentationOptions
	},
	MAX_INTERACTIONS$1 = 10;
class BrowserTracing {
	constructor(Yi) {
		this.name = BROWSER_TRACING_INTEGRATION_ID$1, this._hasSetTracePropagationTargets = !1, addTracingExtensions(), DEBUG_BUILD$4 && (this._hasSetTracePropagationTargets = !!(Yi && (Yi.tracePropagationTargets || Yi.tracingOrigins))), this.options = {
			...DEFAULT_BROWSER_TRACING_OPTIONS$1,
			...Yi
		}, this.options._experiments.enableLongTask !== void 0 && (this.options.enableLongTask = this.options._experiments.enableLongTask), Yi && !Yi.tracePropagationTargets && Yi.tracingOrigins && (this.options.tracePropagationTargets = Yi.tracingOrigins), this._collectWebVitals = startTrackingWebVitals(), this._interactionIdToRouteNameMapping = {}, this.options.enableInp && startTrackingINP(this._interactionIdToRouteNameMapping, this.options.interactionsSampleRate), this.options.enableLongTask && startTrackingLongTasks(), this.options._experiments.enableInteractions && startTrackingInteractions(), this._latestRoute = {
			name: void 0,
			context: void 0
		}
	}
	setupOnce(Yi, ea) {
		this._getCurrentHub = ea;
		const na = ea().getClient(),
			ra = na && na.getOptions(),
			{
				routingInstrumentation: ia,
				startTransactionOnLocationChange: aa,
				startTransactionOnPageLoad: oa,
				markBackgroundTransactions: la,
				traceFetch: sa,
				traceXHR: ca,
				shouldCreateSpanForRequest: ua,
				enableHTTPTimings: da,
				_experiments: ha
			} = this.options,
			pa = ra && ra.tracePropagationTargets,
			va = pa || this.options.tracePropagationTargets;
		DEBUG_BUILD$4 && this._hasSetTracePropagationTargets && pa && logger.warn("[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used."), ia(ba => {
			const Ea = this._createRouteTransaction(ba);
			return this.options._experiments.onStartRouteTransaction && this.options._experiments.onStartRouteTransaction(Ea, ba, ea), Ea
		}, oa, aa), la && registerBackgroundTabDetection(), ha.enableInteractions && this._registerInteractionListener(), this.options.enableInp && this._registerInpInteractionListener(), instrumentOutgoingRequests({
			traceFetch: sa,
			traceXHR: ca,
			tracePropagationTargets: va,
			shouldCreateSpanForRequest: ua,
			enableHTTPTimings: da
		})
	}
	_createRouteTransaction(Yi) {
		if (!this._getCurrentHub) {
			DEBUG_BUILD$4 && logger.warn(`[Tracing] Did not create ${Yi.op} transaction because _getCurrentHub is invalid.`);
			return
		}
		const ea = this._getCurrentHub(),
			{
				beforeNavigate: ta,
				idleTimeout: na,
				finalTimeout: ra,
				heartbeatInterval: ia
			} = this.options,
			aa = Yi.op === "pageload";
		let oa;
		if (aa) {
			const da = aa ? getMetaContent$1("sentry-trace") : "",
				ha = aa ? getMetaContent$1("baggage") : void 0,
				{
					traceId: pa,
					dsc: va,
					parentSpanId: ba,
					sampled: Ea
				} = propagationContextFromHeaders(da, ha);
			oa = {
				traceId: pa,
				parentSpanId: ba,
				parentSampled: Ea,
				...Yi,
				metadata: {
					...Yi.metadata,
					dynamicSamplingContext: va
				},
				trimEnd: !0
			}
		} else oa = {
			trimEnd: !0,
			...Yi
		};
		const la = typeof ta == "function" ? ta(oa) : oa,
			sa = la === void 0 ? {
				...oa,
				sampled: !1
			} : la;
		sa.metadata = sa.name !== oa.name ? {
			...sa.metadata,
			source: "custom"
		} : sa.metadata, this._latestRoute.name = sa.name, this._latestRoute.context = sa, sa.sampled === !1 && DEBUG_BUILD$4 && logger.log(`[Tracing] Will not send ${sa.op} transaction because of beforeNavigate.`), DEBUG_BUILD$4 && logger.log(`[Tracing] Starting ${sa.op} transaction on scope`);
		const {
			location: ca
		} = WINDOW$3, ua = startIdleTransaction(ea, sa, na, ra, !0, {
			location: ca
		}, ia, aa);
		return aa && (WINDOW$3.document.addEventListener("readystatechange", () => {
			["interactive", "complete"].includes(WINDOW$3.document.readyState) && ua.sendAutoFinishSignal()
		}), ["interactive", "complete"].includes(WINDOW$3.document.readyState) && ua.sendAutoFinishSignal()), ua.registerBeforeFinishCallback(da => {
			this._collectWebVitals(), addPerformanceEntries(da)
		}), ua
	}
	_registerInteractionListener() {
		let Yi;
		const ea = () => {
			const {
				idleTimeout: ta,
				finalTimeout: na,
				heartbeatInterval: ra
			} = this.options, ia = "ui.action.click", aa = getActiveTransaction$1();
			if (aa && aa.op && ["navigation", "pageload"].includes(aa.op)) {
				DEBUG_BUILD$4 && logger.warn(`[Tracing] Did not create ${ia} transaction because a pageload or navigation transaction is in progress.`);
				return
			}
			if (Yi && (Yi.setFinishReason("interactionInterrupted"), Yi.end(), Yi = void 0), !this._getCurrentHub) {
				DEBUG_BUILD$4 && logger.warn(`[Tracing] Did not create ${ia} transaction because _getCurrentHub is invalid.`);
				return
			}
			if (!this._latestRoute.name) {
				DEBUG_BUILD$4 && logger.warn(`[Tracing] Did not create ${ia} transaction because _latestRouteName is missing.`);
				return
			}
			const oa = this._getCurrentHub(),
				{
					location: la
				} = WINDOW$3,
				sa = {
					name: this._latestRoute.name,
					op: ia,
					trimEnd: !0,
					data: {
						[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: this._latestRoute.context ? getSource$1(this._latestRoute.context) : "url"
					}
				};
			Yi = startIdleTransaction(oa, sa, ta, na, !0, {
				location: la
			}, ra)
		};
		["click"].forEach(ta => {
			addEventListener(ta, ea, {
				once: !1,
				capture: !0
			})
		})
	}
	_registerInpInteractionListener() {
		const Yi = ({
			entries: ea
		}) => {
			const ta = getClient(),
				na = ta !== void 0 && ta.getIntegrationByName !== void 0 ? ta.getIntegrationByName("Replay") : void 0,
				ra = na !== void 0 ? na.getReplayId() : void 0,
				ia = getActiveTransaction$1(),
				aa = getCurrentScope(),
				oa = aa !== void 0 ? aa.getUser() : void 0;
			ea.forEach(la => {
				if (isPerformanceEventTiming$1(la)) {
					const sa = la.interactionId;
					if (sa === void 0) return;
					const ca = this._interactionIdToRouteNameMapping[sa],
						ua = la.duration,
						da = la.startTime,
						ha = Object.keys(this._interactionIdToRouteNameMapping),
						pa = ha.length > 0 ? ha.reduce((va, ba) => this._interactionIdToRouteNameMapping[va].duration < this._interactionIdToRouteNameMapping[ba].duration ? va : ba) : void 0;
					if (la.entryType === "first-input" && ha.map(ba => this._interactionIdToRouteNameMapping[ba]).some(ba => ba.duration === ua && ba.startTime === da) || !sa) return;
					if (ca) ca.duration = Math.max(ca.duration, ua);
					else if (ha.length < MAX_INTERACTIONS$1 || pa === void 0 || ua > this._interactionIdToRouteNameMapping[pa].duration) {
						const va = this._latestRoute.name,
							ba = this._latestRoute.context;
						va && ba && (pa && Object.keys(this._interactionIdToRouteNameMapping).length >= MAX_INTERACTIONS$1 && delete this._interactionIdToRouteNameMapping[pa], this._interactionIdToRouteNameMapping[sa] = {
							routeName: va,
							duration: ua,
							parentContext: ba,
							user: oa,
							activeTransaction: ia,
							replayId: ra,
							startTime: da
						})
					}
				}
			})
		};
		addPerformanceInstrumentationHandler("event", Yi), addPerformanceInstrumentationHandler("first-input", Yi)
	}
}

function getMetaContent$1(ue) {
	const Yi = getDomElement(`meta[name=${ue}]`);
	return Yi ? Yi.getAttribute("content") : void 0
}

function getSource$1(ue) {
	const Yi = ue.attributes && ue.attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE],
		ea = ue.data && ue.data[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE],
		ta = ue.metadata && ue.metadata.source;
	return Yi || ea || ta
}

function isPerformanceEventTiming$1(ue) {
	return "duration" in ue
}
const BROWSER_TRACING_INTEGRATION_ID = "BrowserTracing",
	DEFAULT_BROWSER_TRACING_OPTIONS = {
		...TRACING_DEFAULTS,
		instrumentNavigation: !0,
		instrumentPageLoad: !0,
		markBackgroundSpan: !0,
		enableLongTask: !0,
		enableInp: !1,
		interactionsSampleRate: 1,
		_experiments: {},
		...defaultRequestInstrumentationOptions
	},
	browserTracingIntegration$1 = (ue = {}) => {
		const Yi = DEBUG_BUILD$4 ? !!(ue.tracePropagationTargets || ue.tracingOrigins) : !1;
		addTracingExtensions(), !ue.tracePropagationTargets && ue.tracingOrigins && (ue.tracePropagationTargets = ue.tracingOrigins);
		const ea = {
				...DEFAULT_BROWSER_TRACING_OPTIONS,
				...ue
			},
			ta = startTrackingWebVitals(),
			na = {};
		ea.enableInp && startTrackingINP(na, ea.interactionsSampleRate), ea.enableLongTask && startTrackingLongTasks(), ea._experiments.enableInteractions && startTrackingInteractions();
		const ra = {
			name: void 0,
			context: void 0
		};

		function ia(aa) {
			const oa = getCurrentHub(),
				{
					beforeStartSpan: la,
					idleTimeout: sa,
					finalTimeout: ca,
					heartbeatInterval: ua
				} = ea,
				da = aa.op === "pageload";
			let ha;
			if (da) {
				const Ea = da ? getMetaContent("sentry-trace") : "",
					Sa = da ? getMetaContent("baggage") : void 0,
					{
						traceId: Ca,
						dsc: ka,
						parentSpanId: Pa,
						sampled: ja
					} = propagationContextFromHeaders(Ea, Sa);
				ha = {
					traceId: Ca,
					parentSpanId: Pa,
					parentSampled: ja,
					...aa,
					metadata: {
						...aa.metadata,
						dynamicSamplingContext: ka
					},
					trimEnd: !0
				}
			} else ha = {
				trimEnd: !0,
				...aa
			};
			const pa = la ? la(ha) : ha;
			pa.metadata = pa.name !== ha.name ? {
				...pa.metadata,
				source: "custom"
			} : pa.metadata, ra.name = pa.name, ra.context = pa, pa.sampled === !1 && DEBUG_BUILD$4 && logger.log(`[Tracing] Will not send ${pa.op} transaction because of beforeNavigate.`), DEBUG_BUILD$4 && logger.log(`[Tracing] Starting ${pa.op} transaction on scope`);
			const {
				location: va
			} = WINDOW$3, ba = startIdleTransaction(oa, pa, sa, ca, !0, {
				location: va
			}, ua, da);
			return da && WINDOW$3.document && (WINDOW$3.document.addEventListener("readystatechange", () => {
				["interactive", "complete"].includes(WINDOW$3.document.readyState) && ba.sendAutoFinishSignal()
			}), ["interactive", "complete"].includes(WINDOW$3.document.readyState) && ba.sendAutoFinishSignal()), ba.registerBeforeFinishCallback(Ea => {
				ta(), addPerformanceEntries(Ea)
			}), ba
		}
		return {
			name: BROWSER_TRACING_INTEGRATION_ID,
			setupOnce: () => {},
			afterAllSetup(aa) {
				const oa = aa.getOptions(),
					{
						markBackgroundSpan: la,
						traceFetch: sa,
						traceXHR: ca,
						shouldCreateSpanForRequest: ua,
						enableHTTPTimings: da,
						_experiments: ha
					} = ea,
					pa = oa && oa.tracePropagationTargets,
					va = pa || ea.tracePropagationTargets;
				DEBUG_BUILD$4 && Yi && pa && logger.warn("[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used.");
				let ba, Ea = WINDOW$3.location && WINDOW$3.location.href;
				if (aa.on && (aa.on("startNavigationSpan", Sa => {
						ba && (DEBUG_BUILD$4 && logger.log(`[Tracing] Finishing current transaction with op: ${spanToJSON(ba).op}`), ba.end()), ba = ia({
							op: "navigation",
							...Sa
						})
					}), aa.on("startPageLoadSpan", Sa => {
						ba && (DEBUG_BUILD$4 && logger.log(`[Tracing] Finishing current transaction with op: ${spanToJSON(ba).op}`), ba.end()), ba = ia({
							op: "pageload",
							...Sa
						})
					})), ea.instrumentPageLoad && aa.emit && WINDOW$3.location) {
					const Sa = {
						name: WINDOW$3.location.pathname,
						startTimestamp: browserPerformanceTimeOrigin ? browserPerformanceTimeOrigin / 1e3 : void 0,
						origin: "auto.pageload.browser",
						attributes: {
							[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "url"
						}
					};
					startBrowserTracingPageLoadSpan(aa, Sa)
				}
				ea.instrumentNavigation && aa.emit && WINDOW$3.location && addHistoryInstrumentationHandler(({
					to: Sa,
					from: Ca
				}) => {
					if (Ca === void 0 && Ea && Ea.indexOf(Sa) !== -1) {
						Ea = void 0;
						return
					}
					if (Ca !== Sa) {
						Ea = void 0;
						const ka = {
							name: WINDOW$3.location.pathname,
							origin: "auto.navigation.browser",
							attributes: {
								[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "url"
							}
						};
						startBrowserTracingNavigationSpan(aa, ka)
					}
				}), la && registerBackgroundTabDetection(), ha.enableInteractions && registerInteractionListener(ea, ra), ea.enableInp && registerInpInteractionListener(na, ra), instrumentOutgoingRequests({
					traceFetch: sa,
					traceXHR: ca,
					tracePropagationTargets: va,
					shouldCreateSpanForRequest: ua,
					enableHTTPTimings: da
				})
			},
			options: ea
		}
	};

function startBrowserTracingPageLoadSpan(ue, Yi) {
	if (!ue.emit) return;
	ue.emit("startPageLoadSpan", Yi);
	const ea = getActiveSpan();
	return (ea && spanToJSON(ea).op) === "pageload" ? ea : void 0
}

function startBrowserTracingNavigationSpan(ue, Yi) {
	if (!ue.emit) return;
	ue.emit("startNavigationSpan", Yi);
	const ea = getActiveSpan();
	return (ea && spanToJSON(ea).op) === "navigation" ? ea : void 0
}

function getMetaContent(ue) {
	const Yi = getDomElement(`meta[name=${ue}]`);
	return Yi ? Yi.getAttribute("content") : void 0
}

function registerInteractionListener(ue, Yi) {
	let ea;
	const ta = () => {
		const {
			idleTimeout: na,
			finalTimeout: ra,
			heartbeatInterval: ia
		} = ue, aa = "ui.action.click", oa = getActiveTransaction$1();
		if (oa && oa.op && ["navigation", "pageload"].includes(oa.op)) {
			DEBUG_BUILD$4 && logger.warn(`[Tracing] Did not create ${aa} transaction because a pageload or navigation transaction is in progress.`);
			return
		}
		if (ea && (ea.setFinishReason("interactionInterrupted"), ea.end(), ea = void 0), !Yi.name) {
			DEBUG_BUILD$4 && logger.warn(`[Tracing] Did not create ${aa} transaction because _latestRouteName is missing.`);
			return
		}
		const {
			location: la
		} = WINDOW$3, sa = {
			name: Yi.name,
			op: aa,
			trimEnd: !0,
			data: {
				[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: Yi.context ? getSource(Yi.context) : "url"
			}
		};
		ea = startIdleTransaction(getCurrentHub(), sa, na, ra, !0, {
			location: la
		}, ia)
	};
	["click"].forEach(na => {
		addEventListener(na, ta, {
			once: !1,
			capture: !0
		})
	})
}

function isPerformanceEventTiming(ue) {
	return "duration" in ue
}
const MAX_INTERACTIONS = 10;

function registerInpInteractionListener(ue, Yi) {
	const ea = ({
		entries: ta
	}) => {
		const na = getClient(),
			ra = na !== void 0 && na.getIntegrationByName !== void 0 ? na.getIntegrationByName("Replay") : void 0,
			ia = ra !== void 0 ? ra.getReplayId() : void 0,
			aa = getActiveTransaction$1(),
			oa = getCurrentScope(),
			la = oa !== void 0 ? oa.getUser() : void 0;
		ta.forEach(sa => {
			if (isPerformanceEventTiming(sa)) {
				const ca = sa.interactionId;
				if (ca === void 0) return;
				const ua = ue[ca],
					da = sa.duration,
					ha = sa.startTime,
					pa = Object.keys(ue),
					va = pa.length > 0 ? pa.reduce((ba, Ea) => ue[ba].duration < ue[Ea].duration ? ba : Ea) : void 0;
				if (sa.entryType === "first-input" && pa.map(Ea => ue[Ea]).some(Ea => Ea.duration === da && Ea.startTime === ha) || !ca) return;
				if (ua) ua.duration = Math.max(ua.duration, da);
				else if (pa.length < MAX_INTERACTIONS || va === void 0 || da > ue[va].duration) {
					const ba = Yi.name,
						Ea = Yi.context;
					ba && Ea && (va && Object.keys(ue).length >= MAX_INTERACTIONS && delete ue[va], ue[ca] = {
						routeName: ba,
						duration: da,
						parentContext: Ea,
						user: la,
						activeTransaction: aa,
						replayId: ia,
						startTime: ha
					})
				}
			}
		})
	};
	addPerformanceInstrumentationHandler("event", ea), addPerformanceInstrumentationHandler("first-input", ea)
}

function getSource(ue) {
	const Yi = ue.attributes && ue.attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE],
		ea = ue.data && ue.data[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE],
		ta = ue.metadata && ue.metadata.source;
	return Yi || ea || ta
}
const WINDOW$2 = GLOBAL_OBJ;
let ignoreOnError = 0;

function shouldIgnoreOnError() {
	return ignoreOnError > 0
}

function ignoreNextOnError() {
	ignoreOnError++, setTimeout(() => {
		ignoreOnError--
	})
}

function wrap$1(ue, Yi = {}, ea) {
	if (typeof ue != "function") return ue;
	try {
		const na = ue.__sentry_wrapped__;
		if (na) return na;
		if (getOriginalFunction(ue)) return ue
	} catch {
		return ue
	}
	const ta = function() {
		const na = Array.prototype.slice.call(arguments);
		try {
			const ra = na.map(ia => wrap$1(ia, Yi));
			return ue.apply(this, ra)
		} catch (ra) {
			throw ignoreNextOnError(), withScope(ia => {
				ia.addEventProcessor(aa => (Yi.mechanism && (addExceptionTypeValue(aa, void 0), addExceptionMechanism(aa, Yi.mechanism)), aa.extra = {
					...aa.extra,
					arguments: na
				}, aa)), captureException(ra)
			}), ra
		}
	};
	try {
		for (const na in ue) Object.prototype.hasOwnProperty.call(ue, na) && (ta[na] = ue[na])
	} catch {}
	markFunctionWrapped(ta, ue), addNonEnumerableProperty(ue, "__sentry_wrapped__", ta);
	try {
		Object.getOwnPropertyDescriptor(ta, "name").configurable && Object.defineProperty(ta, "name", {
			get() {
				return ue.name
			}
		})
	} catch {}
	return ta
}
const DEBUG_BUILD$3 = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;

function exceptionFromError(ue, Yi) {
	const ea = parseStackFrames(ue, Yi),
		ta = {
			type: Yi && Yi.name,
			value: extractMessage(Yi)
		};
	return ea.length && (ta.stacktrace = {
		frames: ea
	}), ta.type === void 0 && ta.value === "" && (ta.value = "Unrecoverable error caught"), ta
}

function eventFromPlainObject(ue, Yi, ea, ta) {
	const na = getClient(),
		ra = na && na.getOptions().normalizeDepth,
		ia = {
			exception: {
				values: [{
					type: isEvent(Yi) ? Yi.constructor.name : ta ? "UnhandledRejection" : "Error",
					value: getNonErrorObjectExceptionValue(Yi, {
						isUnhandledRejection: ta
					})
				}]
			},
			extra: {
				__serialized__: normalizeToSize(Yi, ra)
			}
		};
	if (ea) {
		const aa = parseStackFrames(ue, ea);
		aa.length && (ia.exception.values[0].stacktrace = {
			frames: aa
		})
	}
	return ia
}

function eventFromError(ue, Yi) {
	return {
		exception: {
			values: [exceptionFromError(ue, Yi)]
		}
	}
}

function parseStackFrames(ue, Yi) {
	const ea = Yi.stacktrace || Yi.stack || "",
		ta = getPopSize(Yi);
	try {
		return ue(ea, ta)
	} catch {}
	return []
}
const reactMinifiedRegexp = /Minified React error #\d+;/i;

function getPopSize(ue) {
	if (ue) {
		if (typeof ue.framesToPop == "number") return ue.framesToPop;
		if (reactMinifiedRegexp.test(ue.message)) return 1
	}
	return 0
}

function extractMessage(ue) {
	const Yi = ue && ue.message;
	return Yi ? Yi.error && typeof Yi.error.message == "string" ? Yi.error.message : Yi : "No error message"
}

function eventFromException(ue, Yi, ea, ta) {
	const na = ea && ea.syntheticException || void 0,
		ra = eventFromUnknownInput(ue, Yi, na, ta);
	return addExceptionMechanism(ra), ra.level = "error", ea && ea.event_id && (ra.event_id = ea.event_id), resolvedSyncPromise(ra)
}

function eventFromMessage(ue, Yi, ea = "info", ta, na) {
	const ra = ta && ta.syntheticException || void 0,
		ia = eventFromString(ue, Yi, ra, na);
	return ia.level = ea, ta && ta.event_id && (ia.event_id = ta.event_id), resolvedSyncPromise(ia)
}

function eventFromUnknownInput(ue, Yi, ea, ta, na) {
	let ra;
	if (isErrorEvent$2(Yi) && Yi.error) return eventFromError(ue, Yi.error);
	if (isDOMError(Yi) || isDOMException(Yi)) {
		const ia = Yi;
		if ("stack" in Yi) ra = eventFromError(ue, Yi);
		else {
			const aa = ia.name || (isDOMError(ia) ? "DOMError" : "DOMException"),
				oa = ia.message ? `${aa}: ${ia.message}` : aa;
			ra = eventFromString(ue, oa, ea, ta), addExceptionTypeValue(ra, oa)
		}
		return "code" in ia && (ra.tags = {
			...ra.tags,
			"DOMException.code": `${ia.code}`
		}), ra
	}
	return isError(Yi) ? eventFromError(ue, Yi) : isPlainObject(Yi) || isEvent(Yi) ? (ra = eventFromPlainObject(ue, Yi, ea, na), addExceptionMechanism(ra, {
		synthetic: !0
	}), ra) : (ra = eventFromString(ue, Yi, ea, ta), addExceptionTypeValue(ra, `${Yi}`), addExceptionMechanism(ra, {
		synthetic: !0
	}), ra)
}

function eventFromString(ue, Yi, ea, ta) {
	const na = {};
	if (ta && ea) {
		const ra = parseStackFrames(ue, ea);
		ra.length && (na.exception = {
			values: [{
				value: Yi,
				stacktrace: {
					frames: ra
				}
			}]
		})
	}
	if (isParameterizedString(Yi)) {
		const {
			__sentry_template_string__: ra,
			__sentry_template_values__: ia
		} = Yi;
		return na.logentry = {
			message: ra,
			params: ia
		}, na
	}
	return na.message = Yi, na
}

function getNonErrorObjectExceptionValue(ue, {
	isUnhandledRejection: Yi
}) {
	const ea = extractExceptionKeysForMessage(ue),
		ta = Yi ? "promise rejection" : "exception";
	return isErrorEvent$2(ue) ? `Event \`ErrorEvent\` captured as ${ta} with message \`${ue.message}\`` : isEvent(ue) ? `Event \`${getObjectClassName(ue)}\` (type=${ue.type}) captured as ${ta}` : `Object captured as ${ta} with keys: ${ea}`
}

function getObjectClassName(ue) {
	try {
		const Yi = Object.getPrototypeOf(ue);
		return Yi ? Yi.constructor.name : void 0
	} catch {}
}

function createUserFeedbackEnvelope(ue, {
	metadata: Yi,
	tunnel: ea,
	dsn: ta
}) {
	const na = {
			event_id: ue.event_id,
			sent_at: new Date().toISOString(),
			...Yi && Yi.sdk && {
				sdk: {
					name: Yi.sdk.name,
					version: Yi.sdk.version
				}
			},
			...!!ea && !!ta && {
				dsn: dsnToString(ta)
			}
		},
		ra = createUserFeedbackEnvelopeItem(ue);
	return createEnvelope(na, [ra])
}

function createUserFeedbackEnvelopeItem(ue) {
	return [{
		type: "user_report"
	}, ue]
}
class BrowserClient extends BaseClient {
	constructor(Yi) {
		const ea = WINDOW$2.SENTRY_SDK_SOURCE || getSDKSource();
		applySdkMetadata(Yi, "browser", ["browser"], ea), super(Yi), Yi.sendClientReports && WINDOW$2.document && WINDOW$2.document.addEventListener("visibilitychange", () => {
			WINDOW$2.document.visibilityState === "hidden" && this._flushOutcomes()
		})
	}
	eventFromException(Yi, ea) {
		return eventFromException(this._options.stackParser, Yi, ea, this._options.attachStacktrace)
	}
	eventFromMessage(Yi, ea = "info", ta) {
		return eventFromMessage(this._options.stackParser, Yi, ea, ta, this._options.attachStacktrace)
	}
	captureUserFeedback(Yi) {
		if (!this._isEnabled()) {
			DEBUG_BUILD$3 && logger.warn("SDK not enabled, will not capture user feedback.");
			return
		}
		const ea = createUserFeedbackEnvelope(Yi, {
			metadata: this.getSdkMetadata(),
			dsn: this.getDsn(),
			tunnel: this.getOptions().tunnel
		});
		this._sendEnvelope(ea)
	}
	_prepareEvent(Yi, ea, ta) {
		return Yi.platform = Yi.platform || "javascript", super._prepareEvent(Yi, ea, ta)
	}
	_flushOutcomes() {
		const Yi = this._clearOutcomes();
		if (Yi.length === 0) {
			DEBUG_BUILD$3 && logger.log("No outcomes to send");
			return
		}
		if (!this._dsn) {
			DEBUG_BUILD$3 && logger.log("No dsn provided, will not send outcomes");
			return
		}
		DEBUG_BUILD$3 && logger.log("Sending outcomes:", Yi);
		const ea = createClientReportEnvelope(Yi, this._options.tunnel && dsnToString(this._dsn));
		this._sendEnvelope(ea)
	}
}
let cachedFetchImpl;

function getNativeFetchImplementation() {
	if (cachedFetchImpl) return cachedFetchImpl;
	if (isNativeFetch(WINDOW$2.fetch)) return cachedFetchImpl = WINDOW$2.fetch.bind(WINDOW$2);
	const ue = WINDOW$2.document;
	let Yi = WINDOW$2.fetch;
	if (ue && typeof ue.createElement == "function") try {
		const ea = ue.createElement("iframe");
		ea.hidden = !0, ue.head.appendChild(ea);
		const ta = ea.contentWindow;
		ta && ta.fetch && (Yi = ta.fetch), ue.head.removeChild(ea)
	} catch (ea) {
		DEBUG_BUILD$3 && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", ea)
	}
	return cachedFetchImpl = Yi.bind(WINDOW$2)
}

function clearCachedFetchImplementation() {
	cachedFetchImpl = void 0
}

function makeFetchTransport(ue, Yi = getNativeFetchImplementation()) {
	let ea = 0,
		ta = 0;

	function na(ra) {
		const ia = ra.body.length;
		ea += ia, ta++;
		const aa = {
			body: ra.body,
			method: "POST",
			referrerPolicy: "origin",
			headers: ue.headers,
			keepalive: ea <= 6e4 && ta < 15,
			...ue.fetchOptions
		};
		try {
			return Yi(ue.url, aa).then(oa => (ea -= ia, ta--, {
				statusCode: oa.status,
				headers: {
					"x-sentry-rate-limits": oa.headers.get("X-Sentry-Rate-Limits"),
					"retry-after": oa.headers.get("Retry-After")
				}
			}))
		} catch (oa) {
			return clearCachedFetchImplementation(), ea -= ia, ta--, rejectedSyncPromise(oa)
		}
	}
	return createTransport(ue, na)
}
const XHR_READYSTATE_DONE = 4;

function makeXHRTransport(ue) {
	function Yi(ea) {
		return new SyncPromise((ta, na) => {
			const ra = new XMLHttpRequest;
			ra.onerror = na, ra.onreadystatechange = () => {
				ra.readyState === XHR_READYSTATE_DONE && ta({
					statusCode: ra.status,
					headers: {
						"x-sentry-rate-limits": ra.getResponseHeader("X-Sentry-Rate-Limits"),
						"retry-after": ra.getResponseHeader("Retry-After")
					}
				})
			}, ra.open("POST", ue.url);
			for (const ia in ue.headers) Object.prototype.hasOwnProperty.call(ue.headers, ia) && ra.setRequestHeader(ia, ue.headers[ia]);
			ra.send(ea.body)
		})
	}
	return createTransport(ue, Yi)
}
const UNKNOWN_FUNCTION = "?",
	OPERA10_PRIORITY = 10,
	OPERA11_PRIORITY = 20,
	CHROME_PRIORITY = 30,
	WINJS_PRIORITY = 40,
	GECKO_PRIORITY = 50;

function createFrame(ue, Yi, ea, ta) {
	const na = {
		filename: ue,
		function: Yi,
		in_app: !0
	};
	return ea !== void 0 && (na.lineno = ea), ta !== void 0 && (na.colno = ta), na
}
const chromeRegex = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
	chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/,
	chromeStackParserFn = ue => {
		const Yi = chromeRegex.exec(ue);
		if (Yi) {
			if (Yi[2] && Yi[2].indexOf("eval") === 0) {
				const ra = chromeEvalRegex.exec(Yi[2]);
				ra && (Yi[2] = ra[1], Yi[3] = ra[2], Yi[4] = ra[3])
			}
			const [ta, na] = extractSafariExtensionDetails(Yi[1] || UNKNOWN_FUNCTION, Yi[2]);
			return createFrame(na, ta, Yi[3] ? +Yi[3] : void 0, Yi[4] ? +Yi[4] : void 0)
		}
	},
	chromeStackLineParser = [CHROME_PRIORITY, chromeStackParserFn],
	geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i,
	geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
	gecko = ue => {
		const Yi = geckoREgex.exec(ue);
		if (Yi) {
			if (Yi[3] && Yi[3].indexOf(" > eval") > -1) {
				const ra = geckoEvalRegex.exec(Yi[3]);
				ra && (Yi[1] = Yi[1] || "eval", Yi[3] = ra[1], Yi[4] = ra[2], Yi[5] = "")
			}
			let ta = Yi[3],
				na = Yi[1] || UNKNOWN_FUNCTION;
			return [na, ta] = extractSafariExtensionDetails(na, ta), createFrame(ta, na, Yi[4] ? +Yi[4] : void 0, Yi[5] ? +Yi[5] : void 0)
		}
	},
	geckoStackLineParser = [GECKO_PRIORITY, gecko],
	winjsRegex = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
	winjs = ue => {
		const Yi = winjsRegex.exec(ue);
		return Yi ? createFrame(Yi[2], Yi[1] || UNKNOWN_FUNCTION, +Yi[3], Yi[4] ? +Yi[4] : void 0) : void 0
	},
	winjsStackLineParser = [WINJS_PRIORITY, winjs],
	opera10Regex = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i,
	opera10 = ue => {
		const Yi = opera10Regex.exec(ue);
		return Yi ? createFrame(Yi[2], Yi[3] || UNKNOWN_FUNCTION, +Yi[1]) : void 0
	},
	opera10StackLineParser = [OPERA10_PRIORITY, opera10],
	opera11Regex = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\(.*\))? in (.*):\s*$/i,
	opera11 = ue => {
		const Yi = opera11Regex.exec(ue);
		return Yi ? createFrame(Yi[5], Yi[3] || Yi[4] || UNKNOWN_FUNCTION, +Yi[1], +Yi[2]) : void 0
	},
	opera11StackLineParser = [OPERA11_PRIORITY, opera11],
	defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser, winjsStackLineParser],
	defaultStackParser = createStackParser(...defaultStackLineParsers),
	extractSafariExtensionDetails = (ue, Yi) => {
		const ea = ue.indexOf("safari-extension") !== -1,
			ta = ue.indexOf("safari-web-extension") !== -1;
		return ea || ta ? [ue.indexOf("@") !== -1 ? ue.split("@")[0] : UNKNOWN_FUNCTION, ea ? `safari-extension:${Yi}` : `safari-web-extension:${Yi}`] : [ue, Yi]
	},
	MAX_ALLOWED_STRING_LENGTH = 1024,
	INTEGRATION_NAME$8 = "Breadcrumbs",
	_breadcrumbsIntegration = (ue = {}) => {
		const Yi = {
			console: !0,
			dom: !0,
			fetch: !0,
			history: !0,
			sentry: !0,
			xhr: !0,
			...ue
		};
		return {
			name: INTEGRATION_NAME$8,
			setupOnce() {},
			setup(ea) {
				Yi.console && addConsoleInstrumentationHandler(_getConsoleBreadcrumbHandler(ea)), Yi.dom && addClickKeypressInstrumentationHandler(_getDomBreadcrumbHandler(ea, Yi.dom)), Yi.xhr && addXhrInstrumentationHandler(_getXhrBreadcrumbHandler(ea)), Yi.fetch && addFetchInstrumentationHandler(_getFetchBreadcrumbHandler(ea)), Yi.history && addHistoryInstrumentationHandler(_getHistoryBreadcrumbHandler(ea)), Yi.sentry && ea.on && ea.on("beforeSendEvent", _getSentryBreadcrumbHandler(ea))
			}
		}
	},
	breadcrumbsIntegration = _breadcrumbsIntegration,
	Breadcrumbs = convertIntegrationFnToClass(INTEGRATION_NAME$8, breadcrumbsIntegration);

function _getSentryBreadcrumbHandler(ue) {
	return function(ea) {
		getClient() === ue && addBreadcrumb({
			category: `sentry.${ea.type==="transaction"?"transaction":"event"}`,
			event_id: ea.event_id,
			level: ea.level,
			message: getEventDescription(ea)
		}, {
			event: ea
		})
	}
}

function _getDomBreadcrumbHandler(ue, Yi) {
	return function(ta) {
		if (getClient() !== ue) return;
		let na, ra, ia = typeof Yi == "object" ? Yi.serializeAttribute : void 0,
			aa = typeof Yi == "object" && typeof Yi.maxStringLength == "number" ? Yi.maxStringLength : void 0;
		aa && aa > MAX_ALLOWED_STRING_LENGTH && (DEBUG_BUILD$3 && logger.warn(`\`dom.maxStringLength\` cannot exceed ${MAX_ALLOWED_STRING_LENGTH}, but a value of ${aa} was configured. Sentry will use ${MAX_ALLOWED_STRING_LENGTH} instead.`), aa = MAX_ALLOWED_STRING_LENGTH), typeof ia == "string" && (ia = [ia]);
		try {
			const la = ta.event,
				sa = _isEvent(la) ? la.target : la;
			na = htmlTreeAsString(sa, {
				keyAttrs: ia,
				maxStringLength: aa
			}), ra = getComponentName(sa)
		} catch {
			na = "<unknown>"
		}
		if (na.length === 0) return;
		const oa = {
			category: `ui.${ta.name}`,
			message: na
		};
		ra && (oa.data = {
			"ui.component_name": ra
		}), addBreadcrumb(oa, {
			event: ta.event,
			name: ta.name,
			global: ta.global
		})
	}
}

function _getConsoleBreadcrumbHandler(ue) {
	return function(ea) {
		if (getClient() !== ue) return;
		const ta = {
			category: "console",
			data: {
				arguments: ea.args,
				logger: "console"
			},
			level: severityLevelFromString(ea.level),
			message: safeJoin(ea.args, " ")
		};
		if (ea.level === "assert")
			if (ea.args[0] === !1) ta.message = `Assertion failed: ${safeJoin(ea.args.slice(1)," ")||"console.assert"}`, ta.data.arguments = ea.args.slice(1);
			else return;
		addBreadcrumb(ta, {
			input: ea.args,
			level: ea.level
		})
	}
}

function _getXhrBreadcrumbHandler(ue) {
	return function(ea) {
		if (getClient() !== ue) return;
		const {
			startTimestamp: ta,
			endTimestamp: na
		} = ea, ra = ea.xhr[SENTRY_XHR_DATA_KEY];
		if (!ta || !na || !ra) return;
		const {
			method: ia,
			url: aa,
			status_code: oa,
			body: la
		} = ra, sa = {
			method: ia,
			url: aa,
			status_code: oa
		}, ca = {
			xhr: ea.xhr,
			input: la,
			startTimestamp: ta,
			endTimestamp: na
		};
		addBreadcrumb({
			category: "xhr",
			data: sa,
			type: "http"
		}, ca)
	}
}

function _getFetchBreadcrumbHandler(ue) {
	return function(ea) {
		if (getClient() !== ue) return;
		const {
			startTimestamp: ta,
			endTimestamp: na
		} = ea;
		if (na && !(ea.fetchData.url.match(/sentry_key/) && ea.fetchData.method === "POST"))
			if (ea.error) {
				const ra = ea.fetchData,
					ia = {
						data: ea.error,
						input: ea.args,
						startTimestamp: ta,
						endTimestamp: na
					};
				addBreadcrumb({
					category: "fetch",
					data: ra,
					level: "error",
					type: "http"
				}, ia)
			} else {
				const ra = ea.response,
					ia = {
						...ea.fetchData,
						status_code: ra && ra.status
					},
					aa = {
						input: ea.args,
						response: ra,
						startTimestamp: ta,
						endTimestamp: na
					};
				addBreadcrumb({
					category: "fetch",
					data: ia,
					type: "http"
				}, aa)
			}
	}
}

function _getHistoryBreadcrumbHandler(ue) {
	return function(ea) {
		if (getClient() !== ue) return;
		let ta = ea.from,
			na = ea.to;
		const ra = parseUrl(WINDOW$2.location.href);
		let ia = ta ? parseUrl(ta) : void 0;
		const aa = parseUrl(na);
		(!ia || !ia.path) && (ia = ra), ra.protocol === aa.protocol && ra.host === aa.host && (na = aa.relative), ra.protocol === ia.protocol && ra.host === ia.host && (ta = ia.relative), addBreadcrumb({
			category: "navigation",
			data: {
				from: ta,
				to: na
			}
		})
	}
}

function _isEvent(ue) {
	return !!ue && !!ue.target
}
const INTEGRATION_NAME$7 = "Dedupe",
	_dedupeIntegration = () => {
		let ue;
		return {
			name: INTEGRATION_NAME$7,
			setupOnce() {},
			processEvent(Yi) {
				if (Yi.type) return Yi;
				try {
					if (_shouldDropEvent(Yi, ue)) return DEBUG_BUILD$3 && logger.warn("Event dropped due to being a duplicate of previously captured event."), null
				} catch {}
				return ue = Yi
			}
		}
	},
	dedupeIntegration = _dedupeIntegration,
	Dedupe = convertIntegrationFnToClass(INTEGRATION_NAME$7, dedupeIntegration);

function _shouldDropEvent(ue, Yi) {
	return Yi ? !!(_isSameMessageEvent(ue, Yi) || _isSameExceptionEvent(ue, Yi)) : !1
}

function _isSameMessageEvent(ue, Yi) {
	const ea = ue.message,
		ta = Yi.message;
	return !(!ea && !ta || ea && !ta || !ea && ta || ea !== ta || !_isSameFingerprint(ue, Yi) || !_isSameStacktrace(ue, Yi))
}

function _isSameExceptionEvent(ue, Yi) {
	const ea = _getExceptionFromEvent(Yi),
		ta = _getExceptionFromEvent(ue);
	return !(!ea || !ta || ea.type !== ta.type || ea.value !== ta.value || !_isSameFingerprint(ue, Yi) || !_isSameStacktrace(ue, Yi))
}

function _isSameStacktrace(ue, Yi) {
	let ea = _getFramesFromEvent(ue),
		ta = _getFramesFromEvent(Yi);
	if (!ea && !ta) return !0;
	if (ea && !ta || !ea && ta || (ea = ea, ta = ta, ta.length !== ea.length)) return !1;
	for (let na = 0; na < ta.length; na++) {
		const ra = ta[na],
			ia = ea[na];
		if (ra.filename !== ia.filename || ra.lineno !== ia.lineno || ra.colno !== ia.colno || ra.function !== ia.function) return !1
	}
	return !0
}

function _isSameFingerprint(ue, Yi) {
	let ea = ue.fingerprint,
		ta = Yi.fingerprint;
	if (!ea && !ta) return !0;
	if (ea && !ta || !ea && ta) return !1;
	ea = ea, ta = ta;
	try {
		return ea.join("") === ta.join("")
	} catch {
		return !1
	}
}

function _getExceptionFromEvent(ue) {
	return ue.exception && ue.exception.values && ue.exception.values[0]
}

function _getFramesFromEvent(ue) {
	const Yi = ue.exception;
	if (Yi) try {
		return Yi.values[0].stacktrace.frames
	} catch {
		return
	}
}
const INTEGRATION_NAME$6 = "GlobalHandlers",
	_globalHandlersIntegration = (ue = {}) => {
		const Yi = {
			onerror: !0,
			onunhandledrejection: !0,
			...ue
		};
		return {
			name: INTEGRATION_NAME$6,
			setupOnce() {
				Error.stackTraceLimit = 50
			},
			setup(ea) {
				Yi.onerror && (_installGlobalOnErrorHandler(ea), globalHandlerLog("onerror")), Yi.onunhandledrejection && (_installGlobalOnUnhandledRejectionHandler(ea), globalHandlerLog("onunhandledrejection"))
			}
		}
	},
	globalHandlersIntegration = _globalHandlersIntegration,
	GlobalHandlers = convertIntegrationFnToClass(INTEGRATION_NAME$6, globalHandlersIntegration);

function _installGlobalOnErrorHandler(ue) {
	addGlobalErrorInstrumentationHandler(Yi => {
		const {
			stackParser: ea,
			attachStacktrace: ta
		} = getOptions();
		if (getClient() !== ue || shouldIgnoreOnError()) return;
		const {
			msg: na,
			url: ra,
			line: ia,
			column: aa,
			error: oa
		} = Yi, la = oa === void 0 && isString(na) ? _eventFromIncompleteOnError(na, ra, ia, aa) : _enhanceEventWithInitialFrame(eventFromUnknownInput(ea, oa || na, void 0, ta, !1), ra, ia, aa);
		la.level = "error", captureEvent(la, {
			originalException: oa,
			mechanism: {
				handled: !1,
				type: "onerror"
			}
		})
	})
}

function _installGlobalOnUnhandledRejectionHandler(ue) {
	addGlobalUnhandledRejectionInstrumentationHandler(Yi => {
		const {
			stackParser: ea,
			attachStacktrace: ta
		} = getOptions();
		if (getClient() !== ue || shouldIgnoreOnError()) return;
		const na = _getUnhandledRejectionError(Yi),
			ra = isPrimitive(na) ? _eventFromRejectionWithPrimitive(na) : eventFromUnknownInput(ea, na, void 0, ta, !0);
		ra.level = "error", captureEvent(ra, {
			originalException: na,
			mechanism: {
				handled: !1,
				type: "onunhandledrejection"
			}
		})
	})
}

function _getUnhandledRejectionError(ue) {
	if (isPrimitive(ue)) return ue;
	const Yi = ue;
	try {
		if ("reason" in Yi) return Yi.reason;
		if ("detail" in Yi && "reason" in Yi.detail) return Yi.detail.reason
	} catch {}
	return ue
}

function _eventFromRejectionWithPrimitive(ue) {
	return {
		exception: {
			values: [{
				type: "UnhandledRejection",
				value: `Non-Error promise rejection captured with value: ${String(ue)}`
			}]
		}
	}
}

function _eventFromIncompleteOnError(ue, Yi, ea, ta) {
	const na = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
	let ra = isErrorEvent$2(ue) ? ue.message : ue,
		ia = "Error";
	const aa = ra.match(na);
	return aa && (ia = aa[1], ra = aa[2]), _enhanceEventWithInitialFrame({
		exception: {
			values: [{
				type: ia,
				value: ra
			}]
		}
	}, Yi, ea, ta)
}

function _enhanceEventWithInitialFrame(ue, Yi, ea, ta) {
	const na = ue.exception = ue.exception || {},
		ra = na.values = na.values || [],
		ia = ra[0] = ra[0] || {},
		aa = ia.stacktrace = ia.stacktrace || {},
		oa = aa.frames = aa.frames || [],
		la = isNaN(parseInt(ta, 10)) ? void 0 : ta,
		sa = isNaN(parseInt(ea, 10)) ? void 0 : ea,
		ca = isString(Yi) && Yi.length > 0 ? Yi : getLocationHref();
	return oa.length === 0 && oa.push({
		colno: la,
		filename: ca,
		function: "?",
		in_app: !0,
		lineno: sa
	}), ue
}

function globalHandlerLog(ue) {
	DEBUG_BUILD$3 && logger.log(`Global Handler attached: ${ue}`)
}

function getOptions() {
	const ue = getClient();
	return ue && ue.getOptions() || {
		stackParser: () => [],
		attachStacktrace: !1
	}
}
const INTEGRATION_NAME$5 = "HttpContext",
	_httpContextIntegration = () => ({
		name: INTEGRATION_NAME$5,
		setupOnce() {},
		preprocessEvent(ue) {
			if (!WINDOW$2.navigator && !WINDOW$2.location && !WINDOW$2.document) return;
			const Yi = ue.request && ue.request.url || WINDOW$2.location && WINDOW$2.location.href,
				{
					referrer: ea
				} = WINDOW$2.document || {},
				{
					userAgent: ta
				} = WINDOW$2.navigator || {},
				na = {
					...ue.request && ue.request.headers,
					...ea && {
						Referer: ea
					},
					...ta && {
						"User-Agent": ta
					}
				},
				ra = {
					...ue.request,
					...Yi && {
						url: Yi
					},
					headers: na
				};
			ue.request = ra
		}
	}),
	httpContextIntegration = _httpContextIntegration,
	HttpContext = convertIntegrationFnToClass(INTEGRATION_NAME$5, httpContextIntegration),
	DEFAULT_KEY = "cause",
	DEFAULT_LIMIT = 5,
	INTEGRATION_NAME$4 = "LinkedErrors",
	_linkedErrorsIntegration = (ue = {}) => {
		const Yi = ue.limit || DEFAULT_LIMIT,
			ea = ue.key || DEFAULT_KEY;
		return {
			name: INTEGRATION_NAME$4,
			setupOnce() {},
			preprocessEvent(ta, na, ra) {
				const ia = ra.getOptions();
				applyAggregateErrorsToEvent(exceptionFromError, ia.stackParser, ia.maxValueLength, ea, Yi, ta, na)
			}
		}
	},
	linkedErrorsIntegration = _linkedErrorsIntegration,
	LinkedErrors = convertIntegrationFnToClass(INTEGRATION_NAME$4, linkedErrorsIntegration),
	DEFAULT_EVENT_TARGET = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"],
	INTEGRATION_NAME$3 = "TryCatch",
	_browserApiErrorsIntegration = (ue = {}) => {
		const Yi = {
			XMLHttpRequest: !0,
			eventTarget: !0,
			requestAnimationFrame: !0,
			setInterval: !0,
			setTimeout: !0,
			...ue
		};
		return {
			name: INTEGRATION_NAME$3,
			setupOnce() {
				Yi.setTimeout && fill(WINDOW$2, "setTimeout", _wrapTimeFunction), Yi.setInterval && fill(WINDOW$2, "setInterval", _wrapTimeFunction), Yi.requestAnimationFrame && fill(WINDOW$2, "requestAnimationFrame", _wrapRAF), Yi.XMLHttpRequest && "XMLHttpRequest" in WINDOW$2 && fill(XMLHttpRequest.prototype, "send", _wrapXHR);
				const ea = Yi.eventTarget;
				ea && (Array.isArray(ea) ? ea : DEFAULT_EVENT_TARGET).forEach(_wrapEventTarget)
			}
		}
	},
	browserApiErrorsIntegration = _browserApiErrorsIntegration,
	TryCatch = convertIntegrationFnToClass(INTEGRATION_NAME$3, browserApiErrorsIntegration);

function _wrapTimeFunction(ue) {
	return function(...Yi) {
		const ea = Yi[0];
		return Yi[0] = wrap$1(ea, {
			mechanism: {
				data: {
					function: getFunctionName(ue)
				},
				handled: !1,
				type: "instrument"
			}
		}), ue.apply(this, Yi)
	}
}

function _wrapRAF(ue) {
	return function(Yi) {
		return ue.apply(this, [wrap$1(Yi, {
			mechanism: {
				data: {
					function: "requestAnimationFrame",
					handler: getFunctionName(ue)
				},
				handled: !1,
				type: "instrument"
			}
		})])
	}
}

function _wrapXHR(ue) {
	return function(...Yi) {
		const ea = this;
		return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(na => {
			na in ea && typeof ea[na] == "function" && fill(ea, na, function(ra) {
				const ia = {
						mechanism: {
							data: {
								function: na,
								handler: getFunctionName(ra)
							},
							handled: !1,
							type: "instrument"
						}
					},
					aa = getOriginalFunction(ra);
				return aa && (ia.mechanism.data.handler = getFunctionName(aa)), wrap$1(ra, ia)
			})
		}), ue.apply(this, Yi)
	}
}

function _wrapEventTarget(ue) {
	const Yi = WINDOW$2,
		ea = Yi[ue] && Yi[ue].prototype;
	!ea || !ea.hasOwnProperty || !ea.hasOwnProperty("addEventListener") || (fill(ea, "addEventListener", function(ta) {
		return function(na, ra, ia) {
			try {
				typeof ra.handleEvent == "function" && (ra.handleEvent = wrap$1(ra.handleEvent, {
					mechanism: {
						data: {
							function: "handleEvent",
							handler: getFunctionName(ra),
							target: ue
						},
						handled: !1,
						type: "instrument"
					}
				}))
			} catch {}
			return ta.apply(this, [na, wrap$1(ra, {
				mechanism: {
					data: {
						function: "addEventListener",
						handler: getFunctionName(ra),
						target: ue
					},
					handled: !1,
					type: "instrument"
				}
			}), ia])
		}
	}), fill(ea, "removeEventListener", function(ta) {
		return function(na, ra, ia) {
			const aa = ra;
			try {
				const oa = aa && aa.__sentry_wrapped__;
				oa && ta.call(this, na, oa, ia)
			} catch {}
			return ta.call(this, na, aa, ia)
		}
	}))
}
const defaultIntegrations = [inboundFiltersIntegration(), functionToStringIntegration(), browserApiErrorsIntegration(), breadcrumbsIntegration(), globalHandlersIntegration(), linkedErrorsIntegration(), dedupeIntegration(), httpContextIntegration()];

function getDefaultIntegrations(ue) {
	return [...defaultIntegrations]
}

function init$1(ue = {}) {
	ue.defaultIntegrations === void 0 && (ue.defaultIntegrations = getDefaultIntegrations()), ue.release === void 0 && (typeof __SENTRY_RELEASE__ == "string" && (ue.release = __SENTRY_RELEASE__), WINDOW$2.SENTRY_RELEASE && WINDOW$2.SENTRY_RELEASE.id && (ue.release = WINDOW$2.SENTRY_RELEASE.id)), ue.autoSessionTracking === void 0 && (ue.autoSessionTracking = !0), ue.sendClientReports === void 0 && (ue.sendClientReports = !0);
	const Yi = {
		...ue,
		stackParser: stackParserFromStackParserOptions(ue.stackParser || defaultStackParser),
		integrations: getIntegrationsToSetup(ue),
		transport: ue.transport || (supportsFetch() ? makeFetchTransport : makeXHRTransport)
	};
	initAndBind(BrowserClient, Yi), ue.autoSessionTracking && startSessionTracking()
}
const showReportDialog = (ue = {}, Yi = getCurrentHub()) => {
	if (!WINDOW$2.document) {
		DEBUG_BUILD$3 && logger.error("Global document not defined in showReportDialog call");
		return
	}
	const {
		client: ea,
		scope: ta
	} = Yi.getStackTop(), na = ue.dsn || ea && ea.getDsn();
	if (!na) {
		DEBUG_BUILD$3 && logger.error("DSN not configured for showReportDialog call");
		return
	}
	ta && (ue.user = {
		...ta.getUser(),
		...ue.user
	}), ue.eventId || (ue.eventId = Yi.lastEventId());
	const ra = WINDOW$2.document.createElement("script");
	ra.async = !0, ra.crossOrigin = "anonymous", ra.src = getReportDialogEndpoint(na, ue), ue.onLoad && (ra.onload = ue.onLoad);
	const {
		onClose: ia
	} = ue;
	if (ia) {
		const oa = la => {
			if (la.data === "__sentry_reportdialog_closed__") try {
				ia()
			} finally {
				WINDOW$2.removeEventListener("message", oa)
			}
		};
		WINDOW$2.addEventListener("message", oa)
	}
	const aa = WINDOW$2.document.head || WINDOW$2.document.body;
	aa ? aa.appendChild(ra) : DEBUG_BUILD$3 && logger.error("Not injecting report dialog. No injection point found in HTML")
};

function forceLoad() {}

function onLoad(ue) {
	ue()
}

function wrap(ue) {
	return wrap$1(ue)()
}

function startSessionTracking() {
	if (typeof WINDOW$2.document > "u") {
		DEBUG_BUILD$3 && logger.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
		return
	}
	startSession({
		ignoreDuration: !0
	}), captureSession(), addHistoryInstrumentationHandler(({
		from: ue,
		to: Yi
	}) => {
		ue !== void 0 && ue !== Yi && (startSession({
			ignoreDuration: !0
		}), captureSession())
	})
}

function captureUserFeedback(ue) {
	const Yi = getClient();
	Yi && Yi.captureUserFeedback(ue)
}
const index = Object.freeze(Object.defineProperty({
		__proto__: null,
		Breadcrumbs,
		Dedupe,
		GlobalHandlers,
		HttpContext,
		LinkedErrors,
		TryCatch
	}, Symbol.toStringTag, {
		value: "Module"
	})),
	WINDOW$1 = GLOBAL_OBJ,
	REPLAY_SESSION_KEY = "sentryReplaySession",
	REPLAY_EVENT_NAME = "replay_event",
	UNABLE_TO_SEND_REPLAY = "Unable to send Replay",
	SESSION_IDLE_PAUSE_DURATION = 3e5,
	SESSION_IDLE_EXPIRE_DURATION = 9e5,
	DEFAULT_FLUSH_MIN_DELAY = 5e3,
	DEFAULT_FLUSH_MAX_DELAY = 5500,
	BUFFER_CHECKOUT_TIME = 6e4,
	RETRY_BASE_INTERVAL = 5e3,
	RETRY_MAX_COUNT = 3,
	NETWORK_BODY_MAX_SIZE = 15e4,
	CONSOLE_ARG_MAX_SIZE = 5e3,
	SLOW_CLICK_THRESHOLD = 3e3,
	SLOW_CLICK_SCROLL_TIMEOUT = 300,
	REPLAY_MAX_EVENT_BUFFER_SIZE = 2e7,
	MIN_REPLAY_DURATION = 4999,
	MIN_REPLAY_DURATION_LIMIT = 15e3,
	MAX_REPLAY_DURATION = 36e5;

function _nullishCoalesce$1(ue, Yi) {
	return ue ?? Yi()
}

function _optionalChain$5(ue) {
	let Yi, ea = ue[0],
		ta = 1;
	for (; ta < ue.length;) {
		const na = ue[ta],
			ra = ue[ta + 1];
		if (ta += 2, (na === "optionalAccess" || na === "optionalCall") && ea == null) return;
		na === "access" || na === "optionalAccess" ? (Yi = ea, ea = ra(ea)) : (na === "call" || na === "optionalCall") && (ea = ra((...ia) => ea.call(Yi, ...ia)), Yi = void 0)
	}
	return ea
}
var NodeType$1;
(function(ue) {
	ue[ue.Document = 0] = "Document", ue[ue.DocumentType = 1] = "DocumentType", ue[ue.Element = 2] = "Element", ue[ue.Text = 3] = "Text", ue[ue.CDATA = 4] = "CDATA", ue[ue.Comment = 5] = "Comment"
})(NodeType$1 || (NodeType$1 = {}));

function isElement$1(ue) {
	return ue.nodeType === ue.ELEMENT_NODE
}

function isShadowRoot(ue) {
	const Yi = _optionalChain$5([ue, "optionalAccess", ea => ea.host]);
	return _optionalChain$5([Yi, "optionalAccess", ea => ea.shadowRoot]) === ue
}

function isNativeShadowDom(ue) {
	return Object.prototype.toString.call(ue) === "[object ShadowRoot]"
}

function fixBrowserCompatibilityIssuesInCSS(ue) {
	return ue.includes(" background-clip: text;") && !ue.includes(" -webkit-background-clip: text;") && (ue = ue.replace(" background-clip: text;", " -webkit-background-clip: text; background-clip: text;")), ue
}

function escapeImportStatement(ue) {
	const {
		cssText: Yi
	} = ue;
	if (Yi.split('"').length < 3) return Yi;
	const ea = ["@import", `url(${JSON.stringify(ue.href)})`];
	return ue.layerName === "" ? ea.push("layer") : ue.layerName && ea.push(`layer(${ue.layerName})`), ue.supportsText && ea.push(`supports(${ue.supportsText})`), ue.media.length && ea.push(ue.media.mediaText), ea.join(" ") + ";"
}

function stringifyStylesheet(ue) {
	try {
		const Yi = ue.rules || ue.cssRules;
		return Yi ? fixBrowserCompatibilityIssuesInCSS(Array.from(Yi, stringifyRule).join("")) : null
	} catch {
		return null
	}
}

function stringifyRule(ue) {
	let Yi;
	if (isCSSImportRule(ue)) try {
		Yi = stringifyStylesheet(ue.styleSheet) || escapeImportStatement(ue)
	} catch {} else if (isCSSStyleRule(ue) && ue.selectorText.includes(":")) return fixSafariColons(ue.cssText);
	return Yi || ue.cssText
}

function fixSafariColons(ue) {
	const Yi = /(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm;
	return ue.replace(Yi, "$1\\$2")
}

function isCSSImportRule(ue) {
	return "styleSheet" in ue
}

function isCSSStyleRule(ue) {
	return "selectorText" in ue
}
class Mirror {
	constructor() {
		this.idNodeMap = new Map, this.nodeMetaMap = new WeakMap
	}
	getId(Yi) {
		if (!Yi) return -1;
		const ea = _optionalChain$5([this, "access", ta => ta.getMeta, "call", ta => ta(Yi), "optionalAccess", ta => ta.id]);
		return _nullishCoalesce$1(ea, () => -1)
	}
	getNode(Yi) {
		return this.idNodeMap.get(Yi) || null
	}
	getIds() {
		return Array.from(this.idNodeMap.keys())
	}
	getMeta(Yi) {
		return this.nodeMetaMap.get(Yi) || null
	}
	removeNodeFromMap(Yi) {
		const ea = this.getId(Yi);
		this.idNodeMap.delete(ea), Yi.childNodes && Yi.childNodes.forEach(ta => this.removeNodeFromMap(ta))
	}
	has(Yi) {
		return this.idNodeMap.has(Yi)
	}
	hasNode(Yi) {
		return this.nodeMetaMap.has(Yi)
	}
	add(Yi, ea) {
		const ta = ea.id;
		this.idNodeMap.set(ta, Yi), this.nodeMetaMap.set(Yi, ea)
	}
	replace(Yi, ea) {
		const ta = this.getNode(Yi);
		if (ta) {
			const na = this.nodeMetaMap.get(ta);
			na && this.nodeMetaMap.set(ea, na)
		}
		this.idNodeMap.set(Yi, ea)
	}
	reset() {
		this.idNodeMap = new Map, this.nodeMetaMap = new WeakMap
	}
}

function createMirror() {
	return new Mirror
}

function shouldMaskInput({
	maskInputOptions: ue,
	tagName: Yi,
	type: ea
}) {
	return Yi === "OPTION" && (Yi = "SELECT"), !!(ue[Yi.toLowerCase()] || ea && ue[ea] || ea === "password" || Yi === "INPUT" && !ea && ue.text)
}

function maskInputValue({
	isMasked: ue,
	element: Yi,
	value: ea,
	maskInputFn: ta
}) {
	let na = ea || "";
	return ue ? (ta && (na = ta(na, Yi)), "*".repeat(na.length)) : na
}

function toLowerCase(ue) {
	return ue.toLowerCase()
}

function toUpperCase(ue) {
	return ue.toUpperCase()
}
const ORIGINAL_ATTRIBUTE_NAME = "__rrweb_original__";

function is2DCanvasBlank(ue) {
	const Yi = ue.getContext("2d");
	if (!Yi) return !0;
	const ea = 50;
	for (let ta = 0; ta < ue.width; ta += ea)
		for (let na = 0; na < ue.height; na += ea) {
			const ra = Yi.getImageData,
				ia = ORIGINAL_ATTRIBUTE_NAME in ra ? ra[ORIGINAL_ATTRIBUTE_NAME] : ra;
			if (new Uint32Array(ia.call(Yi, ta, na, Math.min(ea, ue.width - ta), Math.min(ea, ue.height - na)).data.buffer).some(oa => oa !== 0)) return !1
		}
	return !0
}

function getInputType(ue) {
	const Yi = ue.type;
	return ue.hasAttribute("data-rr-is-password") ? "password" : Yi ? toLowerCase(Yi) : null
}

function getInputValue(ue, Yi, ea) {
	return Yi === "INPUT" && (ea === "radio" || ea === "checkbox") ? ue.getAttribute("value") || "" : ue.value
}
let _id = 1;
const tagNameRegex = new RegExp("[^a-z0-9-_:]"),
	IGNORED_NODE = -2;

function genId() {
	return _id++
}

function getValidTagName(ue) {
	if (ue instanceof HTMLFormElement) return "form";
	const Yi = toLowerCase(ue.tagName);
	return tagNameRegex.test(Yi) ? "div" : Yi
}

function extractOrigin(ue) {
	let Yi = "";
	return ue.indexOf("//") > -1 ? Yi = ue.split("/").slice(0, 3).join("/") : Yi = ue.split("/")[0], Yi = Yi.split("?")[0], Yi
}
let canvasService, canvasCtx;
const URL_IN_CSS_REF = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm,
	URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\/\//i,
	URL_WWW_MATCH = /^www\..*/i,
	DATA_URI = /^(data:)([^,]*),(.*)/i;

function absoluteToStylesheet(ue, Yi) {
	return (ue || "").replace(URL_IN_CSS_REF, (ea, ta, na, ra, ia, aa) => {
		const oa = na || ia || aa,
			la = ta || ra || "";
		if (!oa) return ea;
		if (URL_PROTOCOL_MATCH.test(oa) || URL_WWW_MATCH.test(oa)) return `url(${la}${oa}${la})`;
		if (DATA_URI.test(oa)) return `url(${la}${oa}${la})`;
		if (oa[0] === "/") return `url(${la}${extractOrigin(Yi)+oa}${la})`;
		const sa = Yi.split("/"),
			ca = oa.split("/");
		sa.pop();
		for (const ua of ca) ua !== "." && (ua === ".." ? sa.pop() : sa.push(ua));
		return `url(${la}${sa.join("/")}${la})`
	})
}
const SRCSET_NOT_SPACES = /^[^ \t\n\r\u000c]+/,
	SRCSET_COMMAS_OR_SPACES = /^[, \t\n\r\u000c]+/;

function getAbsoluteSrcsetString(ue, Yi) {
	if (Yi.trim() === "") return Yi;
	let ea = 0;

	function ta(ra) {
		let ia;
		const aa = ra.exec(Yi.substring(ea));
		return aa ? (ia = aa[0], ea += ia.length, ia) : ""
	}
	const na = [];
	for (; ta(SRCSET_COMMAS_OR_SPACES), !(ea >= Yi.length);) {
		let ra = ta(SRCSET_NOT_SPACES);
		if (ra.slice(-1) === ",") ra = absoluteToDoc(ue, ra.substring(0, ra.length - 1)), na.push(ra);
		else {
			let ia = "";
			ra = absoluteToDoc(ue, ra);
			let aa = !1;
			for (;;) {
				const oa = Yi.charAt(ea);
				if (oa === "") {
					na.push((ra + ia).trim());
					break
				} else if (aa) oa === ")" && (aa = !1);
				else if (oa === ",") {
					ea += 1, na.push((ra + ia).trim());
					break
				} else oa === "(" && (aa = !0);
				ia += oa, ea += 1
			}
		}
	}
	return na.join(", ")
}

function absoluteToDoc(ue, Yi) {
	if (!Yi || Yi.trim() === "") return Yi;
	const ea = ue.createElement("a");
	return ea.href = Yi, ea.href
}

function isSVGElement(ue) {
	return !!(ue.tagName === "svg" || ue.ownerSVGElement)
}

function getHref() {
	const ue = document.createElement("a");
	return ue.href = "", ue.href
}

function transformAttribute(ue, Yi, ea, ta, na, ra) {
	return ta && (ea === "src" || ea === "href" && !(Yi === "use" && ta[0] === "#") || ea === "xlink:href" && ta[0] !== "#" || ea === "background" && (Yi === "table" || Yi === "td" || Yi === "th") ? absoluteToDoc(ue, ta) : ea === "srcset" ? getAbsoluteSrcsetString(ue, ta) : ea === "style" ? absoluteToStylesheet(ta, getHref()) : Yi === "object" && ea === "data" ? absoluteToDoc(ue, ta) : typeof ra == "function" ? ra(ea, ta, na) : ta)
}

function ignoreAttribute(ue, Yi, ea) {
	return (ue === "video" || ue === "audio") && Yi === "autoplay"
}

function _isBlockedElement(ue, Yi, ea, ta) {
	try {
		if (ta && ue.matches(ta)) return !1;
		if (typeof Yi == "string") {
			if (ue.classList.contains(Yi)) return !0
		} else
			for (let na = ue.classList.length; na--;) {
				const ra = ue.classList[na];
				if (Yi.test(ra)) return !0
			}
		if (ea) return ue.matches(ea)
	} catch {}
	return !1
}

function elementClassMatchesRegex$1(ue, Yi) {
	for (let ea = ue.classList.length; ea--;) {
		const ta = ue.classList[ea];
		if (Yi.test(ta)) return !0
	}
	return !1
}

function distanceToMatch$1(ue, Yi, ea = 1 / 0, ta = 0) {
	return !ue || ue.nodeType !== ue.ELEMENT_NODE || ta > ea ? -1 : Yi(ue) ? ta : distanceToMatch$1(ue.parentNode, Yi, ea, ta + 1)
}

function createMatchPredicate$1(ue, Yi) {
	return ea => {
		const ta = ea;
		if (ta === null) return !1;
		try {
			if (ue) {
				if (typeof ue == "string") {
					if (ta.matches(`.${ue}`)) return !0
				} else if (elementClassMatchesRegex$1(ta, ue)) return !0
			}
			return !!(Yi && ta.matches(Yi))
		} catch {
			return !1
		}
	}
}

function needMaskingText(ue, Yi, ea, ta, na, ra) {
	try {
		const ia = ue.nodeType === ue.ELEMENT_NODE ? ue : ue.parentElement;
		if (ia === null) return !1;
		if (ia.tagName === "INPUT") {
			const la = ia.getAttribute("autocomplete");
			if (["current-password", "new-password", "cc-number", "cc-exp", "cc-exp-month", "cc-exp-year", "cc-csc"].includes(la)) return !0
		}
		let aa = -1,
			oa = -1;
		if (ra) {
			if (oa = distanceToMatch$1(ia, createMatchPredicate$1(ta, na)), oa < 0) return !0;
			aa = distanceToMatch$1(ia, createMatchPredicate$1(Yi, ea), oa >= 0 ? oa : 1 / 0)
		} else {
			if (aa = distanceToMatch$1(ia, createMatchPredicate$1(Yi, ea)), aa < 0) return !1;
			oa = distanceToMatch$1(ia, createMatchPredicate$1(ta, na), aa >= 0 ? aa : 1 / 0)
		}
		return aa >= 0 ? oa >= 0 ? aa <= oa : !0 : oa >= 0 ? !1 : !!ra
	} catch {}
	return !!ra
}

function onceIframeLoaded(ue, Yi, ea) {
	const ta = ue.contentWindow;
	if (!ta) return;
	let na = !1,
		ra;
	try {
		ra = ta.document.readyState
	} catch {
		return
	}
	if (ra !== "complete") {
		const aa = setTimeout(() => {
			na || (Yi(), na = !0)
		}, ea);
		ue.addEventListener("load", () => {
			clearTimeout(aa), na = !0, Yi()
		});
		return
	}
	const ia = "about:blank";
	if (ta.location.href !== ia || ue.src === ia || ue.src === "") return setTimeout(Yi, 0), ue.addEventListener("load", Yi);
	ue.addEventListener("load", Yi)
}

function onceStylesheetLoaded(ue, Yi, ea) {
	let ta = !1,
		na;
	try {
		na = ue.sheet
	} catch {
		return
	}
	if (na) return;
	const ra = setTimeout(() => {
		ta || (Yi(), ta = !0)
	}, ea);
	ue.addEventListener("load", () => {
		clearTimeout(ra), ta = !0, Yi()
	})
}

function serializeNode(ue, Yi) {
	const {
		doc: ea,
		mirror: ta,
		blockClass: na,
		blockSelector: ra,
		unblockSelector: ia,
		maskAllText: aa,
		maskAttributeFn: oa,
		maskTextClass: la,
		unmaskTextClass: sa,
		maskTextSelector: ca,
		unmaskTextSelector: ua,
		inlineStylesheet: da,
		maskInputOptions: ha = {},
		maskTextFn: pa,
		maskInputFn: va,
		dataURLOptions: ba = {},
		inlineImages: Ea,
		recordCanvas: Sa,
		keepIframeSrcFn: Ca,
		newlyAddedElement: ka = !1
	} = Yi, Pa = getRootId(ea, ta);
	switch (ue.nodeType) {
		case ue.DOCUMENT_NODE:
			return ue.compatMode !== "CSS1Compat" ? {
				type: NodeType$1.Document,
				childNodes: [],
				compatMode: ue.compatMode
			} : {
				type: NodeType$1.Document,
				childNodes: []
			};
		case ue.DOCUMENT_TYPE_NODE:
			return {
				type: NodeType$1.DocumentType, name: ue.name, publicId: ue.publicId, systemId: ue.systemId, rootId: Pa
			};
		case ue.ELEMENT_NODE:
			return serializeElementNode(ue, {
				doc: ea,
				blockClass: na,
				blockSelector: ra,
				unblockSelector: ia,
				inlineStylesheet: da,
				maskAttributeFn: oa,
				maskInputOptions: ha,
				maskInputFn: va,
				dataURLOptions: ba,
				inlineImages: Ea,
				recordCanvas: Sa,
				keepIframeSrcFn: Ca,
				newlyAddedElement: ka,
				rootId: Pa,
				maskAllText: aa,
				maskTextClass: la,
				unmaskTextClass: sa,
				maskTextSelector: ca,
				unmaskTextSelector: ua
			});
		case ue.TEXT_NODE:
			return serializeTextNode(ue, {
				maskAllText: aa,
				maskTextClass: la,
				unmaskTextClass: sa,
				maskTextSelector: ca,
				unmaskTextSelector: ua,
				maskTextFn: pa,
				maskInputOptions: ha,
				maskInputFn: va,
				rootId: Pa
			});
		case ue.CDATA_SECTION_NODE:
			return {
				type: NodeType$1.CDATA, textContent: "", rootId: Pa
			};
		case ue.COMMENT_NODE:
			return {
				type: NodeType$1.Comment, textContent: ue.textContent || "", rootId: Pa
			};
		default:
			return !1
	}
}

function getRootId(ue, Yi) {
	if (!Yi.hasNode(ue)) return;
	const ea = Yi.getId(ue);
	return ea === 1 ? void 0 : ea
}

function serializeTextNode(ue, Yi) {
	const {
		maskAllText: ea,
		maskTextClass: ta,
		unmaskTextClass: na,
		maskTextSelector: ra,
		unmaskTextSelector: ia,
		maskTextFn: aa,
		maskInputOptions: oa,
		maskInputFn: la,
		rootId: sa
	} = Yi, ca = ue.parentNode && ue.parentNode.tagName;
	let ua = ue.textContent;
	const da = ca === "STYLE" ? !0 : void 0,
		ha = ca === "SCRIPT" ? !0 : void 0,
		pa = ca === "TEXTAREA" ? !0 : void 0;
	if (da && ua) {
		try {
			ue.nextSibling || ue.previousSibling || _optionalChain$5([ue, "access", ba => ba.parentNode, "access", ba => ba.sheet, "optionalAccess", ba => ba.cssRules]) && (ua = stringifyStylesheet(ue.parentNode.sheet))
		} catch (ba) {
			console.warn(`Cannot get CSS styles from text's parentNode. Error: ${ba}`, ue)
		}
		ua = absoluteToStylesheet(ua, getHref())
	}
	ha && (ua = "SCRIPT_PLACEHOLDER");
	const va = needMaskingText(ue, ta, ra, na, ia, ea);
	if (!da && !ha && !pa && ua && va && (ua = aa ? aa(ua) : ua.replace(/[\S]/g, "*")), pa && ua && (oa.textarea || va) && (ua = la ? la(ua, ue.parentNode) : ua.replace(/[\S]/g, "*")), ca === "OPTION" && ua) {
		const ba = shouldMaskInput({
			type: null,
			tagName: ca,
			maskInputOptions: oa
		});
		ua = maskInputValue({
			isMasked: needMaskingText(ue, ta, ra, na, ia, ba),
			element: ue,
			value: ua,
			maskInputFn: la
		})
	}
	return {
		type: NodeType$1.Text,
		textContent: ua || "",
		isStyle: da,
		rootId: sa
	}
}

function serializeElementNode(ue, Yi) {
	const {
		doc: ea,
		blockClass: ta,
		blockSelector: na,
		unblockSelector: ra,
		inlineStylesheet: ia,
		maskInputOptions: aa = {},
		maskAttributeFn: oa,
		maskInputFn: la,
		dataURLOptions: sa = {},
		inlineImages: ca,
		recordCanvas: ua,
		keepIframeSrcFn: da,
		newlyAddedElement: ha = !1,
		rootId: pa,
		maskAllText: va,
		maskTextClass: ba,
		unmaskTextClass: Ea,
		maskTextSelector: Sa,
		unmaskTextSelector: Ca
	} = Yi, ka = _isBlockedElement(ue, ta, na, ra), Pa = getValidTagName(ue);
	let ja = {};
	const Za = ue.attributes.length;
	for (let Ja = 0; Ja < Za; Ja++) {
		const Ua = ue.attributes[Ja];
		Ua.name && !ignoreAttribute(Pa, Ua.name, Ua.value) && (ja[Ua.name] = transformAttribute(ea, Pa, toLowerCase(Ua.name), Ua.value, ue, oa))
	}
	if (Pa === "link" && ia) {
		const Ja = Array.from(ea.styleSheets).find(xa => xa.href === ue.href);
		let Ua = null;
		Ja && (Ua = stringifyStylesheet(Ja)), Ua && (delete ja.rel, delete ja.href, ja._cssText = absoluteToStylesheet(Ua, Ja.href))
	}
	if (Pa === "style" && ue.sheet && !(ue.innerText || ue.textContent || "").trim().length) {
		const Ja = stringifyStylesheet(ue.sheet);
		Ja && (ja._cssText = absoluteToStylesheet(Ja, getHref()))
	}
	if (Pa === "input" || Pa === "textarea" || Pa === "select" || Pa === "option") {
		const Ja = ue,
			Ua = getInputType(Ja),
			xa = getInputValue(Ja, toUpperCase(Pa), Ua),
			ma = Ja.checked;
		if (Ua !== "submit" && Ua !== "button" && xa) {
			const fa = needMaskingText(Ja, ba, Sa, Ea, Ca, shouldMaskInput({
				type: Ua,
				tagName: toUpperCase(Pa),
				maskInputOptions: aa
			}));
			ja.value = maskInputValue({
				isMasked: fa,
				element: Ja,
				value: xa,
				maskInputFn: la
			})
		}
		ma && (ja.checked = ma)
	}
	if (Pa === "option" && (ue.selected && !aa.select ? ja.selected = !0 : delete ja.selected), Pa === "canvas" && ua) {
		if (ue.__context === "2d") is2DCanvasBlank(ue) || (ja.rr_dataURL = ue.toDataURL(sa.type, sa.quality));
		else if (!("__context" in ue)) {
			const Ja = ue.toDataURL(sa.type, sa.quality),
				Ua = document.createElement("canvas");
			Ua.width = ue.width, Ua.height = ue.height;
			const xa = Ua.toDataURL(sa.type, sa.quality);
			Ja !== xa && (ja.rr_dataURL = Ja)
		}
	}
	if (Pa === "img" && ca) {
		canvasService || (canvasService = ea.createElement("canvas"), canvasCtx = canvasService.getContext("2d"));
		const Ja = ue,
			Ua = Ja.crossOrigin;
		Ja.crossOrigin = "anonymous";
		const xa = () => {
			Ja.removeEventListener("load", xa);
			try {
				canvasService.width = Ja.naturalWidth, canvasService.height = Ja.naturalHeight, canvasCtx.drawImage(Ja, 0, 0), ja.rr_dataURL = canvasService.toDataURL(sa.type, sa.quality)
			} catch (ma) {
				console.warn(`Cannot inline img src=${Ja.currentSrc}! Error: ${ma}`)
			}
			Ua ? ja.crossOrigin = Ua : Ja.removeAttribute("crossorigin")
		};
		Ja.complete && Ja.naturalWidth !== 0 ? xa() : Ja.addEventListener("load", xa)
	}
	if ((Pa === "audio" || Pa === "video") && (ja.rr_mediaState = ue.paused ? "paused" : "played", ja.rr_mediaCurrentTime = ue.currentTime), ha || (ue.scrollLeft && (ja.rr_scrollLeft = ue.scrollLeft), ue.scrollTop && (ja.rr_scrollTop = ue.scrollTop)), ka) {
		const {
			width: Ja,
			height: Ua
		} = ue.getBoundingClientRect();
		ja = {
			class: ja.class,
			rr_width: `${Ja}px`,
			rr_height: `${Ua}px`
		}
	}
	Pa === "iframe" && !da(ja.src) && (ue.contentDocument || (ja.rr_src = ja.src), delete ja.src);
	let Ga;
	try {
		customElements.get(Pa) && (Ga = !0)
	} catch {}
	return {
		type: NodeType$1.Element,
		tagName: Pa,
		attributes: ja,
		childNodes: [],
		isSVG: isSVGElement(ue) || void 0,
		needBlock: ka,
		rootId: pa,
		isCustom: Ga
	}
}

function lowerIfExists(ue) {
	return ue == null ? "" : ue.toLowerCase()
}

function slimDOMExcluded(ue, Yi) {
	if (Yi.comment && ue.type === NodeType$1.Comment) return !0;
	if (ue.type === NodeType$1.Element) {
		if (Yi.script && (ue.tagName === "script" || ue.tagName === "link" && (ue.attributes.rel === "preload" || ue.attributes.rel === "modulepreload") && ue.attributes.as === "script" || ue.tagName === "link" && ue.attributes.rel === "prefetch" && typeof ue.attributes.href == "string" && ue.attributes.href.endsWith(".js"))) return !0;
		if (Yi.headFavicon && (ue.tagName === "link" && ue.attributes.rel === "shortcut icon" || ue.tagName === "meta" && (lowerIfExists(ue.attributes.name).match(/^msapplication-tile(image|color)$/) || lowerIfExists(ue.attributes.name) === "application-name" || lowerIfExists(ue.attributes.rel) === "icon" || lowerIfExists(ue.attributes.rel) === "apple-touch-icon" || lowerIfExists(ue.attributes.rel) === "shortcut icon"))) return !0;
		if (ue.tagName === "meta") {
			if (Yi.headMetaDescKeywords && lowerIfExists(ue.attributes.name).match(/^description|keywords$/)) return !0;
			if (Yi.headMetaSocial && (lowerIfExists(ue.attributes.property).match(/^(og|twitter|fb):/) || lowerIfExists(ue.attributes.name).match(/^(og|twitter):/) || lowerIfExists(ue.attributes.name) === "pinterest")) return !0;
			if (Yi.headMetaRobots && (lowerIfExists(ue.attributes.name) === "robots" || lowerIfExists(ue.attributes.name) === "googlebot" || lowerIfExists(ue.attributes.name) === "bingbot")) return !0;
			if (Yi.headMetaHttpEquiv && ue.attributes["http-equiv"] !== void 0) return !0;
			if (Yi.headMetaAuthorship && (lowerIfExists(ue.attributes.name) === "author" || lowerIfExists(ue.attributes.name) === "generator" || lowerIfExists(ue.attributes.name) === "framework" || lowerIfExists(ue.attributes.name) === "publisher" || lowerIfExists(ue.attributes.name) === "progid" || lowerIfExists(ue.attributes.property).match(/^article:/) || lowerIfExists(ue.attributes.property).match(/^product:/))) return !0;
			if (Yi.headMetaVerification && (lowerIfExists(ue.attributes.name) === "google-site-verification" || lowerIfExists(ue.attributes.name) === "yandex-verification" || lowerIfExists(ue.attributes.name) === "csrf-token" || lowerIfExists(ue.attributes.name) === "p:domain_verify" || lowerIfExists(ue.attributes.name) === "verify-v1" || lowerIfExists(ue.attributes.name) === "verification" || lowerIfExists(ue.attributes.name) === "shopify-checkout-api-token")) return !0
		}
	}
	return !1
}

function serializeNodeWithId(ue, Yi) {
	const {
		doc: ea,
		mirror: ta,
		blockClass: na,
		blockSelector: ra,
		unblockSelector: ia,
		maskAllText: aa,
		maskTextClass: oa,
		unmaskTextClass: la,
		maskTextSelector: sa,
		unmaskTextSelector: ca,
		skipChild: ua = !1,
		inlineStylesheet: da = !0,
		maskInputOptions: ha = {},
		maskAttributeFn: pa,
		maskTextFn: va,
		maskInputFn: ba,
		slimDOMOptions: Ea,
		dataURLOptions: Sa = {},
		inlineImages: Ca = !1,
		recordCanvas: ka = !1,
		onSerialize: Pa,
		onIframeLoad: ja,
		iframeLoadTimeout: Za = 5e3,
		onStylesheetLoad: Ga,
		stylesheetLoadTimeout: Ja = 5e3,
		keepIframeSrcFn: Ua = () => !1,
		newlyAddedElement: xa = !1
	} = Yi;
	let {
		preserveWhiteSpace: ma = !0
	} = Yi;
	const fa = serializeNode(ue, {
		doc: ea,
		mirror: ta,
		blockClass: na,
		blockSelector: ra,
		maskAllText: aa,
		unblockSelector: ia,
		maskTextClass: oa,
		unmaskTextClass: la,
		maskTextSelector: sa,
		unmaskTextSelector: ca,
		inlineStylesheet: da,
		maskInputOptions: ha,
		maskAttributeFn: pa,
		maskTextFn: va,
		maskInputFn: ba,
		dataURLOptions: Sa,
		inlineImages: Ca,
		recordCanvas: ka,
		keepIframeSrcFn: Ua,
		newlyAddedElement: xa
	});
	if (!fa) return console.warn(ue, "not serialized"), null;
	let ga;
	ta.hasNode(ue) ? ga = ta.getId(ue) : slimDOMExcluded(fa, Ea) || !ma && fa.type === NodeType$1.Text && !fa.isStyle && !fa.textContent.replace(/^\s+|\s+$/gm, "").length ? ga = IGNORED_NODE : ga = genId();
	const wa = Object.assign(fa, {
		id: ga
	});
	if (ta.add(ue, wa), ga === IGNORED_NODE) return null;
	Pa && Pa(ue);
	let Ma = !ua;
	if (wa.type === NodeType$1.Element) {
		Ma = Ma && !wa.needBlock, delete wa.needBlock;
		const Aa = ue.shadowRoot;
		Aa && isNativeShadowDom(Aa) && (wa.isShadowHost = !0)
	}
	if ((wa.type === NodeType$1.Document || wa.type === NodeType$1.Element) && Ma) {
		Ea.headWhitespace && wa.type === NodeType$1.Element && wa.tagName === "head" && (ma = !1);
		const Aa = {
			doc: ea,
			mirror: ta,
			blockClass: na,
			blockSelector: ra,
			maskAllText: aa,
			unblockSelector: ia,
			maskTextClass: oa,
			unmaskTextClass: la,
			maskTextSelector: sa,
			unmaskTextSelector: ca,
			skipChild: ua,
			inlineStylesheet: da,
			maskInputOptions: ha,
			maskAttributeFn: pa,
			maskTextFn: va,
			maskInputFn: ba,
			slimDOMOptions: Ea,
			dataURLOptions: Sa,
			inlineImages: Ca,
			recordCanvas: ka,
			preserveWhiteSpace: ma,
			onSerialize: Pa,
			onIframeLoad: ja,
			iframeLoadTimeout: Za,
			onStylesheetLoad: Ga,
			stylesheetLoadTimeout: Ja,
			keepIframeSrcFn: Ua
		};
		for (const Ra of Array.from(ue.childNodes)) {
			const Ta = serializeNodeWithId(Ra, Aa);
			Ta && wa.childNodes.push(Ta)
		}
		if (isElement$1(ue) && ue.shadowRoot)
			for (const Ra of Array.from(ue.shadowRoot.childNodes)) {
				const Ta = serializeNodeWithId(Ra, Aa);
				Ta && (isNativeShadowDom(ue.shadowRoot) && (Ta.isShadow = !0), wa.childNodes.push(Ta))
			}
	}
	return ue.parentNode && isShadowRoot(ue.parentNode) && isNativeShadowDom(ue.parentNode) && (wa.isShadow = !0), wa.type === NodeType$1.Element && wa.tagName === "iframe" && onceIframeLoaded(ue, () => {
		const Aa = ue.contentDocument;
		if (Aa && ja) {
			const Ra = serializeNodeWithId(Aa, {
				doc: Aa,
				mirror: ta,
				blockClass: na,
				blockSelector: ra,
				unblockSelector: ia,
				maskAllText: aa,
				maskTextClass: oa,
				unmaskTextClass: la,
				maskTextSelector: sa,
				unmaskTextSelector: ca,
				skipChild: !1,
				inlineStylesheet: da,
				maskInputOptions: ha,
				maskAttributeFn: pa,
				maskTextFn: va,
				maskInputFn: ba,
				slimDOMOptions: Ea,
				dataURLOptions: Sa,
				inlineImages: Ca,
				recordCanvas: ka,
				preserveWhiteSpace: ma,
				onSerialize: Pa,
				onIframeLoad: ja,
				iframeLoadTimeout: Za,
				onStylesheetLoad: Ga,
				stylesheetLoadTimeout: Ja,
				keepIframeSrcFn: Ua
			});
			Ra && ja(ue, Ra)
		}
	}, Za), wa.type === NodeType$1.Element && wa.tagName === "link" && wa.attributes.rel === "stylesheet" && onceStylesheetLoaded(ue, () => {
		if (Ga) {
			const Aa = serializeNodeWithId(ue, {
				doc: ea,
				mirror: ta,
				blockClass: na,
				blockSelector: ra,
				unblockSelector: ia,
				maskAllText: aa,
				maskTextClass: oa,
				unmaskTextClass: la,
				maskTextSelector: sa,
				unmaskTextSelector: ca,
				skipChild: !1,
				inlineStylesheet: da,
				maskInputOptions: ha,
				maskAttributeFn: pa,
				maskTextFn: va,
				maskInputFn: ba,
				slimDOMOptions: Ea,
				dataURLOptions: Sa,
				inlineImages: Ca,
				recordCanvas: ka,
				preserveWhiteSpace: ma,
				onSerialize: Pa,
				onIframeLoad: ja,
				iframeLoadTimeout: Za,
				onStylesheetLoad: Ga,
				stylesheetLoadTimeout: Ja,
				keepIframeSrcFn: Ua
			});
			Aa && Ga(ue, Aa)
		}
	}, Ja), wa
}

function snapshot(ue, Yi) {
	const {
		mirror: ea = new Mirror,
		blockClass: ta = "rr-block",
		blockSelector: na = null,
		unblockSelector: ra = null,
		maskAllText: ia = !1,
		maskTextClass: aa = "rr-mask",
		unmaskTextClass: oa = null,
		maskTextSelector: la = null,
		unmaskTextSelector: sa = null,
		inlineStylesheet: ca = !0,
		inlineImages: ua = !1,
		recordCanvas: da = !1,
		maskAllInputs: ha = !1,
		maskAttributeFn: pa,
		maskTextFn: va,
		maskInputFn: ba,
		slimDOM: Ea = !1,
		dataURLOptions: Sa,
		preserveWhiteSpace: Ca,
		onSerialize: ka,
		onIframeLoad: Pa,
		iframeLoadTimeout: ja,
		onStylesheetLoad: Za,
		stylesheetLoadTimeout: Ga,
		keepIframeSrcFn: Ja = () => !1
	} = Yi || {};
	return serializeNodeWithId(ue, {
		doc: ue,
		mirror: ea,
		blockClass: ta,
		blockSelector: na,
		unblockSelector: ra,
		maskAllText: ia,
		maskTextClass: aa,
		unmaskTextClass: oa,
		maskTextSelector: la,
		unmaskTextSelector: sa,
		skipChild: !1,
		inlineStylesheet: ca,
		maskInputOptions: ha === !0 ? {
			color: !0,
			date: !0,
			"datetime-local": !0,
			email: !0,
			month: !0,
			number: !0,
			range: !0,
			search: !0,
			tel: !0,
			text: !0,
			time: !0,
			url: !0,
			week: !0,
			textarea: !0,
			select: !0
		} : ha === !1 ? {} : ha,
		maskAttributeFn: pa,
		maskTextFn: va,
		maskInputFn: ba,
		slimDOMOptions: Ea === !0 || Ea === "all" ? {
			script: !0,
			comment: !0,
			headFavicon: !0,
			headWhitespace: !0,
			headMetaDescKeywords: Ea === "all",
			headMetaSocial: !0,
			headMetaRobots: !0,
			headMetaHttpEquiv: !0,
			headMetaAuthorship: !0,
			headMetaVerification: !0
		} : Ea === !1 ? {} : Ea,
		dataURLOptions: Sa,
		inlineImages: ua,
		recordCanvas: da,
		preserveWhiteSpace: Ca,
		onSerialize: ka,
		onIframeLoad: Pa,
		iframeLoadTimeout: ja,
		onStylesheetLoad: Za,
		stylesheetLoadTimeout: Ga,
		keepIframeSrcFn: Ja,
		newlyAddedElement: !1
	})
}

function _optionalChain$4(ue) {
	let Yi, ea = ue[0],
		ta = 1;
	for (; ta < ue.length;) {
		const na = ue[ta],
			ra = ue[ta + 1];
		if (ta += 2, (na === "optionalAccess" || na === "optionalCall") && ea == null) return;
		na === "access" || na === "optionalAccess" ? (Yi = ea, ea = ra(ea)) : (na === "call" || na === "optionalCall") && (ea = ra((...ia) => ea.call(Yi, ...ia)), Yi = void 0)
	}
	return ea
}

function on$1(ue, Yi, ea = document) {
	const ta = {
		capture: !0,
		passive: !0
	};
	return ea.addEventListener(ue, Yi, ta), () => ea.removeEventListener(ue, Yi, ta)
}
const DEPARTED_MIRROR_ACCESS_WARNING$1 = `Please stop import mirror directly. Instead of that,\r
now you can use replayer.getMirror() to access the mirror instance of a replayer,\r
or you can use record.mirror to access the mirror instance during recording.`;
let _mirror$1 = {
	map: {},
	getId() {
		return console.error(DEPARTED_MIRROR_ACCESS_WARNING$1), -1
	},
	getNode() {
		return console.error(DEPARTED_MIRROR_ACCESS_WARNING$1), null
	},
	removeNodeFromMap() {
		console.error(DEPARTED_MIRROR_ACCESS_WARNING$1)
	},
	has() {
		return console.error(DEPARTED_MIRROR_ACCESS_WARNING$1), !1
	},
	reset() {
		console.error(DEPARTED_MIRROR_ACCESS_WARNING$1)
	}
};
typeof window < "u" && window.Proxy && window.Reflect && (_mirror$1 = new Proxy(_mirror$1, {
	get(ue, Yi, ea) {
		return Yi === "map" && console.error(DEPARTED_MIRROR_ACCESS_WARNING$1), Reflect.get(ue, Yi, ea)
	}
}));

function throttle$1(ue, Yi, ea = {}) {
	let ta = null,
		na = 0;
	return function(...ra) {
		const ia = Date.now();
		!na && ea.leading === !1 && (na = ia);
		const aa = Yi - (ia - na),
			oa = this;
		aa <= 0 || aa > Yi ? (ta && (clearTimeout(ta), ta = null), na = ia, ue.apply(oa, ra)) : !ta && ea.trailing !== !1 && (ta = setTimeout(() => {
			na = ea.leading === !1 ? 0 : Date.now(), ta = null, ue.apply(oa, ra)
		}, aa))
	}
}

function hookSetter$1(ue, Yi, ea, ta, na = window) {
	const ra = na.Object.getOwnPropertyDescriptor(ue, Yi);
	return na.Object.defineProperty(ue, Yi, ta ? ea : {
		set(ia) {
			setTimeout(() => {
				ea.set.call(this, ia)
			}, 0), ra && ra.set && ra.set.call(this, ia)
		}
	}), () => hookSetter$1(ue, Yi, ra || {}, !0)
}

function patch$1(ue, Yi, ea) {
	try {
		if (!(Yi in ue)) return () => {};
		const ta = ue[Yi],
			na = ea(ta);
		return typeof na == "function" && (na.prototype = na.prototype || {}, Object.defineProperties(na, {
			__rrweb_original__: {
				enumerable: !1,
				value: ta
			}
		})), ue[Yi] = na, () => {
			ue[Yi] = ta
		}
	} catch {
		return () => {}
	}
}
let nowTimestamp = Date.now;
/[1-9][0-9]{12}/.test(Date.now().toString()) || (nowTimestamp = () => new Date().getTime());

function getWindowScroll(ue) {
	const Yi = ue.document;
	return {
		left: Yi.scrollingElement ? Yi.scrollingElement.scrollLeft : ue.pageXOffset !== void 0 ? ue.pageXOffset : _optionalChain$4([Yi, "optionalAccess", ea => ea.documentElement, "access", ea => ea.scrollLeft]) || _optionalChain$4([Yi, "optionalAccess", ea => ea.body, "optionalAccess", ea => ea.parentElement, "optionalAccess", ea => ea.scrollLeft]) || _optionalChain$4([Yi, "optionalAccess", ea => ea.body, "optionalAccess", ea => ea.scrollLeft]) || 0,
		top: Yi.scrollingElement ? Yi.scrollingElement.scrollTop : ue.pageYOffset !== void 0 ? ue.pageYOffset : _optionalChain$4([Yi, "optionalAccess", ea => ea.documentElement, "access", ea => ea.scrollTop]) || _optionalChain$4([Yi, "optionalAccess", ea => ea.body, "optionalAccess", ea => ea.parentElement, "optionalAccess", ea => ea.scrollTop]) || _optionalChain$4([Yi, "optionalAccess", ea => ea.body, "optionalAccess", ea => ea.scrollTop]) || 0
	}
}

function getWindowHeight() {
	return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight
}

function getWindowWidth() {
	return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth
}

function isBlocked$1(ue, Yi, ea, ta, na) {
	if (!ue) return !1;
	const ra = ue.nodeType === ue.ELEMENT_NODE ? ue : ue.parentElement;
	if (!ra) return !1;
	const ia = createMatchPredicate$1(Yi, ea);
	if (!na) {
		const la = ta && ra.matches(ta);
		return ia(ra) && !la
	}
	const aa = distanceToMatch$1(ra, ia);
	let oa = -1;
	return aa < 0 ? !1 : (ta && (oa = distanceToMatch$1(ra, createMatchPredicate$1(null, ta))), aa > -1 && oa < 0 ? !0 : aa < oa)
}

function isSerialized(ue, Yi) {
	return Yi.getId(ue) !== -1
}

function isIgnored(ue, Yi) {
	return Yi.getId(ue) === IGNORED_NODE
}

function isAncestorRemoved(ue, Yi) {
	if (isShadowRoot(ue)) return !1;
	const ea = Yi.getId(ue);
	return Yi.has(ea) ? ue.parentNode && ue.parentNode.nodeType === ue.DOCUMENT_NODE ? !1 : ue.parentNode ? isAncestorRemoved(ue.parentNode, Yi) : !0 : !0
}

function legacy_isTouchEvent(ue) {
	return !!ue.changedTouches
}

function polyfill(ue = window) {
	"NodeList" in ue && !ue.NodeList.prototype.forEach && (ue.NodeList.prototype.forEach = Array.prototype.forEach), "DOMTokenList" in ue && !ue.DOMTokenList.prototype.forEach && (ue.DOMTokenList.prototype.forEach = Array.prototype.forEach), Node.prototype.contains || (Node.prototype.contains = (...Yi) => {
		let ea = Yi[0];
		if (!(0 in Yi)) throw new TypeError("1 argument is required");
		do
			if (this === ea) return !0; while (ea = ea && ea.parentNode);
		return !1
	})
}

function isSerializedIframe(ue, Yi) {
	return !!(ue.nodeName === "IFRAME" && Yi.getMeta(ue))
}

function isSerializedStylesheet(ue, Yi) {
	return !!(ue.nodeName === "LINK" && ue.nodeType === ue.ELEMENT_NODE && ue.getAttribute && ue.getAttribute("rel") === "stylesheet" && Yi.getMeta(ue))
}

function hasShadowRoot(ue) {
	return !!_optionalChain$4([ue, "optionalAccess", Yi => Yi.shadowRoot])
}
class StyleSheetMirror {
	constructor() {
		this.id = 1, this.styleIDMap = new WeakMap, this.idStyleMap = new Map
	}
	getId(Yi) {
		return _nullishCoalesce(this.styleIDMap.get(Yi), () => -1)
	}
	has(Yi) {
		return this.styleIDMap.has(Yi)
	}
	add(Yi, ea) {
		if (this.has(Yi)) return this.getId(Yi);
		let ta;
		return ea === void 0 ? ta = this.id++ : ta = ea, this.styleIDMap.set(Yi, ta), this.idStyleMap.set(ta, Yi), ta
	}
	getStyle(Yi) {
		return this.idStyleMap.get(Yi) || null
	}
	reset() {
		this.styleIDMap = new WeakMap, this.idStyleMap = new Map, this.id = 1
	}
	generateId() {
		return this.id++
	}
}

function getShadowHost(ue) {
	let Yi = null;
	return _optionalChain$4([ue, "access", ea => ea.getRootNode, "optionalCall", ea => ea(), "optionalAccess", ea => ea.nodeType]) === Node.DOCUMENT_FRAGMENT_NODE && ue.getRootNode().host && (Yi = ue.getRootNode().host), Yi
}

function getRootShadowHost(ue) {
	let Yi = ue,
		ea;
	for (; ea = getShadowHost(Yi);) Yi = ea;
	return Yi
}

function shadowHostInDom(ue) {
	const Yi = ue.ownerDocument;
	if (!Yi) return !1;
	const ea = getRootShadowHost(ue);
	return Yi.contains(ea)
}

function inDom(ue) {
	const Yi = ue.ownerDocument;
	return Yi ? Yi.contains(ue) || shadowHostInDom(ue) : !1
}
let cachedRequestAnimationFrameImplementation$1;

function getRequestAnimationFrameImplementation$1() {
	if (cachedRequestAnimationFrameImplementation$1) return cachedRequestAnimationFrameImplementation$1;
	const ue = window.document;
	let Yi = window.requestAnimationFrame;
	if (ue && typeof ue.createElement == "function") try {
		const ea = ue.createElement("iframe");
		ea.hidden = !0, ue.head.appendChild(ea);
		const ta = ea.contentWindow;
		ta && ta.requestAnimationFrame && (Yi = ta.requestAnimationFrame), ue.head.removeChild(ea)
	} catch {}
	return cachedRequestAnimationFrameImplementation$1 = Yi.bind(window)
}

function onRequestAnimationFrame$1(...ue) {
	return getRequestAnimationFrameImplementation$1()(...ue)
}
var EventType = (ue => (ue[ue.DomContentLoaded = 0] = "DomContentLoaded", ue[ue.Load = 1] = "Load", ue[ue.FullSnapshot = 2] = "FullSnapshot", ue[ue.IncrementalSnapshot = 3] = "IncrementalSnapshot", ue[ue.Meta = 4] = "Meta", ue[ue.Custom = 5] = "Custom", ue[ue.Plugin = 6] = "Plugin", ue))(EventType || {}),
	IncrementalSource = (ue => (ue[ue.Mutation = 0] = "Mutation", ue[ue.MouseMove = 1] = "MouseMove", ue[ue.MouseInteraction = 2] = "MouseInteraction", ue[ue.Scroll = 3] = "Scroll", ue[ue.ViewportResize = 4] = "ViewportResize", ue[ue.Input = 5] = "Input", ue[ue.TouchMove = 6] = "TouchMove", ue[ue.MediaInteraction = 7] = "MediaInteraction", ue[ue.StyleSheetRule = 8] = "StyleSheetRule", ue[ue.CanvasMutation = 9] = "CanvasMutation", ue[ue.Font = 10] = "Font", ue[ue.Log = 11] = "Log", ue[ue.Drag = 12] = "Drag", ue[ue.StyleDeclaration = 13] = "StyleDeclaration", ue[ue.Selection = 14] = "Selection", ue[ue.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", ue[ue.CustomElement = 16] = "CustomElement", ue))(IncrementalSource || {}),
	MouseInteractions = (ue => (ue[ue.MouseUp = 0] = "MouseUp", ue[ue.MouseDown = 1] = "MouseDown", ue[ue.Click = 2] = "Click", ue[ue.ContextMenu = 3] = "ContextMenu", ue[ue.DblClick = 4] = "DblClick", ue[ue.Focus = 5] = "Focus", ue[ue.Blur = 6] = "Blur", ue[ue.TouchStart = 7] = "TouchStart", ue[ue.TouchMove_Departed = 8] = "TouchMove_Departed", ue[ue.TouchEnd = 9] = "TouchEnd", ue[ue.TouchCancel = 10] = "TouchCancel", ue))(MouseInteractions || {}),
	PointerTypes = (ue => (ue[ue.Mouse = 0] = "Mouse", ue[ue.Pen = 1] = "Pen", ue[ue.Touch = 2] = "Touch", ue))(PointerTypes || {});

function _optionalChain$3(ue) {
	let Yi, ea = ue[0],
		ta = 1;
	for (; ta < ue.length;) {
		const na = ue[ta],
			ra = ue[ta + 1];
		if (ta += 2, (na === "optionalAccess" || na === "optionalCall") && ea == null) return;
		na === "access" || na === "optionalAccess" ? (Yi = ea, ea = ra(ea)) : (na === "call" || na === "optionalCall") && (ea = ra((...ia) => ea.call(Yi, ...ia)), Yi = void 0)
	}
	return ea
}

function isNodeInLinkedList(ue) {
	return "__ln" in ue
}
class DoubleLinkedList {
	constructor() {
		this.length = 0, this.head = null, this.tail = null
	}
	get(Yi) {
		if (Yi >= this.length) throw new Error("Position outside of list range");
		let ea = this.head;
		for (let ta = 0; ta < Yi; ta++) ea = _optionalChain$3([ea, "optionalAccess", na => na.next]) || null;
		return ea
	}
	addNode(Yi) {
		const ea = {
			value: Yi,
			previous: null,
			next: null
		};
		if (Yi.__ln = ea, Yi.previousSibling && isNodeInLinkedList(Yi.previousSibling)) {
			const ta = Yi.previousSibling.__ln.next;
			ea.next = ta, ea.previous = Yi.previousSibling.__ln, Yi.previousSibling.__ln.next = ea, ta && (ta.previous = ea)
		} else if (Yi.nextSibling && isNodeInLinkedList(Yi.nextSibling) && Yi.nextSibling.__ln.previous) {
			const ta = Yi.nextSibling.__ln.previous;
			ea.previous = ta, ea.next = Yi.nextSibling.__ln, Yi.nextSibling.__ln.previous = ea, ta && (ta.next = ea)
		} else this.head && (this.head.previous = ea), ea.next = this.head, this.head = ea;
		ea.next === null && (this.tail = ea), this.length++
	}
	removeNode(Yi) {
		const ea = Yi.__ln;
		this.head && (ea.previous ? (ea.previous.next = ea.next, ea.next ? ea.next.previous = ea.previous : this.tail = ea.previous) : (this.head = ea.next, this.head ? this.head.previous = null : this.tail = null), Yi.__ln && delete Yi.__ln, this.length--)
	}
}
const moveKey = (ue, Yi) => `${ue}@${Yi}`;
class MutationBuffer {
	constructor() {
		this.frozen = !1, this.locked = !1, this.texts = [], this.attributes = [], this.removes = [], this.mapRemoves = [], this.movedMap = {}, this.addedSet = new Set, this.movedSet = new Set, this.droppedSet = new Set, this.processMutations = Yi => {
			Yi.forEach(this.processMutation), this.emit()
		}, this.emit = () => {
			if (this.frozen || this.locked) return;
			const Yi = [],
				ea = new Set,
				ta = new DoubleLinkedList,
				na = oa => {
					let la = oa,
						sa = IGNORED_NODE;
					for (; sa === IGNORED_NODE;) la = la && la.nextSibling, sa = la && this.mirror.getId(la);
					return sa
				},
				ra = oa => {
					if (!oa.parentNode || !inDom(oa)) return;
					const la = isShadowRoot(oa.parentNode) ? this.mirror.getId(getShadowHost(oa)) : this.mirror.getId(oa.parentNode),
						sa = na(oa);
					if (la === -1 || sa === -1) return ta.addNode(oa);
					const ca = serializeNodeWithId(oa, {
						doc: this.doc,
						mirror: this.mirror,
						blockClass: this.blockClass,
						blockSelector: this.blockSelector,
						maskAllText: this.maskAllText,
						unblockSelector: this.unblockSelector,
						maskTextClass: this.maskTextClass,
						unmaskTextClass: this.unmaskTextClass,
						maskTextSelector: this.maskTextSelector,
						unmaskTextSelector: this.unmaskTextSelector,
						skipChild: !0,
						newlyAddedElement: !0,
						inlineStylesheet: this.inlineStylesheet,
						maskInputOptions: this.maskInputOptions,
						maskAttributeFn: this.maskAttributeFn,
						maskTextFn: this.maskTextFn,
						maskInputFn: this.maskInputFn,
						slimDOMOptions: this.slimDOMOptions,
						dataURLOptions: this.dataURLOptions,
						recordCanvas: this.recordCanvas,
						inlineImages: this.inlineImages,
						onSerialize: ua => {
							isSerializedIframe(ua, this.mirror) && this.iframeManager.addIframe(ua), isSerializedStylesheet(ua, this.mirror) && this.stylesheetManager.trackLinkElement(ua), hasShadowRoot(oa) && this.shadowDomManager.addShadowRoot(oa.shadowRoot, this.doc)
						},
						onIframeLoad: (ua, da) => {
							this.iframeManager.attachIframe(ua, da), this.shadowDomManager.observeAttachShadow(ua)
						},
						onStylesheetLoad: (ua, da) => {
							this.stylesheetManager.attachLinkElement(ua, da)
						}
					});
					ca && (Yi.push({
						parentId: la,
						nextId: sa,
						node: ca
					}), ea.add(ca.id))
				};
			for (; this.mapRemoves.length;) this.mirror.removeNodeFromMap(this.mapRemoves.shift());
			for (const oa of this.movedSet) isParentRemoved(this.removes, oa, this.mirror) && !this.movedSet.has(oa.parentNode) || ra(oa);
			for (const oa of this.addedSet) !isAncestorInSet(this.droppedSet, oa) && !isParentRemoved(this.removes, oa, this.mirror) || isAncestorInSet(this.movedSet, oa) ? ra(oa) : this.droppedSet.add(oa);
			let ia = null;
			for (; ta.length;) {
				let oa = null;
				if (ia) {
					const la = this.mirror.getId(ia.value.parentNode),
						sa = na(ia.value);
					la !== -1 && sa !== -1 && (oa = ia)
				}
				if (!oa) {
					let la = ta.tail;
					for (; la;) {
						const sa = la;
						if (la = la.previous, sa) {
							const ca = this.mirror.getId(sa.value.parentNode);
							if (na(sa.value) === -1) continue;
							if (ca !== -1) {
								oa = sa;
								break
							} else {
								const da = sa.value;
								if (da.parentNode && da.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
									const ha = da.parentNode.host;
									if (this.mirror.getId(ha) !== -1) {
										oa = sa;
										break
									}
								}
							}
						}
					}
				}
				if (!oa) {
					for (; ta.head;) ta.removeNode(ta.head.value);
					break
				}
				ia = oa.previous, ta.removeNode(oa.value), ra(oa.value)
			}
			const aa = {
				texts: this.texts.map(oa => ({
					id: this.mirror.getId(oa.node),
					value: oa.value
				})).filter(oa => !ea.has(oa.id)).filter(oa => this.mirror.has(oa.id)),
				attributes: this.attributes.map(oa => {
					const {
						attributes: la
					} = oa;
					if (typeof la.style == "string") {
						const sa = JSON.stringify(oa.styleDiff),
							ca = JSON.stringify(oa._unchangedStyles);
						sa.length < la.style.length && (sa + ca).split("var(").length === la.style.split("var(").length && (la.style = oa.styleDiff)
					}
					return {
						id: this.mirror.getId(oa.node),
						attributes: la
					}
				}).filter(oa => !ea.has(oa.id)).filter(oa => this.mirror.has(oa.id)),
				removes: this.removes,
				adds: Yi
			};
			!aa.texts.length && !aa.attributes.length && !aa.removes.length && !aa.adds.length || (this.texts = [], this.attributes = [], this.removes = [], this.addedSet = new Set, this.movedSet = new Set, this.droppedSet = new Set, this.movedMap = {}, this.mutationCb(aa))
		}, this.processMutation = Yi => {
			if (isIgnored(Yi.target, this.mirror)) return;
			let ea;
			try {
				ea = document.implementation.createHTMLDocument()
			} catch {
				ea = this.doc
			}
			switch (Yi.type) {
				case "characterData": {
					const ta = Yi.target.textContent;
					!isBlocked$1(Yi.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) && ta !== Yi.oldValue && this.texts.push({
						value: needMaskingText(Yi.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, this.maskAllText) && ta ? this.maskTextFn ? this.maskTextFn(ta) : ta.replace(/[\S]/g, "*") : ta,
						node: Yi.target
					});
					break
				}
				case "attributes": {
					const ta = Yi.target;
					let na = Yi.attributeName,
						ra = Yi.target.getAttribute(na);
					if (na === "value") {
						const aa = getInputType(ta),
							oa = ta.tagName;
						ra = getInputValue(ta, oa, aa);
						const la = shouldMaskInput({
								maskInputOptions: this.maskInputOptions,
								tagName: oa,
								type: aa
							}),
							sa = needMaskingText(Yi.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, la);
						ra = maskInputValue({
							isMasked: sa,
							element: ta,
							value: ra,
							maskInputFn: this.maskInputFn
						})
					}
					if (isBlocked$1(Yi.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) || ra === Yi.oldValue) return;
					let ia = this.attributes.find(aa => aa.node === Yi.target);
					if (ta.tagName === "IFRAME" && na === "src" && !this.keepIframeSrcFn(ra))
						if (!ta.contentDocument) na = "rr_src";
						else return;
					if (ia || (ia = {
							node: Yi.target,
							attributes: {},
							styleDiff: {},
							_unchangedStyles: {}
						}, this.attributes.push(ia)), na === "type" && ta.tagName === "INPUT" && (Yi.oldValue || "").toLowerCase() === "password" && ta.setAttribute("data-rr-is-password", "true"), !ignoreAttribute(ta.tagName, na) && (ia.attributes[na] = transformAttribute(this.doc, toLowerCase(ta.tagName), toLowerCase(na), ra, ta, this.maskAttributeFn), na === "style")) {
						const aa = ea.createElement("span");
						Yi.oldValue && aa.setAttribute("style", Yi.oldValue);
						for (const oa of Array.from(ta.style)) {
							const la = ta.style.getPropertyValue(oa),
								sa = ta.style.getPropertyPriority(oa);
							la !== aa.style.getPropertyValue(oa) || sa !== aa.style.getPropertyPriority(oa) ? sa === "" ? ia.styleDiff[oa] = la : ia.styleDiff[oa] = [la, sa] : ia._unchangedStyles[oa] = [la, sa]
						}
						for (const oa of Array.from(aa.style)) ta.style.getPropertyValue(oa) === "" && (ia.styleDiff[oa] = !1)
					}
					break
				}
				case "childList": {
					if (isBlocked$1(Yi.target, this.blockClass, this.blockSelector, this.unblockSelector, !0)) return;
					Yi.addedNodes.forEach(ta => this.genAdds(ta, Yi.target)), Yi.removedNodes.forEach(ta => {
						const na = this.mirror.getId(ta),
							ra = isShadowRoot(Yi.target) ? this.mirror.getId(Yi.target.host) : this.mirror.getId(Yi.target);
						isBlocked$1(Yi.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) || isIgnored(ta, this.mirror) || !isSerialized(ta, this.mirror) || (this.addedSet.has(ta) ? (deepDelete(this.addedSet, ta), this.droppedSet.add(ta)) : this.addedSet.has(Yi.target) && na === -1 || isAncestorRemoved(Yi.target, this.mirror) || (this.movedSet.has(ta) && this.movedMap[moveKey(na, ra)] ? deepDelete(this.movedSet, ta) : this.removes.push({
							parentId: ra,
							id: na,
							isShadow: isShadowRoot(Yi.target) && isNativeShadowDom(Yi.target) ? !0 : void 0
						})), this.mapRemoves.push(ta))
					});
					break
				}
			}
		}, this.genAdds = (Yi, ea) => {
			if (!this.processedNodeManager.inOtherBuffer(Yi, this) && !(this.addedSet.has(Yi) || this.movedSet.has(Yi))) {
				if (this.mirror.hasNode(Yi)) {
					if (isIgnored(Yi, this.mirror)) return;
					this.movedSet.add(Yi);
					let ta = null;
					ea && this.mirror.hasNode(ea) && (ta = this.mirror.getId(ea)), ta && ta !== -1 && (this.movedMap[moveKey(this.mirror.getId(Yi), ta)] = !0)
				} else this.addedSet.add(Yi), this.droppedSet.delete(Yi);
				isBlocked$1(Yi, this.blockClass, this.blockSelector, this.unblockSelector, !1) || (Yi.childNodes.forEach(ta => this.genAdds(ta)), hasShadowRoot(Yi) && Yi.shadowRoot.childNodes.forEach(ta => {
					this.processedNodeManager.add(ta, this), this.genAdds(ta, Yi)
				}))
			}
		}
	}
	init(Yi) {
		["mutationCb", "blockClass", "blockSelector", "unblockSelector", "maskAllText", "maskTextClass", "unmaskTextClass", "maskTextSelector", "unmaskTextSelector", "inlineStylesheet", "maskInputOptions", "maskAttributeFn", "maskTextFn", "maskInputFn", "keepIframeSrcFn", "recordCanvas", "inlineImages", "slimDOMOptions", "dataURLOptions", "doc", "mirror", "iframeManager", "stylesheetManager", "shadowDomManager", "canvasManager", "processedNodeManager"].forEach(ea => {
			this[ea] = Yi[ea]
		})
	}
	freeze() {
		this.frozen = !0, this.canvasManager.freeze()
	}
	unfreeze() {
		this.frozen = !1, this.canvasManager.unfreeze(), this.emit()
	}
	isFrozen() {
		return this.frozen
	}
	lock() {
		this.locked = !0, this.canvasManager.lock()
	}
	unlock() {
		this.locked = !1, this.canvasManager.unlock(), this.emit()
	}
	reset() {
		this.shadowDomManager.reset(), this.canvasManager.reset()
	}
}

function deepDelete(ue, Yi) {
	ue.delete(Yi), Yi.childNodes.forEach(ea => deepDelete(ue, ea))
}

function isParentRemoved(ue, Yi, ea) {
	return ue.length === 0 ? !1 : _isParentRemoved(ue, Yi, ea)
}

function _isParentRemoved(ue, Yi, ea) {
	const {
		parentNode: ta
	} = Yi;
	if (!ta) return !1;
	const na = ea.getId(ta);
	return ue.some(ra => ra.id === na) ? !0 : _isParentRemoved(ue, ta, ea)
}

function isAncestorInSet(ue, Yi) {
	return ue.size === 0 ? !1 : _isAncestorInSet(ue, Yi)
}

function _isAncestorInSet(ue, Yi) {
	const {
		parentNode: ea
	} = Yi;
	return ea ? ue.has(ea) ? !0 : _isAncestorInSet(ue, ea) : !1
}
let errorHandler$1;

function registerErrorHandler$1(ue) {
	errorHandler$1 = ue
}

function unregisterErrorHandler() {
	errorHandler$1 = void 0
}
const callbackWrapper$1 = ue => errorHandler$1 ? (...ea) => {
	try {
		return ue(...ea)
	} catch (ta) {
		if (errorHandler$1 && errorHandler$1(ta) === !0) return () => {};
		throw ta
	}
} : ue;

function _optionalChain$2(ue) {
	let Yi, ea = ue[0],
		ta = 1;
	for (; ta < ue.length;) {
		const na = ue[ta],
			ra = ue[ta + 1];
		if (ta += 2, (na === "optionalAccess" || na === "optionalCall") && ea == null) return;
		na === "access" || na === "optionalAccess" ? (Yi = ea, ea = ra(ea)) : (na === "call" || na === "optionalCall") && (ea = ra((...ia) => ea.call(Yi, ...ia)), Yi = void 0)
	}
	return ea
}
const mutationBuffers = [];

function getEventTarget(ue) {
	try {
		if ("composedPath" in ue) {
			const Yi = ue.composedPath();
			if (Yi.length) return Yi[0]
		} else if ("path" in ue && ue.path.length) return ue.path[0]
	} catch {}
	return ue && ue.target
}

function initMutationObserver(ue, Yi) {
	const ea = new MutationBuffer;
	mutationBuffers.push(ea), ea.init(ue);
	let ta = window.MutationObserver || window.__rrMutationObserver;
	const na = _optionalChain$2([window, "optionalAccess", ia => ia.Zone, "optionalAccess", ia => ia.__symbol__, "optionalCall", ia => ia("MutationObserver")]);
	na && window[na] && (ta = window[na]);
	const ra = new ta(callbackWrapper$1(ia => {
		ue.onMutation && ue.onMutation(ia) === !1 || ea.processMutations.bind(ea)(ia)
	}));
	return ra.observe(Yi, {
		attributes: !0,
		attributeOldValue: !0,
		characterData: !0,
		characterDataOldValue: !0,
		childList: !0,
		subtree: !0
	}), ra
}

function initMoveObserver({
	mousemoveCb: ue,
	sampling: Yi,
	doc: ea,
	mirror: ta
}) {
	if (Yi.mousemove === !1) return () => {};
	const na = typeof Yi.mousemove == "number" ? Yi.mousemove : 50,
		ra = typeof Yi.mousemoveCallback == "number" ? Yi.mousemoveCallback : 500;
	let ia = [],
		aa;
	const oa = throttle$1(callbackWrapper$1(ca => {
			const ua = Date.now() - aa;
			ue(ia.map(da => (da.timeOffset -= ua, da)), ca), ia = [], aa = null
		}), ra),
		la = callbackWrapper$1(throttle$1(callbackWrapper$1(ca => {
			const ua = getEventTarget(ca),
				{
					clientX: da,
					clientY: ha
				} = legacy_isTouchEvent(ca) ? ca.changedTouches[0] : ca;
			aa || (aa = nowTimestamp()), ia.push({
				x: da,
				y: ha,
				id: ta.getId(ua),
				timeOffset: nowTimestamp() - aa
			}), oa(typeof DragEvent < "u" && ca instanceof DragEvent ? IncrementalSource.Drag : ca instanceof MouseEvent ? IncrementalSource.MouseMove : IncrementalSource.TouchMove)
		}), na, {
			trailing: !1
		})),
		sa = [on$1("mousemove", la, ea), on$1("touchmove", la, ea), on$1("drag", la, ea)];
	return callbackWrapper$1(() => {
		sa.forEach(ca => ca())
	})
}

function initMouseInteractionObserver({
	mouseInteractionCb: ue,
	doc: Yi,
	mirror: ea,
	blockClass: ta,
	blockSelector: na,
	unblockSelector: ra,
	sampling: ia
}) {
	if (ia.mouseInteraction === !1) return () => {};
	const aa = ia.mouseInteraction === !0 || ia.mouseInteraction === void 0 ? {} : ia.mouseInteraction,
		oa = [];
	let la = null;
	const sa = ca => ua => {
		const da = getEventTarget(ua);
		if (isBlocked$1(da, ta, na, ra, !0)) return;
		let ha = null,
			pa = ca;
		if ("pointerType" in ua) {
			switch (ua.pointerType) {
				case "mouse":
					ha = PointerTypes.Mouse;
					break;
				case "touch":
					ha = PointerTypes.Touch;
					break;
				case "pen":
					ha = PointerTypes.Pen;
					break
			}
			ha === PointerTypes.Touch ? MouseInteractions[ca] === MouseInteractions.MouseDown ? pa = "TouchStart" : MouseInteractions[ca] === MouseInteractions.MouseUp && (pa = "TouchEnd") : PointerTypes.Pen
		} else legacy_isTouchEvent(ua) && (ha = PointerTypes.Touch);
		ha !== null ? (la = ha, (pa.startsWith("Touch") && ha === PointerTypes.Touch || pa.startsWith("Mouse") && ha === PointerTypes.Mouse) && (ha = null)) : MouseInteractions[ca] === MouseInteractions.Click && (ha = la, la = null);
		const va = legacy_isTouchEvent(ua) ? ua.changedTouches[0] : ua;
		if (!va) return;
		const ba = ea.getId(da),
			{
				clientX: Ea,
				clientY: Sa
			} = va;
		callbackWrapper$1(ue)({
			type: MouseInteractions[pa],
			id: ba,
			x: Ea,
			y: Sa,
			...ha !== null && {
				pointerType: ha
			}
		})
	};
	return Object.keys(MouseInteractions).filter(ca => Number.isNaN(Number(ca)) && !ca.endsWith("_Departed") && aa[ca] !== !1).forEach(ca => {
		let ua = toLowerCase(ca);
		const da = sa(ca);
		if (window.PointerEvent) switch (MouseInteractions[ca]) {
			case MouseInteractions.MouseDown:
			case MouseInteractions.MouseUp:
				ua = ua.replace("mouse", "pointer");
				break;
			case MouseInteractions.TouchStart:
			case MouseInteractions.TouchEnd:
				return
		}
		oa.push(on$1(ua, da, Yi))
	}), callbackWrapper$1(() => {
		oa.forEach(ca => ca())
	})
}

function initScrollObserver({
	scrollCb: ue,
	doc: Yi,
	mirror: ea,
	blockClass: ta,
	blockSelector: na,
	unblockSelector: ra,
	sampling: ia
}) {
	const aa = callbackWrapper$1(throttle$1(callbackWrapper$1(oa => {
		const la = getEventTarget(oa);
		if (!la || isBlocked$1(la, ta, na, ra, !0)) return;
		const sa = ea.getId(la);
		if (la === Yi && Yi.defaultView) {
			const ca = getWindowScroll(Yi.defaultView);
			ue({
				id: sa,
				x: ca.left,
				y: ca.top
			})
		} else ue({
			id: sa,
			x: la.scrollLeft,
			y: la.scrollTop
		})
	}), ia.scroll || 100));
	return on$1("scroll", aa, Yi)
}

function initViewportResizeObserver({
	viewportResizeCb: ue
}, {
	win: Yi
}) {
	let ea = -1,
		ta = -1;
	const na = callbackWrapper$1(throttle$1(callbackWrapper$1(() => {
		const ra = getWindowHeight(),
			ia = getWindowWidth();
		(ea !== ra || ta !== ia) && (ue({
			width: Number(ia),
			height: Number(ra)
		}), ea = ra, ta = ia)
	}), 200));
	return on$1("resize", na, Yi)
}
const INPUT_TAGS = ["INPUT", "TEXTAREA", "SELECT"],
	lastInputValueMap = new WeakMap;

function initInputObserver({
	inputCb: ue,
	doc: Yi,
	mirror: ea,
	blockClass: ta,
	blockSelector: na,
	unblockSelector: ra,
	ignoreClass: ia,
	ignoreSelector: aa,
	maskInputOptions: oa,
	maskInputFn: la,
	sampling: sa,
	userTriggeredOnInput: ca,
	maskTextClass: ua,
	unmaskTextClass: da,
	maskTextSelector: ha,
	unmaskTextSelector: pa
}) {
	function va(ja) {
		let Za = getEventTarget(ja);
		const Ga = ja.isTrusted,
			Ja = Za && toUpperCase(Za.tagName);
		if (Ja === "OPTION" && (Za = Za.parentElement), !Za || !Ja || INPUT_TAGS.indexOf(Ja) < 0 || isBlocked$1(Za, ta, na, ra, !0)) return;
		const Ua = Za;
		if (Ua.classList.contains(ia) || aa && Ua.matches(aa)) return;
		const xa = getInputType(Za);
		let ma = getInputValue(Ua, Ja, xa),
			fa = !1;
		const ga = shouldMaskInput({
				maskInputOptions: oa,
				tagName: Ja,
				type: xa
			}),
			wa = needMaskingText(Za, ua, ha, da, pa, ga);
		(xa === "radio" || xa === "checkbox") && (fa = Za.checked), ma = maskInputValue({
			isMasked: wa,
			element: Za,
			value: ma,
			maskInputFn: la
		}), ba(Za, ca ? {
			text: ma,
			isChecked: fa,
			userTriggered: Ga
		} : {
			text: ma,
			isChecked: fa
		});
		const Ma = Za.name;
		xa === "radio" && Ma && fa && Yi.querySelectorAll(`input[type="radio"][name="${Ma}"]`).forEach(Aa => {
			if (Aa !== Za) {
				const Ra = maskInputValue({
					isMasked: wa,
					element: Aa,
					value: getInputValue(Aa, Ja, xa),
					maskInputFn: la
				});
				ba(Aa, ca ? {
					text: Ra,
					isChecked: !fa,
					userTriggered: !1
				} : {
					text: Ra,
					isChecked: !fa
				})
			}
		})
	}

	function ba(ja, Za) {
		const Ga = lastInputValueMap.get(ja);
		if (!Ga || Ga.text !== Za.text || Ga.isChecked !== Za.isChecked) {
			lastInputValueMap.set(ja, Za);
			const Ja = ea.getId(ja);
			callbackWrapper$1(ue)({
				...Za,
				id: Ja
			})
		}
	}
	const Sa = (sa.input === "last" ? ["change"] : ["input", "change"]).map(ja => on$1(ja, callbackWrapper$1(va), Yi)),
		Ca = Yi.defaultView;
	if (!Ca) return () => {
		Sa.forEach(ja => ja())
	};
	const ka = Ca.Object.getOwnPropertyDescriptor(Ca.HTMLInputElement.prototype, "value"),
		Pa = [
			[Ca.HTMLInputElement.prototype, "value"],
			[Ca.HTMLInputElement.prototype, "checked"],
			[Ca.HTMLSelectElement.prototype, "value"],
			[Ca.HTMLTextAreaElement.prototype, "value"],
			[Ca.HTMLSelectElement.prototype, "selectedIndex"],
			[Ca.HTMLOptionElement.prototype, "selected"]
		];
	return ka && ka.set && Sa.push(...Pa.map(ja => hookSetter$1(ja[0], ja[1], {
		set() {
			callbackWrapper$1(va)({
				target: this,
				isTrusted: !1
			})
		}
	}, !1, Ca))), callbackWrapper$1(() => {
		Sa.forEach(ja => ja())
	})
}

function getNestedCSSRulePositions(ue) {
	const Yi = [];

	function ea(ta, na) {
		if (hasNestedCSSRule("CSSGroupingRule") && ta.parentRule instanceof CSSGroupingRule || hasNestedCSSRule("CSSMediaRule") && ta.parentRule instanceof CSSMediaRule || hasNestedCSSRule("CSSSupportsRule") && ta.parentRule instanceof CSSSupportsRule || hasNestedCSSRule("CSSConditionRule") && ta.parentRule instanceof CSSConditionRule) {
			const ia = Array.from(ta.parentRule.cssRules).indexOf(ta);
			na.unshift(ia)
		} else if (ta.parentStyleSheet) {
			const ia = Array.from(ta.parentStyleSheet.cssRules).indexOf(ta);
			na.unshift(ia)
		}
		return na
	}
	return ea(ue, Yi)
}

function getIdAndStyleId(ue, Yi, ea) {
	let ta, na;
	return ue ? (ue.ownerNode ? ta = Yi.getId(ue.ownerNode) : na = ea.getId(ue), {
		styleId: na,
		id: ta
	}) : {}
}

function initStyleSheetObserver({
	styleSheetRuleCb: ue,
	mirror: Yi,
	stylesheetManager: ea
}, {
	win: ta
}) {
	if (!ta.CSSStyleSheet || !ta.CSSStyleSheet.prototype) return () => {};
	const na = ta.CSSStyleSheet.prototype.insertRule;
	ta.CSSStyleSheet.prototype.insertRule = new Proxy(na, {
		apply: callbackWrapper$1((sa, ca, ua) => {
			const [da, ha] = ua, {
				id: pa,
				styleId: va
			} = getIdAndStyleId(ca, Yi, ea.styleMirror);
			return (pa && pa !== -1 || va && va !== -1) && ue({
				id: pa,
				styleId: va,
				adds: [{
					rule: da,
					index: ha
				}]
			}), sa.apply(ca, ua)
		})
	});
	const ra = ta.CSSStyleSheet.prototype.deleteRule;
	ta.CSSStyleSheet.prototype.deleteRule = new Proxy(ra, {
		apply: callbackWrapper$1((sa, ca, ua) => {
			const [da] = ua, {
				id: ha,
				styleId: pa
			} = getIdAndStyleId(ca, Yi, ea.styleMirror);
			return (ha && ha !== -1 || pa && pa !== -1) && ue({
				id: ha,
				styleId: pa,
				removes: [{
					index: da
				}]
			}), sa.apply(ca, ua)
		})
	});
	let ia;
	ta.CSSStyleSheet.prototype.replace && (ia = ta.CSSStyleSheet.prototype.replace, ta.CSSStyleSheet.prototype.replace = new Proxy(ia, {
		apply: callbackWrapper$1((sa, ca, ua) => {
			const [da] = ua, {
				id: ha,
				styleId: pa
			} = getIdAndStyleId(ca, Yi, ea.styleMirror);
			return (ha && ha !== -1 || pa && pa !== -1) && ue({
				id: ha,
				styleId: pa,
				replace: da
			}), sa.apply(ca, ua)
		})
	}));
	let aa;
	ta.CSSStyleSheet.prototype.replaceSync && (aa = ta.CSSStyleSheet.prototype.replaceSync, ta.CSSStyleSheet.prototype.replaceSync = new Proxy(aa, {
		apply: callbackWrapper$1((sa, ca, ua) => {
			const [da] = ua, {
				id: ha,
				styleId: pa
			} = getIdAndStyleId(ca, Yi, ea.styleMirror);
			return (ha && ha !== -1 || pa && pa !== -1) && ue({
				id: ha,
				styleId: pa,
				replaceSync: da
			}), sa.apply(ca, ua)
		})
	}));
	const oa = {};
	canMonkeyPatchNestedCSSRule("CSSGroupingRule") ? oa.CSSGroupingRule = ta.CSSGroupingRule : (canMonkeyPatchNestedCSSRule("CSSMediaRule") && (oa.CSSMediaRule = ta.CSSMediaRule), canMonkeyPatchNestedCSSRule("CSSConditionRule") && (oa.CSSConditionRule = ta.CSSConditionRule), canMonkeyPatchNestedCSSRule("CSSSupportsRule") && (oa.CSSSupportsRule = ta.CSSSupportsRule));
	const la = {};
	return Object.entries(oa).forEach(([sa, ca]) => {
		la[sa] = {
			insertRule: ca.prototype.insertRule,
			deleteRule: ca.prototype.deleteRule
		}, ca.prototype.insertRule = new Proxy(la[sa].insertRule, {
			apply: callbackWrapper$1((ua, da, ha) => {
				const [pa, va] = ha, {
					id: ba,
					styleId: Ea
				} = getIdAndStyleId(da.parentStyleSheet, Yi, ea.styleMirror);
				return (ba && ba !== -1 || Ea && Ea !== -1) && ue({
					id: ba,
					styleId: Ea,
					adds: [{
						rule: pa,
						index: [...getNestedCSSRulePositions(da), va || 0]
					}]
				}), ua.apply(da, ha)
			})
		}), ca.prototype.deleteRule = new Proxy(la[sa].deleteRule, {
			apply: callbackWrapper$1((ua, da, ha) => {
				const [pa] = ha, {
					id: va,
					styleId: ba
				} = getIdAndStyleId(da.parentStyleSheet, Yi, ea.styleMirror);
				return (va && va !== -1 || ba && ba !== -1) && ue({
					id: va,
					styleId: ba,
					removes: [{
						index: [...getNestedCSSRulePositions(da), pa]
					}]
				}), ua.apply(da, ha)
			})
		})
	}), callbackWrapper$1(() => {
		ta.CSSStyleSheet.prototype.insertRule = na, ta.CSSStyleSheet.prototype.deleteRule = ra, ia && (ta.CSSStyleSheet.prototype.replace = ia), aa && (ta.CSSStyleSheet.prototype.replaceSync = aa), Object.entries(oa).forEach(([sa, ca]) => {
			ca.prototype.insertRule = la[sa].insertRule, ca.prototype.deleteRule = la[sa].deleteRule
		})
	})
}

function initAdoptedStyleSheetObserver({
	mirror: ue,
	stylesheetManager: Yi
}, ea) {
	let ta = null;
	ea.nodeName === "#document" ? ta = ue.getId(ea) : ta = ue.getId(ea.host);
	const na = ea.nodeName === "#document" ? _optionalChain$2([ea, "access", ia => ia.defaultView, "optionalAccess", ia => ia.Document]) : _optionalChain$2([ea, "access", ia => ia.ownerDocument, "optionalAccess", ia => ia.defaultView, "optionalAccess", ia => ia.ShadowRoot]),
		ra = _optionalChain$2([na, "optionalAccess", ia => ia.prototype]) ? Object.getOwnPropertyDescriptor(_optionalChain$2([na, "optionalAccess", ia => ia.prototype]), "adoptedStyleSheets") : void 0;
	return ta === null || ta === -1 || !na || !ra ? () => {} : (Object.defineProperty(ea, "adoptedStyleSheets", {
		configurable: ra.configurable,
		enumerable: ra.enumerable,
		get() {
			return _optionalChain$2([ra, "access", ia => ia.get, "optionalAccess", ia => ia.call, "call", ia => ia(this)])
		},
		set(ia) {
			const aa = _optionalChain$2([ra, "access", oa => oa.set, "optionalAccess", oa => oa.call, "call", oa => oa(this, ia)]);
			if (ta !== null && ta !== -1) try {
				Yi.adoptStyleSheets(ia, ta)
			} catch {}
			return aa
		}
	}), callbackWrapper$1(() => {
		Object.defineProperty(ea, "adoptedStyleSheets", {
			configurable: ra.configurable,
			enumerable: ra.enumerable,
			get: ra.get,
			set: ra.set
		})
	}))
}

function initStyleDeclarationObserver({
	styleDeclarationCb: ue,
	mirror: Yi,
	ignoreCSSAttributes: ea,
	stylesheetManager: ta
}, {
	win: na
}) {
	const ra = na.CSSStyleDeclaration.prototype.setProperty;
	na.CSSStyleDeclaration.prototype.setProperty = new Proxy(ra, {
		apply: callbackWrapper$1((aa, oa, la) => {
			const [sa, ca, ua] = la;
			if (ea.has(sa)) return ra.apply(oa, [sa, ca, ua]);
			const {
				id: da,
				styleId: ha
			} = getIdAndStyleId(_optionalChain$2([oa, "access", pa => pa.parentRule, "optionalAccess", pa => pa.parentStyleSheet]), Yi, ta.styleMirror);
			return (da && da !== -1 || ha && ha !== -1) && ue({
				id: da,
				styleId: ha,
				set: {
					property: sa,
					value: ca,
					priority: ua
				},
				index: getNestedCSSRulePositions(oa.parentRule)
			}), aa.apply(oa, la)
		})
	});
	const ia = na.CSSStyleDeclaration.prototype.removeProperty;
	return na.CSSStyleDeclaration.prototype.removeProperty = new Proxy(ia, {
		apply: callbackWrapper$1((aa, oa, la) => {
			const [sa] = la;
			if (ea.has(sa)) return ia.apply(oa, [sa]);
			const {
				id: ca,
				styleId: ua
			} = getIdAndStyleId(_optionalChain$2([oa, "access", da => da.parentRule, "optionalAccess", da => da.parentStyleSheet]), Yi, ta.styleMirror);
			return (ca && ca !== -1 || ua && ua !== -1) && ue({
				id: ca,
				styleId: ua,
				remove: {
					property: sa
				},
				index: getNestedCSSRulePositions(oa.parentRule)
			}), aa.apply(oa, la)
		})
	}), callbackWrapper$1(() => {
		na.CSSStyleDeclaration.prototype.setProperty = ra, na.CSSStyleDeclaration.prototype.removeProperty = ia
	})
}

function initMediaInteractionObserver({
	mediaInteractionCb: ue,
	blockClass: Yi,
	blockSelector: ea,
	unblockSelector: ta,
	mirror: na,
	sampling: ra,
	doc: ia
}) {
	const aa = callbackWrapper$1(la => throttle$1(callbackWrapper$1(sa => {
			const ca = getEventTarget(sa);
			if (!ca || isBlocked$1(ca, Yi, ea, ta, !0)) return;
			const {
				currentTime: ua,
				volume: da,
				muted: ha,
				playbackRate: pa
			} = ca;
			ue({
				type: la,
				id: na.getId(ca),
				currentTime: ua,
				volume: da,
				muted: ha,
				playbackRate: pa
			})
		}), ra.media || 500)),
		oa = [on$1("play", aa(0), ia), on$1("pause", aa(1), ia), on$1("seeked", aa(2), ia), on$1("volumechange", aa(3), ia), on$1("ratechange", aa(4), ia)];
	return callbackWrapper$1(() => {
		oa.forEach(la => la())
	})
}

function initFontObserver({
	fontCb: ue,
	doc: Yi
}) {
	const ea = Yi.defaultView;
	if (!ea) return () => {};
	const ta = [],
		na = new WeakMap,
		ra = ea.FontFace;
	ea.FontFace = function(oa, la, sa) {
		const ca = new ra(oa, la, sa);
		return na.set(ca, {
			family: oa,
			buffer: typeof la != "string",
			descriptors: sa,
			fontSource: typeof la == "string" ? la : JSON.stringify(Array.from(new Uint8Array(la)))
		}), ca
	};
	const ia = patch$1(Yi.fonts, "add", function(aa) {
		return function(oa) {
			return setTimeout(callbackWrapper$1(() => {
				const la = na.get(oa);
				la && (ue(la), na.delete(oa))
			}), 0), aa.apply(this, [oa])
		}
	});
	return ta.push(() => {
		ea.FontFace = ra
	}), ta.push(ia), callbackWrapper$1(() => {
		ta.forEach(aa => aa())
	})
}

function initSelectionObserver(ue) {
	const {
		doc: Yi,
		mirror: ea,
		blockClass: ta,
		blockSelector: na,
		unblockSelector: ra,
		selectionCb: ia
	} = ue;
	let aa = !0;
	const oa = callbackWrapper$1(() => {
		const la = Yi.getSelection();
		if (!la || aa && _optionalChain$2([la, "optionalAccess", ua => ua.isCollapsed])) return;
		aa = la.isCollapsed || !1;
		const sa = [],
			ca = la.rangeCount || 0;
		for (let ua = 0; ua < ca; ua++) {
			const da = la.getRangeAt(ua),
				{
					startContainer: ha,
					startOffset: pa,
					endContainer: va,
					endOffset: ba
				} = da;
			isBlocked$1(ha, ta, na, ra, !0) || isBlocked$1(va, ta, na, ra, !0) || sa.push({
				start: ea.getId(ha),
				startOffset: pa,
				end: ea.getId(va),
				endOffset: ba
			})
		}
		ia({
			ranges: sa
		})
	});
	return oa(), on$1("selectionchange", oa)
}

function initCustomElementObserver({
	doc: ue,
	customElementCb: Yi
}) {
	const ea = ue.defaultView;
	return !ea || !ea.customElements ? () => {} : patch$1(ea.customElements, "define", function(na) {
		return function(ra, ia, aa) {
			try {
				Yi({
					define: {
						name: ra
					}
				})
			} catch {}
			return na.apply(this, [ra, ia, aa])
		}
	})
}

function initObservers(ue, Yi = {}) {
	const ea = ue.doc.defaultView;
	if (!ea) return () => {};
	const ta = initMutationObserver(ue, ue.doc),
		na = initMoveObserver(ue),
		ra = initMouseInteractionObserver(ue),
		ia = initScrollObserver(ue),
		aa = initViewportResizeObserver(ue, {
			win: ea
		}),
		oa = initInputObserver(ue),
		la = initMediaInteractionObserver(ue),
		sa = initStyleSheetObserver(ue, {
			win: ea
		}),
		ca = initAdoptedStyleSheetObserver(ue, ue.doc),
		ua = initStyleDeclarationObserver(ue, {
			win: ea
		}),
		da = ue.collectFonts ? initFontObserver(ue) : () => {},
		ha = initSelectionObserver(ue),
		pa = initCustomElementObserver(ue),
		va = [];
	for (const ba of ue.plugins) va.push(ba.observer(ba.callback, ea, ba.options));
	return callbackWrapper$1(() => {
		mutationBuffers.forEach(ba => ba.reset()), ta.disconnect(), na(), ra(), ia(), aa(), oa(), la(), sa(), ca(), ua(), da(), ha(), pa(), va.forEach(ba => ba())
	})
}

function hasNestedCSSRule(ue) {
	return typeof window[ue] < "u"
}

function canMonkeyPatchNestedCSSRule(ue) {
	return !!(typeof window[ue] < "u" && window[ue].prototype && "insertRule" in window[ue].prototype && "deleteRule" in window[ue].prototype)
}
class CrossOriginIframeMirror {
	constructor(Yi) {
		this.generateIdFn = Yi, this.iframeIdToRemoteIdMap = new WeakMap, this.iframeRemoteIdToIdMap = new WeakMap
	}
	getId(Yi, ea, ta, na) {
		const ra = ta || this.getIdToRemoteIdMap(Yi),
			ia = na || this.getRemoteIdToIdMap(Yi);
		let aa = ra.get(ea);
		return aa || (aa = this.generateIdFn(), ra.set(ea, aa), ia.set(aa, ea)), aa
	}
	getIds(Yi, ea) {
		const ta = this.getIdToRemoteIdMap(Yi),
			na = this.getRemoteIdToIdMap(Yi);
		return ea.map(ra => this.getId(Yi, ra, ta, na))
	}
	getRemoteId(Yi, ea, ta) {
		const na = ta || this.getRemoteIdToIdMap(Yi);
		if (typeof ea != "number") return ea;
		const ra = na.get(ea);
		return ra || -1
	}
	getRemoteIds(Yi, ea) {
		const ta = this.getRemoteIdToIdMap(Yi);
		return ea.map(na => this.getRemoteId(Yi, na, ta))
	}
	reset(Yi) {
		if (!Yi) {
			this.iframeIdToRemoteIdMap = new WeakMap, this.iframeRemoteIdToIdMap = new WeakMap;
			return
		}
		this.iframeIdToRemoteIdMap.delete(Yi), this.iframeRemoteIdToIdMap.delete(Yi)
	}
	getIdToRemoteIdMap(Yi) {
		let ea = this.iframeIdToRemoteIdMap.get(Yi);
		return ea || (ea = new Map, this.iframeIdToRemoteIdMap.set(Yi, ea)), ea
	}
	getRemoteIdToIdMap(Yi) {
		let ea = this.iframeRemoteIdToIdMap.get(Yi);
		return ea || (ea = new Map, this.iframeRemoteIdToIdMap.set(Yi, ea)), ea
	}
}

function _optionalChain$1(ue) {
	let Yi, ea = ue[0],
		ta = 1;
	for (; ta < ue.length;) {
		const na = ue[ta],
			ra = ue[ta + 1];
		if (ta += 2, (na === "optionalAccess" || na === "optionalCall") && ea == null) return;
		na === "access" || na === "optionalAccess" ? (Yi = ea, ea = ra(ea)) : (na === "call" || na === "optionalCall") && (ea = ra((...ia) => ea.call(Yi, ...ia)), Yi = void 0)
	}
	return ea
}
class IframeManagerNoop {
	constructor() {
		this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId), this.crossOriginIframeRootIdMap = new WeakMap
	}
	addIframe() {}
	addLoadListener() {}
	attachIframe() {}
}
class IframeManager {
	constructor(Yi) {
		this.iframes = new WeakMap, this.crossOriginIframeMap = new WeakMap, this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId), this.crossOriginIframeRootIdMap = new WeakMap, this.mutationCb = Yi.mutationCb, this.wrappedEmit = Yi.wrappedEmit, this.stylesheetManager = Yi.stylesheetManager, this.recordCrossOriginIframes = Yi.recordCrossOriginIframes, this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror)), this.mirror = Yi.mirror, this.recordCrossOriginIframes && window.addEventListener("message", this.handleMessage.bind(this))
	}
	addIframe(Yi) {
		this.iframes.set(Yi, !0), Yi.contentWindow && this.crossOriginIframeMap.set(Yi.contentWindow, Yi)
	}
	addLoadListener(Yi) {
		this.loadListener = Yi
	}
	attachIframe(Yi, ea) {
		this.mutationCb({
			adds: [{
				parentId: this.mirror.getId(Yi),
				nextId: null,
				node: ea
			}],
			removes: [],
			texts: [],
			attributes: [],
			isAttachIframe: !0
		}), _optionalChain$1([this, "access", ta => ta.loadListener, "optionalCall", ta => ta(Yi)]), Yi.contentDocument && Yi.contentDocument.adoptedStyleSheets && Yi.contentDocument.adoptedStyleSheets.length > 0 && this.stylesheetManager.adoptStyleSheets(Yi.contentDocument.adoptedStyleSheets, this.mirror.getId(Yi.contentDocument))
	}
	handleMessage(Yi) {
		const ea = Yi;
		if (ea.data.type !== "rrweb" || ea.origin !== ea.data.origin || !Yi.source) return;
		const na = this.crossOriginIframeMap.get(Yi.source);
		if (!na) return;
		const ra = this.transformCrossOriginEvent(na, ea.data.event);
		ra && this.wrappedEmit(ra, ea.data.isCheckout)
	}
	transformCrossOriginEvent(Yi, ea) {
		switch (ea.type) {
			case EventType.FullSnapshot: {
				this.crossOriginIframeMirror.reset(Yi), this.crossOriginIframeStyleMirror.reset(Yi), this.replaceIdOnNode(ea.data.node, Yi);
				const ta = ea.data.node.id;
				return this.crossOriginIframeRootIdMap.set(Yi, ta), this.patchRootIdOnNode(ea.data.node, ta), {
					timestamp: ea.timestamp,
					type: EventType.IncrementalSnapshot,
					data: {
						source: IncrementalSource.Mutation,
						adds: [{
							parentId: this.mirror.getId(Yi),
							nextId: null,
							node: ea.data.node
						}],
						removes: [],
						texts: [],
						attributes: [],
						isAttachIframe: !0
					}
				}
			}
			case EventType.Meta:
			case EventType.Load:
			case EventType.DomContentLoaded:
				return !1;
			case EventType.Plugin:
				return ea;
			case EventType.Custom:
				return this.replaceIds(ea.data.payload, Yi, ["id", "parentId", "previousId", "nextId"]), ea;
			case EventType.IncrementalSnapshot:
				switch (ea.data.source) {
					case IncrementalSource.Mutation:
						return ea.data.adds.forEach(ta => {
							this.replaceIds(ta, Yi, ["parentId", "nextId", "previousId"]), this.replaceIdOnNode(ta.node, Yi);
							const na = this.crossOriginIframeRootIdMap.get(Yi);
							na && this.patchRootIdOnNode(ta.node, na)
						}), ea.data.removes.forEach(ta => {
							this.replaceIds(ta, Yi, ["parentId", "id"])
						}), ea.data.attributes.forEach(ta => {
							this.replaceIds(ta, Yi, ["id"])
						}), ea.data.texts.forEach(ta => {
							this.replaceIds(ta, Yi, ["id"])
						}), ea;
					case IncrementalSource.Drag:
					case IncrementalSource.TouchMove:
					case IncrementalSource.MouseMove:
						return ea.data.positions.forEach(ta => {
							this.replaceIds(ta, Yi, ["id"])
						}), ea;
					case IncrementalSource.ViewportResize:
						return !1;
					case IncrementalSource.MediaInteraction:
					case IncrementalSource.MouseInteraction:
					case IncrementalSource.Scroll:
					case IncrementalSource.CanvasMutation:
					case IncrementalSource.Input:
						return this.replaceIds(ea.data, Yi, ["id"]), ea;
					case IncrementalSource.StyleSheetRule:
					case IncrementalSource.StyleDeclaration:
						return this.replaceIds(ea.data, Yi, ["id"]), this.replaceStyleIds(ea.data, Yi, ["styleId"]), ea;
					case IncrementalSource.Font:
						return ea;
					case IncrementalSource.Selection:
						return ea.data.ranges.forEach(ta => {
							this.replaceIds(ta, Yi, ["start", "end"])
						}), ea;
					case IncrementalSource.AdoptedStyleSheet:
						return this.replaceIds(ea.data, Yi, ["id"]), this.replaceStyleIds(ea.data, Yi, ["styleIds"]), _optionalChain$1([ea, "access", ta => ta.data, "access", ta => ta.styles, "optionalAccess", ta => ta.forEach, "call", ta => ta(na => {
							this.replaceStyleIds(na, Yi, ["styleId"])
						})]), ea
				}
		}
		return !1
	}
	replace(Yi, ea, ta, na) {
		for (const ra of na) !Array.isArray(ea[ra]) && typeof ea[ra] != "number" || (Array.isArray(ea[ra]) ? ea[ra] = Yi.getIds(ta, ea[ra]) : ea[ra] = Yi.getId(ta, ea[ra]));
		return ea
	}
	replaceIds(Yi, ea, ta) {
		return this.replace(this.crossOriginIframeMirror, Yi, ea, ta)
	}
	replaceStyleIds(Yi, ea, ta) {
		return this.replace(this.crossOriginIframeStyleMirror, Yi, ea, ta)
	}
	replaceIdOnNode(Yi, ea) {
		this.replaceIds(Yi, ea, ["id", "rootId"]), "childNodes" in Yi && Yi.childNodes.forEach(ta => {
			this.replaceIdOnNode(ta, ea)
		})
	}
	patchRootIdOnNode(Yi, ea) {
		Yi.type !== NodeType$1.Document && !Yi.rootId && (Yi.rootId = ea), "childNodes" in Yi && Yi.childNodes.forEach(ta => {
			this.patchRootIdOnNode(ta, ea)
		})
	}
}
class ShadowDomManagerNoop {
	init() {}
	addShadowRoot() {}
	observeAttachShadow() {}
	reset() {}
}
class ShadowDomManager {
	constructor(Yi) {
		this.shadowDoms = new WeakSet, this.restoreHandlers = [], this.mutationCb = Yi.mutationCb, this.scrollCb = Yi.scrollCb, this.bypassOptions = Yi.bypassOptions, this.mirror = Yi.mirror, this.init()
	}
	init() {
		this.reset(), this.patchAttachShadow(Element, document)
	}
	addShadowRoot(Yi, ea) {
		if (!isNativeShadowDom(Yi) || this.shadowDoms.has(Yi)) return;
		this.shadowDoms.add(Yi);
		const ta = initMutationObserver({
			...this.bypassOptions,
			doc: ea,
			mutationCb: this.mutationCb,
			mirror: this.mirror,
			shadowDomManager: this
		}, Yi);
		this.restoreHandlers.push(() => ta.disconnect()), this.restoreHandlers.push(initScrollObserver({
			...this.bypassOptions,
			scrollCb: this.scrollCb,
			doc: Yi,
			mirror: this.mirror
		})), setTimeout(() => {
			Yi.adoptedStyleSheets && Yi.adoptedStyleSheets.length > 0 && this.bypassOptions.stylesheetManager.adoptStyleSheets(Yi.adoptedStyleSheets, this.mirror.getId(Yi.host)), this.restoreHandlers.push(initAdoptedStyleSheetObserver({
				mirror: this.mirror,
				stylesheetManager: this.bypassOptions.stylesheetManager
			}, Yi))
		}, 0)
	}
	observeAttachShadow(Yi) {
		!Yi.contentWindow || !Yi.contentDocument || this.patchAttachShadow(Yi.contentWindow.Element, Yi.contentDocument)
	}
	patchAttachShadow(Yi, ea) {
		const ta = this;
		this.restoreHandlers.push(patch$1(Yi.prototype, "attachShadow", function(na) {
			return function(ra) {
				const ia = na.call(this, ra);
				return this.shadowRoot && inDom(this) && ta.addShadowRoot(this.shadowRoot, ea), ia
			}
		}))
	}
	reset() {
		this.restoreHandlers.forEach(Yi => {
			try {
				Yi()
			} catch {}
		}), this.restoreHandlers = [], this.shadowDoms = new WeakSet
	}
}
class CanvasManagerNoop {
	reset() {}
	freeze() {}
	unfreeze() {}
	lock() {}
	unlock() {}
	snapshot() {}
}
class StylesheetManager {
	constructor(Yi) {
		this.trackedLinkElements = new WeakSet, this.styleMirror = new StyleSheetMirror, this.mutationCb = Yi.mutationCb, this.adoptedStyleSheetCb = Yi.adoptedStyleSheetCb
	}
	attachLinkElement(Yi, ea) {
		"_cssText" in ea.attributes && this.mutationCb({
			adds: [],
			removes: [],
			texts: [],
			attributes: [{
				id: ea.id,
				attributes: ea.attributes
			}]
		}), this.trackLinkElement(Yi)
	}
	trackLinkElement(Yi) {
		this.trackedLinkElements.has(Yi) || (this.trackedLinkElements.add(Yi), this.trackStylesheetInLinkElement(Yi))
	}
	adoptStyleSheets(Yi, ea) {
		if (Yi.length === 0) return;
		const ta = {
				id: ea,
				styleIds: []
			},
			na = [];
		for (const ra of Yi) {
			let ia;
			this.styleMirror.has(ra) ? ia = this.styleMirror.getId(ra) : (ia = this.styleMirror.add(ra), na.push({
				styleId: ia,
				rules: Array.from(ra.rules || CSSRule, (aa, oa) => ({
					rule: stringifyRule(aa),
					index: oa
				}))
			})), ta.styleIds.push(ia)
		}
		na.length > 0 && (ta.styles = na), this.adoptedStyleSheetCb(ta)
	}
	reset() {
		this.styleMirror.reset(), this.trackedLinkElements = new WeakSet
	}
	trackStylesheetInLinkElement(Yi) {}
}
class ProcessedNodeManager {
	constructor() {
		this.nodeMap = new WeakMap, this.loop = !0, this.periodicallyClear()
	}
	periodicallyClear() {
		onRequestAnimationFrame$1(() => {
			this.clear(), this.loop && this.periodicallyClear()
		})
	}
	inOtherBuffer(Yi, ea) {
		const ta = this.nodeMap.get(Yi);
		return ta && Array.from(ta).some(na => na !== ea)
	}
	add(Yi, ea) {
		this.nodeMap.set(Yi, (this.nodeMap.get(Yi) || new Set).add(ea))
	}
	clear() {
		this.nodeMap = new WeakMap
	}
	destroy() {
		this.loop = !1
	}
}

function wrapEvent(ue) {
	const Yi = ue;
	return Yi.timestamp = nowTimestamp(), Yi
}
let _takeFullSnapshot;
const mirror = createMirror();

function record(ue = {}) {
	const {
		emit: Yi,
		checkoutEveryNms: ea,
		checkoutEveryNth: ta,
		blockClass: na = "rr-block",
		blockSelector: ra = null,
		unblockSelector: ia = null,
		ignoreClass: aa = "rr-ignore",
		ignoreSelector: oa = null,
		maskAllText: la = !1,
		maskTextClass: sa = "rr-mask",
		unmaskTextClass: ca = null,
		maskTextSelector: ua = null,
		unmaskTextSelector: da = null,
		inlineStylesheet: ha = !0,
		maskAllInputs: pa,
		maskInputOptions: va,
		slimDOMOptions: ba,
		maskAttributeFn: Ea,
		maskInputFn: Sa,
		maskTextFn: Ca,
		packFn: ka,
		sampling: Pa = {},
		dataURLOptions: ja = {},
		mousemoveWait: Za,
		recordCanvas: Ga = !1,
		recordCrossOriginIframes: Ja = !1,
		recordAfter: Ua = ue.recordAfter === "DOMContentLoaded" ? ue.recordAfter : "load",
		userTriggeredOnInput: xa = !1,
		collectFonts: ma = !1,
		inlineImages: fa = !1,
		plugins: ga,
		keepIframeSrcFn: wa = () => !1,
		ignoreCSSAttributes: Ma = new Set([]),
		errorHandler: Aa,
		onMutation: Ra,
		getCanvasManager: Ta
	} = ue;
	registerErrorHandler$1(Aa);
	const La = Ja ? window.parent === window : !0;
	let ya = !1;
	if (!La) try {
		window.parent.document && (ya = !1)
	} catch {
		ya = !0
	}
	if (La && !Yi) throw new Error("emit function is required");
	Za !== void 0 && Pa.mousemove === void 0 && (Pa.mousemove = Za), mirror.reset();
	const Ba = pa === !0 ? {
			color: !0,
			date: !0,
			"datetime-local": !0,
			email: !0,
			month: !0,
			number: !0,
			range: !0,
			search: !0,
			tel: !0,
			text: !0,
			time: !0,
			url: !0,
			week: !0,
			textarea: !0,
			select: !0,
			radio: !0,
			checkbox: !0
		} : va !== void 0 ? va : {},
		io = ba === !0 || ba === "all" ? {
			script: !0,
			comment: !0,
			headFavicon: !0,
			headWhitespace: !0,
			headMetaSocial: !0,
			headMetaRobots: !0,
			headMetaHttpEquiv: !0,
			headMetaVerification: !0,
			headMetaAuthorship: ba === "all",
			headMetaDescKeywords: ba === "all"
		} : ba || {};
	polyfill();
	let oo, ao = 0;
	const Ia = so => {
			for (const Xa of ga || []) Xa.eventProcessor && (so = Xa.eventProcessor(so));
			return ka && !ya && (so = ka(so)), so
		},
		Na = (so, Xa) => {
			if (_optionalChain([mutationBuffers, "access", to => to[0], "optionalAccess", to => to.isFrozen, "call", to => to()]) && so.type !== EventType.FullSnapshot && !(so.type === EventType.IncrementalSnapshot && so.data.source === IncrementalSource.Mutation) && mutationBuffers.forEach(to => to.unfreeze()), La) _optionalChain([Yi, "optionalCall", to => to(Ia(so), Xa)]);
			else if (ya) {
				const to = {
					type: "rrweb",
					event: Ia(so),
					origin: window.location.origin,
					isCheckout: Xa
				};
				window.parent.postMessage(to, "*")
			}
			if (so.type === EventType.FullSnapshot) oo = so, ao = 0;
			else if (so.type === EventType.IncrementalSnapshot) {
				if (so.data.source === IncrementalSource.Mutation && so.data.isAttachIframe) return;
				ao++;
				const to = ta && ao >= ta,
					ho = ea && oo && so.timestamp - oo.timestamp > ea;
				(to || ho) && vo(!0)
			}
		},
		za = so => {
			Na(wrapEvent({
				type: EventType.IncrementalSnapshot,
				data: {
					source: IncrementalSource.Mutation,
					...so
				}
			}))
		},
		ro = so => Na(wrapEvent({
			type: EventType.IncrementalSnapshot,
			data: {
				source: IncrementalSource.Scroll,
				...so
			}
		})),
		Va = so => Na(wrapEvent({
			type: EventType.IncrementalSnapshot,
			data: {
				source: IncrementalSource.CanvasMutation,
				...so
			}
		})),
		Wa = so => Na(wrapEvent({
			type: EventType.IncrementalSnapshot,
			data: {
				source: IncrementalSource.AdoptedStyleSheet,
				...so
			}
		})),
		qa = new StylesheetManager({
			mutationCb: za,
			adoptedStyleSheetCb: Wa
		}),
		Ka = typeof __RRWEB_EXCLUDE_IFRAME__ == "boolean" && __RRWEB_EXCLUDE_IFRAME__ ? new IframeManagerNoop : new IframeManager({
			mirror,
			mutationCb: za,
			stylesheetManager: qa,
			recordCrossOriginIframes: Ja,
			wrappedEmit: Na
		});
	for (const so of ga || []) so.getMirror && so.getMirror({
		nodeMirror: mirror,
		crossOriginIframeMirror: Ka.crossOriginIframeMirror,
		crossOriginIframeStyleMirror: Ka.crossOriginIframeStyleMirror
	});
	const lo = new ProcessedNodeManager,
		yo = _getCanvasManager(Ta, {
			mirror,
			win: window,
			mutationCb: so => Na(wrapEvent({
				type: EventType.IncrementalSnapshot,
				data: {
					source: IncrementalSource.CanvasMutation,
					...so
				}
			})),
			recordCanvas: Ga,
			blockClass: na,
			blockSelector: ra,
			unblockSelector: ia,
			sampling: Pa.canvas,
			dataURLOptions: ja,
			errorHandler: Aa
		}),
		fo = typeof __RRWEB_EXCLUDE_SHADOW_DOM__ == "boolean" && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new ShadowDomManagerNoop : new ShadowDomManager({
			mutationCb: za,
			scrollCb: ro,
			bypassOptions: {
				onMutation: Ra,
				blockClass: na,
				blockSelector: ra,
				unblockSelector: ia,
				maskAllText: la,
				maskTextClass: sa,
				unmaskTextClass: ca,
				maskTextSelector: ua,
				unmaskTextSelector: da,
				inlineStylesheet: ha,
				maskInputOptions: Ba,
				dataURLOptions: ja,
				maskAttributeFn: Ea,
				maskTextFn: Ca,
				maskInputFn: Sa,
				recordCanvas: Ga,
				inlineImages: fa,
				sampling: Pa,
				slimDOMOptions: io,
				iframeManager: Ka,
				stylesheetManager: qa,
				canvasManager: yo,
				keepIframeSrcFn: wa,
				processedNodeManager: lo
			},
			mirror
		}),
		vo = (so = !1) => {
			Na(wrapEvent({
				type: EventType.Meta,
				data: {
					href: window.location.href,
					width: getWindowWidth(),
					height: getWindowHeight()
				}
			}), so), qa.reset(), fo.init(), mutationBuffers.forEach(to => to.lock());
			const Xa = snapshot(document, {
				mirror,
				blockClass: na,
				blockSelector: ra,
				unblockSelector: ia,
				maskAllText: la,
				maskTextClass: sa,
				unmaskTextClass: ca,
				maskTextSelector: ua,
				unmaskTextSelector: da,
				inlineStylesheet: ha,
				maskAllInputs: Ba,
				maskAttributeFn: Ea,
				maskInputFn: Sa,
				maskTextFn: Ca,
				slimDOM: io,
				dataURLOptions: ja,
				recordCanvas: Ga,
				inlineImages: fa,
				onSerialize: to => {
					isSerializedIframe(to, mirror) && Ka.addIframe(to), isSerializedStylesheet(to, mirror) && qa.trackLinkElement(to), hasShadowRoot(to) && fo.addShadowRoot(to.shadowRoot, document)
				},
				onIframeLoad: (to, ho) => {
					Ka.attachIframe(to, ho), fo.observeAttachShadow(to)
				},
				onStylesheetLoad: (to, ho) => {
					qa.attachLinkElement(to, ho)
				},
				keepIframeSrcFn: wa
			});
			if (!Xa) return console.warn("Failed to snapshot the document");
			Na(wrapEvent({
				type: EventType.FullSnapshot,
				data: {
					node: Xa,
					initialOffset: getWindowScroll(window)
				}
			})), mutationBuffers.forEach(to => to.unlock()), document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0 && qa.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document))
		};
	_takeFullSnapshot = vo;
	try {
		const so = [],
			Xa = ho => callbackWrapper$1(initObservers)({
				onMutation: Ra,
				mutationCb: za,
				mousemoveCb: (Eo, wo) => Na(wrapEvent({
					type: EventType.IncrementalSnapshot,
					data: {
						source: wo,
						positions: Eo
					}
				})),
				mouseInteractionCb: Eo => Na(wrapEvent({
					type: EventType.IncrementalSnapshot,
					data: {
						source: IncrementalSource.MouseInteraction,
						...Eo
					}
				})),
				scrollCb: ro,
				viewportResizeCb: Eo => Na(wrapEvent({
					type: EventType.IncrementalSnapshot,
					data: {
						source: IncrementalSource.ViewportResize,
						...Eo
					}
				})),
				inputCb: Eo => Na(wrapEvent({
					type: EventType.IncrementalSnapshot,
					data: {
						source: IncrementalSource.Input,
						...Eo
					}
				})),
				mediaInteractionCb: Eo => Na(wrapEvent({
					type: EventType.IncrementalSnapshot,
					data: {
						source: IncrementalSource.MediaInteraction,
						...Eo
					}
				})),
				styleSheetRuleCb: Eo => Na(wrapEvent({
					type: EventType.IncrementalSnapshot,
					data: {
						source: IncrementalSource.StyleSheetRule,
						...Eo
					}
				})),
				styleDeclarationCb: Eo => Na(wrapEvent({
					type: EventType.IncrementalSnapshot,
					data: {
						source: IncrementalSource.StyleDeclaration,
						...Eo
					}
				})),
				canvasMutationCb: Va,
				fontCb: Eo => Na(wrapEvent({
					type: EventType.IncrementalSnapshot,
					data: {
						source: IncrementalSource.Font,
						...Eo
					}
				})),
				selectionCb: Eo => {
					Na(wrapEvent({
						type: EventType.IncrementalSnapshot,
						data: {
							source: IncrementalSource.Selection,
							...Eo
						}
					}))
				},
				customElementCb: Eo => {
					Na(wrapEvent({
						type: EventType.IncrementalSnapshot,
						data: {
							source: IncrementalSource.CustomElement,
							...Eo
						}
					}))
				},
				blockClass: na,
				ignoreClass: aa,
				ignoreSelector: oa,
				maskAllText: la,
				maskTextClass: sa,
				unmaskTextClass: ca,
				maskTextSelector: ua,
				unmaskTextSelector: da,
				maskInputOptions: Ba,
				inlineStylesheet: ha,
				sampling: Pa,
				recordCanvas: Ga,
				inlineImages: fa,
				userTriggeredOnInput: xa,
				collectFonts: ma,
				doc: ho,
				maskAttributeFn: Ea,
				maskInputFn: Sa,
				maskTextFn: Ca,
				keepIframeSrcFn: wa,
				blockSelector: ra,
				unblockSelector: ia,
				slimDOMOptions: io,
				dataURLOptions: ja,
				mirror,
				iframeManager: Ka,
				stylesheetManager: qa,
				shadowDomManager: fo,
				processedNodeManager: lo,
				canvasManager: yo,
				ignoreCSSAttributes: Ma,
				plugins: _optionalChain([ga, "optionalAccess", Eo => Eo.filter, "call", Eo => Eo(wo => wo.observer), "optionalAccess", Eo => Eo.map, "call", Eo => Eo(wo => ({
					observer: wo.observer,
					options: wo.options,
					callback: Ao => Na(wrapEvent({
						type: EventType.Plugin,
						data: {
							plugin: wo.name,
							payload: Ao
						}
					}))
				}))]) || []
			}, {});
		Ka.addLoadListener(ho => {
			try {
				so.push(Xa(ho.contentDocument))
			} catch (Eo) {
				console.warn(Eo)
			}
		});
		const to = () => {
			vo(), so.push(Xa(document))
		};
		return document.readyState === "interactive" || document.readyState === "complete" ? to() : (so.push(on$1("DOMContentLoaded", () => {
			Na(wrapEvent({
				type: EventType.DomContentLoaded,
				data: {}
			})), Ua === "DOMContentLoaded" && to()
		})), so.push(on$1("load", () => {
			Na(wrapEvent({
				type: EventType.Load,
				data: {}
			})), Ua === "load" && to()
		}, window))), () => {
			so.forEach(ho => ho()), lo.destroy(), _takeFullSnapshot = void 0, unregisterErrorHandler()
		}
	} catch (so) {
		console.warn(so)
	}
}

function takeFullSnapshot(ue) {
	if (!_takeFullSnapshot) throw new Error("please take full snapshot after start recording");
	_takeFullSnapshot(ue)
}
record.mirror = mirror;
record.takeFullSnapshot = takeFullSnapshot;

function _getCanvasManager(ue, Yi) {
	try {
		return ue ? ue(Yi) : new CanvasManagerNoop
	} catch {
		return console.warn("Unable to initialize CanvasManager"), new CanvasManagerNoop
	}
}
const ReplayEventTypeIncrementalSnapshot = 3,
	ReplayEventTypeCustom = 5;

function timestampToMs(ue) {
	return ue > 9999999999 ? ue : ue * 1e3
}

function timestampToS(ue) {
	return ue > 9999999999 ? ue / 1e3 : ue
}

function addBreadcrumbEvent(ue, Yi) {
	Yi.category !== "sentry.transaction" && (["ui.click", "ui.input"].includes(Yi.category) ? ue.triggerUserActivity() : ue.checkAndHandleExpiredSession(), ue.addUpdate(() => (ue.throttledAddEvent({
		type: EventType.Custom,
		timestamp: (Yi.timestamp || 0) * 1e3,
		data: {
			tag: "breadcrumb",
			payload: normalize(Yi, 10, 1e3)
		}
	}), Yi.category === "console")))
}
const INTERACTIVE_SELECTOR = "button,a";

function getClosestInteractive(ue) {
	return ue.closest(INTERACTIVE_SELECTOR) || ue
}

function getClickTargetNode(ue) {
	const Yi = getTargetNode(ue);
	return !Yi || !(Yi instanceof Element) ? Yi : getClosestInteractive(Yi)
}

function getTargetNode(ue) {
	return isEventWithTarget(ue) ? ue.target : ue
}

function isEventWithTarget(ue) {
	return typeof ue == "object" && !!ue && "target" in ue
}
let handlers;

function onWindowOpen(ue) {
	return handlers || (handlers = [], monkeyPatchWindowOpen()), handlers.push(ue), () => {
		const Yi = handlers ? handlers.indexOf(ue) : -1;
		Yi > -1 && handlers.splice(Yi, 1)
	}
}

function monkeyPatchWindowOpen() {
	fill(WINDOW$1, "open", function(ue) {
		return function(...Yi) {
			if (handlers) try {
				handlers.forEach(ea => ea())
			} catch {}
			return ue.apply(WINDOW$1, Yi)
		}
	})
}

function handleClick(ue, Yi, ea) {
	ue.handleClick(Yi, ea)
}
class ClickDetector {
	constructor(Yi, ea, ta = addBreadcrumbEvent) {
		this._lastMutation = 0, this._lastScroll = 0, this._clicks = [], this._timeout = ea.timeout / 1e3, this._threshold = ea.threshold / 1e3, this._scollTimeout = ea.scrollTimeout / 1e3, this._replay = Yi, this._ignoreSelector = ea.ignoreSelector, this._addBreadcrumbEvent = ta
	}
	addListeners() {
		const Yi = onWindowOpen(() => {
			this._lastMutation = nowInSeconds()
		});
		this._teardown = () => {
			Yi(), this._clicks = [], this._lastMutation = 0, this._lastScroll = 0
		}
	}
	removeListeners() {
		this._teardown && this._teardown(), this._checkClickTimeout && clearTimeout(this._checkClickTimeout)
	}
	handleClick(Yi, ea) {
		if (ignoreElement(ea, this._ignoreSelector) || !isClickBreadcrumb(Yi)) return;
		const ta = {
			timestamp: timestampToS(Yi.timestamp),
			clickBreadcrumb: Yi,
			clickCount: 0,
			node: ea
		};
		this._clicks.some(na => na.node === ta.node && Math.abs(na.timestamp - ta.timestamp) < 1) || (this._clicks.push(ta), this._clicks.length === 1 && this._scheduleCheckClicks())
	}
	registerMutation(Yi = Date.now()) {
		this._lastMutation = timestampToS(Yi)
	}
	registerScroll(Yi = Date.now()) {
		this._lastScroll = timestampToS(Yi)
	}
	registerClick(Yi) {
		const ea = getClosestInteractive(Yi);
		this._handleMultiClick(ea)
	}
	_handleMultiClick(Yi) {
		this._getClicks(Yi).forEach(ea => {
			ea.clickCount++
		})
	}
	_getClicks(Yi) {
		return this._clicks.filter(ea => ea.node === Yi)
	}
	_checkClicks() {
		const Yi = [],
			ea = nowInSeconds();
		this._clicks.forEach(ta => {
			!ta.mutationAfter && this._lastMutation && (ta.mutationAfter = ta.timestamp <= this._lastMutation ? this._lastMutation - ta.timestamp : void 0), !ta.scrollAfter && this._lastScroll && (ta.scrollAfter = ta.timestamp <= this._lastScroll ? this._lastScroll - ta.timestamp : void 0), ta.timestamp + this._timeout <= ea && Yi.push(ta)
		});
		for (const ta of Yi) {
			const na = this._clicks.indexOf(ta);
			na > -1 && (this._generateBreadcrumbs(ta), this._clicks.splice(na, 1))
		}
		this._clicks.length && this._scheduleCheckClicks()
	}
	_generateBreadcrumbs(Yi) {
		const ea = this._replay,
			ta = Yi.scrollAfter && Yi.scrollAfter <= this._scollTimeout,
			na = Yi.mutationAfter && Yi.mutationAfter <= this._threshold,
			ra = !ta && !na,
			{
				clickCount: ia,
				clickBreadcrumb: aa
			} = Yi;
		if (ra) {
			const oa = Math.min(Yi.mutationAfter || this._timeout, this._timeout) * 1e3,
				la = oa < this._timeout * 1e3 ? "mutation" : "timeout",
				sa = {
					type: "default",
					message: aa.message,
					timestamp: aa.timestamp,
					category: "ui.slowClickDetected",
					data: {
						...aa.data,
						url: WINDOW$1.location.href,
						route: ea.getCurrentRoute(),
						timeAfterClickMs: oa,
						endReason: la,
						clickCount: ia || 1
					}
				};
			this._addBreadcrumbEvent(ea, sa);
			return
		}
		if (ia > 1) {
			const oa = {
				type: "default",
				message: aa.message,
				timestamp: aa.timestamp,
				category: "ui.multiClick",
				data: {
					...aa.data,
					url: WINDOW$1.location.href,
					route: ea.getCurrentRoute(),
					clickCount: ia,
					metric: !0
				}
			};
			this._addBreadcrumbEvent(ea, oa)
		}
	}
	_scheduleCheckClicks() {
		this._checkClickTimeout && clearTimeout(this._checkClickTimeout), this._checkClickTimeout = setTimeout(() => this._checkClicks(), 1e3)
	}
}
const SLOW_CLICK_TAGS = ["A", "BUTTON", "INPUT"];

function ignoreElement(ue, Yi) {
	return !!(!SLOW_CLICK_TAGS.includes(ue.tagName) || ue.tagName === "INPUT" && !["submit", "button"].includes(ue.getAttribute("type") || "") || ue.tagName === "A" && (ue.hasAttribute("download") || ue.hasAttribute("target") && ue.getAttribute("target") !== "_self") || Yi && ue.matches(Yi))
}

function isClickBreadcrumb(ue) {
	return !!(ue.data && typeof ue.data.nodeId == "number" && ue.timestamp)
}

function nowInSeconds() {
	return Date.now() / 1e3
}

function updateClickDetectorForRecordingEvent(ue, Yi) {
	try {
		if (!isIncrementalEvent(Yi)) return;
		const {
			source: ea
		} = Yi.data;
		if (ea === IncrementalSource.Mutation && ue.registerMutation(Yi.timestamp), ea === IncrementalSource.Scroll && ue.registerScroll(Yi.timestamp), isIncrementalMouseInteraction(Yi)) {
			const {
				type: ta,
				id: na
			} = Yi.data, ra = record.mirror.getNode(na);
			ra instanceof HTMLElement && ta === MouseInteractions.Click && ue.registerClick(ra)
		}
	} catch {}
}

function isIncrementalEvent(ue) {
	return ue.type === ReplayEventTypeIncrementalSnapshot
}

function isIncrementalMouseInteraction(ue) {
	return ue.data.source === IncrementalSource.MouseInteraction
}

function createBreadcrumb(ue) {
	return {
		timestamp: Date.now() / 1e3,
		type: "default",
		...ue
	}
}
var NodeType$2;
(function(ue) {
	ue[ue.Document = 0] = "Document", ue[ue.DocumentType = 1] = "DocumentType", ue[ue.Element = 2] = "Element", ue[ue.Text = 3] = "Text", ue[ue.CDATA = 4] = "CDATA", ue[ue.Comment = 5] = "Comment"
})(NodeType$2 || (NodeType$2 = {}));
const ATTRIBUTES_TO_RECORD = new Set(["id", "class", "aria-label", "role", "name", "alt", "title", "data-test-id", "data-testid", "disabled", "aria-disabled", "data-sentry-component"]);

function getAttributesToRecord(ue) {
	const Yi = {};
	for (const ea in ue)
		if (ATTRIBUTES_TO_RECORD.has(ea)) {
			let ta = ea;
			(ea === "data-testid" || ea === "data-test-id") && (ta = "testId"), Yi[ta] = ue[ea]
		} return Yi
}
const handleDomListener = ue => Yi => {
	if (!ue.isEnabled()) return;
	const ea = handleDom(Yi);
	if (!ea) return;
	const ta = Yi.name === "click",
		na = ta ? Yi.event : void 0;
	ta && ue.clickDetector && na && na.target && !na.altKey && !na.metaKey && !na.ctrlKey && !na.shiftKey && handleClick(ue.clickDetector, ea, getClickTargetNode(Yi.event)), addBreadcrumbEvent(ue, ea)
};

function getBaseDomBreadcrumb(ue, Yi) {
	const ea = record.mirror.getId(ue),
		ta = ea && record.mirror.getNode(ea),
		na = ta && record.mirror.getMeta(ta),
		ra = na && isElement(na) ? na : null;
	return {
		message: Yi,
		data: ra ? {
			nodeId: ea,
			node: {
				id: ea,
				tagName: ra.tagName,
				textContent: Array.from(ra.childNodes).map(ia => ia.type === NodeType$2.Text && ia.textContent).filter(Boolean).map(ia => ia.trim()).join(""),
				attributes: getAttributesToRecord(ra.attributes)
			}
		} : {}
	}
}

function handleDom(ue) {
	const {
		target: Yi,
		message: ea
	} = getDomTarget(ue);
	return createBreadcrumb({
		category: `ui.${ue.name}`,
		...getBaseDomBreadcrumb(Yi, ea)
	})
}

function getDomTarget(ue) {
	const Yi = ue.name === "click";
	let ea, ta = null;
	try {
		ta = Yi ? getClickTargetNode(ue.event) : getTargetNode(ue.event), ea = htmlTreeAsString(ta, {
			maxStringLength: 200
		}) || "<unknown>"
	} catch {
		ea = "<unknown>"
	}
	return {
		target: ta,
		message: ea
	}
}

function isElement(ue) {
	return ue.type === NodeType$2.Element
}

function handleKeyboardEvent(ue, Yi) {
	if (!ue.isEnabled()) return;
	ue.updateUserActivity();
	const ea = getKeyboardBreadcrumb(Yi);
	ea && addBreadcrumbEvent(ue, ea)
}

function getKeyboardBreadcrumb(ue) {
	const {
		metaKey: Yi,
		shiftKey: ea,
		ctrlKey: ta,
		altKey: na,
		key: ra,
		target: ia
	} = ue;
	if (!ia || isInputElement(ia) || !ra) return null;
	const aa = Yi || ta || na,
		oa = ra.length === 1;
	if (!aa && oa) return null;
	const la = htmlTreeAsString(ia, {
			maxStringLength: 200
		}) || "<unknown>",
		sa = getBaseDomBreadcrumb(ia, la);
	return createBreadcrumb({
		category: "ui.keyDown",
		message: la,
		data: {
			...sa.data,
			metaKey: Yi,
			shiftKey: ea,
			ctrlKey: ta,
			altKey: na,
			key: ra
		}
	})
}

function isInputElement(ue) {
	return ue.tagName === "INPUT" || ue.tagName === "TEXTAREA" || ue.isContentEditable
}
const ENTRY_TYPES = {
	resource: createResourceEntry,
	paint: createPaintEntry,
	navigation: createNavigationEntry
};

function createPerformanceEntries(ue) {
	return ue.map(createPerformanceEntry).filter(Boolean)
}

function createPerformanceEntry(ue) {
	return ENTRY_TYPES[ue.entryType] ? ENTRY_TYPES[ue.entryType](ue) : null
}

function getAbsoluteTime(ue) {
	return ((browserPerformanceTimeOrigin || WINDOW$1.performance.timeOrigin) + ue) / 1e3
}

function createPaintEntry(ue) {
	const {
		duration: Yi,
		entryType: ea,
		name: ta,
		startTime: na
	} = ue, ra = getAbsoluteTime(na);
	return {
		type: ea,
		name: ta,
		start: ra,
		end: ra + Yi,
		data: void 0
	}
}

function createNavigationEntry(ue) {
	const {
		entryType: Yi,
		name: ea,
		decodedBodySize: ta,
		duration: na,
		domComplete: ra,
		encodedBodySize: ia,
		domContentLoadedEventStart: aa,
		domContentLoadedEventEnd: oa,
		domInteractive: la,
		loadEventStart: sa,
		loadEventEnd: ca,
		redirectCount: ua,
		startTime: da,
		transferSize: ha,
		type: pa
	} = ue;
	return na === 0 ? null : {
		type: `${Yi}.${pa}`,
		start: getAbsoluteTime(da),
		end: getAbsoluteTime(ra),
		name: ea,
		data: {
			size: ha,
			decodedBodySize: ta,
			encodedBodySize: ia,
			duration: na,
			domInteractive: la,
			domContentLoadedEventStart: aa,
			domContentLoadedEventEnd: oa,
			loadEventStart: sa,
			loadEventEnd: ca,
			domComplete: ra,
			redirectCount: ua
		}
	}
}

function createResourceEntry(ue) {
	const {
		entryType: Yi,
		initiatorType: ea,
		name: ta,
		responseEnd: na,
		startTime: ra,
		decodedBodySize: ia,
		encodedBodySize: aa,
		responseStatus: oa,
		transferSize: la
	} = ue;
	return ["fetch", "xmlhttprequest"].includes(ea) ? null : {
		type: `${Yi}.${ea}`,
		start: getAbsoluteTime(ra),
		end: getAbsoluteTime(na),
		name: ta,
		data: {
			size: la,
			statusCode: oa,
			decodedBodySize: ia,
			encodedBodySize: aa
		}
	}
}

function getLargestContentfulPaint(ue) {
	const Yi = ue.entries,
		ea = Yi[Yi.length - 1],
		ta = ea ? ea.element : void 0,
		na = ue.value,
		ra = getAbsoluteTime(na);
	return {
		type: "largest-contentful-paint",
		name: "largest-contentful-paint",
		start: ra,
		end: ra,
		data: {
			value: na,
			size: na,
			nodeId: ta ? record.mirror.getId(ta) : void 0
		}
	}
}

function setupPerformanceObserver(ue) {
	function Yi(na) {
		ue.performanceEntries.includes(na) || ue.performanceEntries.push(na)
	}

	function ea({
		entries: na
	}) {
		na.forEach(Yi)
	}
	const ta = [];
	return ["navigation", "paint", "resource"].forEach(na => {
		ta.push(addPerformanceInstrumentationHandler(na, ea))
	}), ta.push(addLcpInstrumentationHandler(({
		metric: na
	}) => {
		ue.replayPerformanceEntries.push(getLargestContentfulPaint(na))
	})), () => {
		ta.forEach(na => na())
	}
}
const DEBUG_BUILD$2 = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
	r$2 = 'var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),a=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),s=function(t,e){for(var i=new n(31),a=0;a<31;++a)i[a]=e+=1<<t[a-1];var s=new r(i[30]);for(a=1;a<30;++a)for(var o=i[a];o<i[a+1];++o)s[o]=o-i[a]<<5|a;return{b:i,r:s}},o=s(e,2),f=o.b,h=o.r;f[28]=258,h[258]=28;for(var l=s(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,a=0,s=new n(r);a<i;++a)t[a]&&++s[t[a]-1];var o,f=new n(r);for(a=1;a<r;++a)f[a]=f[a-1]+s[a-1]<<1;if(e){o=new n(1<<r);var h=15-r;for(a=0;a<i;++a)if(t[a])for(var l=a<<4|t[a],c=r-t[a],v=f[t[a]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>h]=l}else for(o=new n(i),a=0;a<i;++a)t[a]&&(o[a]=u[f[t[a]-1]++]>>15-t[a]);return o},g=new t(288);for(c=0;c<144;++c)g[c]=8;for(c=144;c<256;++c)g[c]=9;for(c=256;c<280;++c)g[c]=7;for(c=280;c<288;++c)g[c]=8;var w=new t(32);for(c=0;c<32;++c)w[c]=5;var p=d(g,9,0),y=d(w,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==r||r<0)&&(r=0),(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},A=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},_=function(r,e){for(var i=[],a=0;a<r.length;++a)r[a]&&i.push({s:a,f:r[a]});var s=i.length,o=i.slice();if(!s)return{t:F,l:0};if(1==s){var f=new t(i[0].s+1);return f[i[0].s]=1,{t:f,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var h=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:h.f+l.f,l:h,r:l};c!=s-1;)h=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:h.f+l.f,l:h,r:l};var d=o[0].s;for(a=1;a<s;++a)o[a].s>d&&(d=o[a].s);var g=new n(d+1),w=x(i[c-1],g,0);if(w>e){a=0;var p=0,y=w-e,m=1<<y;for(o.sort((function(t,n){return g[n.s]-g[t.s]||t.f-n.f}));a<s;++a){var b=o[a].s;if(!(g[b]>e))break;p+=m-(1<<w-g[b]),g[b]=e}for(p>>=y;p>0;){var M=o[a].s;g[M]<e?p-=1<<e-g[M]++-1:++a}for(;a>=0&&p;--a){var E=o[a].s;g[E]==e&&(--g[E],++p)}w=e}return{t:new t(g),l:w}},x=function(t,n,r){return-1==t.s?Math.max(x(t.l,n,r+1),x(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,a=t[0],s=1,o=function(t){e[i++]=t},f=1;f<=r;++f)if(t[f]==a&&f!=r)++s;else{if(!a&&s>2){for(;s>138;s-=138)o(32754);s>2&&(o(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(o(a),--s;s>6;s-=6)o(8304);s>2&&(o(s-3<<5|8208),s=0)}for(;s--;)o(a);s=1,a=t[f]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var a=0;a<e;++a)t[i+a+4]=r[a];return 8*(i+4+e)},C=function(t,r,s,o,f,h,l,u,c,v,m){z(r,m++,s),++f[256];for(var b=_(f,15),M=b.t,E=b.l,x=_(h,15),C=x.t,U=x.l,F=D(M),I=F.c,S=F.n,L=D(C),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=_(q,7),H=G.t,J=G.l,K=19;K>4&&!H[a[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(f,g)+T(h,w)+l,X=T(f,M)+T(h,C)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(C,U,0),R=C;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[a[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=p,P=g,Q=y,R=w;for(B=0;B<u;++B){var rt=o[B];if(rt>255){A(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;A(r,m,Q[et]),m+=R[et],et>3&&(A(r,m,rt>>5&8191),m+=i[et])}else A(r,m,N[rt]),m+=P[rt]}return A(r,m,N[256]),m+P[256]},U=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,a=0|r.length,s=0;s!=a;){for(var o=Math.min(s+2655,a);s<o;++s)i+=e+=r[s];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},L=function(a,s,o,f,u){if(!u&&(u={l:1},s.dictionary)){var c=s.dictionary.subarray(-32768),v=new t(c.length+a.length);v.set(c),v.set(a,c.length),a=v,u.w=c.length}return function(a,s,o,f,u,c){var v=c.z||a.length,d=new t(f+v+5*(1+Math.ceil(v/7e3))+u),g=d.subarray(f,d.length-u),w=c.l,p=7&(c.r||0);if(s){p&&(g[0]=c.r>>3);for(var y=U[s-1],M=y>>13,E=8191&y,z=(1<<o)-1,A=c.p||new n(32768),_=c.h||new n(z+1),x=Math.ceil(o/3),D=2*x,T=function(t){return(a[t]^a[t+1]<<x^a[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=_[H];if(A[J]=K,_[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!w)){p=C(a,g,0,F,I,S,O,q,G,j-G,p),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(a[j+Q]==a[j+Q-W]){for(var $=0;$<Z&&a[j+$]==a[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-A[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=A[J])&32767}if(R){F[q++]=268435456|h[Q]<<18|l[R];var it=31&h[Q],at=31&l[R];O+=e[it]+i[at],++I[257+it],++S[at],B=j+Q,++L}else F[q++]=a[j],++I[a[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=a[j],++I[a[j]];p=C(a,g,w,F,I,S,O,q,G,j-G,p),w||(c.r=7&p|g[p/8|0]<<3,p-=7,c.h=_,c.p=A,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+w;j+=65535){var st=j+65535;st>=v&&(g[p/8|0]=w,st=v),p=k(g,p+1,a.subarray(j,st))}c.i=v}return b(d,0,f+m(p)+u)}(a,null==s.level?6:s.level,null==s.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(a.length)))):12+s.mem,o,f,u)},O=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},j=function(){function n(n,r){if("function"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(L(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var a=this.b.length-this.s.z;a&&(this.b.set(n.subarray(0,a),this.s.z),this.s.z=this.b.length,this.p(this.b,!1)),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(a),32768),this.s.z=n.length-a+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n}();function q(t,n){n||(n={});var r=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}}(),e=t.length;r.p(t);var i,a=L(t,n,10+((i=n).filename?i.filename.length+1:0),8),s=a.length;return function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&O(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}}(a,n),O(a,s-8,r.d()),O(a,s-4,e),a}var B=function(){function t(t,n){this.c=S(),this.v=1,j.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),j.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=L(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=S();i.p(n.dictionary),O(t,2,i.d())}}(r,this.o),this.v=0),n&&O(r,r.length-4,this.c.d()),this.ondata(r,n)},t}(),G="undefined"!=typeof TextEncoder&&new TextEncoder,H="undefined"!=typeof TextDecoder&&new TextDecoder;try{H.decode(F,{stream:!0})}catch(t){}var J=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(K(t),this.d=n||!1)},t}();function K(n,r){if(r){for(var e=new t(n.length),i=0;i<n.length;++i)e[i]=n.charCodeAt(i);return e}if(G)return G.encode(n);var a=n.length,s=new t(n.length+(n.length>>1)),o=0,f=function(t){s[o++]=t};for(i=0;i<a;++i){if(o+5>s.length){var h=new t(o+8+(a-i<<1));h.set(s),s=h}var l=n.charCodeAt(i);l<128||r?f(l):l<2048?(f(192|l>>6),f(128|63&l)):l>55295&&l<57344?(f(240|(l=65536+(1047552&l)|1023&n.charCodeAt(++i))>>18),f(128|l>>12&63),f(128|l>>6&63),f(128|63&l)):(f(224|l>>12),f(128|l>>6&63),f(128|63&l))}return b(s,0,o)}const N=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error("Adding invalid event");const n=this._hasEvents?",":"";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push("]",!0);const t=function(t){let n=0;for(let r=0,e=t.length;r<e;r++)n+=t[r].length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new B,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new J(((t,n)=>{this.deflate.push(t,n)})),this.stream.push("[")}},P={clear:()=>{N.clear()},addEvent:t=>N.addEvent(t),finish:()=>N.finish(),compress:t=>function(t){return q(K(t))}(t)};addEventListener("message",(function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in P&&"function"==typeof P[n])try{const t=P[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:"init",success:!0,response:void 0});';

function e$1() {
	const ue = new Blob([r$2]);
	return URL.createObjectURL(ue)
}

function logInfo(ue, Yi) {
	DEBUG_BUILD$2 && (logger.info(ue), Yi && addLogBreadcrumb(ue))
}

function logInfoNextTick(ue, Yi) {
	DEBUG_BUILD$2 && (logger.info(ue), Yi && setTimeout(() => {
		addLogBreadcrumb(ue)
	}, 0))
}

function addLogBreadcrumb(ue) {
	addBreadcrumb({
		category: "console",
		data: {
			logger: "replay"
		},
		level: "info",
		message: ue
	}, {
		level: "info"
	})
}
class EventBufferSizeExceededError extends Error {
	constructor() {
		super(`Event buffer exceeded maximum size of ${REPLAY_MAX_EVENT_BUFFER_SIZE}.`)
	}
}
class EventBufferArray {
	constructor() {
		this.events = [], this._totalSize = 0, this.hasCheckout = !1
	}
	get hasEvents() {
		return this.events.length > 0
	}
	get type() {
		return "sync"
	}
	destroy() {
		this.events = []
	}
	async addEvent(Yi) {
		const ea = JSON.stringify(Yi).length;
		if (this._totalSize += ea, this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) throw new EventBufferSizeExceededError;
		this.events.push(Yi)
	}
	finish() {
		return new Promise(Yi => {
			const ea = this.events;
			this.clear(), Yi(JSON.stringify(ea))
		})
	}
	clear() {
		this.events = [], this._totalSize = 0, this.hasCheckout = !1
	}
	getEarliestTimestamp() {
		const Yi = this.events.map(ea => ea.timestamp).sort()[0];
		return Yi ? timestampToMs(Yi) : null
	}
}
class WorkerHandler {
	constructor(Yi) {
		this._worker = Yi, this._id = 0
	}
	ensureReady() {
		return this._ensureReadyPromise ? this._ensureReadyPromise : (this._ensureReadyPromise = new Promise((Yi, ea) => {
			this._worker.addEventListener("message", ({
				data: ta
			}) => {
				ta.success ? Yi() : ea()
			}, {
				once: !0
			}), this._worker.addEventListener("error", ta => {
				ea(ta)
			}, {
				once: !0
			})
		}), this._ensureReadyPromise)
	}
	destroy() {
		logInfo("[Replay] Destroying compression worker"), this._worker.terminate()
	}
	postMessage(Yi, ea) {
		const ta = this._getAndIncrementId();
		return new Promise((na, ra) => {
			const ia = ({
				data: aa
			}) => {
				const oa = aa;
				if (oa.method === Yi && oa.id === ta) {
					if (this._worker.removeEventListener("message", ia), !oa.success) {
						DEBUG_BUILD$2 && logger.error("[Replay]", oa.response), ra(new Error("Error in compression worker"));
						return
					}
					na(oa.response)
				}
			};
			this._worker.addEventListener("message", ia), this._worker.postMessage({
				id: ta,
				method: Yi,
				arg: ea
			})
		})
	}
	_getAndIncrementId() {
		return this._id++
	}
}
class EventBufferCompressionWorker {
	constructor(Yi) {
		this._worker = new WorkerHandler(Yi), this._earliestTimestamp = null, this._totalSize = 0, this.hasCheckout = !1
	}
	get hasEvents() {
		return !!this._earliestTimestamp
	}
	get type() {
		return "worker"
	}
	ensureReady() {
		return this._worker.ensureReady()
	}
	destroy() {
		this._worker.destroy()
	}
	addEvent(Yi) {
		const ea = timestampToMs(Yi.timestamp);
		(!this._earliestTimestamp || ea < this._earliestTimestamp) && (this._earliestTimestamp = ea);
		const ta = JSON.stringify(Yi);
		return this._totalSize += ta.length, this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE ? Promise.reject(new EventBufferSizeExceededError) : this._sendEventToWorker(ta)
	}
	finish() {
		return this._finishRequest()
	}
	clear() {
		this._earliestTimestamp = null, this._totalSize = 0, this.hasCheckout = !1, this._worker.postMessage("clear").then(null, Yi => {
			DEBUG_BUILD$2 && logger.warn('[Replay] Sending "clear" message to worker failed', Yi)
		})
	}
	getEarliestTimestamp() {
		return this._earliestTimestamp
	}
	_sendEventToWorker(Yi) {
		return this._worker.postMessage("addEvent", Yi)
	}
	async _finishRequest() {
		const Yi = await this._worker.postMessage("finish");
		return this._earliestTimestamp = null, this._totalSize = 0, Yi
	}
}
class EventBufferProxy {
	constructor(Yi) {
		this._fallback = new EventBufferArray, this._compression = new EventBufferCompressionWorker(Yi), this._used = this._fallback, this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded()
	}
	get type() {
		return this._used.type
	}
	get hasEvents() {
		return this._used.hasEvents
	}
	get hasCheckout() {
		return this._used.hasCheckout
	}
	set hasCheckout(Yi) {
		this._used.hasCheckout = Yi
	}
	destroy() {
		this._fallback.destroy(), this._compression.destroy()
	}
	clear() {
		return this._used.clear()
	}
	getEarliestTimestamp() {
		return this._used.getEarliestTimestamp()
	}
	addEvent(Yi) {
		return this._used.addEvent(Yi)
	}
	async finish() {
		return await this.ensureWorkerIsLoaded(), this._used.finish()
	}
	ensureWorkerIsLoaded() {
		return this._ensureWorkerIsLoadedPromise
	}
	async _ensureWorkerIsLoaded() {
		try {
			await this._compression.ensureReady()
		} catch {
			logInfo("[Replay] Failed to load the compression worker, falling back to simple buffer");
			return
		}
		await this._switchToCompressionWorker()
	}
	async _switchToCompressionWorker() {
		const {
			events: Yi,
			hasCheckout: ea
		} = this._fallback, ta = [];
		for (const na of Yi) ta.push(this._compression.addEvent(na));
		this._compression.hasCheckout = ea, this._used = this._compression;
		try {
			await Promise.all(ta)
		} catch (na) {
			DEBUG_BUILD$2 && logger.warn("[Replay] Failed to add events when switching buffers.", na)
		}
	}
}

function createEventBuffer({
	useCompression: ue,
	workerUrl: Yi
}) {
	if (ue && window.Worker) {
		const ea = _loadWorker(Yi);
		if (ea) return ea
	}
	return logInfo("[Replay] Using simple buffer"), new EventBufferArray
}

function _loadWorker(ue) {
	try {
		const Yi = ue || _getWorkerUrl();
		if (!Yi) return;
		logInfo(`[Replay] Using compression worker${ue?` from ${ue}`:""}`);
		const ea = new Worker(Yi);
		return new EventBufferProxy(ea)
	} catch {
		logInfo("[Replay] Failed to create compression worker")
	}
}

function _getWorkerUrl() {
	return typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ > "u" || !__SENTRY_EXCLUDE_REPLAY_WORKER__ ? e$1() : ""
}

function hasSessionStorage() {
	try {
		return "sessionStorage" in WINDOW$1 && !!WINDOW$1.sessionStorage
	} catch {
		return !1
	}
}

function clearSession(ue) {
	deleteSession(), ue.session = void 0
}

function deleteSession() {
	if (hasSessionStorage()) try {
		WINDOW$1.sessionStorage.removeItem(REPLAY_SESSION_KEY)
	} catch {}
}

function isSampled(ue) {
	return ue === void 0 ? !1 : Math.random() < ue
}

function makeSession(ue) {
	const Yi = Date.now(),
		ea = ue.id || uuid4(),
		ta = ue.started || Yi,
		na = ue.lastActivity || Yi,
		ra = ue.segmentId || 0,
		ia = ue.sampled,
		aa = ue.previousSessionId;
	return {
		id: ea,
		started: ta,
		lastActivity: na,
		segmentId: ra,
		sampled: ia,
		previousSessionId: aa
	}
}

function saveSession(ue) {
	if (hasSessionStorage()) try {
		WINDOW$1.sessionStorage.setItem(REPLAY_SESSION_KEY, JSON.stringify(ue))
	} catch {}
}

function getSessionSampleType(ue, Yi) {
	return isSampled(ue) ? "session" : Yi ? "buffer" : !1
}

function createSession({
	sessionSampleRate: ue,
	allowBuffering: Yi,
	stickySession: ea = !1
}, {
	previousSessionId: ta
} = {}) {
	const na = getSessionSampleType(ue, Yi),
		ra = makeSession({
			sampled: na,
			previousSessionId: ta
		});
	return ea && saveSession(ra), ra
}

function fetchSession(ue) {
	if (!hasSessionStorage()) return null;
	try {
		const Yi = WINDOW$1.sessionStorage.getItem(REPLAY_SESSION_KEY);
		if (!Yi) return null;
		const ea = JSON.parse(Yi);
		return logInfoNextTick("[Replay] Loading existing session", ue), makeSession(ea)
	} catch {
		return null
	}
}

function isExpired(ue, Yi, ea = +new Date) {
	return ue === null || Yi === void 0 || Yi < 0 ? !0 : Yi === 0 ? !1 : ue + Yi <= ea
}

function isSessionExpired(ue, {
	maxReplayDuration: Yi,
	sessionIdleExpire: ea,
	targetTime: ta = Date.now()
}) {
	return isExpired(ue.started, Yi, ta) || isExpired(ue.lastActivity, ea, ta)
}

function shouldRefreshSession(ue, {
	sessionIdleExpire: Yi,
	maxReplayDuration: ea
}) {
	return !(!isSessionExpired(ue, {
		sessionIdleExpire: Yi,
		maxReplayDuration: ea
	}) || ue.sampled === "buffer" && ue.segmentId === 0)
}

function loadOrCreateSession({
	traceInternals: ue,
	sessionIdleExpire: Yi,
	maxReplayDuration: ea,
	previousSessionId: ta
}, na) {
	const ra = na.stickySession && fetchSession(ue);
	return ra ? shouldRefreshSession(ra, {
		sessionIdleExpire: Yi,
		maxReplayDuration: ea
	}) ? (logInfoNextTick("[Replay] Session in sessionStorage is expired, creating new one..."), createSession(na, {
		previousSessionId: ra.id
	})) : ra : (logInfoNextTick("[Replay] Creating new session", ue), createSession(na, {
		previousSessionId: ta
	}))
}

function isCustomEvent(ue) {
	return ue.type === EventType.Custom
}

function addEventSync(ue, Yi, ea) {
	return shouldAddEvent(ue, Yi) ? (_addEvent(ue, Yi, ea), !0) : !1
}

function addEvent(ue, Yi, ea) {
	return shouldAddEvent(ue, Yi) ? _addEvent(ue, Yi, ea) : Promise.resolve(null)
}
async function _addEvent(ue, Yi, ea) {
	if (!ue.eventBuffer) return null;
	try {
		ea && ue.recordingMode === "buffer" && ue.eventBuffer.clear(), ea && (ue.eventBuffer.hasCheckout = !0);
		const ta = ue.getOptions(),
			na = maybeApplyCallback(Yi, ta.beforeAddRecordingEvent);
		return na ? await ue.eventBuffer.addEvent(na) : void 0
	} catch (ta) {
		const na = ta && ta instanceof EventBufferSizeExceededError ? "addEventSizeExceeded" : "addEvent";
		DEBUG_BUILD$2 && logger.error(ta), await ue.stop({
			reason: na
		});
		const ra = getClient();
		ra && ra.recordDroppedEvent("internal_sdk_error", "replay")
	}
}

function shouldAddEvent(ue, Yi) {
	if (!ue.eventBuffer || ue.isPaused() || !ue.isEnabled()) return !1;
	const ea = timestampToMs(Yi.timestamp);
	return ea + ue.timeouts.sessionIdlePause < Date.now() ? !1 : ea > ue.getContext().initialTimestamp + ue.getOptions().maxReplayDuration ? (logInfo(`[Replay] Skipping event with timestamp ${ea} because it is after maxReplayDuration`, ue.getOptions()._experiments.traceInternals), !1) : !0
}

function maybeApplyCallback(ue, Yi) {
	try {
		if (typeof Yi == "function" && isCustomEvent(ue)) return Yi(ue)
	} catch (ea) {
		return DEBUG_BUILD$2 && logger.error("[Replay] An error occured in the `beforeAddRecordingEvent` callback, skipping the event...", ea), null
	}
	return ue
}

function isErrorEvent(ue) {
	return !ue.type
}

function isTransactionEvent(ue) {
	return ue.type === "transaction"
}

function isReplayEvent(ue) {
	return ue.type === "replay_event"
}

function isFeedbackEvent(ue) {
	return ue.type === "feedback"
}

function handleAfterSendEvent(ue) {
	const Yi = isBaseTransportSend();
	return (ea, ta) => {
		if (!ue.isEnabled() || !isErrorEvent(ea) && !isTransactionEvent(ea)) return;
		const na = ta && ta.statusCode;
		if (!(Yi && (!na || na < 200 || na >= 300))) {
			if (isTransactionEvent(ea)) {
				handleTransactionEvent(ue, ea);
				return
			}
			handleErrorEvent(ue, ea)
		}
	}
}

function handleTransactionEvent(ue, Yi) {
	const ea = ue.getContext();
	Yi.contexts && Yi.contexts.trace && Yi.contexts.trace.trace_id && ea.traceIds.size < 100 && ea.traceIds.add(Yi.contexts.trace.trace_id)
}

function handleErrorEvent(ue, Yi) {
	const ea = ue.getContext();
	if (Yi.event_id && ea.errorIds.size < 100 && ea.errorIds.add(Yi.event_id), ue.recordingMode !== "buffer" || !Yi.tags || !Yi.tags.replayId) return;
	const {
		beforeErrorSampling: ta
	} = ue.getOptions();
	typeof ta == "function" && !ta(Yi) || setTimeout(() => {
		ue.sendBufferedReplayOrFlush()
	})
}

function isBaseTransportSend() {
	const ue = getClient();
	if (!ue) return !1;
	const Yi = ue.getTransport();
	return Yi && Yi.send.__sentry__baseTransport__ || !1
}

function handleBeforeSendEvent(ue) {
	return Yi => {
		!ue.isEnabled() || !isErrorEvent(Yi) || handleHydrationError(ue, Yi)
	}
}

function handleHydrationError(ue, Yi) {
	const ea = Yi.exception && Yi.exception.values && Yi.exception.values[0].value;
	if (typeof ea == "string" && (ea.match(/reactjs\.org\/docs\/error-decoder\.html\?invariant=(418|419|422|423|425)/) || ea.match(/(does not match server-rendered HTML|Hydration failed because)/i))) {
		const ta = createBreadcrumb({
			category: "replay.hydrate-error"
		});
		addBreadcrumbEvent(ue, ta)
	}
}

function isRrwebError(ue, Yi) {
	return ue.type || !ue.exception || !ue.exception.values || !ue.exception.values.length ? !1 : !!(Yi.originalException && Yi.originalException.__rrweb__)
}

function addFeedbackBreadcrumb(ue, Yi) {
	ue.triggerUserActivity(), ue.addUpdate(() => Yi.timestamp ? (ue.throttledAddEvent({
		type: EventType.Custom,
		timestamp: Yi.timestamp * 1e3,
		data: {
			tag: "breadcrumb",
			payload: {
				timestamp: Yi.timestamp,
				type: "default",
				category: "sentry.feedback",
				data: {
					feedbackId: Yi.event_id
				}
			}
		}
	}), !1) : !0)
}

function shouldSampleForBufferEvent(ue, Yi) {
	return ue.recordingMode !== "buffer" || Yi.message === UNABLE_TO_SEND_REPLAY || !Yi.exception || Yi.type ? !1 : isSampled(ue.getOptions().errorSampleRate)
}

function handleGlobalEventListener(ue, Yi = !1) {
	const ea = Yi ? handleAfterSendEvent(ue) : void 0;
	return Object.assign((ta, na) => ue.isEnabled() ? isReplayEvent(ta) ? (delete ta.breadcrumbs, ta) : !isErrorEvent(ta) && !isTransactionEvent(ta) && !isFeedbackEvent(ta) || !ue.checkAndHandleExpiredSession() ? ta : isFeedbackEvent(ta) ? (ue.flush(), ta.contexts.feedback.replay_id = ue.getSessionId(), addFeedbackBreadcrumb(ue, ta), ta) : isRrwebError(ta, na) && !ue.getOptions()._experiments.captureExceptions ? (DEBUG_BUILD$2 && logger.log("[Replay] Ignoring error from rrweb internals", ta), null) : ((shouldSampleForBufferEvent(ue, ta) || ue.recordingMode === "session") && (ta.tags = {
		...ta.tags,
		replayId: ue.getSessionId()
	}), ea && ea(ta, {
		statusCode: 200
	}), ta) : ta, {
		id: "Replay"
	})
}

function createPerformanceSpans(ue, Yi) {
	return Yi.map(({
		type: ea,
		start: ta,
		end: na,
		name: ra,
		data: ia
	}) => {
		const aa = ue.throttledAddEvent({
			type: EventType.Custom,
			timestamp: ta,
			data: {
				tag: "performanceSpan",
				payload: {
					op: ea,
					description: ra,
					startTimestamp: ta,
					endTimestamp: na,
					data: ia
				}
			}
		});
		return typeof aa == "string" ? Promise.resolve(null) : aa
	})
}

function handleHistory(ue) {
	const {
		from: Yi,
		to: ea
	} = ue, ta = Date.now() / 1e3;
	return {
		type: "navigation.push",
		start: ta,
		end: ta,
		name: ea,
		data: {
			previous: Yi
		}
	}
}

function handleHistorySpanListener(ue) {
	return Yi => {
		if (!ue.isEnabled()) return;
		const ea = handleHistory(Yi);
		ea !== null && (ue.getContext().urls.push(ea.name), ue.triggerUserActivity(), ue.addUpdate(() => (createPerformanceSpans(ue, [ea]), !1)))
	}
}

function shouldFilterRequest(ue, Yi) {
	return DEBUG_BUILD$2 && ue.getOptions()._experiments.traceInternals ? !1 : isSentryRequestUrl(Yi, getClient())
}

function addNetworkBreadcrumb(ue, Yi) {
	ue.isEnabled() && Yi !== null && (shouldFilterRequest(ue, Yi.name) || ue.addUpdate(() => (createPerformanceSpans(ue, [Yi]), !0)))
}

function handleFetch(ue) {
	const {
		startTimestamp: Yi,
		endTimestamp: ea,
		fetchData: ta,
		response: na
	} = ue;
	if (!ea) return null;
	const {
		method: ra,
		url: ia
	} = ta;
	return {
		type: "resource.fetch",
		start: Yi / 1e3,
		end: ea / 1e3,
		name: ia,
		data: {
			method: ra,
			statusCode: na ? na.status : void 0
		}
	}
}

function handleFetchSpanListener(ue) {
	return Yi => {
		if (!ue.isEnabled()) return;
		const ea = handleFetch(Yi);
		addNetworkBreadcrumb(ue, ea)
	}
}

function handleXhr(ue) {
	const {
		startTimestamp: Yi,
		endTimestamp: ea,
		xhr: ta
	} = ue, na = ta[SENTRY_XHR_DATA_KEY];
	if (!Yi || !ea || !na) return null;
	const {
		method: ra,
		url: ia,
		status_code: aa
	} = na;
	return ia === void 0 ? null : {
		type: "resource.xhr",
		name: ia,
		start: Yi / 1e3,
		end: ea / 1e3,
		data: {
			method: ra,
			statusCode: aa
		}
	}
}

function handleXhrSpanListener(ue) {
	return Yi => {
		if (!ue.isEnabled()) return;
		const ea = handleXhr(Yi);
		addNetworkBreadcrumb(ue, ea)
	}
}

function getBodySize(ue, Yi) {
	if (ue) try {
		if (typeof ue == "string") return Yi.encode(ue).length;
		if (ue instanceof URLSearchParams) return Yi.encode(ue.toString()).length;
		if (ue instanceof FormData) {
			const ea = _serializeFormData(ue);
			return Yi.encode(ea).length
		}
		if (ue instanceof Blob) return ue.size;
		if (ue instanceof ArrayBuffer) return ue.byteLength
	} catch {}
}

function parseContentLengthHeader(ue) {
	if (!ue) return;
	const Yi = parseInt(ue, 10);
	return isNaN(Yi) ? void 0 : Yi
}

function getBodyString(ue) {
	try {
		if (typeof ue == "string") return [ue];
		if (ue instanceof URLSearchParams) return [ue.toString()];
		if (ue instanceof FormData) return [_serializeFormData(ue)];
		if (!ue) return [void 0]
	} catch {
		return DEBUG_BUILD$2 && logger.warn("[Replay] Failed to serialize body", ue), [void 0, "BODY_PARSE_ERROR"]
	}
	return DEBUG_BUILD$2 && logger.info("[Replay] Skipping network body because of body type", ue), [void 0, "UNPARSEABLE_BODY_TYPE"]
}

function mergeWarning(ue, Yi) {
	if (!ue) return {
		headers: {},
		size: void 0,
		_meta: {
			warnings: [Yi]
		}
	};
	const ea = {
			...ue._meta
		},
		ta = ea.warnings || [];
	return ea.warnings = [...ta, Yi], ue._meta = ea, ue
}

function makeNetworkReplayBreadcrumb(ue, Yi) {
	if (!Yi) return null;
	const {
		startTimestamp: ea,
		endTimestamp: ta,
		url: na,
		method: ra,
		statusCode: ia,
		request: aa,
		response: oa
	} = Yi;
	return {
		type: ue,
		start: ea / 1e3,
		end: ta / 1e3,
		name: na,
		data: dropUndefinedKeys({
			method: ra,
			statusCode: ia,
			request: aa,
			response: oa
		})
	}
}

function buildSkippedNetworkRequestOrResponse(ue) {
	return {
		headers: {},
		size: ue,
		_meta: {
			warnings: ["URL_SKIPPED"]
		}
	}
}

function buildNetworkRequestOrResponse(ue, Yi, ea) {
	if (!Yi && Object.keys(ue).length === 0) return;
	if (!Yi) return {
		headers: ue
	};
	if (!ea) return {
		headers: ue,
		size: Yi
	};
	const ta = {
			headers: ue,
			size: Yi
		},
		{
			body: na,
			warnings: ra
		} = normalizeNetworkBody(ea);
	return ta.body = na, ra && ra.length > 0 && (ta._meta = {
		warnings: ra
	}), ta
}

function getAllowedHeaders(ue, Yi) {
	return Object.keys(ue).reduce((ea, ta) => {
		const na = ta.toLowerCase();
		return Yi.includes(na) && ue[ta] && (ea[na] = ue[ta]), ea
	}, {})
}

function _serializeFormData(ue) {
	return new URLSearchParams(ue).toString()
}

function normalizeNetworkBody(ue) {
	if (!ue || typeof ue != "string") return {
		body: ue
	};
	const Yi = ue.length > NETWORK_BODY_MAX_SIZE,
		ea = _strIsProbablyJson(ue);
	if (Yi) {
		const ta = ue.slice(0, NETWORK_BODY_MAX_SIZE);
		return ea ? {
			body: ta,
			warnings: ["MAYBE_JSON_TRUNCATED"]
		} : {
			body: `${ta}…`,
			warnings: ["TEXT_TRUNCATED"]
		}
	}
	if (ea) try {
		return {
			body: JSON.parse(ue)
		}
	} catch {}
	return {
		body: ue
	}
}

function _strIsProbablyJson(ue) {
	const Yi = ue[0],
		ea = ue[ue.length - 1];
	return Yi === "[" && ea === "]" || Yi === "{" && ea === "}"
}

function urlMatches(ue, Yi) {
	const ea = getFullUrl(ue);
	return stringMatchesSomePattern(ea, Yi)
}

function getFullUrl(ue, Yi = WINDOW$1.document.baseURI) {
	if (ue.startsWith("http://") || ue.startsWith("https://") || ue.startsWith(WINDOW$1.location.origin)) return ue;
	const ea = new URL(ue, Yi);
	if (ea.origin !== new URL(Yi).origin) return ue;
	const ta = ea.href;
	return !ue.endsWith("/") && ta.endsWith("/") ? ta.slice(0, -1) : ta
}
async function captureFetchBreadcrumbToReplay(ue, Yi, ea) {
	try {
		const ta = await _prepareFetchData(ue, Yi, ea),
			na = makeNetworkReplayBreadcrumb("resource.fetch", ta);
		addNetworkBreadcrumb(ea.replay, na)
	} catch (ta) {
		DEBUG_BUILD$2 && logger.error("[Replay] Failed to capture fetch breadcrumb", ta)
	}
}

function enrichFetchBreadcrumb(ue, Yi, ea) {
	const {
		input: ta,
		response: na
	} = Yi, ra = ta ? _getFetchRequestArgBody(ta) : void 0, ia = getBodySize(ra, ea.textEncoder), aa = na ? parseContentLengthHeader(na.headers.get("content-length")) : void 0;
	ia !== void 0 && (ue.data.request_body_size = ia), aa !== void 0 && (ue.data.response_body_size = aa)
}
async function _prepareFetchData(ue, Yi, ea) {
	const ta = Date.now(),
		{
			startTimestamp: na = ta,
			endTimestamp: ra = ta
		} = Yi,
		{
			url: ia,
			method: aa,
			status_code: oa = 0,
			request_body_size: la,
			response_body_size: sa
		} = ue.data,
		ca = urlMatches(ia, ea.networkDetailAllowUrls) && !urlMatches(ia, ea.networkDetailDenyUrls),
		ua = ca ? _getRequestInfo(ea, Yi.input, la) : buildSkippedNetworkRequestOrResponse(la),
		da = await _getResponseInfo(ca, ea, Yi.response, sa);
	return {
		startTimestamp: na,
		endTimestamp: ra,
		url: ia,
		method: aa,
		statusCode: oa,
		request: ua,
		response: da
	}
}

function _getRequestInfo({
	networkCaptureBodies: ue,
	networkRequestHeaders: Yi
}, ea, ta) {
	const na = ea ? getRequestHeaders(ea, Yi) : {};
	if (!ue) return buildNetworkRequestOrResponse(na, ta, void 0);
	const ra = _getFetchRequestArgBody(ea),
		[ia, aa] = getBodyString(ra),
		oa = buildNetworkRequestOrResponse(na, ta, ia);
	return aa ? mergeWarning(oa, aa) : oa
}
async function _getResponseInfo(ue, {
	networkCaptureBodies: Yi,
	textEncoder: ea,
	networkResponseHeaders: ta
}, na, ra) {
	if (!ue && ra !== void 0) return buildSkippedNetworkRequestOrResponse(ra);
	const ia = na ? getAllHeaders(na.headers, ta) : {};
	if (!na || !Yi && ra !== void 0) return buildNetworkRequestOrResponse(ia, ra, void 0);
	const [aa, oa] = await _parseFetchResponseBody(na), la = getResponseData(aa, {
		networkCaptureBodies: Yi,
		textEncoder: ea,
		responseBodySize: ra,
		captureDetails: ue,
		headers: ia
	});
	return oa ? mergeWarning(la, oa) : la
}

function getResponseData(ue, {
	networkCaptureBodies: Yi,
	textEncoder: ea,
	responseBodySize: ta,
	captureDetails: na,
	headers: ra
}) {
	try {
		const ia = ue && ue.length && ta === void 0 ? getBodySize(ue, ea) : ta;
		return na ? Yi ? buildNetworkRequestOrResponse(ra, ia, ue) : buildNetworkRequestOrResponse(ra, ia, void 0) : buildSkippedNetworkRequestOrResponse(ia)
	} catch (ia) {
		return DEBUG_BUILD$2 && logger.warn("[Replay] Failed to serialize response body", ia), buildNetworkRequestOrResponse(ra, ta, void 0)
	}
}
async function _parseFetchResponseBody(ue) {
	const Yi = _tryCloneResponse(ue);
	if (!Yi) return [void 0, "BODY_PARSE_ERROR"];
	try {
		return [await _tryGetResponseText(Yi)]
	} catch (ea) {
		return DEBUG_BUILD$2 && logger.warn("[Replay] Failed to get text body from response", ea), [void 0, "BODY_PARSE_ERROR"]
	}
}

function _getFetchRequestArgBody(ue = []) {
	if (!(ue.length !== 2 || typeof ue[1] != "object")) return ue[1].body
}

function getAllHeaders(ue, Yi) {
	const ea = {};
	return Yi.forEach(ta => {
		ue.get(ta) && (ea[ta] = ue.get(ta))
	}), ea
}

function getRequestHeaders(ue, Yi) {
	return ue.length === 1 && typeof ue[0] != "string" ? getHeadersFromOptions(ue[0], Yi) : ue.length === 2 ? getHeadersFromOptions(ue[1], Yi) : {}
}

function getHeadersFromOptions(ue, Yi) {
	if (!ue) return {};
	const ea = ue.headers;
	return ea ? ea instanceof Headers ? getAllHeaders(ea, Yi) : Array.isArray(ea) ? {} : getAllowedHeaders(ea, Yi) : {}
}

function _tryCloneResponse(ue) {
	try {
		return ue.clone()
	} catch (Yi) {
		DEBUG_BUILD$2 && logger.warn("[Replay] Failed to clone response body", Yi)
	}
}

function _tryGetResponseText(ue) {
	return new Promise((Yi, ea) => {
		const ta = setTimeout(() => ea(new Error("Timeout while trying to read response body")), 500);
		_getResponseText(ue).then(na => Yi(na), na => ea(na)).finally(() => clearTimeout(ta))
	})
}
async function _getResponseText(ue) {
	return await ue.text()
}
async function captureXhrBreadcrumbToReplay(ue, Yi, ea) {
	try {
		const ta = _prepareXhrData(ue, Yi, ea),
			na = makeNetworkReplayBreadcrumb("resource.xhr", ta);
		addNetworkBreadcrumb(ea.replay, na)
	} catch (ta) {
		DEBUG_BUILD$2 && logger.error("[Replay] Failed to capture xhr breadcrumb", ta)
	}
}

function enrichXhrBreadcrumb(ue, Yi, ea) {
	const {
		xhr: ta,
		input: na
	} = Yi;
	if (!ta) return;
	const ra = getBodySize(na, ea.textEncoder),
		ia = ta.getResponseHeader("content-length") ? parseContentLengthHeader(ta.getResponseHeader("content-length")) : _getBodySize(ta.response, ta.responseType, ea.textEncoder);
	ra !== void 0 && (ue.data.request_body_size = ra), ia !== void 0 && (ue.data.response_body_size = ia)
}

function _prepareXhrData(ue, Yi, ea) {
	const ta = Date.now(),
		{
			startTimestamp: na = ta,
			endTimestamp: ra = ta,
			input: ia,
			xhr: aa
		} = Yi,
		{
			url: oa,
			method: la,
			status_code: sa = 0,
			request_body_size: ca,
			response_body_size: ua
		} = ue.data;
	if (!oa) return null;
	if (!aa || !urlMatches(oa, ea.networkDetailAllowUrls) || urlMatches(oa, ea.networkDetailDenyUrls)) {
		const Pa = buildSkippedNetworkRequestOrResponse(ca),
			ja = buildSkippedNetworkRequestOrResponse(ua);
		return {
			startTimestamp: na,
			endTimestamp: ra,
			url: oa,
			method: la,
			statusCode: sa,
			request: Pa,
			response: ja
		}
	}
	const da = aa[SENTRY_XHR_DATA_KEY],
		ha = da ? getAllowedHeaders(da.request_headers, ea.networkRequestHeaders) : {},
		pa = getAllowedHeaders(getResponseHeaders(aa), ea.networkResponseHeaders),
		[va, ba] = ea.networkCaptureBodies ? getBodyString(ia) : [void 0],
		[Ea, Sa] = ea.networkCaptureBodies ? _getXhrResponseBody(aa) : [void 0],
		Ca = buildNetworkRequestOrResponse(ha, ca, va),
		ka = buildNetworkRequestOrResponse(pa, ua, Ea);
	return {
		startTimestamp: na,
		endTimestamp: ra,
		url: oa,
		method: la,
		statusCode: sa,
		request: ba ? mergeWarning(Ca, ba) : Ca,
		response: Sa ? mergeWarning(ka, Sa) : ka
	}
}

function getResponseHeaders(ue) {
	const Yi = ue.getAllResponseHeaders();
	return Yi ? Yi.split(`\r
`).reduce((ea, ta) => {
		const [na, ra] = ta.split(": ");
		return ea[na.toLowerCase()] = ra, ea
	}, {}) : {}
}

function _getXhrResponseBody(ue) {
	const Yi = [];
	try {
		return [ue.responseText]
	} catch (ea) {
		Yi.push(ea)
	}
	try {
		return _parseXhrResponse(ue.response, ue.responseType)
	} catch (ea) {
		Yi.push(ea)
	}
	return DEBUG_BUILD$2 && logger.warn("[Replay] Failed to get xhr response body", ...Yi), [void 0]
}

function _parseXhrResponse(ue, Yi) {
	try {
		if (typeof ue == "string") return [ue];
		if (ue instanceof Document) return [ue.body.outerHTML];
		if (Yi === "json" && ue && typeof ue == "object") return [JSON.stringify(ue)];
		if (!ue) return [void 0]
	} catch {
		return DEBUG_BUILD$2 && logger.warn("[Replay] Failed to serialize body", ue), [void 0, "BODY_PARSE_ERROR"]
	}
	return DEBUG_BUILD$2 && logger.info("[Replay] Skipping network body because of body type", ue), [void 0, "UNPARSEABLE_BODY_TYPE"]
}

function _getBodySize(ue, Yi, ea) {
	try {
		const ta = Yi === "json" && ue && typeof ue == "object" ? JSON.stringify(ue) : ue;
		return getBodySize(ta, ea)
	} catch {
		return
	}
}

function handleNetworkBreadcrumbs(ue) {
	const Yi = getClient();
	try {
		const ea = new TextEncoder,
			{
				networkDetailAllowUrls: ta,
				networkDetailDenyUrls: na,
				networkCaptureBodies: ra,
				networkRequestHeaders: ia,
				networkResponseHeaders: aa
			} = ue.getOptions(),
			oa = {
				replay: ue,
				textEncoder: ea,
				networkDetailAllowUrls: ta,
				networkDetailDenyUrls: na,
				networkCaptureBodies: ra,
				networkRequestHeaders: ia,
				networkResponseHeaders: aa
			};
		Yi && Yi.on ? Yi.on("beforeAddBreadcrumb", (la, sa) => beforeAddNetworkBreadcrumb(oa, la, sa)) : (addFetchInstrumentationHandler(handleFetchSpanListener(ue)), addXhrInstrumentationHandler(handleXhrSpanListener(ue)))
	} catch {}
}

function beforeAddNetworkBreadcrumb(ue, Yi, ea) {
	if (Yi.data) try {
		_isXhrBreadcrumb(Yi) && _isXhrHint(ea) && (enrichXhrBreadcrumb(Yi, ea, ue), captureXhrBreadcrumbToReplay(Yi, ea, ue)), _isFetchBreadcrumb(Yi) && _isFetchHint(ea) && (enrichFetchBreadcrumb(Yi, ea, ue), captureFetchBreadcrumbToReplay(Yi, ea, ue))
	} catch {
		DEBUG_BUILD$2 && logger.warn("Error when enriching network breadcrumb")
	}
}

function _isXhrBreadcrumb(ue) {
	return ue.category === "xhr"
}

function _isFetchBreadcrumb(ue) {
	return ue.category === "fetch"
}

function _isXhrHint(ue) {
	return ue && ue.xhr
}

function _isFetchHint(ue) {
	return ue && ue.response
}
let _LAST_BREADCRUMB = null;

function isBreadcrumbWithCategory(ue) {
	return !!ue.category
}
const handleScopeListener = ue => Yi => {
	if (!ue.isEnabled()) return;
	const ea = handleScope(Yi);
	ea && addBreadcrumbEvent(ue, ea)
};

function handleScope(ue) {
	const Yi = ue.getLastBreadcrumb && ue.getLastBreadcrumb();
	return _LAST_BREADCRUMB === Yi || !Yi || (_LAST_BREADCRUMB = Yi, !isBreadcrumbWithCategory(Yi) || ["fetch", "xhr", "sentry.event", "sentry.transaction"].includes(Yi.category) || Yi.category.startsWith("ui.")) ? null : Yi.category === "console" ? normalizeConsoleBreadcrumb(Yi) : createBreadcrumb(Yi)
}

function normalizeConsoleBreadcrumb(ue) {
	const Yi = ue.data && ue.data.arguments;
	if (!Array.isArray(Yi) || Yi.length === 0) return createBreadcrumb(ue);
	let ea = !1;
	const ta = Yi.map(na => {
		if (!na) return na;
		if (typeof na == "string") return na.length > CONSOLE_ARG_MAX_SIZE ? (ea = !0, `${na.slice(0,CONSOLE_ARG_MAX_SIZE)}…`) : na;
		if (typeof na == "object") try {
			const ra = normalize(na, 7);
			return JSON.stringify(ra).length > CONSOLE_ARG_MAX_SIZE ? (ea = !0, `${JSON.stringify(ra,null,2).slice(0,CONSOLE_ARG_MAX_SIZE)}…`) : ra
		} catch {}
		return na
	});
	return createBreadcrumb({
		...ue,
		data: {
			...ue.data,
			arguments: ta,
			...ea ? {
				_meta: {
					warnings: ["CONSOLE_ARG_TRUNCATED"]
				}
			} : {}
		}
	})
}

function addGlobalListeners(ue) {
	const Yi = getCurrentScope(),
		ea = getClient();
	Yi.addScopeListener(handleScopeListener(ue)), addClickKeypressInstrumentationHandler(handleDomListener(ue)), addHistoryInstrumentationHandler(handleHistorySpanListener(ue)), handleNetworkBreadcrumbs(ue);
	const ta = handleGlobalEventListener(ue, !hasHooks(ea));
	ea && ea.addEventProcessor ? ea.addEventProcessor(ta) : addEventProcessor(ta), hasHooks(ea) && (ea.on("beforeSendEvent", handleBeforeSendEvent(ue)), ea.on("afterSendEvent", handleAfterSendEvent(ue)), ea.on("createDsc", na => {
		const ra = ue.getSessionId();
		ra && ue.isEnabled() && ue.recordingMode === "session" && ue.checkAndHandleExpiredSession() && (na.replay_id = ra)
	}), ea.on("startTransaction", na => {
		ue.lastTransaction = na
	}), ea.on("finishTransaction", na => {
		ue.lastTransaction = na
	}), ea.on("beforeSendFeedback", (na, ra) => {
		const ia = ue.getSessionId();
		ra && ra.includeReplay && ue.isEnabled() && ia && na.contexts && na.contexts.feedback && (na.contexts.feedback.replay_id = ia)
	}))
}

function hasHooks(ue) {
	return !!(ue && ue.on)
}
async function addMemoryEntry(ue) {
	try {
		return Promise.all(createPerformanceSpans(ue, [createMemoryEntry(WINDOW$1.performance.memory)]))
	} catch {
		return []
	}
}

function createMemoryEntry(ue) {
	const {
		jsHeapSizeLimit: Yi,
		totalJSHeapSize: ea,
		usedJSHeapSize: ta
	} = ue, na = Date.now() / 1e3;
	return {
		type: "memory",
		name: "memory",
		start: na,
		end: na,
		data: {
			memory: {
				jsHeapSizeLimit: Yi,
				totalJSHeapSize: ea,
				usedJSHeapSize: ta
			}
		}
	}
}

function debounce(ue, Yi, ea) {
	let ta, na, ra;
	const ia = ea && ea.maxWait ? Math.max(ea.maxWait, Yi) : 0;

	function aa() {
		return oa(), ta = ue(), ta
	}

	function oa() {
		na !== void 0 && clearTimeout(na), ra !== void 0 && clearTimeout(ra), na = ra = void 0
	}

	function la() {
		return na !== void 0 || ra !== void 0 ? aa() : ta
	}

	function sa() {
		return na && clearTimeout(na), na = setTimeout(aa, Yi), ia && ra === void 0 && (ra = setTimeout(aa, ia)), ta
	}
	return sa.cancel = oa, sa.flush = la, sa
}

function getHandleRecordingEmit(ue) {
	let Yi = !1;
	return (ea, ta) => {
		if (!ue.checkAndHandleExpiredSession()) {
			DEBUG_BUILD$2 && logger.warn("[Replay] Received replay event after session expired.");
			return
		}
		const na = ta || !Yi;
		Yi = !0, ue.clickDetector && updateClickDetectorForRecordingEvent(ue.clickDetector, ea), ue.addUpdate(() => {
			if (ue.recordingMode === "buffer" && na && ue.setInitialState(), !addEventSync(ue, ea, na)) return !0;
			if (!na) return !1;
			if (addSettingsEvent(ue, na), ue.session && ue.session.previousSessionId) return !0;
			if (ue.recordingMode === "buffer" && ue.session && ue.eventBuffer) {
				const ra = ue.eventBuffer.getEarliestTimestamp();
				ra && (logInfo(`[Replay] Updating session start time to earliest event in buffer to ${new Date(ra)}`, ue.getOptions()._experiments.traceInternals), ue.session.started = ra, ue.getOptions().stickySession && saveSession(ue.session))
			}
			return ue.recordingMode === "session" && ue.flush(), !0
		})
	}
}

function createOptionsEvent(ue) {
	const Yi = ue.getOptions();
	return {
		type: EventType.Custom,
		timestamp: Date.now(),
		data: {
			tag: "options",
			payload: {
				shouldRecordCanvas: ue.isRecordingCanvas(),
				sessionSampleRate: Yi.sessionSampleRate,
				errorSampleRate: Yi.errorSampleRate,
				useCompressionOption: Yi.useCompression,
				blockAllMedia: Yi.blockAllMedia,
				maskAllText: Yi.maskAllText,
				maskAllInputs: Yi.maskAllInputs,
				useCompression: ue.eventBuffer ? ue.eventBuffer.type === "worker" : !1,
				networkDetailHasUrls: Yi.networkDetailAllowUrls.length > 0,
				networkCaptureBodies: Yi.networkCaptureBodies,
				networkRequestHasHeaders: Yi.networkRequestHeaders.length > 0,
				networkResponseHasHeaders: Yi.networkResponseHeaders.length > 0
			}
		}
	}
}

function addSettingsEvent(ue, Yi) {
	!Yi || !ue.session || ue.session.segmentId !== 0 || addEventSync(ue, createOptionsEvent(ue), !1)
}

function createReplayEnvelope(ue, Yi, ea, ta) {
	return createEnvelope(createEventEnvelopeHeaders(ue, getSdkMetadataForEnvelopeHeader(ue), ta, ea), [
		[{
			type: "replay_event"
		}, ue],
		[{
			type: "replay_recording",
			length: typeof Yi == "string" ? new TextEncoder().encode(Yi).length : Yi.length
		}, Yi]
	])
}

function prepareRecordingData({
	recordingData: ue,
	headers: Yi
}) {
	let ea;
	const ta = `${JSON.stringify(Yi)}
`;
	if (typeof ue == "string") ea = `${ta}${ue}`;
	else {
		const ra = new TextEncoder().encode(ta);
		ea = new Uint8Array(ra.length + ue.length), ea.set(ra), ea.set(ue, ra.length)
	}
	return ea
}
async function prepareReplayEvent({
	client: ue,
	scope: Yi,
	replayId: ea,
	event: ta
}) {
	const na = typeof ue._integrations == "object" && ue._integrations !== null && !Array.isArray(ue._integrations) ? Object.keys(ue._integrations) : void 0,
		ra = {
			event_id: ea,
			integrations: na
		};
	ue.emit && ue.emit("preprocessEvent", ta, ra);
	const ia = await prepareEvent(ue.getOptions(), ta, ra, Yi, ue, getIsolationScope());
	if (!ia) return null;
	ia.platform = ia.platform || "javascript";
	const aa = ue.getSdkMetadata && ue.getSdkMetadata(),
		{
			name: oa,
			version: la
		} = aa && aa.sdk || {};
	return ia.sdk = {
		...ia.sdk,
		name: oa || "sentry.javascript.unknown",
		version: la || "0.0.0"
	}, ia
}
async function sendReplayRequest({
	recordingData: ue,
	replayId: Yi,
	segmentId: ea,
	eventContext: ta,
	timestamp: na,
	session: ra
}) {
	const ia = prepareRecordingData({
			recordingData: ue,
			headers: {
				segment_id: ea
			}
		}),
		{
			urls: aa,
			errorIds: oa,
			traceIds: la,
			initialTimestamp: sa
		} = ta,
		ca = getClient(),
		ua = getCurrentScope(),
		da = ca && ca.getTransport(),
		ha = ca && ca.getDsn();
	if (!ca || !da || !ha || !ra.sampled) return;
	const pa = {
			type: REPLAY_EVENT_NAME,
			replay_start_timestamp: sa / 1e3,
			timestamp: na / 1e3,
			error_ids: oa,
			trace_ids: la,
			urls: aa,
			replay_id: Yi,
			segment_id: ea,
			replay_type: ra.sampled
		},
		va = await prepareReplayEvent({
			scope: ua,
			client: ca,
			replayId: Yi,
			event: pa
		});
	if (!va) {
		ca.recordDroppedEvent("event_processor", "replay", pa), logInfo("An event processor returned `null`, will not send event.");
		return
	}
	delete va.sdkProcessingMetadata;
	const ba = createReplayEnvelope(va, ia, ha, ca.getOptions().tunnel);
	let Ea;
	try {
		Ea = await da.send(ba)
	} catch (Ca) {
		const ka = new Error(UNABLE_TO_SEND_REPLAY);
		try {
			ka.cause = Ca
		} catch {}
		throw ka
	}
	if (!Ea) return Ea;
	if (typeof Ea.statusCode == "number" && (Ea.statusCode < 200 || Ea.statusCode >= 300)) throw new TransportStatusCodeError(Ea.statusCode);
	const Sa = updateRateLimits({}, Ea);
	if (isRateLimited(Sa, "replay")) throw new RateLimitError(Sa);
	return Ea
}
class TransportStatusCodeError extends Error {
	constructor(Yi) {
		super(`Transport returned status code ${Yi}`)
	}
}
class RateLimitError extends Error {
	constructor(Yi) {
		super("Rate limit hit"), this.rateLimits = Yi
	}
}
async function sendReplay(ue, Yi = {
	count: 0,
	interval: RETRY_BASE_INTERVAL
}) {
	const {
		recordingData: ea,
		options: ta
	} = ue;
	if (ea.length) try {
		return await sendReplayRequest(ue), !0
	} catch (na) {
		if (na instanceof TransportStatusCodeError || na instanceof RateLimitError) throw na;
		if (setContext("Replays", {
				_retryCount: Yi.count
			}), DEBUG_BUILD$2 && ta._experiments && ta._experiments.captureExceptions && captureException(na), Yi.count >= RETRY_MAX_COUNT) {
			const ra = new Error(`${UNABLE_TO_SEND_REPLAY} - max retries exceeded`);
			try {
				ra.cause = na
			} catch {}
			throw ra
		}
		return Yi.interval *= ++Yi.count, new Promise((ra, ia) => {
			setTimeout(async () => {
				try {
					await sendReplay(ue, Yi), ra(!0)
				} catch (aa) {
					ia(aa)
				}
			}, Yi.interval)
		})
	}
}
const THROTTLED = "__THROTTLED",
	SKIPPED = "__SKIPPED";

function throttle(ue, Yi, ea) {
	const ta = new Map,
		na = aa => {
			const oa = aa - ea;
			ta.forEach((la, sa) => {
				sa < oa && ta.delete(sa)
			})
		},
		ra = () => [...ta.values()].reduce((aa, oa) => aa + oa, 0);
	let ia = !1;
	return (...aa) => {
		const oa = Math.floor(Date.now() / 1e3);
		if (na(oa), ra() >= Yi) {
			const sa = ia;
			return ia = !0, sa ? SKIPPED : THROTTLED
		}
		ia = !1;
		const la = ta.get(oa) || 0;
		return ta.set(oa, la + 1), ue(...aa)
	}
}
class ReplayContainer {
	constructor({
		options: Yi,
		recordingOptions: ea
	}) {
		ReplayContainer.prototype.__init.call(this), ReplayContainer.prototype.__init2.call(this), ReplayContainer.prototype.__init3.call(this), ReplayContainer.prototype.__init4.call(this), ReplayContainer.prototype.__init5.call(this), ReplayContainer.prototype.__init6.call(this), this.eventBuffer = null, this.performanceEntries = [], this.replayPerformanceEntries = [], this.recordingMode = "session", this.timeouts = {
			sessionIdlePause: SESSION_IDLE_PAUSE_DURATION,
			sessionIdleExpire: SESSION_IDLE_EXPIRE_DURATION
		}, this._lastActivity = Date.now(), this._isEnabled = !1, this._isPaused = !1, this._hasInitializedCoreListeners = !1, this._context = {
			errorIds: new Set,
			traceIds: new Set,
			urls: [],
			initialTimestamp: Date.now(),
			initialUrl: ""
		}, this._recordingOptions = ea, this._options = Yi, this._debouncedFlush = debounce(() => this._flush(), this._options.flushMinDelay, {
			maxWait: this._options.flushMaxDelay
		}), this._throttledAddEvent = throttle((ia, aa) => addEvent(this, ia, aa), 300, 5);
		const {
			slowClickTimeout: ta,
			slowClickIgnoreSelectors: na
		} = this.getOptions(), ra = ta ? {
			threshold: Math.min(SLOW_CLICK_THRESHOLD, ta),
			timeout: ta,
			scrollTimeout: SLOW_CLICK_SCROLL_TIMEOUT,
			ignoreSelector: na ? na.join(",") : ""
		} : void 0;
		ra && (this.clickDetector = new ClickDetector(this, ra))
	}
	getContext() {
		return this._context
	}
	isEnabled() {
		return this._isEnabled
	}
	isPaused() {
		return this._isPaused
	}
	isRecordingCanvas() {
		return !!this._canvas
	}
	getOptions() {
		return this._options
	}
	initializeSampling(Yi) {
		const {
			errorSampleRate: ea,
			sessionSampleRate: ta
		} = this._options;
		if (!(ea <= 0 && ta <= 0)) {
			if (this._initializeSessionForSampling(Yi), !this.session) {
				this._handleException(new Error("Unable to initialize and create session"));
				return
			}
			this.session.sampled !== !1 && (this.recordingMode = this.session.sampled === "buffer" && this.session.segmentId === 0 ? "buffer" : "session", logInfoNextTick(`[Replay] Starting replay in ${this.recordingMode} mode`, this._options._experiments.traceInternals), this._initializeRecording())
		}
	}
	start() {
		if (this._isEnabled && this.recordingMode === "session") throw new Error("Replay recording is already in progress");
		if (this._isEnabled && this.recordingMode === "buffer") throw new Error("Replay buffering is in progress, call `flush()` to save the replay");
		logInfoNextTick("[Replay] Starting replay in session mode", this._options._experiments.traceInternals);
		const Yi = loadOrCreateSession({
			maxReplayDuration: this._options.maxReplayDuration,
			sessionIdleExpire: this.timeouts.sessionIdleExpire,
			traceInternals: this._options._experiments.traceInternals
		}, {
			stickySession: this._options.stickySession,
			sessionSampleRate: 1,
			allowBuffering: !1
		});
		this.session = Yi, this._initializeRecording()
	}
	startBuffering() {
		if (this._isEnabled) throw new Error("Replay recording is already in progress");
		logInfoNextTick("[Replay] Starting replay in buffer mode", this._options._experiments.traceInternals);
		const Yi = loadOrCreateSession({
			sessionIdleExpire: this.timeouts.sessionIdleExpire,
			maxReplayDuration: this._options.maxReplayDuration,
			traceInternals: this._options._experiments.traceInternals
		}, {
			stickySession: this._options.stickySession,
			sessionSampleRate: 0,
			allowBuffering: !0
		});
		this.session = Yi, this.recordingMode = "buffer", this._initializeRecording()
	}
	startRecording() {
		try {
			const Yi = this._canvas;
			this._stopRecording = record({
				...this._recordingOptions,
				...this.recordingMode === "buffer" && {
					checkoutEveryNms: BUFFER_CHECKOUT_TIME
				},
				emit: getHandleRecordingEmit(this),
				onMutation: this._onMutationHandler,
				...Yi ? {
					recordCanvas: Yi.recordCanvas,
					getCanvasManager: Yi.getCanvasManager,
					sampling: Yi.sampling,
					dataURLOptions: Yi.dataURLOptions
				} : {}
			})
		} catch (Yi) {
			this._handleException(Yi)
		}
	}
	stopRecording() {
		try {
			return this._stopRecording && (this._stopRecording(), this._stopRecording = void 0), !0
		} catch (Yi) {
			return this._handleException(Yi), !1
		}
	}
	async stop({
		forceFlush: Yi = !1,
		reason: ea
	} = {}) {
		if (this._isEnabled) {
			this._isEnabled = !1;
			try {
				logInfo(`[Replay] Stopping Replay${ea?` triggered by ${ea}`:""}`, this._options._experiments.traceInternals), this._removeListeners(), this.stopRecording(), this._debouncedFlush.cancel(), Yi && await this._flush({
					force: !0
				}), this.eventBuffer && this.eventBuffer.destroy(), this.eventBuffer = null, clearSession(this)
			} catch (ta) {
				this._handleException(ta)
			}
		}
	}
	pause() {
		this._isPaused || (this._isPaused = !0, this.stopRecording(), logInfo("[Replay] Pausing replay", this._options._experiments.traceInternals))
	}
	resume() {
		!this._isPaused || !this._checkSession() || (this._isPaused = !1, this.startRecording(), logInfo("[Replay] Resuming replay", this._options._experiments.traceInternals))
	}
	async sendBufferedReplayOrFlush({
		continueRecording: Yi = !0
	} = {}) {
		if (this.recordingMode === "session") return this.flushImmediate();
		const ea = Date.now();
		logInfo("[Replay] Converting buffer to session", this._options._experiments.traceInternals), await this.flushImmediate();
		const ta = this.stopRecording();
		!Yi || !ta || this.recordingMode !== "session" && (this.recordingMode = "session", this.session && (this._updateUserActivity(ea), this._updateSessionActivity(ea), this._maybeSaveSession()), this.startRecording())
	}
	addUpdate(Yi) {
		const ea = Yi();
		this.recordingMode !== "buffer" && ea !== !0 && this._debouncedFlush()
	}
	triggerUserActivity() {
		if (this._updateUserActivity(), !this._stopRecording) {
			if (!this._checkSession()) return;
			this.resume();
			return
		}
		this.checkAndHandleExpiredSession(), this._updateSessionActivity()
	}
	updateUserActivity() {
		this._updateUserActivity(), this._updateSessionActivity()
	}
	conditionalFlush() {
		return this.recordingMode === "buffer" ? Promise.resolve() : this.flushImmediate()
	}
	flush() {
		return this._debouncedFlush()
	}
	flushImmediate() {
		return this._debouncedFlush(), this._debouncedFlush.flush()
	}
	cancelFlush() {
		this._debouncedFlush.cancel()
	}
	getSessionId() {
		return this.session && this.session.id
	}
	checkAndHandleExpiredSession() {
		if (this._lastActivity && isExpired(this._lastActivity, this.timeouts.sessionIdlePause) && this.session && this.session.sampled === "session") {
			this.pause();
			return
		}
		return !!this._checkSession()
	}
	setInitialState() {
		const Yi = `${WINDOW$1.location.pathname}${WINDOW$1.location.hash}${WINDOW$1.location.search}`,
			ea = `${WINDOW$1.location.origin}${Yi}`;
		this.performanceEntries = [], this.replayPerformanceEntries = [], this._clearContext(), this._context.initialUrl = ea, this._context.initialTimestamp = Date.now(), this._context.urls.push(ea)
	}
	throttledAddEvent(Yi, ea) {
		const ta = this._throttledAddEvent(Yi, ea);
		if (ta === THROTTLED) {
			const na = createBreadcrumb({
				category: "replay.throttled"
			});
			this.addUpdate(() => !addEventSync(this, {
				type: ReplayEventTypeCustom,
				timestamp: na.timestamp || 0,
				data: {
					tag: "breadcrumb",
					payload: na,
					metric: !0
				}
			}))
		}
		return ta
	}
	getCurrentRoute() {
		const Yi = this.lastTransaction || getCurrentScope().getTransaction(),
			ta = (Yi && spanToJSON(Yi).data || {})[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
		if (!(!Yi || !ta || !["route", "custom"].includes(ta))) return spanToJSON(Yi).description
	}
	_initializeRecording() {
		this.setInitialState(), this._updateSessionActivity(), this.eventBuffer = createEventBuffer({
			useCompression: this._options.useCompression,
			workerUrl: this._options.workerUrl
		}), this._removeListeners(), this._addListeners(), this._isEnabled = !0, this._isPaused = !1, this.startRecording()
	}
	_handleException(Yi) {
		DEBUG_BUILD$2 && logger.error("[Replay]", Yi), DEBUG_BUILD$2 && this._options._experiments && this._options._experiments.captureExceptions && captureException(Yi)
	}
	_initializeSessionForSampling(Yi) {
		const ea = this._options.errorSampleRate > 0,
			ta = loadOrCreateSession({
				sessionIdleExpire: this.timeouts.sessionIdleExpire,
				maxReplayDuration: this._options.maxReplayDuration,
				traceInternals: this._options._experiments.traceInternals,
				previousSessionId: Yi
			}, {
				stickySession: this._options.stickySession,
				sessionSampleRate: this._options.sessionSampleRate,
				allowBuffering: ea
			});
		this.session = ta
	}
	_checkSession() {
		if (!this.session) return !1;
		const Yi = this.session;
		return shouldRefreshSession(Yi, {
			sessionIdleExpire: this.timeouts.sessionIdleExpire,
			maxReplayDuration: this._options.maxReplayDuration
		}) ? (this._refreshSession(Yi), !1) : !0
	}
	async _refreshSession(Yi) {
		this._isEnabled && (await this.stop({
			reason: "refresh session"
		}), this.initializeSampling(Yi.id))
	}
	_addListeners() {
		try {
			WINDOW$1.document.addEventListener("visibilitychange", this._handleVisibilityChange), WINDOW$1.addEventListener("blur", this._handleWindowBlur), WINDOW$1.addEventListener("focus", this._handleWindowFocus), WINDOW$1.addEventListener("keydown", this._handleKeyboardEvent), this.clickDetector && this.clickDetector.addListeners(), this._hasInitializedCoreListeners || (addGlobalListeners(this), this._hasInitializedCoreListeners = !0)
		} catch (Yi) {
			this._handleException(Yi)
		}
		this._performanceCleanupCallback = setupPerformanceObserver(this)
	}
	_removeListeners() {
		try {
			WINDOW$1.document.removeEventListener("visibilitychange", this._handleVisibilityChange), WINDOW$1.removeEventListener("blur", this._handleWindowBlur), WINDOW$1.removeEventListener("focus", this._handleWindowFocus), WINDOW$1.removeEventListener("keydown", this._handleKeyboardEvent), this.clickDetector && this.clickDetector.removeListeners(), this._performanceCleanupCallback && this._performanceCleanupCallback()
		} catch (Yi) {
			this._handleException(Yi)
		}
	}
	__init() {
		this._handleVisibilityChange = () => {
			WINDOW$1.document.visibilityState === "visible" ? this._doChangeToForegroundTasks() : this._doChangeToBackgroundTasks()
		}
	}
	__init2() {
		this._handleWindowBlur = () => {
			const Yi = createBreadcrumb({
				category: "ui.blur"
			});
			this._doChangeToBackgroundTasks(Yi)
		}
	}
	__init3() {
		this._handleWindowFocus = () => {
			const Yi = createBreadcrumb({
				category: "ui.focus"
			});
			this._doChangeToForegroundTasks(Yi)
		}
	}
	__init4() {
		this._handleKeyboardEvent = Yi => {
			handleKeyboardEvent(this, Yi)
		}
	}
	_doChangeToBackgroundTasks(Yi) {
		!this.session || isSessionExpired(this.session, {
			maxReplayDuration: this._options.maxReplayDuration,
			sessionIdleExpire: this.timeouts.sessionIdleExpire
		}) || (Yi && this._createCustomBreadcrumb(Yi), this.conditionalFlush())
	}
	_doChangeToForegroundTasks(Yi) {
		if (!this.session) return;
		if (!this.checkAndHandleExpiredSession()) {
			logInfo("[Replay] Document has become active, but session has expired");
			return
		}
		Yi && this._createCustomBreadcrumb(Yi)
	}
	_updateUserActivity(Yi = Date.now()) {
		this._lastActivity = Yi
	}
	_updateSessionActivity(Yi = Date.now()) {
		this.session && (this.session.lastActivity = Yi, this._maybeSaveSession())
	}
	_createCustomBreadcrumb(Yi) {
		this.addUpdate(() => {
			this.throttledAddEvent({
				type: EventType.Custom,
				timestamp: Yi.timestamp || 0,
				data: {
					tag: "breadcrumb",
					payload: Yi
				}
			})
		})
	}
	_addPerformanceEntries() {
		const Yi = createPerformanceEntries(this.performanceEntries).concat(this.replayPerformanceEntries);
		return this.performanceEntries = [], this.replayPerformanceEntries = [], Promise.all(createPerformanceSpans(this, Yi))
	}
	_clearContext() {
		this._context.errorIds.clear(), this._context.traceIds.clear(), this._context.urls = []
	}
	_updateInitialTimestampFromEventBuffer() {
		const {
			session: Yi,
			eventBuffer: ea
		} = this;
		if (!Yi || !ea || Yi.segmentId) return;
		const ta = ea.getEarliestTimestamp();
		ta && ta < this._context.initialTimestamp && (this._context.initialTimestamp = ta)
	}
	_popEventContext() {
		const Yi = {
			initialTimestamp: this._context.initialTimestamp,
			initialUrl: this._context.initialUrl,
			errorIds: Array.from(this._context.errorIds),
			traceIds: Array.from(this._context.traceIds),
			urls: this._context.urls
		};
		return this._clearContext(), Yi
	}
	async _runFlush() {
		const Yi = this.getSessionId();
		if (!this.session || !this.eventBuffer || !Yi) {
			DEBUG_BUILD$2 && logger.error("[Replay] No session or eventBuffer found to flush.");
			return
		}
		if (await this._addPerformanceEntries(), !(!this.eventBuffer || !this.eventBuffer.hasEvents) && (await addMemoryEntry(this), !!this.eventBuffer && Yi === this.getSessionId())) try {
			this._updateInitialTimestampFromEventBuffer();
			const ea = Date.now();
			if (ea - this._context.initialTimestamp > this._options.maxReplayDuration + 3e4) throw new Error("Session is too long, not sending replay");
			const ta = this._popEventContext(),
				na = this.session.segmentId++;
			this._maybeSaveSession();
			const ra = await this.eventBuffer.finish();
			await sendReplay({
				replayId: Yi,
				recordingData: ra,
				segmentId: na,
				eventContext: ta,
				session: this.session,
				options: this.getOptions(),
				timestamp: ea
			})
		} catch (ea) {
			this._handleException(ea), this.stop({
				reason: "sendReplay"
			});
			const ta = getClient();
			ta && ta.recordDroppedEvent("send_error", "replay")
		}
	}
	__init5() {
		this._flush = async ({
			force: Yi = !1
		} = {}) => {
			if (!this._isEnabled && !Yi) return;
			if (!this.checkAndHandleExpiredSession()) {
				DEBUG_BUILD$2 && logger.error("[Replay] Attempting to finish replay event after session expired.");
				return
			}
			if (!this.session) return;
			const ea = this.session.started,
				na = Date.now() - ea;
			this._debouncedFlush.cancel();
			const ra = na < this._options.minReplayDuration,
				ia = na > this._options.maxReplayDuration + 5e3;
			if (ra || ia) {
				logInfo(`[Replay] Session duration (${Math.floor(na/1e3)}s) is too ${ra?"short":"long"}, not sending replay.`, this._options._experiments.traceInternals), ra && this._debouncedFlush();
				return
			}
			const aa = this.eventBuffer;
			if (aa && this.session.segmentId === 0 && !aa.hasCheckout && logInfo("[Replay] Flushing initial segment without checkout.", this._options._experiments.traceInternals), !this._flushLock) {
				this._flushLock = this._runFlush(), await this._flushLock, this._flushLock = void 0;
				return
			}
			try {
				await this._flushLock
			} catch (oa) {
				DEBUG_BUILD$2 && logger.error(oa)
			} finally {
				this._debouncedFlush()
			}
		}
	}
	_maybeSaveSession() {
		this.session && this._options.stickySession && saveSession(this.session)
	}
	__init6() {
		this._onMutationHandler = Yi => {
			const ea = Yi.length,
				ta = this._options.mutationLimit,
				na = this._options.mutationBreadcrumbLimit,
				ra = ta && ea > ta;
			if (ea > na || ra) {
				const ia = createBreadcrumb({
					category: "replay.mutations",
					data: {
						count: ea,
						limit: ra
					}
				});
				this._createCustomBreadcrumb(ia)
			}
			return ra ? (this.stop({
				reason: "mutationLimit",
				forceFlush: this.recordingMode === "session"
			}), !1) : !0
		}
	}
}

function getOption(ue, Yi, ea, ta) {
	const na = typeof ta == "string" ? ta.split(",") : [],
		ra = [...ue, ...na, ...Yi];
	return typeof ea < "u" && (typeof ea == "string" && ra.push(`.${ea}`), consoleSandbox(() => {
		console.warn("[Replay] You are using a deprecated configuration item for privacy. Read the documentation on how to use the new privacy configuration.")
	})), ra.join(",")
}

function getPrivacyOptions({
	mask: ue,
	unmask: Yi,
	block: ea,
	unblock: ta,
	ignore: na,
	blockClass: ra,
	blockSelector: ia,
	maskTextClass: aa,
	maskTextSelector: oa,
	ignoreClass: la
}) {
	const sa = ['base[href="/"]'],
		ca = getOption(ue, [".sentry-mask", "[data-sentry-mask]"], aa, oa),
		ua = getOption(Yi, [".sentry-unmask", "[data-sentry-unmask]"]),
		da = {
			maskTextSelector: ca,
			unmaskTextSelector: ua,
			blockSelector: getOption(ea, [".sentry-block", "[data-sentry-block]", ...sa], ra, ia),
			unblockSelector: getOption(ta, [".sentry-unblock", "[data-sentry-unblock]"]),
			ignoreSelector: getOption(na, [".sentry-ignore", "[data-sentry-ignore]", 'input[type="file"]'], la)
		};
	return ra instanceof RegExp && (da.blockClass = ra), aa instanceof RegExp && (da.maskTextClass = aa), da
}

function maskAttribute({
	el: ue,
	key: Yi,
	maskAttributes: ea,
	maskAllText: ta,
	privacyOptions: na,
	value: ra
}) {
	return !ta || na.unmaskTextSelector && ue.matches(na.unmaskTextSelector) ? ra : ea.includes(Yi) || Yi === "value" && ue.tagName === "INPUT" && ["submit", "button"].includes(ue.getAttribute("type") || "") ? ra.replace(/[\S]/g, "*") : ra
}
const MEDIA_SELECTORS = 'img,image,svg,video,object,picture,embed,map,audio,link[rel="icon"],link[rel="apple-touch-icon"]',
	DEFAULT_NETWORK_HEADERS = ["content-length", "content-type", "accept"];
let _initialized = !1;
const replayIntegration$1 = ue => new Replay$1(ue);
class Replay$1 {
	static __initStatic() {
		this.id = "Replay"
	}
	constructor({
		flushMinDelay: Yi = DEFAULT_FLUSH_MIN_DELAY,
		flushMaxDelay: ea = DEFAULT_FLUSH_MAX_DELAY,
		minReplayDuration: ta = MIN_REPLAY_DURATION,
		maxReplayDuration: na = MAX_REPLAY_DURATION,
		stickySession: ra = !0,
		useCompression: ia = !0,
		workerUrl: aa,
		_experiments: oa = {},
		sessionSampleRate: la,
		errorSampleRate: sa,
		maskAllText: ca = !0,
		maskAllInputs: ua = !0,
		blockAllMedia: da = !0,
		mutationBreadcrumbLimit: ha = 750,
		mutationLimit: pa = 1e4,
		slowClickTimeout: va = 7e3,
		slowClickIgnoreSelectors: ba = [],
		networkDetailAllowUrls: Ea = [],
		networkDetailDenyUrls: Sa = [],
		networkCaptureBodies: Ca = !0,
		networkRequestHeaders: ka = [],
		networkResponseHeaders: Pa = [],
		mask: ja = [],
		maskAttributes: Za = ["title", "placeholder"],
		unmask: Ga = [],
		block: Ja = [],
		unblock: Ua = [],
		ignore: xa = [],
		maskFn: ma,
		beforeAddRecordingEvent: fa,
		beforeErrorSampling: ga,
		blockClass: wa,
		blockSelector: Ma,
		maskInputOptions: Aa,
		maskTextClass: Ra,
		maskTextSelector: Ta,
		ignoreClass: La
	} = {}) {
		this.name = Replay$1.id;
		const ya = getPrivacyOptions({
			mask: ja,
			unmask: Ga,
			block: Ja,
			unblock: Ua,
			ignore: xa,
			blockClass: wa,
			blockSelector: Ma,
			maskTextClass: Ra,
			maskTextSelector: Ta,
			ignoreClass: La
		});
		if (this._recordingOptions = {
				maskAllInputs: ua,
				maskAllText: ca,
				maskInputOptions: {
					...Aa || {},
					password: !0
				},
				maskTextFn: ma,
				maskInputFn: ma,
				maskAttributeFn: (Ba, io, oo) => maskAttribute({
					maskAttributes: Za,
					maskAllText: ca,
					privacyOptions: ya,
					key: Ba,
					value: io,
					el: oo
				}),
				...ya,
				slimDOMOptions: "all",
				inlineStylesheet: !0,
				inlineImages: !1,
				collectFonts: !0,
				errorHandler: Ba => {
					try {
						Ba.__rrweb__ = !0
					} catch {}
				}
			}, this._initialOptions = {
				flushMinDelay: Yi,
				flushMaxDelay: ea,
				minReplayDuration: Math.min(ta, MIN_REPLAY_DURATION_LIMIT),
				maxReplayDuration: Math.min(na, MAX_REPLAY_DURATION),
				stickySession: ra,
				sessionSampleRate: la,
				errorSampleRate: sa,
				useCompression: ia,
				workerUrl: aa,
				blockAllMedia: da,
				maskAllInputs: ua,
				maskAllText: ca,
				mutationBreadcrumbLimit: ha,
				mutationLimit: pa,
				slowClickTimeout: va,
				slowClickIgnoreSelectors: ba,
				networkDetailAllowUrls: Ea,
				networkDetailDenyUrls: Sa,
				networkCaptureBodies: Ca,
				networkRequestHeaders: _getMergedNetworkHeaders(ka),
				networkResponseHeaders: _getMergedNetworkHeaders(Pa),
				beforeAddRecordingEvent: fa,
				beforeErrorSampling: ga,
				_experiments: oa
			}, typeof la == "number" && (console.warn(`[Replay] You are passing \`sessionSampleRate\` to the Replay integration.
This option is deprecated and will be removed soon.
Instead, configure \`replaysSessionSampleRate\` directly in the SDK init options, e.g.:
Sentry.init({ replaysSessionSampleRate: ${la} })`), this._initialOptions.sessionSampleRate = la), typeof sa == "number" && (console.warn(`[Replay] You are passing \`errorSampleRate\` to the Replay integration.
This option is deprecated and will be removed soon.
Instead, configure \`replaysOnErrorSampleRate\` directly in the SDK init options, e.g.:
Sentry.init({ replaysOnErrorSampleRate: ${sa} })`), this._initialOptions.errorSampleRate = sa), this._initialOptions.blockAllMedia && (this._recordingOptions.blockSelector = this._recordingOptions.blockSelector ? `${this._recordingOptions.blockSelector},${MEDIA_SELECTORS}` : MEDIA_SELECTORS), this._isInitialized && isBrowser()) throw new Error("Multiple Sentry Session Replay instances are not supported");
		this._isInitialized = !0
	}
	get _isInitialized() {
		return _initialized
	}
	set _isInitialized(Yi) {
		_initialized = Yi
	}
	setupOnce() {
		isBrowser() && (this._setup(), setTimeout(() => this._initialize()))
	}
	start() {
		this._replay && this._replay.start()
	}
	startBuffering() {
		this._replay && this._replay.startBuffering()
	}
	stop() {
		return this._replay ? this._replay.stop({
			forceFlush: this._replay.recordingMode === "session"
		}) : Promise.resolve()
	}
	flush(Yi) {
		return !this._replay || !this._replay.isEnabled() ? Promise.resolve() : this._replay.sendBufferedReplayOrFlush(Yi)
	}
	getReplayId() {
		if (!(!this._replay || !this._replay.isEnabled())) return this._replay.getSessionId()
	}
	_initialize() {
		this._replay && (this._maybeLoadFromReplayCanvasIntegration(), this._replay.initializeSampling())
	}
	_setup() {
		const Yi = loadReplayOptionsFromClient(this._initialOptions);
		this._replay = new ReplayContainer({
			options: Yi,
			recordingOptions: this._recordingOptions
		})
	}
	_maybeLoadFromReplayCanvasIntegration() {
		try {
			const ea = getClient().getIntegrationByName("ReplayCanvas");
			if (!ea) return;
			this._replay._canvas = ea.getOptions()
		} catch {}
	}
}
Replay$1.__initStatic();

function loadReplayOptionsFromClient(ue) {
	const Yi = getClient(),
		ea = Yi && Yi.getOptions(),
		ta = {
			sessionSampleRate: 0,
			errorSampleRate: 0,
			...dropUndefinedKeys(ue)
		};
	return ea ? (ue.sessionSampleRate == null && ue.errorSampleRate == null && ea.replaysSessionSampleRate == null && ea.replaysOnErrorSampleRate == null && consoleSandbox(() => {
		console.warn("Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set.")
	}), typeof ea.replaysSessionSampleRate == "number" && (ta.sessionSampleRate = ea.replaysSessionSampleRate), typeof ea.replaysOnErrorSampleRate == "number" && (ta.errorSampleRate = ea.replaysOnErrorSampleRate), ta) : (consoleSandbox(() => {
		console.warn("SDK client is not available.")
	}), ta)
}

function _getMergedNetworkHeaders(ue) {
	return [...DEFAULT_NETWORK_HEADERS, ...ue.map(Yi => Yi.toLowerCase())]
}

function getReplay$1() {
	const ue = getClient();
	return ue && ue.getIntegrationByName && ue.getIntegrationByName("Replay")
}
var NodeType;
(function(ue) {
	ue[ue.Document = 0] = "Document", ue[ue.DocumentType = 1] = "DocumentType", ue[ue.Element = 2] = "Element", ue[ue.Text = 3] = "Text", ue[ue.CDATA = 4] = "CDATA", ue[ue.Comment = 5] = "Comment"
})(NodeType || (NodeType = {}));

function elementClassMatchesRegex(ue, Yi) {
	for (let ea = ue.classList.length; ea--;) {
		const ta = ue.classList[ea];
		if (Yi.test(ta)) return !0
	}
	return !1
}

function distanceToMatch(ue, Yi, ea = 1 / 0, ta = 0) {
	return !ue || ue.nodeType !== ue.ELEMENT_NODE || ta > ea ? -1 : Yi(ue) ? ta : distanceToMatch(ue.parentNode, Yi, ea, ta + 1)
}

function createMatchPredicate(ue, Yi) {
	return ea => {
		const ta = ea;
		if (ta === null) return !1;
		try {
			if (ue) {
				if (typeof ue == "string") {
					if (ta.matches(`.${ue}`)) return !0
				} else if (elementClassMatchesRegex(ta, ue)) return !0
			}
			return !!(Yi && ta.matches(Yi))
		} catch {
			return !1
		}
	}
}
const DEPARTED_MIRROR_ACCESS_WARNING = `Please stop import mirror directly. Instead of that,\r
now you can use replayer.getMirror() to access the mirror instance of a replayer,\r
or you can use record.mirror to access the mirror instance during recording.`;
let _mirror = {
	map: {},
	getId() {
		return console.error(DEPARTED_MIRROR_ACCESS_WARNING), -1
	},
	getNode() {
		return console.error(DEPARTED_MIRROR_ACCESS_WARNING), null
	},
	removeNodeFromMap() {
		console.error(DEPARTED_MIRROR_ACCESS_WARNING)
	},
	has() {
		return console.error(DEPARTED_MIRROR_ACCESS_WARNING), !1
	},
	reset() {
		console.error(DEPARTED_MIRROR_ACCESS_WARNING)
	}
};
typeof window < "u" && window.Proxy && window.Reflect && (_mirror = new Proxy(_mirror, {
	get(ue, Yi, ea) {
		return Yi === "map" && console.error(DEPARTED_MIRROR_ACCESS_WARNING), Reflect.get(ue, Yi, ea)
	}
}));

function hookSetter(ue, Yi, ea, ta, na = window) {
	const ra = na.Object.getOwnPropertyDescriptor(ue, Yi);
	return na.Object.defineProperty(ue, Yi, ta ? ea : {
		set(ia) {
			setTimeout(() => {
				ea.set.call(this, ia)
			}, 0), ra && ra.set && ra.set.call(this, ia)
		}
	}), () => hookSetter(ue, Yi, ra || {}, !0)
}

function patch(ue, Yi, ea) {
	try {
		if (!(Yi in ue)) return () => {};
		const ta = ue[Yi],
			na = ea(ta);
		return typeof na == "function" && (na.prototype = na.prototype || {}, Object.defineProperties(na, {
			__rrweb_original__: {
				enumerable: !1,
				value: ta
			}
		})), ue[Yi] = na, () => {
			ue[Yi] = ta
		}
	} catch {
		return () => {}
	}
}
/[1-9][0-9]{12}/.test(Date.now().toString());

function isBlocked(ue, Yi, ea, ta, na) {
	if (!ue) return !1;
	const ra = ue.nodeType === ue.ELEMENT_NODE ? ue : ue.parentElement;
	if (!ra) return !1;
	const ia = createMatchPredicate(Yi, ea),
		aa = distanceToMatch(ra, ia);
	let oa = -1;
	return aa < 0 ? !1 : (ta && (oa = distanceToMatch(ra, createMatchPredicate(null, ta))), aa > -1 && oa < 0 ? !0 : aa < oa)
}
let cachedRequestAnimationFrameImplementation;

function getRequestAnimationFrameImplementation() {
	if (cachedRequestAnimationFrameImplementation) return cachedRequestAnimationFrameImplementation;
	const ue = window.document;
	let Yi = window.requestAnimationFrame;
	if (ue && typeof ue.createElement == "function") try {
		const ea = ue.createElement("iframe");
		ea.hidden = !0, ue.head.appendChild(ea);
		const ta = ea.contentWindow;
		ta && ta.requestAnimationFrame && (Yi = ta.requestAnimationFrame), ue.head.removeChild(ea)
	} catch {}
	return cachedRequestAnimationFrameImplementation = Yi.bind(window)
}

function onRequestAnimationFrame(...ue) {
	return getRequestAnimationFrameImplementation()(...ue)
}
var CanvasContext = (ue => (ue[ue["2D"] = 0] = "2D", ue[ue.WebGL = 1] = "WebGL", ue[ue.WebGL2 = 2] = "WebGL2", ue))(CanvasContext || {});
let errorHandler;

function registerErrorHandler(ue) {
	errorHandler = ue
}
const callbackWrapper = ue => errorHandler ? (...ea) => {
	try {
		return ue(...ea)
	} catch (ta) {
		if (errorHandler && errorHandler(ta) === !0) return () => {};
		throw ta
	}
} : ue;
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
	lookup = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var i$1 = 0; i$1 < chars.length; i$1++) lookup[chars.charCodeAt(i$1)] = i$1;
var encode = function(ue) {
	var Yi = new Uint8Array(ue),
		ea, ta = Yi.length,
		na = "";
	for (ea = 0; ea < ta; ea += 3) na += chars[Yi[ea] >> 2], na += chars[(Yi[ea] & 3) << 4 | Yi[ea + 1] >> 4], na += chars[(Yi[ea + 1] & 15) << 2 | Yi[ea + 2] >> 6], na += chars[Yi[ea + 2] & 63];
	return ta % 3 === 2 ? na = na.substring(0, na.length - 1) + "=" : ta % 3 === 1 && (na = na.substring(0, na.length - 2) + "=="), na
};
const canvasVarMap = new Map;

function variableListFor(ue, Yi) {
	let ea = canvasVarMap.get(ue);
	return ea || (ea = new Map, canvasVarMap.set(ue, ea)), ea.has(Yi) || ea.set(Yi, []), ea.get(Yi)
}
const saveWebGLVar = (ue, Yi, ea) => {
	if (!ue || !(isInstanceOfWebGLObject(ue, Yi) || typeof ue == "object")) return;
	const ta = ue.constructor.name,
		na = variableListFor(ea, ta);
	let ra = na.indexOf(ue);
	return ra === -1 && (ra = na.length, na.push(ue)), ra
};

function serializeArg(ue, Yi, ea) {
	if (ue instanceof Array) return ue.map(ta => serializeArg(ta, Yi, ea));
	if (ue === null) return ue;
	if (ue instanceof Float32Array || ue instanceof Float64Array || ue instanceof Int32Array || ue instanceof Uint32Array || ue instanceof Uint8Array || ue instanceof Uint16Array || ue instanceof Int16Array || ue instanceof Int8Array || ue instanceof Uint8ClampedArray) return {
		rr_type: ue.constructor.name,
		args: [Object.values(ue)]
	};
	if (ue instanceof ArrayBuffer) {
		const ta = ue.constructor.name,
			na = encode(ue);
		return {
			rr_type: ta,
			base64: na
		}
	} else {
		if (ue instanceof DataView) return {
			rr_type: ue.constructor.name,
			args: [serializeArg(ue.buffer, Yi, ea), ue.byteOffset, ue.byteLength]
		};
		if (ue instanceof HTMLImageElement) {
			const ta = ue.constructor.name,
				{
					src: na
				} = ue;
			return {
				rr_type: ta,
				src: na
			}
		} else if (ue instanceof HTMLCanvasElement) {
			const ta = "HTMLImageElement",
				na = ue.toDataURL();
			return {
				rr_type: ta,
				src: na
			}
		} else {
			if (ue instanceof ImageData) return {
				rr_type: ue.constructor.name,
				args: [serializeArg(ue.data, Yi, ea), ue.width, ue.height]
			};
			if (isInstanceOfWebGLObject(ue, Yi) || typeof ue == "object") {
				const ta = ue.constructor.name,
					na = saveWebGLVar(ue, Yi, ea);
				return {
					rr_type: ta,
					index: na
				}
			}
		}
	}
	return ue
}
const serializeArgs = (ue, Yi, ea) => ue.map(ta => serializeArg(ta, Yi, ea)),
	isInstanceOfWebGLObject = (ue, Yi) => !!["WebGLActiveInfo", "WebGLBuffer", "WebGLFramebuffer", "WebGLProgram", "WebGLRenderbuffer", "WebGLShader", "WebGLShaderPrecisionFormat", "WebGLTexture", "WebGLUniformLocation", "WebGLVertexArrayObject", "WebGLVertexArrayObjectOES"].filter(na => typeof Yi[na] == "function").find(na => ue instanceof Yi[na]);

function initCanvas2DMutationObserver(ue, Yi, ea, ta, na) {
	const ra = [],
		ia = Object.getOwnPropertyNames(Yi.CanvasRenderingContext2D.prototype);
	for (const aa of ia) try {
		if (typeof Yi.CanvasRenderingContext2D.prototype[aa] != "function") continue;
		const oa = patch(Yi.CanvasRenderingContext2D.prototype, aa, function(la) {
			return function(...sa) {
				return isBlocked(this.canvas, ea, ta, na, !0) || setTimeout(() => {
					const ca = serializeArgs(sa, Yi, this);
					ue(this.canvas, {
						type: CanvasContext["2D"],
						property: aa,
						args: ca
					})
				}, 0), la.apply(this, sa)
			}
		});
		ra.push(oa)
	} catch {
		const la = hookSetter(Yi.CanvasRenderingContext2D.prototype, aa, {
			set(sa) {
				ue(this.canvas, {
					type: CanvasContext["2D"],
					property: aa,
					args: [sa],
					setter: !0
				})
			}
		});
		ra.push(la)
	}
	return () => {
		ra.forEach(aa => aa())
	}
}

function getNormalizedContextName(ue) {
	return ue === "experimental-webgl" ? "webgl" : ue
}

function initCanvasContextObserver(ue, Yi, ea, ta, na) {
	const ra = [];
	try {
		const ia = patch(ue.HTMLCanvasElement.prototype, "getContext", function(aa) {
			return function(oa, ...la) {
				if (!isBlocked(this, Yi, ea, ta, !0)) {
					const sa = getNormalizedContextName(oa);
					if ("__context" in this || (this.__context = sa), na && ["webgl", "webgl2"].includes(sa))
						if (la[0] && typeof la[0] == "object") {
							const ca = la[0];
							ca.preserveDrawingBuffer || (ca.preserveDrawingBuffer = !0)
						} else la.splice(0, 1, {
							preserveDrawingBuffer: !0
						})
				}
				return aa.apply(this, [oa, ...la])
			}
		});
		ra.push(ia)
	} catch {
		console.error("failed to patch HTMLCanvasElement.prototype.getContext")
	}
	return () => {
		ra.forEach(ia => ia())
	}
}

function patchGLPrototype(ue, Yi, ea, ta, na, ra, ia, aa) {
	const oa = [],
		la = Object.getOwnPropertyNames(ue);
	for (const sa of la)
		if (!["isContextLost", "canvas", "drawingBufferWidth", "drawingBufferHeight"].includes(sa)) try {
			if (typeof ue[sa] != "function") continue;
			const ca = patch(ue, sa, function(ua) {
				return function(...da) {
					const ha = ua.apply(this, da);
					if (saveWebGLVar(ha, aa, this), "tagName" in this.canvas && !isBlocked(this.canvas, ta, na, ra, !0)) {
						const pa = serializeArgs(da, aa, this),
							va = {
								type: Yi,
								property: sa,
								args: pa
							};
						ea(this.canvas, va)
					}
					return ha
				}
			});
			oa.push(ca)
		} catch {
			const ua = hookSetter(ue, sa, {
				set(da) {
					ea(this.canvas, {
						type: Yi,
						property: sa,
						args: [da],
						setter: !0
					})
				}
			});
			oa.push(ua)
		}
	return oa
}

function initCanvasWebGLMutationObserver(ue, Yi, ea, ta, na, ra) {
	const ia = [];
	return ia.push(...patchGLPrototype(Yi.WebGLRenderingContext.prototype, CanvasContext.WebGL, ue, ea, ta, na, ra, Yi)), typeof Yi.WebGL2RenderingContext < "u" && ia.push(...patchGLPrototype(Yi.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, ue, ea, ta, na, ra, Yi)), () => {
		ia.forEach(aa => aa())
	}
}
var r$1 = 'for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",e="undefined"==typeof Uint8Array?[]:new Uint8Array(256),n=0;n<64;n++)e[t.charCodeAt(n)]=n;var a=function(e){var n,a=new Uint8Array(e),s=a.length,r="";for(n=0;n<s;n+=3)r+=t[a[n]>>2],r+=t[(3&a[n])<<4|a[n+1]>>4],r+=t[(15&a[n+1])<<2|a[n+2]>>6],r+=t[63&a[n+2]];return s%3==2?r=r.substring(0,r.length-1)+"=":s%3==1&&(r=r.substring(0,r.length-2)+"=="),r};const s=new Map,r=new Map;const i=self;i.onmessage=async function(t){if(!("OffscreenCanvas"in globalThis))return i.postMessage({id:t.data.id});{const{id:e,bitmap:n,width:o,height:f,dataURLOptions:c}=t.data,g=async function(t,e,n){const s=t+"-"+e;if("OffscreenCanvas"in globalThis){if(r.has(s))return r.get(s);const i=new OffscreenCanvas(t,e);i.getContext("2d");const o=await i.convertToBlob(n),f=await o.arrayBuffer(),c=a(f);return r.set(s,c),c}return""}(o,f,c),d=new OffscreenCanvas(o,f);d.getContext("2d").drawImage(n,0,0),n.close();const u=await d.convertToBlob(c),h=u.type,w=await u.arrayBuffer(),l=a(w);if(!s.has(e)&&await g===l)return s.set(e,l),i.postMessage({id:e});if(s.get(e)===l)return i.postMessage({id:e});i.postMessage({id:e,type:h,base64:l,width:o,height:f}),s.set(e,l)}};';

function t$1() {
	const ue = new Blob([r$1]);
	return URL.createObjectURL(ue)
}
class CanvasManager {
	reset() {
		this.pendingCanvasMutations.clear(), this.resetObservers && this.resetObservers()
	}
	freeze() {
		this.frozen = !0
	}
	unfreeze() {
		this.frozen = !1
	}
	lock() {
		this.locked = !0
	}
	unlock() {
		this.locked = !1
	}
	constructor(Yi) {
		this.pendingCanvasMutations = new Map, this.rafStamps = {
			latestId: 0,
			invokeId: null
		}, this.frozen = !1, this.locked = !1, this.processMutation = (sa, ca) => {
			(this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId || !this.rafStamps.invokeId) && (this.rafStamps.invokeId = this.rafStamps.latestId), this.pendingCanvasMutations.has(sa) || this.pendingCanvasMutations.set(sa, []), this.pendingCanvasMutations.get(sa).push(ca)
		};
		const {
			sampling: ea = "all",
			win: ta,
			blockClass: na,
			blockSelector: ra,
			unblockSelector: ia,
			recordCanvas: aa,
			dataURLOptions: oa,
			errorHandler: la
		} = Yi;
		this.mutationCb = Yi.mutationCb, this.mirror = Yi.mirror, this.options = Yi, la && registerErrorHandler(la), !Yi.enableManualSnapshot && callbackWrapper(() => {
			aa && ea === "all" && this.initCanvasMutationObserver(ta, na, ra, ia), aa && typeof ea == "number" && this.initCanvasFPSObserver(ea, ta, na, ra, ia, {
				dataURLOptions: oa
			})
		})()
	}
	initCanvasFPSObserver(Yi, ea, ta, na, ra, ia) {
		const aa = initCanvasContextObserver(ea, ta, na, ra, !0),
			oa = this.takeSnapshot(!1, Yi, ea, ta, na, ra, ia.dataURLOptions);
		this.resetObservers = () => {
			aa(), cancelAnimationFrame(oa)
		}
	}
	initCanvasMutationObserver(Yi, ea, ta, na) {
		this.startRAFTimestamping(), this.startPendingCanvasMutationFlusher();
		const ra = initCanvasContextObserver(Yi, ea, ta, na, !1),
			ia = initCanvas2DMutationObserver(this.processMutation.bind(this), Yi, ea, ta, na),
			aa = initCanvasWebGLMutationObserver(this.processMutation.bind(this), Yi, ea, ta, na, this.mirror);
		this.resetObservers = () => {
			ra(), ia(), aa()
		}
	}
	snapshot(Yi) {
		const {
			options: ea
		} = this, ta = this.takeSnapshot(!0, ea.sampling === "all" ? 2 : ea.sampling || 2, ea.win, ea.blockClass, ea.blockSelector, ea.unblockSelector, ea.dataURLOptions, Yi);
		this.resetObservers = () => {
			cancelAnimationFrame(ta)
		}
	}
	takeSnapshot(Yi, ea, ta, na, ra, ia, aa, oa) {
		const la = new Map,
			sa = new Worker(t$1());
		sa.onmessage = va => {
			const ba = va.data,
				{
					id: Ea
				} = ba;
			if (la.set(Ea, !1), !("base64" in ba)) return;
			const {
				base64: Sa,
				type: Ca,
				width: ka,
				height: Pa
			} = ba;
			this.mutationCb({
				id: Ea,
				type: CanvasContext["2D"],
				commands: [{
					property: "clearRect",
					args: [0, 0, ka, Pa]
				}, {
					property: "drawImage",
					args: [{
						rr_type: "ImageBitmap",
						args: [{
							rr_type: "Blob",
							data: [{
								rr_type: "ArrayBuffer",
								base64: Sa
							}],
							type: Ca
						}]
					}, 0, 0]
				}]
			})
		};
		const ca = 1e3 / ea;
		let ua = 0,
			da;
		const ha = va => {
				if (va) return [va];
				const ba = [];
				return ta.document.querySelectorAll("canvas").forEach(Ea => {
					isBlocked(Ea, na, ra, ia) || ba.push(Ea)
				}), ba
			},
			pa = va => {
				if (ua && va - ua < ca) {
					da = onRequestAnimationFrame(pa);
					return
				}
				ua = va, ha(oa).forEach(ba => {
					const Ea = this.mirror.getId(ba);
					if (!la.get(Ea) && !(!ba.width || !ba.height)) {
						if (la.set(Ea, !0), !Yi && ["webgl", "webgl2"].includes(ba.__context)) {
							const Sa = ba.getContext(ba.__context);
							_optionalChain([Sa, "optionalAccess", Ca => Ca.getContextAttributes, "call", Ca => Ca(), "optionalAccess", Ca => Ca.preserveDrawingBuffer]) === !1 && Sa.clear(Sa.COLOR_BUFFER_BIT)
						}
						createImageBitmap(ba).then(Sa => {
							sa.postMessage({
								id: Ea,
								bitmap: Sa,
								width: ba.width,
								height: ba.height,
								dataURLOptions: aa
							}, [Sa])
						}).catch(Sa => {
							callbackWrapper(() => {
								throw Sa
							})()
						})
					}
				}), da = onRequestAnimationFrame(pa)
			};
		return da = onRequestAnimationFrame(pa), da
	}
	startPendingCanvasMutationFlusher() {
		onRequestAnimationFrame(() => this.flushPendingCanvasMutations())
	}
	startRAFTimestamping() {
		const Yi = ea => {
			this.rafStamps.latestId = ea, onRequestAnimationFrame(Yi)
		};
		onRequestAnimationFrame(Yi)
	}
	flushPendingCanvasMutations() {
		this.pendingCanvasMutations.forEach((Yi, ea) => {
			const ta = this.mirror.getId(ea);
			this.flushPendingCanvasMutationFor(ea, ta)
		}), onRequestAnimationFrame(() => this.flushPendingCanvasMutations())
	}
	flushPendingCanvasMutationFor(Yi, ea) {
		if (this.frozen || this.locked) return;
		const ta = this.pendingCanvasMutations.get(Yi);
		if (!ta || ea === -1) return;
		const na = ta.map(ia => {
				const {
					type: aa,
					...oa
				} = ia;
				return oa
			}),
			{
				type: ra
			} = ta[0];
		this.mutationCb({
			id: ea,
			type: ra,
			commands: na
		}), this.pendingCanvasMutations.delete(Yi)
	}
}
const CANVAS_QUALITY = {
		low: {
			sampling: {
				canvas: 1
			},
			dataURLOptions: {
				type: "image/webp",
				quality: .25
			}
		},
		medium: {
			sampling: {
				canvas: 2
			},
			dataURLOptions: {
				type: "image/webp",
				quality: .4
			}
		},
		high: {
			sampling: {
				canvas: 4
			},
			dataURLOptions: {
				type: "image/webp",
				quality: .5
			}
		}
	},
	INTEGRATION_NAME$2 = "ReplayCanvas",
	_replayCanvasIntegration = (ue = {}) => {
		const Yi = {
			quality: ue.quality || "medium",
			enableManualSnapshot: ue.enableManualSnapshot
		};
		let ea;
		const ta = new Promise(na => ea = na);
		return {
			name: INTEGRATION_NAME$2,
			setupOnce() {},
			getOptions() {
				const {
					quality: na,
					enableManualSnapshot: ra
				} = Yi;
				return {
					enableManualSnapshot: ra,
					recordCanvas: !0,
					getCanvasManager: ia => {
						const aa = new CanvasManager({
							...ia,
							enableManualSnapshot: ra,
							errorHandler: oa => {
								try {
									typeof oa == "object" && (oa.__rrweb__ = !0)
								} catch {}
							}
						});
						return ea(aa), aa
					},
					...CANVAS_QUALITY[na || "medium"] || CANVAS_QUALITY.medium
				}
			},
			async snapshot(na) {
				(await ta).snapshot(na)
			}
		}
	},
	replayCanvasIntegration = _replayCanvasIntegration,
	ReplayCanvas = convertIntegrationFnToClass(INTEGRATION_NAME$2, replayCanvasIntegration),
	WINDOW = GLOBAL_OBJ,
	LIGHT_BACKGROUND = "#ffffff",
	INHERIT = "inherit",
	SUBMIT_COLOR = "rgba(108, 95, 199, 1)",
	LIGHT_THEME = {
		fontFamily: "system-ui, 'Helvetica Neue', Arial, sans-serif",
		fontSize: "14px",
		background: LIGHT_BACKGROUND,
		backgroundHover: "#f6f6f7",
		foreground: "#2b2233",
		border: "1.5px solid rgba(41, 35, 47, 0.13)",
		borderRadius: "12px",
		boxShadow: "0px 4px 24px 0px rgba(43, 34, 51, 0.12)",
		success: "#268d75",
		error: "#df3338",
		submitBackground: "rgba(88, 74, 192, 1)",
		submitBackgroundHover: SUBMIT_COLOR,
		submitBorder: SUBMIT_COLOR,
		submitOutlineFocus: "#29232f",
		submitForeground: LIGHT_BACKGROUND,
		submitForegroundHover: LIGHT_BACKGROUND,
		cancelBackground: "transparent",
		cancelBackgroundHover: "var(--background-hover)",
		cancelBorder: "var(--border)",
		cancelOutlineFocus: "var(--input-outline-focus)",
		cancelForeground: "var(--foreground)",
		cancelForegroundHover: "var(--foreground)",
		inputBackground: INHERIT,
		inputForeground: INHERIT,
		inputBorder: "var(--border)",
		inputOutlineFocus: SUBMIT_COLOR,
		formBorderRadius: "20px",
		formContentBorderRadius: "6px"
	},
	DEFAULT_THEME = {
		light: LIGHT_THEME,
		dark: {
			...LIGHT_THEME,
			background: "#29232f",
			backgroundHover: "#352f3b",
			foreground: "#ebe6ef",
			border: "1.5px solid rgba(235, 230, 239, 0.15)",
			success: "#2da98c",
			error: "#f55459"
		}
	},
	ACTOR_LABEL = "Report a Bug",
	CANCEL_BUTTON_LABEL = "Cancel",
	SUBMIT_BUTTON_LABEL = "Send Bug Report",
	FORM_TITLE = "Report a Bug",
	EMAIL_PLACEHOLDER = "your.email@example.org",
	EMAIL_LABEL = "Email",
	MESSAGE_PLACEHOLDER = "What's the bug? What did you expect?",
	MESSAGE_LABEL = "Description",
	NAME_PLACEHOLDER = "Your Name",
	NAME_LABEL = "Name",
	IS_REQUIRED_LABEL = "(required)",
	SUCCESS_MESSAGE_TEXT = "Thank you for your report!",
	FEEDBACK_WIDGET_SOURCE = "widget",
	FEEDBACK_API_SOURCE = "api";
async function prepareFeedbackEvent({
	client: ue,
	scope: Yi,
	event: ea
}) {
	const ta = {};
	ue.emit && ue.emit("preprocessEvent", ea, ta);
	const na = await prepareEvent(ue.getOptions(), ea, ta, Yi, ue, getIsolationScope());
	return na === null ? (ue.recordDroppedEvent("event_processor", "feedback", ea), null) : (na.platform = na.platform || "javascript", na)
}
async function sendFeedbackRequest({
	feedback: {
		message: ue,
		email: Yi,
		name: ea,
		source: ta,
		url: na
	}
}, {
	includeReplay: ra = !0
} = {}) {
	const ia = getClient(),
		aa = ia && ia.getTransport(),
		oa = ia && ia.getDsn();
	if (!ia || !aa || !oa) return;
	const la = {
		contexts: {
			feedback: {
				contact_email: Yi,
				name: ea,
				message: ue,
				url: na,
				source: ta
			}
		},
		type: "feedback"
	};
	return withScope(async sa => {
		sa.clearBreadcrumbs(), [FEEDBACK_API_SOURCE, FEEDBACK_WIDGET_SOURCE].includes(String(ta)) && sa.setLevel("info");
		const ca = await prepareFeedbackEvent({
			scope: sa,
			client: ia,
			event: la
		});
		if (!ca) return;
		ia.emit && ia.emit("beforeSendFeedback", ca, {
			includeReplay: !!ra
		});
		const ua = createEventEnvelope(ca, oa, ia.getOptions()._metadata, ia.getOptions().tunnel);
		let da;
		try {
			da = await aa.send(ua)
		} catch (ha) {
			const pa = new Error("Unable to send Feedback");
			try {
				pa.cause = ha
			} catch {}
			throw pa
		}
		if (da) {
			if (typeof da.statusCode == "number" && (da.statusCode < 200 || da.statusCode >= 300)) throw new Error("Unable to send Feedback");
			return da
		}
	})
}

function sendFeedback({
	name: ue,
	email: Yi,
	message: ea,
	source: ta = FEEDBACK_API_SOURCE,
	url: na = getLocationHref()
}, ra = {}) {
	if (!ea) throw new Error("Unable to submit feedback with empty message");
	return sendFeedbackRequest({
		feedback: {
			name: ue,
			email: Yi,
			message: ea,
			url: na,
			source: ta
		}
	}, ra)
}
const DEBUG_BUILD$1 = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;

function mergeOptions(ue, Yi) {
	return {
		...ue,
		...Yi,
		themeDark: {
			...ue.themeDark,
			...Yi.themeDark
		},
		themeLight: {
			...ue.themeLight,
			...Yi.themeLight
		}
	}
}

function createActorStyles(ue) {
	const Yi = ue.createElement("style");
	return Yi.textContent = `
.widget__actor {
  line-height: 25px;

  display: flex;
  align-items: center;
  gap: 8px;

  border-radius: var(--border-radius);
  cursor: pointer;
  font-family: inherit;
  font-size: var(--font-size);
  font-weight: 600;
  padding: 12px 16px;
  text-decoration: none;
  z-index: 9000;

  color: var(--foreground);
  background-color: var(--background);
  border: var(--border);
  box-shadow: var(--box-shadow);
  opacity: 1;
  transition: opacity 0.1s ease-in-out;
}

.widget__actor:hover {
  background-color: var(--background-hover);
}

.widget__actor svg {
  width: 16px;
  height: 16px;
}

.widget__actor--hidden {
  opacity: 0;
  pointer-events: none;
  visibility: hidden;
}

.widget__actor__text {
}

.feedback-icon path {
  fill: var(--foreground);
}
`, Yi
}

function createDialogStyles(ue) {
	const Yi = ue.createElement("style");
	return Yi.textContent = `
.dialog {
  line-height: 25px;
  background-color: rgba(0, 0, 0, 0.05);
  border: none;
  position: fixed;
  inset: 0;
  z-index: 10000;
  width: 100vw;
  height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 1;
  transition: opacity 0.2s ease-in-out;
}

.dialog:not([open]) {
  opacity: 0;
  pointer-events: none;
  visibility: hidden;
}
.dialog:not([open]) .dialog__content {
  transform: translate(0, -16px) scale(0.98);
}

.dialog__content {
  position: fixed;
  left: var(--left);
  right: var(--right);
  bottom: var(--bottom);
  top: var(--top);

  border: var(--border);
  border-radius: var(--form-border-radius);
  background-color: var(--background);
  color: var(--foreground);

  width: 320px;
  max-width: 100%;
  max-height: calc(100% - 2rem);
  display: flex;
  flex-direction: column;
  box-shadow: var(--box-shadow);
  transition: transform 0.2s ease-in-out;
  transform: translate(0, 0) scale(1);
}

.dialog__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: 20px;
  font-weight: 600;
  padding: 24px 24px 0 24px;
  margin: 0;
  margin-bottom: 16px;
}

.brand-link {
  display: inline-flex;
}

.error {
  color: var(--error);
  margin-bottom: 16px;
}

.form {
  display: grid;
  overflow: auto;
  flex-direction: column;
  gap: 16px;
  padding: 0 24px 24px;
}

.form__error-container {
  color: var(--error);
}

.form__error-container--hidden {
  display: none;
}

.form__label {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin: 0px;
}

.form__label__text {
  display: grid;
  gap: 4px;
  align-items: center;
  grid-auto-flow: column;
  grid-auto-columns: max-content;
}

.form__label__text--required {
  font-size: 0.85em;
}

.form__input {
  line-height: inherit;
  background-color: var(--input-background);
  box-sizing: border-box;
  border: var(--input-border);
  border-radius: var(--form-content-border-radius);
  color: var(--input-foreground);
  font-family: inherit;
  font-size: var(--font-size);
  font-weight: 500;
  padding: 6px 12px;
}

.form__input::placeholder {
  color: var(--input-foreground);
  opacity: 0.65;
}

.form__input:focus-visible {
  outline: 1px auto var(--input-outline-focus);
}

.form__input--textarea {
  font-family: inherit;
  resize: vertical;
}

.btn-group {
  display: grid;
  gap: 8px;
  margin-top: 8px;
}

.btn {
  line-height: inherit;
  border: var(--cancel-border);
  border-radius: var(--form-content-border-radius);
  cursor: pointer;
  font-family: inherit;
  font-size: var(--font-size);
  font-weight: 600;
  padding: 6px 16px;
}
.btn[disabled] {
  opacity: 0.6;
  pointer-events: none;
}

.btn--primary {
  background-color: var(--submit-background);
  border-color: var(--submit-border);
  color: var(--submit-foreground);
}
.btn--primary:hover {
  background-color: var(--submit-background-hover);
  color: var(--submit-foreground-hover);
}
.btn--primary:focus-visible {
  outline: 1px auto var(--submit-outline-focus);
}

.btn--default {
  background-color: var(--cancel-background);
  color: var(--cancel-foreground);
  font-weight: 500;
}
.btn--default:hover {
  background-color: var(--cancel-background-hover);
  color: var(--cancel-foreground-hover);
}
.btn--default:focus-visible {
  outline: 1px auto var(--cancel-outline-focus);
}

.success-message {
  background-color: var(--background);
  border: var(--border);
  border-radius: var(--border-radius);
  box-shadow: var(--box-shadow);
  font-weight: 600;
  color: var(--success);
  padding: 12px 24px;
  line-height: 25px;
  display: grid;
  align-items: center;
  grid-auto-flow: column;
  gap: 6px;
  cursor: default;
}

.success-icon path {
  fill: var(--success);
}
`, Yi
}

function getThemedCssVariables(ue) {
	return `
  --background: ${ue.background};
  --background-hover: ${ue.backgroundHover};
  --foreground: ${ue.foreground};
  --error: ${ue.error};
  --success: ${ue.success};
  --border: ${ue.border};
  --border-radius: ${ue.borderRadius};
  --box-shadow: ${ue.boxShadow};

  --submit-background: ${ue.submitBackground};
  --submit-background-hover: ${ue.submitBackgroundHover};
  --submit-border: ${ue.submitBorder};
  --submit-outline-focus: ${ue.submitOutlineFocus};
  --submit-foreground: ${ue.submitForeground};
  --submit-foreground-hover: ${ue.submitForegroundHover};

  --cancel-background: ${ue.cancelBackground};
  --cancel-background-hover: ${ue.cancelBackgroundHover};
  --cancel-border: ${ue.cancelBorder};
  --cancel-outline-focus: ${ue.cancelOutlineFocus};
  --cancel-foreground: ${ue.cancelForeground};
  --cancel-foreground-hover: ${ue.cancelForegroundHover};

  --input-background: ${ue.inputBackground};
  --input-foreground: ${ue.inputForeground};
  --input-border: ${ue.inputBorder};
  --input-outline-focus: ${ue.inputOutlineFocus};

  --form-border-radius: ${ue.formBorderRadius};
  --form-content-border-radius: ${ue.formContentBorderRadius};
  `
}

function createMainStyles(ue, Yi, ea) {
	const ta = ue.createElement("style");
	return ta.textContent = `
:host {
  --bottom: 1rem;
  --right: 1rem;
  --top: auto;
  --left: auto;
  --z-index: 100000;
  --font-family: ${ea.light.fontFamily};
  --font-size: ${ea.light.fontSize};

  position: fixed;
  left: var(--left);
  right: var(--right);
  bottom: var(--bottom);
  top: var(--top);
  z-index: var(--z-index);

  font-family: var(--font-family);
  font-size: var(--font-size);

  ${getThemedCssVariables(Yi==="dark"?ea.dark:ea.light)}
}

${Yi==="system"?`
@media (prefers-color-scheme: dark) {
  :host {
    ${getThemedCssVariables(ea.dark)}
  }
}`:""}
}`, ta
}

function createShadowHost({
	id: ue,
	colorScheme: Yi,
	themeDark: ea,
	themeLight: ta
}) {
	try {
		const na = WINDOW.document,
			ra = na.createElement("div");
		ra.id = ue;
		const ia = ra.attachShadow({
			mode: "open"
		});
		return ia.appendChild(createMainStyles(na, Yi, {
			dark: ea,
			light: ta
		})), ia.appendChild(createDialogStyles(na)), {
			shadow: ia,
			host: ra
		}
	} catch {
		throw logger.warn("[Feedback] Browser does not support shadow DOM API"), new Error("Browser does not support shadow DOM API.")
	}
}
async function handleFeedbackSubmit(ue, Yi, ea) {
	if (!ue) return;
	const ta = () => {
		ue && ue.showError("There was a problem submitting feedback, please wait and try again.")
	};
	ue.hideError();
	try {
		return await sendFeedback({
			...Yi,
			source: FEEDBACK_WIDGET_SOURCE
		}, ea)
	} catch (na) {
		DEBUG_BUILD$1 && logger.error(na), ta()
	}
}

function setAttributesNS(ue, Yi) {
	return Object.entries(Yi).forEach(([ea, ta]) => {
		ue.setAttributeNS(null, ea, ta)
	}), ue
}
const SIZE = 20,
	XMLNS$2 = "http://www.w3.org/2000/svg";

function Icon() {
	const ue = aa => WINDOW.document.createElementNS(XMLNS$2, aa),
		Yi = setAttributesNS(ue("svg"), {
			class: "feedback-icon",
			width: `${SIZE}`,
			height: `${SIZE}`,
			viewBox: `0 0 ${SIZE} ${SIZE}`,
			fill: "none"
		}),
		ea = setAttributesNS(ue("g"), {
			clipPath: "url(#clip0_57_80)"
		}),
		ta = setAttributesNS(ue("path"), {
			"fill-rule": "evenodd",
			"clip-rule": "evenodd",
			d: "M15.6622 15H12.3997C12.2129 14.9959 12.031 14.9396 11.8747 14.8375L8.04965 12.2H7.49956V19.1C7.4875 19.3348 7.3888 19.5568 7.22256 19.723C7.05632 19.8892 6.83435 19.9879 6.59956 20H2.04956C1.80193 19.9968 1.56535 19.8969 1.39023 19.7218C1.21511 19.5467 1.1153 19.3101 1.11206 19.0625V12.2H0.949652C0.824431 12.2017 0.700142 12.1783 0.584123 12.1311C0.468104 12.084 0.362708 12.014 0.274155 11.9255C0.185602 11.8369 0.115689 11.7315 0.0685419 11.6155C0.0213952 11.4995 -0.00202913 11.3752 -0.00034808 11.25V3.75C-0.00900498 3.62067 0.0092504 3.49095 0.0532651 3.36904C0.0972798 3.24712 0.166097 3.13566 0.255372 3.04168C0.344646 2.94771 0.452437 2.87327 0.571937 2.82307C0.691437 2.77286 0.82005 2.74798 0.949652 2.75H8.04965L11.8747 0.1625C12.031 0.0603649 12.2129 0.00407221 12.3997 0H15.6622C15.9098 0.00323746 16.1464 0.103049 16.3215 0.278167C16.4966 0.453286 16.5964 0.689866 16.5997 0.9375V3.25269C17.3969 3.42959 18.1345 3.83026 18.7211 4.41679C19.5322 5.22788 19.9878 6.32796 19.9878 7.47502C19.9878 8.62209 19.5322 9.72217 18.7211 10.5333C18.1345 11.1198 17.3969 11.5205 16.5997 11.6974V14.0125C16.6047 14.1393 16.5842 14.2659 16.5395 14.3847C16.4948 14.5035 16.4268 14.6121 16.3394 14.7042C16.252 14.7962 16.147 14.8698 16.0307 14.9206C15.9144 14.9714 15.7891 14.9984 15.6622 15ZM1.89695 10.325H1.88715V4.625H8.33715C8.52423 4.62301 8.70666 4.56654 8.86215 4.4625L12.6872 1.875H14.7247V13.125H12.6872L8.86215 10.4875C8.70666 10.3835 8.52423 10.327 8.33715 10.325H2.20217C2.15205 10.3167 2.10102 10.3125 2.04956 10.3125C1.9981 10.3125 1.94708 10.3167 1.89695 10.325ZM2.98706 12.2V18.1625H5.66206V12.2H2.98706ZM16.5997 9.93612V5.01393C16.6536 5.02355 16.7072 5.03495 16.7605 5.04814C17.1202 5.13709 17.4556 5.30487 17.7425 5.53934C18.0293 5.77381 18.2605 6.06912 18.4192 6.40389C18.578 6.73866 18.6603 7.10452 18.6603 7.47502C18.6603 7.84552 18.578 8.21139 18.4192 8.54616C18.2605 8.88093 18.0293 9.17624 17.7425 9.41071C17.4556 9.64518 17.1202 9.81296 16.7605 9.90191C16.7072 9.91509 16.6536 9.9265 16.5997 9.93612Z"
		});
	Yi.appendChild(ea).appendChild(ta);
	const na = ue("defs"),
		ra = setAttributesNS(ue("clipPath"), {
			id: "clip0_57_80"
		}),
		ia = setAttributesNS(ue("rect"), {
			width: `${SIZE}`,
			height: `${SIZE}`,
			fill: "white"
		});
	return ra.appendChild(ia), na.appendChild(ra), Yi.appendChild(na).appendChild(ra).appendChild(ia), {
		get el() {
			return Yi
		}
	}
}

function createElement(ue, Yi, ...ea) {
	const na = WINDOW.document.createElement(ue);
	Yi && Object.entries(Yi).forEach(([ra, ia]) => {
		ra === "className" && typeof ia == "string" ? na.setAttribute("class", ia) : typeof ia == "boolean" && ia ? na.setAttribute(ra, "") : typeof ia == "string" ? na.setAttribute(ra, ia) : ra.startsWith("on") && typeof ia == "function" && na.addEventListener(ra.substring(2).toLowerCase(), ia)
	});
	for (const ra of ea) appendChild(na, ra);
	return na
}

function appendChild(ue, Yi) {
	const ea = WINDOW.document;
	if (!(typeof Yi > "u" || Yi === null))
		if (Array.isArray(Yi))
			for (const ta of Yi) appendChild(ue, ta);
		else Yi === !1 || (typeof Yi == "string" ? ue.appendChild(ea.createTextNode(Yi)) : Yi instanceof Node ? ue.appendChild(Yi) : ue.appendChild(ea.createTextNode(String(Yi))))
}

function Actor({
	buttonLabel: ue,
	onClick: Yi
}) {
	function ea(na) {
		Yi && Yi(na)
	}
	const ta = createElement("button", {
		type: "button",
		className: "widget__actor",
		"aria-label": ue,
		"aria-hidden": "false"
	}, Icon().el, ue ? createElement("span", {
		className: "widget__actor__text"
	}, ue) : null);
	return ta.addEventListener("click", ea), {
		get el() {
			return ta
		},
		show: () => {
			ta.classList.remove("widget__actor--hidden"), ta.setAttribute("aria-hidden", "false")
		},
		hide: () => {
			ta.classList.add("widget__actor--hidden"), ta.setAttribute("aria-hidden", "true")
		}
	}
}

function SubmitButton({
	label: ue
}) {
	return {
		el: createElement("button", {
			type: "submit",
			className: "btn btn--primary",
			"aria-label": ue
		}, ue)
	}
}

function retrieveStringValue(ue, Yi) {
	const ea = ue.get(Yi);
	return typeof ea == "string" ? ea.trim() : ""
}

function Form({
	nameLabel: ue,
	namePlaceholder: Yi,
	emailLabel: ea,
	emailPlaceholder: ta,
	messageLabel: na,
	messagePlaceholder: ra,
	isRequiredLabel: ia,
	cancelButtonLabel: aa,
	submitButtonLabel: oa,
	showName: la,
	showEmail: sa,
	isNameRequired: ca,
	isEmailRequired: ua,
	defaultName: da,
	defaultEmail: ha,
	onCancel: pa,
	onSubmit: va
}) {
	const {
		el: ba
	} = SubmitButton({
		label: oa
	});

	function Ea(Ua) {
		if (Ua.preventDefault(), Ua.target instanceof HTMLFormElement) try {
			if (va) {
				const xa = new FormData(Ua.target),
					ma = {
						name: retrieveStringValue(xa, "name"),
						email: retrieveStringValue(xa, "email"),
						message: retrieveStringValue(xa, "message")
					};
				va(ma)
			}
		} catch {}
	}
	const Sa = createElement("div", {
		className: "form__error-container form__error-container--hidden",
		"aria-hidden": "true"
	});

	function Ca(Ua) {
		Sa.textContent = Ua, Sa.classList.remove("form__error-container--hidden"), Sa.setAttribute("aria-hidden", "false")
	}

	function ka() {
		Sa.textContent = "", Sa.classList.add("form__error-container--hidden"), Sa.setAttribute("aria-hidden", "true")
	}
	const Pa = createElement("input", {
			id: "name",
			type: la ? "text" : "hidden",
			"aria-hidden": la ? "false" : "true",
			name: "name",
			required: ca,
			className: "form__input",
			placeholder: Yi,
			value: da
		}),
		ja = createElement("input", {
			id: "email",
			type: sa ? "text" : "hidden",
			"aria-hidden": sa ? "false" : "true",
			name: "email",
			required: ua,
			className: "form__input",
			placeholder: ta,
			value: ha
		}),
		Za = createElement("textarea", {
			id: "message",
			autoFocus: "true",
			rows: "5",
			name: "message",
			required: !0,
			className: "form__input form__input--textarea",
			placeholder: ra
		}),
		Ga = createElement("button", {
			type: "button",
			className: "btn btn--default",
			"aria-label": aa,
			onClick: Ua => {
				pa && pa(Ua)
			}
		}, aa),
		Ja = createElement("form", {
			className: "form",
			onSubmit: Ea
		}, [Sa, la && createElement("label", {
			htmlFor: "name",
			className: "form__label"
		}, [createElement("span", {
			className: "form__label__text"
		}, ue, ca && createElement("span", {
			className: "form__label__text--required"
		}, ` ${ia}`)), Pa]), !la && Pa, sa && createElement("label", {
			htmlFor: "email",
			className: "form__label"
		}, [createElement("span", {
			className: "form__label__text"
		}, ea, ua && createElement("span", {
			className: "form__label__text--required"
		}, ` ${ia}`)), ja]), !sa && ja, createElement("label", {
			htmlFor: "message",
			className: "form__label"
		}, [createElement("span", {
			className: "form__label__text"
		}, na, createElement("span", {
			className: "form__label__text--required"
		}, ` ${ia}`)), Za]), createElement("div", {
			className: "btn-group"
		}, [ba, Ga])]);
	return {
		get el() {
			return Ja
		},
		showError: Ca,
		hideError: ka
	}
}
const XMLNS$1 = "http://www.w3.org/2000/svg";

function Logo({
	colorScheme: ue
}) {
	const Yi = ia => WINDOW.document.createElementNS(XMLNS$1, ia),
		ea = setAttributesNS(Yi("svg"), {
			class: "sentry-logo",
			width: "32",
			height: "30",
			viewBox: "0 0 72 66",
			fill: "none"
		}),
		ta = setAttributesNS(Yi("path"), {
			transform: "translate(11, 11)",
			d: "M29,2.26a4.67,4.67,0,0,0-8,0L14.42,13.53A32.21,32.21,0,0,1,32.17,40.19H27.55A27.68,27.68,0,0,0,12.09,17.47L6,28a15.92,15.92,0,0,1,9.23,12.17H4.62A.76.76,0,0,1,4,39.06l2.94-5a10.74,10.74,0,0,0-3.36-1.9l-2.91,5a4.54,4.54,0,0,0,1.69,6.24A4.66,4.66,0,0,0,4.62,44H19.15a19.4,19.4,0,0,0-8-17.31l2.31-4A23.87,23.87,0,0,1,23.76,44H36.07a35.88,35.88,0,0,0-16.41-31.8l4.67-8a.77.77,0,0,1,1.05-.27c.53.29,20.29,34.77,20.66,35.17a.76.76,0,0,1-.68,1.13H40.6q.09,1.91,0,3.81h4.78A4.59,4.59,0,0,0,50,39.43a4.49,4.49,0,0,0-.62-2.28Z"
		});
	ea.append(ta);
	const na = Yi("defs"),
		ra = Yi("style");
	return ra.textContent = `
    path {
      fill: ${ue==="dark"?"#fff":"#362d59"};
    }`, ue === "system" && (ra.textContent += `
    @media (prefers-color-scheme: dark) {
      path: {
        fill: '#fff';
      }
    }
    `), na.append(ra), ea.append(na), {
		get el() {
			return ea
		}
	}
}

function Dialog({
	formTitle: ue,
	showBranding: Yi,
	showName: ea,
	showEmail: ta,
	isNameRequired: na,
	isEmailRequired: ra,
	colorScheme: ia,
	defaultName: aa,
	defaultEmail: oa,
	onClosed: la,
	onCancel: sa,
	onSubmit: ca,
	...ua
}) {
	let da = null;

	function ha() {
		pa(), la && la()
	}

	function pa() {
		da && (da.open = !1)
	}

	function va() {
		da && (da.open = !0)
	}

	function ba() {
		return da && da.open === !0 || !1
	}
	const {
		el: Ea,
		showError: Sa,
		hideError: Ca
	} = Form({
		showEmail: ta,
		showName: ea,
		isEmailRequired: ra,
		isNameRequired: na,
		defaultName: aa,
		defaultEmail: oa,
		onSubmit: ca,
		onCancel: sa,
		...ua
	});
	return da = createElement("dialog", {
		className: "dialog",
		open: !0,
		onClick: ha
	}, createElement("div", {
		className: "dialog__content",
		onClick: ka => {
			ka.stopPropagation()
		}
	}, createElement("h2", {
		className: "dialog__header"
	}, ue, Yi && createElement("a", {
		className: "brand-link",
		target: "_blank",
		href: "https://sentry.io/welcome/",
		title: "Powered by Sentry",
		rel: "noopener noreferrer"
	}, Logo({
		colorScheme: ia
	}).el)), Ea)), {
		get el() {
			return da
		},
		showError: Sa,
		hideError: Ca,
		open: va,
		close: pa,
		checkIsOpen: ba
	}
}
const WIDTH = 16,
	HEIGHT = 17,
	XMLNS = "http://www.w3.org/2000/svg";

function SuccessIcon() {
	const ue = oa => WINDOW.document.createElementNS(XMLNS, oa),
		Yi = setAttributesNS(ue("svg"), {
			class: "success-icon",
			width: `${WIDTH}`,
			height: `${HEIGHT}`,
			viewBox: `0 0 ${WIDTH} ${HEIGHT}`,
			fill: "none"
		}),
		ea = setAttributesNS(ue("g"), {
			clipPath: "url(#clip0_57_156)"
		}),
		ta = setAttributesNS(ue("path"), {
			"fill-rule": "evenodd",
			"clip-rule": "evenodd",
			d: "M3.55544 15.1518C4.87103 16.0308 6.41775 16.5 8 16.5C10.1217 16.5 12.1566 15.6571 13.6569 14.1569C15.1571 12.6566 16 10.6217 16 8.5C16 6.91775 15.5308 5.37103 14.6518 4.05544C13.7727 2.73985 12.5233 1.71447 11.0615 1.10897C9.59966 0.503466 7.99113 0.34504 6.43928 0.653721C4.88743 0.962403 3.46197 1.72433 2.34315 2.84315C1.22433 3.96197 0.462403 5.38743 0.153721 6.93928C-0.15496 8.49113 0.00346625 10.0997 0.608967 11.5615C1.21447 13.0233 2.23985 14.2727 3.55544 15.1518ZM4.40546 3.1204C5.46945 2.40946 6.72036 2.03 8 2.03C9.71595 2.03 11.3616 2.71166 12.575 3.92502C13.7883 5.13838 14.47 6.78405 14.47 8.5C14.47 9.77965 14.0905 11.0306 13.3796 12.0945C12.6687 13.1585 11.6582 13.9878 10.476 14.4775C9.29373 14.9672 7.99283 15.0953 6.73777 14.8457C5.48271 14.596 4.32987 13.9798 3.42502 13.075C2.52018 12.1701 1.90397 11.0173 1.65432 9.76224C1.40468 8.50718 1.5328 7.20628 2.0225 6.02404C2.5122 4.8418 3.34148 3.83133 4.40546 3.1204Z"
		}),
		na = setAttributesNS(ue("path"), {
			d: "M6.68775 12.4297C6.78586 12.4745 6.89218 12.4984 7 12.5C7.11275 12.4955 7.22315 12.4664 7.32337 12.4145C7.4236 12.3627 7.51121 12.2894 7.58 12.2L12 5.63999C12.0848 5.47724 12.1071 5.28902 12.0625 5.11098C12.0178 4.93294 11.9095 4.77744 11.7579 4.67392C11.6064 4.57041 11.4221 4.52608 11.24 4.54931C11.0579 4.57254 10.8907 4.66173 10.77 4.79999L6.88 10.57L5.13 8.56999C5.06508 8.49566 4.98613 8.43488 4.89768 8.39111C4.80922 8.34735 4.713 8.32148 4.61453 8.31498C4.51605 8.30847 4.41727 8.32147 4.32382 8.35322C4.23038 8.38497 4.14413 8.43484 4.07 8.49999C3.92511 8.63217 3.83692 8.81523 3.82387 9.01092C3.81083 9.2066 3.87393 9.39976 4 9.54999L6.43 12.24C6.50187 12.3204 6.58964 12.385 6.68775 12.4297Z"
		});
	Yi.appendChild(ea).append(na, ta);
	const ra = ue("defs"),
		ia = setAttributesNS(ue("clipPath"), {
			id: "clip0_57_156"
		}),
		aa = setAttributesNS(ue("rect"), {
			width: `${WIDTH}`,
			height: `${WIDTH}`,
			fill: "white",
			transform: "translate(0 0.5)"
		});
	return ia.appendChild(aa), ra.appendChild(ia), Yi.appendChild(ra).appendChild(ia).appendChild(aa), {
		get el() {
			return Yi
		}
	}
}

function SuccessMessage({
	message: ue,
	onRemove: Yi
}) {
	function ea() {
		ta && (ta.remove(), Yi && Yi())
	}
	const ta = createElement("div", {
		className: "success-message",
		onClick: ea
	}, SuccessIcon().el, ue);
	return {
		el: ta,
		remove: ea
	}
}

function createWidget({
	shadow: ue,
	options: {
		shouldCreateActor: Yi = !0,
		...ea
	},
	attachTo: ta
}) {
	let na, ra, ia = !1;

	function aa() {
		if (ue) try {
			const ba = SuccessMessage({
				message: ea.successMessageText,
				onRemove: () => {
					Ea && clearTimeout(Ea), sa()
				}
			});
			if (!ba.el) throw new Error("Unable to show success message");
			ue.appendChild(ba.el);
			const Ea = setTimeout(() => {
				ba && ba.remove()
			}, 5e3)
		} catch (ba) {
			logger.error(ba)
		}
	}
	async function oa(ba) {
		if (!ra) return;
		const Ea = [];
		if (ea.isNameRequired && !ba.name && Ea.push(ea.nameLabel), ea.isEmailRequired && !ba.email && Ea.push(ea.emailLabel), ba.message || Ea.push(ea.messageLabel), Ea.length > 0) {
			ra.showError(`Please enter in the following required fields: ${Ea.join(", ")}`);
			return
		}
		if (!await handleFeedbackSubmit(ra, ba)) {
			ea.onSubmitError && ea.onSubmitError();
			return
		}
		pa(), aa(), ea.onSubmitSuccess && ea.onSubmitSuccess()
	}

	function la() {
		const ba = getClient(),
			Ea = ba && ba.getIntegrationByName && ba.getIntegrationByName("Replay");
		Ea && Ea.flush().catch(Sa => {
			DEBUG_BUILD$1 && logger.error(Sa)
		})
	}

	function sa() {
		na && na.show()
	}

	function ca() {
		na && na.hide()
	}

	function ua() {
		na && na.el && na.el.remove()
	}

	function da() {
		try {
			if (ra) {
				ra.open(), ia = !0, ea.onFormOpen && ea.onFormOpen(), la();
				return
			}
			const ba = ea.useSentryUser,
				Ea = getCurrentScope(),
				Sa = Ea && Ea.getUser();
			if (ra = Dialog({
					colorScheme: ea.colorScheme,
					showBranding: ea.showBranding,
					showName: ea.showName || ea.isNameRequired,
					showEmail: ea.showEmail || ea.isEmailRequired,
					isNameRequired: ea.isNameRequired,
					isEmailRequired: ea.isEmailRequired,
					formTitle: ea.formTitle,
					cancelButtonLabel: ea.cancelButtonLabel,
					submitButtonLabel: ea.submitButtonLabel,
					emailLabel: ea.emailLabel,
					emailPlaceholder: ea.emailPlaceholder,
					messageLabel: ea.messageLabel,
					messagePlaceholder: ea.messagePlaceholder,
					nameLabel: ea.nameLabel,
					namePlaceholder: ea.namePlaceholder,
					isRequiredLabel: ea.isRequiredLabel,
					defaultName: ba && Sa && Sa[ba.name] || "",
					defaultEmail: ba && Sa && Sa[ba.email] || "",
					onClosed: () => {
						sa(), ia = !1, ea.onFormClose && ea.onFormClose()
					},
					onCancel: () => {
						ha(), sa()
					},
					onSubmit: oa
				}), !ra.el) throw new Error("Unable to open Feedback dialog");
			ue.appendChild(ra.el), ca(), ea.onFormOpen && ea.onFormOpen(), la()
		} catch (ba) {
			logger.error(ba)
		}
	}

	function ha() {
		ra && (ra.close(), ia = !1, ea.onFormClose && ea.onFormClose())
	}

	function pa() {
		if (ra) {
			ha();
			const ba = ra.el;
			ba && ba.remove(), ra = void 0
		}
	}

	function va() {
		ia || da(), ca()
	}
	return ta ? ta.addEventListener("click", va) : Yi && (na = Actor({
		buttonLabel: ea.buttonLabel,
		onClick: va
	}), na.el && ue.appendChild(na.el)), {
		get actor() {
			return na
		},
		get dialog() {
			return ra
		},
		showActor: sa,
		hideActor: ca,
		removeActor: ua,
		openDialog: da,
		closeDialog: ha,
		removeDialog: pa
	}
}
const doc = WINDOW.document,
	feedbackIntegration = ue => new Feedback(ue);
class Feedback {
	static __initStatic() {
		this.id = "Feedback"
	}
	constructor({
		autoInject: Yi = !0,
		id: ea = "sentry-feedback",
		isEmailRequired: ta = !1,
		isNameRequired: na = !1,
		showBranding: ra = !0,
		showEmail: ia = !0,
		showName: aa = !0,
		useSentryUser: oa = {
			email: "email",
			name: "username"
		},
		themeDark: la,
		themeLight: sa,
		colorScheme: ca = "system",
		buttonLabel: ua = ACTOR_LABEL,
		cancelButtonLabel: da = CANCEL_BUTTON_LABEL,
		submitButtonLabel: ha = SUBMIT_BUTTON_LABEL,
		formTitle: pa = FORM_TITLE,
		emailPlaceholder: va = EMAIL_PLACEHOLDER,
		emailLabel: ba = EMAIL_LABEL,
		messagePlaceholder: Ea = MESSAGE_PLACEHOLDER,
		messageLabel: Sa = MESSAGE_LABEL,
		namePlaceholder: Ca = NAME_PLACEHOLDER,
		nameLabel: ka = NAME_LABEL,
		isRequiredLabel: Pa = IS_REQUIRED_LABEL,
		successMessageText: ja = SUCCESS_MESSAGE_TEXT,
		onFormClose: Za,
		onFormOpen: Ga,
		onSubmitError: Ja,
		onSubmitSuccess: Ua
	} = {}) {
		this.name = Feedback.id, this._host = null, this._shadow = null, this._widget = null, this._widgets = new Set, this._hasInsertedActorStyles = !1, this.options = {
			autoInject: Yi,
			showBranding: ra,
			id: ea,
			isEmailRequired: ta,
			isNameRequired: na,
			showEmail: ia,
			showName: aa,
			useSentryUser: oa,
			colorScheme: ca,
			themeDark: {
				...DEFAULT_THEME.dark,
				...la
			},
			themeLight: {
				...DEFAULT_THEME.light,
				...sa
			},
			buttonLabel: ua,
			cancelButtonLabel: da,
			submitButtonLabel: ha,
			formTitle: pa,
			emailLabel: ba,
			emailPlaceholder: va,
			messageLabel: Sa,
			messagePlaceholder: Ea,
			nameLabel: ka,
			namePlaceholder: Ca,
			isRequiredLabel: Pa,
			successMessageText: ja,
			onFormClose: Za,
			onFormOpen: Ga,
			onSubmitError: Ja,
			onSubmitSuccess: Ua
		}
	}
	setupOnce() {
		if (isBrowser()) try {
			this._cleanupWidgetIfExists();
			const {
				autoInject: Yi
			} = this.options;
			if (!Yi) return;
			this._createWidget(this.options)
		} catch (Yi) {
			DEBUG_BUILD$1 && logger.error(Yi)
		}
	}
	openDialog() {
		this._widget || this._createWidget({
			...this.options,
			shouldCreateActor: !1
		}), this._widget && this._widget.openDialog()
	}
	closeDialog() {
		this._widget && this._widget.closeDialog()
	}
	attachTo(Yi, ea) {
		try {
			const ta = mergeOptions(this.options, ea || {});
			return this._ensureShadowHost(ta, ({
				shadow: na
			}) => {
				const ra = typeof Yi == "string" ? doc.querySelector(Yi) : typeof Yi.addEventListener == "function" ? Yi : null;
				if (!ra) return DEBUG_BUILD$1 && logger.error("[Feedback] Unable to attach to target element"), null;
				const ia = createWidget({
					shadow: na,
					options: ta,
					attachTo: ra
				});
				return this._widgets.add(ia), this._widget || (this._widget = ia), ia
			})
		} catch (ta) {
			return DEBUG_BUILD$1 && logger.error(ta), null
		}
	}
	createWidget(Yi) {
		try {
			return this._createWidget(mergeOptions(this.options, Yi || {}))
		} catch (ea) {
			return DEBUG_BUILD$1 && logger.error(ea), null
		}
	}
	removeWidget(Yi) {
		if (!Yi) return !1;
		try {
			if (this._widgets.has(Yi)) return Yi.removeActor(), Yi.removeDialog(), this._widgets.delete(Yi), this._widget === Yi && (this._widget = null), !0
		} catch (ea) {
			DEBUG_BUILD$1 && logger.error(ea)
		}
		return !1
	}
	getWidget() {
		return this._widget
	}
	remove() {
		this._host && this._host.remove(), this._initialize()
	}
	_initialize() {
		this._host = null, this._shadow = null, this._widget = null, this._widgets = new Set, this._hasInsertedActorStyles = !1
	}
	_cleanupWidgetIfExists() {
		this._host && this.remove();
		const Yi = doc.querySelector(`#${this.options.id}`);
		Yi && Yi.remove()
	}
	_createWidget(Yi) {
		return this._ensureShadowHost(Yi, ({
			shadow: ea
		}) => {
			const ta = createWidget({
				shadow: ea,
				options: Yi
			});
			return !this._hasInsertedActorStyles && ta.actor && (ea.appendChild(createActorStyles(doc)), this._hasInsertedActorStyles = !0), this._widgets.add(ta), this._widget || (this._widget = ta), ta
		})
	}
	_ensureShadowHost(Yi, ea) {
		let ta = !1;
		if (!this._shadow || !this._host) {
			const {
				id: ra,
				colorScheme: ia,
				themeLight: aa,
				themeDark: oa
			} = Yi, {
				shadow: la,
				host: sa
			} = createShadowHost({
				id: ra,
				colorScheme: ia,
				themeLight: aa,
				themeDark: oa
			});
			this._shadow = la, this._host = sa, ta = !0
		}
		this._host.dataset.sentryFeedbackColorscheme = Yi.colorScheme;
		const na = ea({
			shadow: this._shadow,
			host: this._host
		});
		return ta && doc.body.appendChild(this._host), na
	}
}
Feedback.__initStatic();

function promisifyRequest(ue) {
	return new Promise((Yi, ea) => {
		ue.oncomplete = ue.onsuccess = () => Yi(ue.result), ue.onabort = ue.onerror = () => ea(ue.error)
	})
}

function createStore(ue, Yi) {
	const ea = indexedDB.open(ue);
	ea.onupgradeneeded = () => ea.result.createObjectStore(Yi);
	const ta = promisifyRequest(ea);
	return na => ta.then(ra => na(ra.transaction(Yi, "readwrite").objectStore(Yi)))
}

function keys(ue) {
	return promisifyRequest(ue.getAllKeys())
}

function insert(ue, Yi, ea) {
	return ue(ta => keys(ta).then(na => {
		if (!(na.length >= ea)) return ta.put(Yi, Math.max(...na, 0) + 1), promisifyRequest(ta.transaction)
	}))
}

function pop(ue) {
	return ue(Yi => keys(Yi).then(ea => {
		if (ea.length !== 0) return promisifyRequest(Yi.get(ea[0])).then(ta => (Yi.delete(ea[0]), promisifyRequest(Yi.transaction).then(() => ta)))
	}))
}

function createIndexedDbStore(ue) {
	let Yi;

	function ea() {
		return Yi == null && (Yi = createStore(ue.dbName || "sentry-offline", ue.storeName || "queue")), Yi
	}
	return {
		insert: async ta => {
			try {
				const na = await serializeEnvelope(ta, ue.textEncoder);
				await insert(ea(), na, ue.maxQueueSize || 30)
			} catch {}
		},
		pop: async () => {
			try {
				const ta = await pop(ea());
				if (ta) return parseEnvelope(ta, ue.textEncoder || new TextEncoder, ue.textDecoder || new TextDecoder)
			} catch {}
		}
	}
}

function makeIndexedDbOfflineTransport(ue) {
	return Yi => ue({
		...Yi,
		createStore: createIndexedDbStore
	})
}

function makeBrowserOfflineTransport(ue) {
	return makeIndexedDbOfflineTransport(makeOfflineTransport(ue))
}
const MS_TO_NS = 1e6,
	THREAD_ID_STRING = String(0),
	THREAD_NAME = "main";
let OS_PLATFORM = "",
	OS_PLATFORM_VERSION = "",
	OS_ARCH = "",
	OS_BROWSER = WINDOW$2.navigator && WINDOW$2.navigator.userAgent || "",
	OS_MODEL = "";
const OS_LOCALE = WINDOW$2.navigator && WINDOW$2.navigator.language || WINDOW$2.navigator && WINDOW$2.navigator.languages && WINDOW$2.navigator.languages[0] || "";

function isUserAgentData(ue) {
	return typeof ue == "object" && ue !== null && "getHighEntropyValues" in ue
}
const userAgentData = WINDOW$2.navigator && WINDOW$2.navigator.userAgentData;
isUserAgentData(userAgentData) && userAgentData.getHighEntropyValues(["architecture", "model", "platform", "platformVersion", "fullVersionList"]).then(ue => {
	if (OS_PLATFORM = ue.platform || "", OS_ARCH = ue.architecture || "", OS_MODEL = ue.model || "", OS_PLATFORM_VERSION = ue.platformVersion || "", ue.fullVersionList && ue.fullVersionList.length > 0) {
		const Yi = ue.fullVersionList[ue.fullVersionList.length - 1];
		OS_BROWSER = `${Yi.brand} ${Yi.version}`
	}
}).catch(ue => {});

function isProcessedJSSelfProfile(ue) {
	return !("thread_metadata" in ue)
}

function enrichWithThreadInformation(ue) {
	return isProcessedJSSelfProfile(ue) ? convertJSSelfProfileToSampledFormat(ue) : ue
}

function getTraceId(ue) {
	const Yi = ue && ue.contexts && ue.contexts.trace && ue.contexts.trace.trace_id;
	return typeof Yi == "string" && Yi.length !== 32 && DEBUG_BUILD$3 && logger.log(`[Profiling] Invalid traceId: ${Yi} on profiled event`), typeof Yi != "string" ? "" : Yi
}

function createProfilePayload(ue, Yi, ea, ta) {
	if (ta.type !== "transaction") throw new TypeError("Profiling events may only be attached to transactions, this should never occur.");
	if (ea == null) throw new TypeError(`Cannot construct profiling event envelope without a valid profile. Got ${ea} instead.`);
	const na = getTraceId(ta),
		ra = enrichWithThreadInformation(ea),
		ia = Yi || (typeof ta.start_timestamp == "number" ? ta.start_timestamp * 1e3 : Date.now()),
		aa = typeof ta.timestamp == "number" ? ta.timestamp * 1e3 : Date.now();
	return {
		event_id: ue,
		timestamp: new Date(ia).toISOString(),
		platform: "javascript",
		version: "1",
		release: ta.release || "",
		environment: ta.environment || DEFAULT_ENVIRONMENT,
		runtime: {
			name: "javascript",
			version: WINDOW$2.navigator.userAgent
		},
		os: {
			name: OS_PLATFORM,
			version: OS_PLATFORM_VERSION,
			build_number: OS_BROWSER
		},
		device: {
			locale: OS_LOCALE,
			model: OS_MODEL,
			manufacturer: OS_BROWSER,
			architecture: OS_ARCH,
			is_emulator: !1
		},
		debug_meta: {
			images: applyDebugMetadata(ea.resources)
		},
		profile: ra,
		transactions: [{
			name: ta.transaction || "",
			id: ta.event_id || uuid4(),
			trace_id: na,
			active_thread_id: THREAD_ID_STRING,
			relative_start_ns: "0",
			relative_end_ns: ((aa - ia) * 1e6).toFixed(0)
		}]
	}
}

function isAutomatedPageLoadTransaction(ue) {
	return ue.op === "pageload"
}

function convertJSSelfProfileToSampledFormat(ue) {
	let Yi, ea = 0;
	const ta = {
		samples: [],
		stacks: [],
		frames: [],
		thread_metadata: {
			[THREAD_ID_STRING]: {
				name: THREAD_NAME
			}
		}
	};
	if (!ue.samples.length) return ta;
	const na = ue.samples[0].timestamp,
		ra = typeof performance.timeOrigin == "number" ? performance.timeOrigin : browserPerformanceTimeOrigin || 0,
		ia = ra - (browserPerformanceTimeOrigin || ra);
	for (let aa = 0; aa < ue.samples.length; aa++) {
		const oa = ue.samples[aa];
		if (oa.stackId === void 0) {
			Yi === void 0 && (Yi = ea, ta.stacks[Yi] = [], ea++), ta.samples[aa] = {
				elapsed_since_start_ns: ((oa.timestamp + ia - na) * MS_TO_NS).toFixed(0),
				stack_id: Yi,
				thread_id: THREAD_ID_STRING
			};
			continue
		}
		let la = ue.stacks[oa.stackId];
		const sa = [];
		for (; la;) {
			sa.push(la.frameId);
			const ua = ue.frames[la.frameId];
			ta.frames[la.frameId] === void 0 && (ta.frames[la.frameId] = {
				function: ua.name,
				abs_path: typeof ua.resourceId == "number" ? ue.resources[ua.resourceId] : void 0,
				lineno: ua.line,
				colno: ua.column
			}), la = la.parentId === void 0 ? void 0 : ue.stacks[la.parentId]
		}
		const ca = {
			elapsed_since_start_ns: ((oa.timestamp + ia - na) * MS_TO_NS).toFixed(0),
			stack_id: ea,
			thread_id: THREAD_ID_STRING
		};
		ta.stacks[ea] = sa, ta.samples[aa] = ca, ea++
	}
	return ta
}

function addProfilesToEnvelope(ue, Yi) {
	if (!Yi.length) return ue;
	for (const ea of Yi) ue[1].push([{
		type: "profile"
	}, ea]);
	return ue
}

function findProfiledTransactionsFromEnvelope(ue) {
	const Yi = [];
	return forEachEnvelopeItem(ue, (ea, ta) => {
		if (ta === "transaction")
			for (let na = 1; na < ea.length; na++) {
				const ra = ea[na];
				ra && ra.contexts && ra.contexts.profile && ra.contexts.profile.profile_id && Yi.push(ea[na])
			}
	}), Yi
}
const debugIdStackParserCache = new WeakMap;

function applyDebugMetadata(ue) {
	const Yi = GLOBAL_OBJ._sentryDebugIds;
	if (!Yi) return [];
	const ea = getClient(),
		ta = ea && ea.getOptions(),
		na = ta && ta.stackParser;
	if (!na) return [];
	let ra;
	const ia = debugIdStackParserCache.get(na);
	ia ? ra = ia : (ra = new Map, debugIdStackParserCache.set(na, ra));
	const aa = Object.keys(Yi).reduce((la, sa) => {
			let ca;
			const ua = ra.get(sa);
			ua ? ca = ua : (ca = na(sa), ra.set(sa, ca));
			for (let da = ca.length - 1; da >= 0; da--) {
				const ha = ca[da],
					pa = ha && ha.filename;
				if (ha && pa) {
					la[pa] = Yi[sa];
					break
				}
			}
			return la
		}, {}),
		oa = [];
	for (const la of ue) la && aa[la] && oa.push({
		type: "sourcemap",
		code_file: la,
		debug_id: aa[la]
	});
	return oa
}

function isValidSampleRate(ue) {
	return typeof ue != "number" && typeof ue != "boolean" || typeof ue == "number" && isNaN(ue) ? (DEBUG_BUILD$3 && logger.warn(`[Profiling] Invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(ue)} of type ${JSON.stringify(typeof ue)}.`), !1) : ue === !0 || ue === !1 ? !0 : ue < 0 || ue > 1 ? (DEBUG_BUILD$3 && logger.warn(`[Profiling] Invalid sample rate. Sample rate must be between 0 and 1. Got ${ue}.`), !1) : !0
}

function isValidProfile(ue) {
	return ue.samples.length < 2 ? (DEBUG_BUILD$3 && logger.log("[Profiling] Discarding profile because it contains less than 2 samples"), !1) : ue.frames.length ? !0 : (DEBUG_BUILD$3 && logger.log("[Profiling] Discarding profile because it contains no frames"), !1)
}
let PROFILING_CONSTRUCTOR_FAILED = !1;
const MAX_PROFILE_DURATION_MS = 3e4;

function isJSProfilerSupported(ue) {
	return typeof ue == "function"
}

function startJSSelfProfile() {
	const ue = WINDOW$2.Profiler;
	if (!isJSProfilerSupported(ue)) {
		DEBUG_BUILD$3 && logger.log("[Profiling] Profiling is not supported by this browser, Profiler interface missing on window object.");
		return
	}
	const Yi = 10,
		ea = Math.floor(MAX_PROFILE_DURATION_MS / Yi);
	try {
		return new ue({
			sampleInterval: Yi,
			maxBufferSize: ea
		})
	} catch {
		DEBUG_BUILD$3 && (logger.log("[Profiling] Failed to initialize the Profiling constructor, this is likely due to a missing 'Document-Policy': 'js-profiling' header."), logger.log("[Profiling] Disabling profiling for current user session.")), PROFILING_CONSTRUCTOR_FAILED = !0
	}
}

function shouldProfileTransaction(ue) {
	if (PROFILING_CONSTRUCTOR_FAILED) return DEBUG_BUILD$3 && logger.log("[Profiling] Profiling has been disabled for the duration of the current user session."), !1;
	if (!ue.isRecording()) return DEBUG_BUILD$3 && logger.log("[Profiling] Discarding profile because transaction was not sampled."), !1;
	const Yi = getClient(),
		ea = Yi && Yi.getOptions();
	if (!ea) return DEBUG_BUILD$3 && logger.log("[Profiling] Profiling disabled, no options found."), !1;
	const ta = ea.profilesSampleRate;
	return isValidSampleRate(ta) ? ta ? (ta === !0 ? !0 : Math.random() < ta) ? !0 : (DEBUG_BUILD$3 && logger.log(`[Profiling] Discarding profile because it's not included in the random sample (sampling rate = ${Number(ta)})`), !1) : (DEBUG_BUILD$3 && logger.log("[Profiling] Discarding profile because a negative sampling decision was inherited or profileSampleRate is set to 0"), !1) : (DEBUG_BUILD$3 && logger.warn("[Profiling] Discarding profile because of invalid sample rate."), !1)
}

function createProfilingEvent(ue, Yi, ea, ta) {
	return isValidProfile(ea) ? createProfilePayload(ue, Yi, ea, ta) : null
}
const PROFILE_MAP = new Map;

function getActiveProfilesCount() {
	return PROFILE_MAP.size
}

function takeProfileFromGlobalCache(ue) {
	const Yi = PROFILE_MAP.get(ue);
	return Yi && PROFILE_MAP.delete(ue), Yi
}

function addProfileToGlobalCache(ue, Yi) {
	if (PROFILE_MAP.set(ue, Yi), PROFILE_MAP.size > 30) {
		const ea = PROFILE_MAP.keys().next().value;
		PROFILE_MAP.delete(ea)
	}
}

function onProfilingStartRouteTransaction(ue) {
	return ue ? shouldProfileTransaction(ue) ? startProfileForTransaction(ue) : ue : (DEBUG_BUILD$3 && logger.log("[Profiling] Transaction is undefined, skipping profiling"), ue)
}

function startProfileForTransaction(ue) {
	let Yi;
	isAutomatedPageLoadTransaction(ue) && (Yi = timestampInSeconds() * 1e3);
	const ea = startJSSelfProfile();
	if (!ea) return ue;
	DEBUG_BUILD$3 && logger.log(`[Profiling] started profiling transaction: ${spanToJSON(ue).description}`);
	const ta = uuid4();
	async function na() {
		return !ue || !ea ? null : ea.stop().then(oa => (ra && (WINDOW$2.clearTimeout(ra), ra = void 0), DEBUG_BUILD$3 && logger.log(`[Profiling] stopped profiling of transaction: ${spanToJSON(ue).description}`), oa ? (addProfileToGlobalCache(ta, oa), null) : (DEBUG_BUILD$3 && logger.log(`[Profiling] profiler returned null profile for: ${spanToJSON(ue).description}`, "this may indicate an overlapping transaction or a call to stopProfiling with a profile title that was never started"), null))).catch(oa => (DEBUG_BUILD$3 && logger.log("[Profiling] error while stopping profiler:", oa), null))
	}
	let ra = WINDOW$2.setTimeout(() => {
		DEBUG_BUILD$3 && logger.log("[Profiling] max profile duration elapsed, stopping profiling for:", spanToJSON(ue).description), na()
	}, MAX_PROFILE_DURATION_MS);
	const ia = ue.end.bind(ue);

	function aa() {
		return ue ? (na().then(() => {
			ue.setContext("profile", {
				profile_id: ta,
				start_timestamp: Yi
			}), ia()
		}, () => {
			ia()
		}), ue) : ia()
	}
	return ue.end = aa, ue
}
const INTEGRATION_NAME$1 = "BrowserProfiling",
	_browserProfilingIntegration = () => ({
		name: INTEGRATION_NAME$1,
		setupOnce() {},
		setup(ue) {
			const ea = getCurrentScope().getTransaction();
			if (ea && isAutomatedPageLoadTransaction(ea) && shouldProfileTransaction(ea) && startProfileForTransaction(ea), typeof ue.on != "function") {
				logger.warn("[Profiling] Client does not support hooks, profiling will be disabled");
				return
			}
			ue.on("startTransaction", ta => {
				shouldProfileTransaction(ta) && startProfileForTransaction(ta)
			}), ue.on("beforeEnvelope", ta => {
				if (!getActiveProfilesCount()) return;
				const na = findProfiledTransactionsFromEnvelope(ta);
				if (!na.length) return;
				const ra = [];
				for (const ia of na) {
					const aa = ia && ia.contexts,
						oa = aa && aa.profile && aa.profile.profile_id,
						la = aa && aa.profile && aa.profile.start_timestamp;
					if (typeof oa != "string") {
						DEBUG_BUILD$3 && logger.log("[Profiling] cannot find profile for a transaction without a profile context");
						continue
					}
					if (!oa) {
						DEBUG_BUILD$3 && logger.log("[Profiling] cannot find profile for a transaction without a profile context");
						continue
					}
					aa && aa.profile && delete aa.profile;
					const sa = takeProfileFromGlobalCache(oa);
					if (!sa) {
						DEBUG_BUILD$3 && logger.log(`[Profiling] Could not retrieve profile for transaction: ${oa}`);
						continue
					}
					const ca = createProfilingEvent(oa, la, sa, ia);
					ca && ra.push(ca)
				}
				addProfilesToEnvelope(ta, ra)
			})
		}
	}),
	browserProfilingIntegration = _browserProfilingIntegration,
	BrowserProfilingIntegration = convertIntegrationFnToClass(INTEGRATION_NAME$1, browserProfilingIntegration);
let windowIntegrations = {};
WINDOW$2.Sentry && WINDOW$2.Sentry.Integrations && (windowIntegrations = WINDOW$2.Sentry.Integrations);
const INTEGRATIONS = {
		...windowIntegrations,
		...Integrations,
		...index
	},
	DEFAULT_HOOKS = ["activate", "mount", "update"],
	classifyRE = /(?:^|[-_])(\w)/g,
	classify = ue => ue.replace(classifyRE, Yi => Yi.toUpperCase()).replace(/[-_]/g, ""),
	ROOT_COMPONENT_NAME = "<Root>",
	ANONYMOUS_COMPONENT_NAME = "<Anonymous>",
	repeat = (ue, Yi) => ue.repeat ? ue.repeat(Yi) : ue,
	formatComponentName = (ue, Yi) => {
		if (!ue) return ANONYMOUS_COMPONENT_NAME;
		if (ue.$root === ue) return ROOT_COMPONENT_NAME;
		if (!ue.$options) return ANONYMOUS_COMPONENT_NAME;
		const ea = ue.$options;
		let ta = ea.name || ea._componentTag;
		const na = ea.__file;
		if (!ta && na) {
			const ra = na.match(/([^/\\]+)\.vue$/);
			ra && (ta = ra[1])
		}
		return (ta ? `<${classify(ta)}>` : ANONYMOUS_COMPONENT_NAME) + (na && Yi !== !1 ? ` at ${na}` : "")
	},
	generateComponentTrace = ue => {
		if (ue && (ue._isVue || ue.__isVue) && ue.$parent) {
			const Yi = [];
			let ea = 0;
			for (; ue;) {
				if (Yi.length > 0) {
					const na = Yi[Yi.length - 1];
					if (na.constructor === ue.constructor) {
						ea++, ue = ue.$parent;
						continue
					} else ea > 0 && (Yi[Yi.length - 1] = [na, ea], ea = 0)
				}
				Yi.push(ue), ue = ue.$parent
			}
			return `

found in

${Yi.map((na,ra)=>`${(ra===0?"---> ":repeat(" ",5+ra*2))+(Array.isArray(na)?`${formatComponentName(na[0])}... (${na[1]} recursive calls)`:formatComponentName(na))}`).join(`
`)}`
		}
		return `

(found in ${formatComponentName(ue)})`
	},
	attachErrorHandler = (ue, Yi) => {
		const {
			errorHandler: ea,
			warnHandler: ta,
			silent: na
		} = ue.config;
		ue.config.errorHandler = (ra, ia, aa) => {
			const oa = formatComponentName(ia, !1),
				la = ia ? generateComponentTrace(ia) : "",
				sa = {
					componentName: oa,
					lifecycleHook: aa,
					trace: la
				};
			if (Yi.attachProps && ia && (ia.$options && ia.$options.propsData ? sa.propsData = ia.$options.propsData : ia.$props && (sa.propsData = ia.$props)), setTimeout(() => {
					captureException(ra, {
						captureContext: {
							contexts: {
								vue: sa
							}
						},
						mechanism: {
							handled: !1
						}
					})
				}), typeof ea == "function" && ea.call(ue, ra, ia, aa), Yi.logErrors) {
				const ca = typeof console < "u",
					ua = `Error in ${aa}: "${ra&&ra.toString()}"`;
				ta ? ta.call(null, ua, ia, la) : ca && !na && consoleSandbox(() => {
					console.error(`[Vue warn]: ${ua}${la}`)
				})
			}
		}
	},
	DEBUG_BUILD = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
	VUE_OP = "ui.vue",
	HOOKS = {
		activate: ["activated", "deactivated"],
		create: ["beforeCreate", "created"],
		unmount: ["beforeUnmount", "unmounted"],
		destroy: ["beforeDestroy", "destroyed"],
		mount: ["beforeMount", "mounted"],
		update: ["beforeUpdate", "updated"]
	};

function getActiveTransaction() {
	return getCurrentScope().getTransaction()
}

function finishRootSpan(ue, Yi, ea) {
	ue.$_sentryRootSpanTimer && clearTimeout(ue.$_sentryRootSpanTimer), ue.$_sentryRootSpanTimer = setTimeout(() => {
		ue.$root && ue.$root.$_sentryRootSpan && (ue.$root.$_sentryRootSpan.end(Yi), ue.$root.$_sentryRootSpan = void 0)
	}, ea)
}
const createTracingMixins = ue => {
		const Yi = (ue.hooks || []).concat(DEFAULT_HOOKS).filter((ta, na, ra) => ra.indexOf(ta) === na),
			ea = {};
		for (const ta of Yi) {
			const na = HOOKS[ta];
			if (!na) {
				DEBUG_BUILD && logger.warn(`Unknown hook: ${ta}`);
				continue
			}
			for (const ra of na) ea[ra] = function() {
				const ia = this.$root === this;
				ia && getActiveSpan() && (this.$_sentryRootSpan = this.$_sentryRootSpan || startInactiveSpan({
					name: "Application Render",
					op: `${VUE_OP}.render`,
					origin: "auto.ui.vue"
				}));
				const aa = formatComponentName(this, !1),
					oa = Array.isArray(ue.trackComponents) ? ue.trackComponents.indexOf(aa) > -1 : ue.trackComponents;
				if (!(!ia && !oa))
					if (this.$_sentrySpans = this.$_sentrySpans || {}, ra == na[0]) {
						if (this.$root && this.$root.$_sentryRootSpan || getActiveSpan()) {
							const sa = this.$_sentrySpans[ta];
							sa && sa.end(), this.$_sentrySpans[ta] = startInactiveSpan({
								name: `Vue <${aa}>`,
								op: `${VUE_OP}.${ta}`,
								origin: "auto.ui.vue"
							})
						}
					} else {
						const la = this.$_sentrySpans[ta];
						if (!la) return;
						la.end(), finishRootSpan(this, timestampInSeconds(), ue.timeout)
					}
			}
		}
		return ea
	},
	globalWithVue = GLOBAL_OBJ,
	DEFAULT_CONFIG = {
		Vue: globalWithVue.Vue,
		attachProps: !0,
		logErrors: !0,
		hooks: DEFAULT_HOOKS,
		timeout: 2e3,
		trackComponents: !1
	},
	INTEGRATION_NAME = "Vue",
	_vueIntegration = (ue = {}) => ({
		name: INTEGRATION_NAME,
		setupOnce() {},
		setup(Yi) {
			_setupIntegration(Yi, ue)
		}
	}),
	vueIntegration = _vueIntegration,
	VueIntegration = convertIntegrationFnToClass(INTEGRATION_NAME, vueIntegration);

function _setupIntegration(ue, Yi) {
	const ea = {
		...DEFAULT_CONFIG,
		...ue.getOptions(),
		...Yi
	};
	if (!ea.Vue && !ea.app) {
		consoleSandbox(() => {
			console.warn("[@sentry/vue]: Misconfigured SDK. Vue specific errors will not be captured.\nUpdate your `Sentry.init` call with an appropriate config option:\n`app` (Application Instance - Vue 3) or `Vue` (Vue Constructor - Vue 2).")
		});
		return
	}
	ea.app ? arrayify(ea.app).forEach(na => vueInit(na, ea)) : ea.Vue && vueInit(ea.Vue, ea)
}
const vueInit = (ue, Yi) => {
	const ea = ue;
	(ea._instance && ea._instance.isMounted) === !0 && consoleSandbox(() => {
		console.warn("[@sentry/vue]: Misconfigured SDK. Vue app is already mounted. Make sure to call `app.mount()` after `Sentry.init()`.")
	}), attachErrorHandler(ue, Yi), hasTracingEnabled(Yi) && ue.mixin(createTracingMixins({
		...Yi,
		...Yi.tracingOptions
	}))
};

function init(ue = {}) {
	const Yi = {
		_metadata: {
			sdk: {
				name: "sentry.javascript.vue",
				packages: [{
					name: "npm:@sentry/vue",
					version: SDK_VERSION
				}],
				version: SDK_VERSION
			}
		},
		defaultIntegrations: [...getDefaultIntegrations(), vueIntegration()],
		...ue
	};
	init$1(Yi)
}

function vueRouterInstrumentation(ue, Yi = {}) {
	return (ea, ta = !0, na = !0) => {
		ta && WINDOW$2 && WINDOW$2.location && ea({
			name: WINDOW$2.location.pathname,
			op: "pageload",
			attributes: {
				[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.pageload.vue",
				[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "url"
			}
		}), instrumentVueRouter(ue, {
			routeLabel: Yi.routeLabel || "name",
			instrumentNavigation: na,
			instrumentPageLoad: ta
		}, ea)
	}
}

function instrumentVueRouter(ue, Yi, ea) {
	ue.onError(ta => captureException(ta, {
		mechanism: {
			handled: !1
		}
	})), ue.beforeEach((ta, na, ra) => {
		const ia = na.name == null && na.matched.length === 0,
			aa = {
				[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.navigation.vue"
			};
		for (const sa of Object.keys(ta.params)) aa[`params.${sa}`] = ta.params[sa];
		for (const sa of Object.keys(ta.query)) {
			const ca = ta.query[sa];
			ca && (aa[`query.${sa}`] = ca)
		}
		let oa = ta.path,
			la = "url";
		if (ta.name && Yi.routeLabel !== "path" ? (oa = ta.name.toString(), la = "custom") : ta.matched[0] && ta.matched[0].path && (oa = ta.matched[0].path, la = "route"), Yi.instrumentPageLoad && ia) {
			const sa = getActiveTransaction();
			sa && ((spanToJSON(sa).data || {})[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] !== "custom" && (sa.updateName(oa), sa.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, la)), sa.setAttributes({
				...aa,
				[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.pageload.vue"
			}))
		}
		Yi.instrumentNavigation && !ia && (aa[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = la, ea({
			name: oa,
			op: "navigation",
			attributes: aa
		})), ra && ra()
	})
}

function browserTracingIntegration(ue = {}) {
	if (!ue.router) return browserTracingIntegration$1(ue);
	const Yi = browserTracingIntegration$1({
			...ue,
			instrumentNavigation: !1
		}),
		{
			router: ea,
			instrumentNavigation: ta = !0,
			instrumentPageLoad: na = !0,
			routeLabel: ra = "name"
		} = ue;
	return {
		...Yi,
		afterAllSetup(ia) {
			Yi.afterAllSetup(ia), instrumentVueRouter(ea, {
				routeLabel: ra,
				instrumentNavigation: ta,
				instrumentPageLoad: na
			}, oa => {
				startBrowserTracingNavigationSpan(ia, oa)
			})
		}
	}
}
const Sentry = Object.freeze(Object.defineProperty({
	__proto__: null,
	Breadcrumbs,
	BrowserClient,
	BrowserProfilingIntegration,
	BrowserTracing,
	Dedupe,
	Feedback,
	FunctionToString,
	GlobalHandlers,
	HttpContext,
	Hub,
	InboundFilters,
	Integrations: INTEGRATIONS,
	LinkedErrors,
	ModuleMetadata,
	Replay: Replay$1,
	ReplayCanvas,
	SDK_VERSION,
	SEMANTIC_ATTRIBUTE_SENTRY_OP,
	SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,
	SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE,
	SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,
	Scope,
	TryCatch,
	VueIntegration,
	WINDOW: WINDOW$2,
	addBreadcrumb,
	addEventProcessor,
	addGlobalEventProcessor,
	addIntegration,
	addTracingExtensions,
	attachErrorHandler,
	breadcrumbsIntegration,
	browserApiErrorsIntegration,
	browserProfilingIntegration,
	browserTracingIntegration,
	captureEvent,
	captureException,
	captureMessage,
	captureSession,
	captureUserFeedback,
	chromeStackLineParser,
	close,
	configureScope,
	continueTrace,
	createTracingMixins,
	createTransport,
	createUserFeedbackEnvelope,
	dedupeIntegration,
	defaultIntegrations,
	defaultRequestInstrumentationOptions,
	defaultStackLineParsers,
	defaultStackParser,
	endSession,
	eventFromException,
	eventFromMessage,
	exceptionFromError,
	extractTraceparentData,
	feedbackIntegration,
	flush,
	forceLoad,
	functionToStringIntegration,
	geckoStackLineParser,
	getActiveSpan,
	getActiveTransaction: getActiveTransaction$1,
	getClient,
	getCurrentHub,
	getCurrentScope,
	getDefaultIntegrations,
	getHubFromCarrier,
	getReplay: getReplay$1,
	getSpanStatusFromHttpCode,
	globalHandlersIntegration,
	httpContextIntegration,
	inboundFiltersIntegration,
	init,
	instrumentOutgoingRequests,
	isInitialized,
	lastEventId,
	linkedErrorsIntegration,
	makeBrowserOfflineTransport,
	makeFetchTransport,
	makeMain,
	makeMultiplexedTransport,
	makeXHRTransport,
	metrics,
	moduleMetadataIntegration,
	onLoad,
	onProfilingStartRouteTransaction,
	opera10StackLineParser,
	opera11StackLineParser,
	parameterize,
	replayCanvasIntegration,
	replayIntegration: replayIntegration$1,
	sendFeedback,
	setContext,
	setCurrentClient,
	setExtra,
	setExtras,
	setHttpStatus,
	setMeasurement,
	setTag,
	setTags,
	setUser,
	showReportDialog,
	spanStatusfromHttpCode,
	startBrowserTracingNavigationSpan,
	startBrowserTracingPageLoadSpan,
	startInactiveSpan,
	startSession,
	startSpan,
	startSpanManual,
	startTransaction,
	trace,
	vueIntegration,
	vueRouterInstrumentation,
	winjsStackLineParser,
	withActiveSpan,
	withIsolationScope,
	withScope,
	wrap
}, Symbol.toStringTag, {
	value: "Module"
}));

function e(ue, Yi) {
	var ea = Object.keys(ue);
	if (Object.getOwnPropertySymbols) {
		var ta = Object.getOwnPropertySymbols(ue);
		Yi && (ta = ta.filter(function(na) {
			return Object.getOwnPropertyDescriptor(ue, na).enumerable
		})), ea.push.apply(ea, ta)
	}
	return ea
}

function t(ue) {
	for (var Yi = 1; Yi < arguments.length; Yi++) {
		var ea = arguments[Yi] != null ? arguments[Yi] : {};
		Yi % 2 ? e(Object(ea), !0).forEach(function(ta) {
			o(ue, ta, ea[ta])
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ue, Object.getOwnPropertyDescriptors(ea)) : e(Object(ea)).forEach(function(ta) {
			Object.defineProperty(ue, ta, Object.getOwnPropertyDescriptor(ea, ta))
		})
	}
	return ue
}

function n(ue) {
	return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Yi) {
		return typeof Yi
	} : function(Yi) {
		return Yi && typeof Symbol == "function" && Yi.constructor === Symbol && Yi !== Symbol.prototype ? "symbol" : typeof Yi
	}, n(ue)
}

function i(ue, Yi) {
	if (!(ue instanceof Yi)) throw new TypeError("Cannot call a class as a function")
}

function r(ue, Yi) {
	for (var ea = 0; ea < Yi.length; ea++) {
		var ta = Yi[ea];
		ta.enumerable = ta.enumerable || !1, ta.configurable = !0, "value" in ta && (ta.writable = !0), Object.defineProperty(ue, ta.key, ta)
	}
}

function s(ue, Yi, ea) {
	return Yi && r(ue.prototype, Yi), ea && r(ue, ea), Object.defineProperty(ue, "prototype", {
		writable: !1
	}), ue
}

function o(ue, Yi, ea) {
	return Yi in ue ? Object.defineProperty(ue, Yi, {
		value: ea,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : ue[Yi] = ea, ue
}

function a(ue, Yi) {
	if (ue == null) return {};
	var ea, ta, na = function(ia, aa) {
		if (ia == null) return {};
		var oa, la, sa = {},
			ca = Object.keys(ia);
		for (la = 0; la < ca.length; la++) oa = ca[la], aa.indexOf(oa) >= 0 || (sa[oa] = ia[oa]);
		return sa
	}(ue, Yi);
	if (Object.getOwnPropertySymbols) {
		var ra = Object.getOwnPropertySymbols(ue);
		for (ta = 0; ta < ra.length; ta++) ea = ra[ta], Yi.indexOf(ea) >= 0 || Object.prototype.propertyIsEnumerable.call(ue, ea) && (na[ea] = ue[ea])
	}
	return na
}

function u(ue, Yi) {
	return function(ea) {
		if (Array.isArray(ea)) return ea
	}(ue) || function(ea, ta) {
		var na = ea == null ? null : typeof Symbol < "u" && ea[Symbol.iterator] || ea["@@iterator"];
		if (na != null) {
			var ra, ia, aa = [],
				oa = !0,
				la = !1;
			try {
				for (na = na.call(ea); !(oa = (ra = na.next()).done) && (aa.push(ra.value), !ta || aa.length !== ta); oa = !0);
			} catch (sa) {
				la = !0, ia = sa
			} finally {
				try {
					oa || na.return == null || na.return()
				} finally {
					if (la) throw ia
				}
			}
			return aa
		}
	}(ue, Yi) || c(ue, Yi) || function() {
		throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
	}()
}

function l(ue) {
	return function(Yi) {
		if (Array.isArray(Yi)) return d(Yi)
	}(ue) || function(Yi) {
		if (typeof Symbol < "u" && Yi[Symbol.iterator] != null || Yi["@@iterator"] != null) return Array.from(Yi)
	}(ue) || c(ue) || function() {
		throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
	}()
}

function c(ue, Yi) {
	if (ue) {
		if (typeof ue == "string") return d(ue, Yi);
		var ea = Object.prototype.toString.call(ue).slice(8, -1);
		return ea === "Object" && ue.constructor && (ea = ue.constructor.name), ea === "Map" || ea === "Set" ? Array.from(ue) : ea === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(ea) ? d(ue, Yi) : void 0
	}
}

function d(ue, Yi) {
	(Yi == null || Yi > ue.length) && (Yi = ue.length);
	for (var ea = 0, ta = new Array(Yi); ea < Yi; ea++) ta[ea] = ue[ea];
	return ta
}

function h(ue, Yi) {
	var ea = typeof Symbol < "u" && ue[Symbol.iterator] || ue["@@iterator"];
	if (!ea) {
		if (Array.isArray(ue) || (ea = c(ue)) || Yi) {
			ea && (ue = ea);
			var ta = 0,
				na = function() {};
			return {
				s: na,
				n: function() {
					return ta >= ue.length ? {
						done: !0
					} : {
						done: !1,
						value: ue[ta++]
					}
				},
				e: function(oa) {
					throw oa
				},
				f: na
			}
		}
		throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
	}
	var ra, ia = !0,
		aa = !1;
	return {
		s: function() {
			ea = ea.call(ue)
		},
		n: function() {
			var oa = ea.next();
			return ia = oa.done, oa
		},
		e: function(oa) {
			aa = !0, ra = oa
		},
		f: function() {
			try {
				ia || ea.return == null || ea.return()
			} finally {
				if (aa) throw ra
			}
		}
	}
}
var f = {
		DEBUG: !1,
		LIB_VERSION: "1.160.0"
	},
	v = Array.isArray,
	p = Object.prototype,
	g = p.hasOwnProperty,
	_ = p.toString,
	m = v || function(ue) {
		return _.call(ue) === "[object Array]"
	},
	y = function(ue) {
		return typeof ue == "function"
	},
	b = function(ue) {
		return ue === Object(ue) && !m(ue)
	},
	k = function(ue) {
		if (b(ue)) {
			for (var Yi in ue)
				if (g.call(ue, Yi)) return !1;
			return !0
		}
		return !1
	},
	w = function(ue) {
		return ue === void 0
	},
	S = function(ue) {
		return _.call(ue) == "[object String]"
	},
	E = function(ue) {
		return S(ue) && ue.trim().length === 0
	},
	I = function(ue) {
		return ue === null
	},
	R = function(ue) {
		return w(ue) || I(ue)
	},
	F = function(ue) {
		return _.call(ue) == "[object Number]"
	},
	x = function(ue) {
		return _.call(ue) === "[object Boolean]"
	},
	P = function(ue) {
		return ue instanceof FormData
	},
	T = typeof window < "u" ? window : void 0,
	C = typeof globalThis < "u" ? globalThis : T,
	$ = Array.prototype,
	O = $.forEach,
	M = $.indexOf,
	A = C == null ? void 0 : C.navigator,
	L = C == null ? void 0 : C.document,
	D = C == null ? void 0 : C.location,
	q = C == null ? void 0 : C.fetch,
	N = C != null && C.XMLHttpRequest && "withCredentials" in new C.XMLHttpRequest ? C.XMLHttpRequest : void 0,
	B = C == null ? void 0 : C.AbortController,
	H = A == null ? void 0 : A.userAgent,
	U = T ?? {},
	j = "[PostHog.js]",
	G = {
		_log: function(ue) {
			if (T && (f.DEBUG || U.POSTHOG_DEBUG) && !w(T.console) && T.console) {
				for (var Yi = ("__rrweb_original__" in T.console[ue]) ? T.console[ue].__rrweb_original__ : T.console[ue], ea = arguments.length, ta = new Array(ea > 1 ? ea - 1 : 0), na = 1; na < ea; na++) ta[na - 1] = arguments[na];
				Yi.apply(void 0, [j].concat(ta))
			}
		},
		info: function() {
			for (var ue = arguments.length, Yi = new Array(ue), ea = 0; ea < ue; ea++) Yi[ea] = arguments[ea];
			G._log.apply(G, ["log"].concat(Yi))
		},
		warn: function() {
			for (var ue = arguments.length, Yi = new Array(ue), ea = 0; ea < ue; ea++) Yi[ea] = arguments[ea];
			G._log.apply(G, ["warn"].concat(Yi))
		},
		error: function() {
			for (var ue = arguments.length, Yi = new Array(ue), ea = 0; ea < ue; ea++) Yi[ea] = arguments[ea];
			G._log.apply(G, ["error"].concat(Yi))
		},
		critical: function() {
			for (var ue, Yi = arguments.length, ea = new Array(Yi), ta = 0; ta < Yi; ta++) ea[ta] = arguments[ta];
			(ue = console).error.apply(ue, [j].concat(ea))
		},
		uninitializedWarning: function(ue) {
			G.error("You must initialize PostHog before calling ".concat(ue))
		}
	},
	W = {},
	V = function(ue) {
		return ue.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
	};

function z(ue, Yi, ea) {
	if (m(ue)) {
		if (O && ue.forEach === O) ue.forEach(Yi, ea);
		else if ("length" in ue && ue.length === +ue.length) {
			for (var ta = 0, na = ue.length; ta < na; ta++)
				if (ta in ue && Yi.call(ea, ue[ta], ta) === W) return
		}
	}
}

function Q(ue, Yi, ea) {
	if (!R(ue)) {
		if (m(ue)) return z(ue, Yi, ea);
		if (P(ue)) {
			var ta, na = h(ue.entries());
			try {
				for (na.s(); !(ta = na.n()).done;) {
					var ra = ta.value;
					if (Yi.call(ea, ra[1], ra[0]) === W) return
				}
			} catch (aa) {
				na.e(aa)
			} finally {
				na.f()
			}
		} else
			for (var ia in ue)
				if (g.call(ue, ia) && Yi.call(ea, ue[ia], ia) === W) return
	}
}
var J = function(ue) {
	for (var Yi = arguments.length, ea = new Array(Yi > 1 ? Yi - 1 : 0), ta = 1; ta < Yi; ta++) ea[ta - 1] = arguments[ta];
	return z(ea, function(na) {
		for (var ra in na) na[ra] !== void 0 && (ue[ra] = na[ra])
	}), ue
};

function Y(ue, Yi) {
	return ue.indexOf(Yi) !== -1
}

function X(ue) {
	for (var Yi = Object.keys(ue), ea = Yi.length, ta = new Array(ea); ea--;) ta[ea] = [Yi[ea], ue[Yi[ea]]];
	return ta
}
var K = function() {
		return Date.now = Date.now || function() {
			return +new Date
		}, Date.now()
	},
	Z = function(ue) {
		try {
			return ue()
		} catch {
			return
		}
	},
	ee = function(ue) {
		return function() {
			try {
				for (var Yi = arguments.length, ea = new Array(Yi), ta = 0; ta < Yi; ta++) ea[ta] = arguments[ta];
				return ue.apply(this, ea)
			} catch (na) {
				G.critical("Implementation error. Please turn on debug mode and open a ticket on https://app.posthog.com/home#panel=support%3Asupport%3A."), G.critical(na)
			}
		}
	},
	te = function(ue) {
		var Yi = {};
		return Q(ue, function(ea, ta) {
			S(ea) && ea.length > 0 && (Yi[ta] = ea)
		}), Yi
	},
	ne = function(ue) {
		return ue.replace(/^\$/, "")
	};

function ie(ue, Yi) {
	return ea = ue, ta = function(ra) {
			return S(ra) && !I(Yi) ? ra.slice(0, Yi) : ra
		}, na = new Set,
		function ra(ia, aa) {
			return ia !== Object(ia) ? ta ? ta(ia, aa) : ia : na.has(ia) ? void 0 : (na.add(ia), m(ia) ? (oa = [], z(ia, function(la) {
				oa.push(ra(la))
			})) : (oa = {}, Q(ia, function(la, sa) {
				na.has(la) || (oa[sa] = ra(la, sa))
			})), oa);
			var oa
		}(ea);
	var ea, ta, na
}
var re, se = function(ue) {
		var Yi, ea, ta, na, ra = "";
		for (Yi = ea = 0, ta = (ue = (ue + "").replace(/\r\n/g, `
`).replace(/\r/g, `
`)).length, na = 0; na < ta; na++) {
			var ia = ue.charCodeAt(na),
				aa = null;
			ia < 128 ? ea++ : aa = ia > 127 && ia < 2048 ? String.fromCharCode(ia >> 6 | 192, 63 & ia | 128) : String.fromCharCode(ia >> 12 | 224, ia >> 6 & 63 | 128, 63 & ia | 128), I(aa) || (ea > Yi && (ra += ue.substring(Yi, ea)), ra += aa, Yi = ea = na + 1)
		}
		return ea > Yi && (ra += ue.substring(Yi, ue.length)), ra
	},
	oe = function() {
		function ue(Yi) {
			return Yi && (Yi.preventDefault = ue.preventDefault, Yi.stopPropagation = ue.stopPropagation), Yi
		}
		return ue.preventDefault = function() {
				this.returnValue = !1
			}, ue.stopPropagation = function() {
				this.cancelBubble = !0
			},
			function(Yi, ea, ta, na, ra) {
				if (Yi)
					if (Yi.addEventListener && !na) Yi.addEventListener(ea, ta, !!ra);
					else {
						var ia = "on" + ea,
							aa = Yi[ia];
						Yi[ia] = function(oa, la, sa) {
							return function(ca) {
								if (ca = ca || ue(T == null ? void 0 : T.event)) {
									var ua, da = !0;
									y(sa) && (ua = sa(ca));
									var ha = la.call(oa, ca);
									return ua !== !1 && ha !== !1 || (da = !1), da
								}
							}
						}(Yi, ta, aa)
					}
				else G.error("No valid element provided to register_event")
			}
	}();

function ae(ue, Yi) {
	for (var ea = 0; ea < ue.length; ea++)
		if (Yi(ue[ea])) return ue[ea]
}(function(ue) {
	ue.GZipJS = "gzip-js", ue.Base64 = "base64"
})(re || (re = {}));
var le = "$people_distinct_id",
	ce = "__alias",
	de = "__timers",
	he = "$autocapture_disabled_server_side",
	fe = "$heatmaps_enabled_server_side",
	ve = "$exception_capture_enabled_server_side",
	pe = "$exception_capture_endpoint_suffix",
	ge = "$web_vitals_enabled_server_side",
	_e = "$session_recording_enabled_server_side",
	me = "$console_log_recording_enabled_server_side",
	ye = "$session_recording_network_payload_capture",
	be = "$session_recording_canvas_recording",
	ke = "$replay_sample_rate",
	we = "$replay_minimum_duration",
	Se = "$sesid",
	Ee = "$session_is_sampled",
	Ie = "$enabled_feature_flags",
	Re = "$early_access_features",
	Fe = "$stored_person_properties",
	xe = "$stored_group_properties",
	Pe = "$surveys",
	Te = "$surveys_activated",
	Ce = "$flag_call_reported",
	$e = "$user_state",
	Oe = "$client_session_props",
	Me = "$capture_rate_limit",
	Ae = "$initial_campaign_params",
	Le = "$initial_referrer_info",
	De = "$initial_person_info",
	qe = "$epp",
	Ne = "__POSTHOG_TOOLBAR__",
	Be = [le, ce, "__cmpns", de, _e, fe, Se, Ie, $e, Re, xe, Fe, Pe, Ce, Oe, Me, Ae, Le, qe],
	He = "$active_feature_flags",
	Ue = "$override_feature_flags",
	je = "$feature_flag_payloads",
	Ge = function(ue) {
		var Yi, ea = {},
			ta = h(X(ue || {}));
		try {
			for (ta.s(); !(Yi = ta.n()).done;) {
				var na = u(Yi.value, 2),
					ra = na[0],
					ia = na[1];
				ia && (ea[ra] = ia)
			}
		} catch (aa) {
			ta.e(aa)
		} finally {
			ta.f()
		}
		return ea
	},
	We = function() {
		function ue(Yi) {
			i(this, ue), this.instance = Yi, this._override_warning = !1, this.featureFlagEventHandlers = [], this.reloadFeatureFlagsQueued = !1, this.reloadFeatureFlagsInAction = !1
		}
		return s(ue, [{
			key: "getFlags",
			value: function() {
				return Object.keys(this.getFlagVariants())
			}
		}, {
			key: "getFlagVariants",
			value: function() {
				var Yi = this.instance.get_property(Ie),
					ea = this.instance.get_property(Ue);
				if (!ea) return Yi || {};
				for (var ta = J({}, Yi), na = Object.keys(ea), ra = 0; ra < na.length; ra++) ta[na[ra]] = ea[na[ra]];
				return this._override_warning || (G.warn(" Overriding feature flags!", {
					enabledFlags: Yi,
					overriddenFlags: ea,
					finalFlags: ta
				}), this._override_warning = !0), ta
			}
		}, {
			key: "getFlagPayloads",
			value: function() {
				return this.instance.get_property(je) || {}
			}
		}, {
			key: "reloadFeatureFlags",
			value: function() {
				this.reloadFeatureFlagsQueued || (this.reloadFeatureFlagsQueued = !0, this._startReloadTimer())
			}
		}, {
			key: "setAnonymousDistinctId",
			value: function(Yi) {
				this.$anon_distinct_id = Yi
			}
		}, {
			key: "setReloadingPaused",
			value: function(Yi) {
				this.reloadFeatureFlagsInAction = Yi
			}
		}, {
			key: "resetRequestQueue",
			value: function() {
				this.reloadFeatureFlagsQueued = !1
			}
		}, {
			key: "_startReloadTimer",
			value: function() {
				var Yi = this;
				this.reloadFeatureFlagsQueued && !this.reloadFeatureFlagsInAction && setTimeout(function() {
					!Yi.reloadFeatureFlagsInAction && Yi.reloadFeatureFlagsQueued && (Yi.reloadFeatureFlagsQueued = !1, Yi._reloadFeatureFlagsRequest())
				}, 5)
			}
		}, {
			key: "_reloadFeatureFlagsRequest",
			value: function() {
				var Yi = this;
				if (!this.instance.config.advanced_disable_feature_flags) {
					this.setReloadingPaused(!0);
					var ea = this.instance.config.token,
						ta = this.instance.get_property(Fe),
						na = this.instance.get_property(xe),
						ra = {
							token: ea,
							distinct_id: this.instance.get_distinct_id(),
							groups: this.instance.getGroups(),
							$anon_distinct_id: this.$anon_distinct_id,
							person_properties: ta,
							group_properties: na,
							disable_flags: this.instance.config.advanced_disable_feature_flags || void 0
						};
					this.instance._send_request({
						method: "POST",
						url: this.instance.requestRouter.endpointFor("api", "/decide/?v=3"),
						data: ra,
						compression: this.instance.config.disable_compression ? void 0 : re.Base64,
						timeout: this.instance.config.feature_flag_request_timeout_ms,
						callback: function(ia) {
							var aa;
							Yi.setReloadingPaused(!1);
							var oa = !0;
							ia.statusCode === 200 && (Yi.$anon_distinct_id = void 0, oa = !1), Yi.receivedFeatureFlags((aa = ia.json) !== null && aa !== void 0 ? aa : {}, oa), Yi._startReloadTimer()
						}
					})
				}
			}
		}, {
			key: "getFeatureFlag",
			value: function(Yi) {
				var ea = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
				if (this.instance.decideEndpointWasHit || this.getFlags() && this.getFlags().length > 0) {
					var ta, na = this.getFlagVariants()[Yi],
						ra = "".concat(na),
						ia = this.instance.get_property(Ce) || {};
					return (ea.send_event || !("send_event" in ea)) && (!(Yi in ia) || !ia[Yi].includes(ra)) && (m(ia[Yi]) ? ia[Yi].push(ra) : ia[Yi] = [ra], (ta = this.instance.persistence) === null || ta === void 0 || ta.register(o({}, Ce, ia)), this.instance.capture("$feature_flag_called", {
						$feature_flag: Yi,
						$feature_flag_response: na
					})), na
				}
				G.warn('getFeatureFlag for key "' + Yi + `" failed. Feature flags didn't load in time.`)
			}
		}, {
			key: "getFeatureFlagPayload",
			value: function(Yi) {
				return this.getFlagPayloads()[Yi]
			}
		}, {
			key: "isFeatureEnabled",
			value: function(Yi) {
				var ea = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
				if (this.instance.decideEndpointWasHit || this.getFlags() && this.getFlags().length > 0) return !!this.getFeatureFlag(Yi, ea);
				G.warn('isFeatureEnabled for key "' + Yi + `" failed. Feature flags didn't load in time.`)
			}
		}, {
			key: "addFeatureFlagsHandler",
			value: function(Yi) {
				this.featureFlagEventHandlers.push(Yi)
			}
		}, {
			key: "removeFeatureFlagsHandler",
			value: function(Yi) {
				this.featureFlagEventHandlers = this.featureFlagEventHandlers.filter(function(ea) {
					return ea !== Yi
				})
			}
		}, {
			key: "receivedFeatureFlags",
			value: function(Yi, ea) {
				if (this.instance.persistence) {
					this.instance.decideEndpointWasHit = !0;
					var ta = this.getFlagVariants(),
						na = this.getFlagPayloads();
					(function(ra, ia) {
						var aa, oa = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
							la = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
							sa = ra.featureFlags,
							ca = ra.featureFlagPayloads;
						if (sa)
							if (m(sa)) {
								var ua, da = {};
								if (sa)
									for (var ha = 0; ha < sa.length; ha++) da[sa[ha]] = !0;
								ia && ia.register((o(ua = {}, He, sa), o(ua, Ie, da), ua))
							} else {
								var pa = sa,
									va = ca;
								ra.errorsWhileComputingFlags && (pa = t(t({}, oa), pa), va = t(t({}, la), va)), ia && ia.register((o(aa = {}, He, Object.keys(Ge(pa))), o(aa, Ie, pa || {}), o(aa, je, va || {}), aa))
							}
					})(Yi, this.instance.persistence, ta, na), this._fireFeatureFlagsCallbacks(ea)
				}
			}
		}, {
			key: "override",
			value: function(Yi) {
				var ea = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
				if (!this.instance.__loaded || !this.instance.persistence) return G.uninitializedWarning("posthog.feature_flags.override");
				if (this._override_warning = ea, Yi === !1) this.instance.persistence.unregister(Ue);
				else if (m(Yi)) {
					for (var ta = {}, na = 0; na < Yi.length; na++) ta[Yi[na]] = !0;
					this.instance.persistence.register(o({}, Ue, ta))
				} else this.instance.persistence.register(o({}, Ue, Yi))
			}
		}, {
			key: "onFeatureFlags",
			value: function(Yi) {
				var ea = this;
				if (this.addFeatureFlagsHandler(Yi), this.instance.decideEndpointWasHit) {
					var ta = this._prepareFeatureFlagsForCallbacks(),
						na = ta.flags,
						ra = ta.flagVariants;
					Yi(na, ra)
				}
				return function() {
					return ea.removeFeatureFlagsHandler(Yi)
				}
			}
		}, {
			key: "updateEarlyAccessFeatureEnrollment",
			value: function(Yi, ea) {
				var ta, na, ra = o({}, "$feature_enrollment/".concat(Yi), ea);
				this.instance.capture("$feature_enrollment_update", {
					$feature_flag: Yi,
					$feature_enrollment: ea,
					$set: ra
				}), this.setPersonPropertiesForFlags(ra, !1);
				var ia = t(t({}, this.getFlagVariants()), {}, o({}, Yi, ea));
				(ta = this.instance.persistence) === null || ta === void 0 || ta.register((o(na = {}, He, Object.keys(Ge(ia))), o(na, Ie, ia), na)), this._fireFeatureFlagsCallbacks()
			}
		}, {
			key: "getEarlyAccessFeatures",
			value: function(Yi) {
				var ea = this,
					ta = arguments.length > 1 && arguments[1] !== void 0 && arguments[1],
					na = this.instance.get_property(Re);
				if (na && !ta) return Yi(na);
				this.instance._send_request({
					transport: "XHR",
					url: this.instance.requestRouter.endpointFor("api", "/api/early_access_features/?token=".concat(this.instance.config.token)),
					method: "GET",
					callback: function(ra) {
						var ia;
						if (ra.json) {
							var aa = ra.json.earlyAccessFeatures;
							return (ia = ea.instance.persistence) === null || ia === void 0 || ia.register(o({}, Re, aa)), Yi(aa)
						}
					}
				})
			}
		}, {
			key: "_prepareFeatureFlagsForCallbacks",
			value: function() {
				var Yi = this.getFlags(),
					ea = this.getFlagVariants();
				return {
					flags: Yi.filter(function(ta) {
						return ea[ta]
					}),
					flagVariants: Object.keys(ea).filter(function(ta) {
						return ea[ta]
					}).reduce(function(ta, na) {
						return ta[na] = ea[na], ta
					}, {})
				}
			}
		}, {
			key: "_fireFeatureFlagsCallbacks",
			value: function(Yi) {
				var ea = this._prepareFeatureFlagsForCallbacks(),
					ta = ea.flags,
					na = ea.flagVariants;
				this.featureFlagEventHandlers.forEach(function(ra) {
					return ra(ta, na, {
						errorsLoading: Yi
					})
				})
			}
		}, {
			key: "setPersonPropertiesForFlags",
			value: function(Yi) {
				var ea = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1],
					ta = this.instance.get_property(Fe) || {};
				this.instance.register(o({}, Fe, t(t({}, ta), Yi))), ea && this.instance.reloadFeatureFlags()
			}
		}, {
			key: "resetPersonPropertiesForFlags",
			value: function() {
				this.instance.unregister(Fe)
			}
		}, {
			key: "setGroupPropertiesForFlags",
			value: function(Yi) {
				var ea = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1],
					ta = this.instance.get_property(xe) || {};
				Object.keys(ta).length !== 0 && Object.keys(ta).forEach(function(na) {
					ta[na] = t(t({}, ta[na]), Yi[na]), delete Yi[na]
				}), this.instance.register(o({}, xe, t(t({}, ta), Yi))), ea && this.instance.reloadFeatureFlags()
			}
		}, {
			key: "resetGroupPropertiesForFlags",
			value: function(Yi) {
				if (Yi) {
					var ea = this.instance.get_property(xe) || {};
					this.instance.register(o({}, xe, t(t({}, ea), {}, o({}, Yi, {}))))
				} else this.instance.unregister(xe)
			}
		}]), ue
	}();
Math.trunc || (Math.trunc = function(ue) {
	return ue < 0 ? Math.ceil(ue) : Math.floor(ue)
}), Number.isInteger || (Number.isInteger = function(ue) {
	return F(ue) && isFinite(ue) && Math.floor(ue) === ue
});
var Ve = "0123456789abcdef",
	ze = function() {
		function ue(Yi) {
			if (i(this, ue), this.bytes = Yi, Yi.length !== 16) throw new TypeError("not 128-bit length")
		}
		return s(ue, [{
			key: "toString",
			value: function() {
				for (var Yi = "", ea = 0; ea < this.bytes.length; ea++) Yi = Yi + Ve.charAt(this.bytes[ea] >>> 4) + Ve.charAt(15 & this.bytes[ea]), ea !== 3 && ea !== 5 && ea !== 7 && ea !== 9 || (Yi += "-");
				if (Yi.length !== 36) throw new Error("Invalid UUIDv7 was generated");
				return Yi
			}
		}, {
			key: "clone",
			value: function() {
				return new ue(this.bytes.slice(0))
			}
		}, {
			key: "equals",
			value: function(Yi) {
				return this.compareTo(Yi) === 0
			}
		}, {
			key: "compareTo",
			value: function(Yi) {
				for (var ea = 0; ea < 16; ea++) {
					var ta = this.bytes[ea] - Yi.bytes[ea];
					if (ta !== 0) return Math.sign(ta)
				}
				return 0
			}
		}], [{
			key: "fromFieldsV7",
			value: function(Yi, ea, ta, na) {
				if (!Number.isInteger(Yi) || !Number.isInteger(ea) || !Number.isInteger(ta) || !Number.isInteger(na) || Yi < 0 || ea < 0 || ta < 0 || na < 0 || Yi > 0xffffffffffff || ea > 4095 || ta > 1073741823 || na > 4294967295) throw new RangeError("invalid field value");
				var ra = new Uint8Array(16);
				return ra[0] = Yi / Math.pow(2, 40), ra[1] = Yi / Math.pow(2, 32), ra[2] = Yi / Math.pow(2, 24), ra[3] = Yi / Math.pow(2, 16), ra[4] = Yi / Math.pow(2, 8), ra[5] = Yi, ra[6] = 112 | ea >>> 8, ra[7] = ea, ra[8] = 128 | ta >>> 24, ra[9] = ta >>> 16, ra[10] = ta >>> 8, ra[11] = ta, ra[12] = na >>> 24, ra[13] = na >>> 16, ra[14] = na >>> 8, ra[15] = na, new ue(ra)
			}
		}]), ue
	}(),
	Qe = function() {
		function ue() {
			i(this, ue), o(this, "timestamp", 0), o(this, "counter", 0), o(this, "random", new Xe)
		}
		return s(ue, [{
			key: "generate",
			value: function() {
				var Yi = this.generateOrAbort();
				if (w(Yi)) {
					this.timestamp = 0;
					var ea = this.generateOrAbort();
					if (w(ea)) throw new Error("Could not generate UUID after timestamp reset");
					return ea
				}
				return Yi
			}
		}, {
			key: "generateOrAbort",
			value: function() {
				var Yi = Date.now();
				if (Yi > this.timestamp) this.timestamp = Yi, this.resetCounter();
				else {
					if (!(Yi + 1e4 > this.timestamp)) return;
					this.counter++, this.counter > 4398046511103 && (this.timestamp++, this.resetCounter())
				}
				return ze.fromFieldsV7(this.timestamp, Math.trunc(this.counter / Math.pow(2, 30)), this.counter & Math.pow(2, 30) - 1, this.random.nextUint32())
			}
		}, {
			key: "resetCounter",
			value: function() {
				this.counter = 1024 * this.random.nextUint32() + (1023 & this.random.nextUint32())
			}
		}]), ue
	}(),
	Je = function(ue) {
		if (typeof UUIDV7_DENY_WEAK_RNG < "u" && UUIDV7_DENY_WEAK_RNG) throw new Error("no cryptographically strong RNG available");
		for (var Yi = 0; Yi < ue.length; Yi++) ue[Yi] = 65536 * Math.trunc(65536 * Math.random()) + Math.trunc(65536 * Math.random());
		return ue
	};
T && !w(T.crypto) && crypto.getRandomValues && (Je = function(ue) {
	return crypto.getRandomValues(ue)
});
var Ye, Xe = function() {
		function ue() {
			i(this, ue), o(this, "buffer", new Uint32Array(8)), o(this, "cursor", 1 / 0)
		}
		return s(ue, [{
			key: "nextUint32",
			value: function() {
				return this.cursor >= this.buffer.length && (Je(this.buffer), this.cursor = 0), this.buffer[this.cursor++]
			}
		}]), ue
	}(),
	Ke = function() {
		return Ze().toString()
	},
	Ze = function() {
		return (Ye || (Ye = new Qe)).generate()
	},
	et = "Thu, 01 Jan 1970 00:00:00 GMT",
	tt = "",
	nt = /[a-z0-9][a-z0-9-]+\.[a-z]{2,}$/i;

function it(ue, Yi) {
	if (Yi) {
		var ea = function(na) {
			var ra = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : L;
			if (tt) return tt;
			if (!ra || ["localhost", "127.0.0.1"].includes(na)) return "";
			for (var ia = na.split("."), aa = Math.min(ia.length, 8), oa = "dmn_chk_" + Ke(), la = new RegExp("(^|;)\\s*" + oa + "=1"); !tt && aa--;) {
				var sa = ia.slice(aa).join("."),
					ca = oa + "=1;domain=." + sa;
				ra.cookie = ca, la.test(ra.cookie) && (ra.cookie = ca + ";expires=" + et, tt = sa)
			}
			return tt
		}(ue);
		if (!ea) {
			var ta = function(na) {
				var ra = na.match(nt);
				return ra ? ra[0] : ""
			}(ue);
			ta !== ea && G.info("Warning: cookie subdomain discovery mismatch", ta, ea), ea = ta
		}
		return ea ? "; domain=." + ea : ""
	}
	return ""
}
var rt, st = {
		is_supported: function() {
			return !!L
		},
		error: function(ue) {
			G.error("cookieStore error: " + ue)
		},
		get: function(ue) {
			if (L) {
				try {
					for (var Yi = ue + "=", ea = L.cookie.split(";").filter(function(ra) {
							return ra.length
						}), ta = 0; ta < ea.length; ta++) {
						for (var na = ea[ta]; na.charAt(0) == " ";) na = na.substring(1, na.length);
						if (na.indexOf(Yi) === 0) return decodeURIComponent(na.substring(Yi.length, na.length))
					}
				} catch {}
				return null
			}
		},
		parse: function(ue) {
			var Yi;
			try {
				Yi = JSON.parse(st.get(ue)) || {}
			} catch {}
			return Yi
		},
		set: function(ue, Yi, ea, ta, na) {
			if (L) try {
				var ra = "",
					ia = "",
					aa = it(L.location.hostname, ta);
				if (ea) {
					var oa = new Date;
					oa.setTime(oa.getTime() + 24 * ea * 60 * 60 * 1e3), ra = "; expires=" + oa.toUTCString()
				}
				na && (ia = "; secure");
				var la = ue + "=" + encodeURIComponent(JSON.stringify(Yi)) + ra + "; SameSite=Lax; path=/" + aa + ia;
				return la.length > 3686.4 && G.warn("cookieStore warning: large cookie, len=" + la.length), L.cookie = la, la
			} catch {
				return
			}
		},
		remove: function(ue, Yi) {
			try {
				st.set(ue, "", -1, Yi)
			} catch {
				return
			}
		}
	},
	ot = null,
	at = {
		is_supported: function() {
			if (!I(ot)) return ot;
			var ue = !0;
			if (w(T)) ue = !1;
			else try {
				var Yi = "__mplssupport__";
				at.set(Yi, "xyz"), at.get(Yi) !== '"xyz"' && (ue = !1), at.remove(Yi)
			} catch {
				ue = !1
			}
			return ue || G.error("localStorage unsupported; falling back to cookie store"), ot = ue, ue
		},
		error: function(ue) {
			G.error("localStorage error: " + ue)
		},
		get: function(ue) {
			try {
				return T == null ? void 0 : T.localStorage.getItem(ue)
			} catch (Yi) {
				at.error(Yi)
			}
			return null
		},
		parse: function(ue) {
			try {
				return JSON.parse(at.get(ue)) || {}
			} catch {}
			return null
		},
		set: function(ue, Yi) {
			try {
				T == null || T.localStorage.setItem(ue, JSON.stringify(Yi))
			} catch (ea) {
				at.error(ea)
			}
		},
		remove: function(ue) {
			try {
				T == null || T.localStorage.removeItem(ue)
			} catch (Yi) {
				at.error(Yi)
			}
		}
	},
	ut = ["distinct_id", Se, Ee, qe],
	lt = t(t({}, at), {}, {
		parse: function(ue) {
			try {
				var Yi = {};
				try {
					Yi = st.parse(ue) || {}
				} catch {}
				var ea = J(Yi, JSON.parse(at.get(ue) || "{}"));
				return at.set(ue, ea), ea
			} catch {}
			return null
		},
		set: function(ue, Yi, ea, ta, na, ra) {
			try {
				at.set(ue, Yi, void 0, void 0, ra);
				var ia = {};
				ut.forEach(function(aa) {
					Yi[aa] && (ia[aa] = Yi[aa])
				}), Object.keys(ia).length && st.set(ue, ia, ea, ta, na, ra)
			} catch (aa) {
				at.error(aa)
			}
		},
		remove: function(ue, Yi) {
			try {
				T == null || T.localStorage.removeItem(ue), st.remove(ue, Yi)
			} catch (ea) {
				at.error(ea)
			}
		}
	}),
	ct = {},
	dt = {
		is_supported: function() {
			return !0
		},
		error: function(ue) {
			G.error("memoryStorage error: " + ue)
		},
		get: function(ue) {
			return ct[ue] || null
		},
		parse: function(ue) {
			return ct[ue] || null
		},
		set: function(ue, Yi) {
			ct[ue] = Yi
		},
		remove: function(ue) {
			delete ct[ue]
		}
	},
	ht = null,
	ft = {
		is_supported: function() {
			if (!I(ht)) return ht;
			if (ht = !0, w(T)) ht = !1;
			else try {
				var ue = "__support__";
				ft.set(ue, "xyz"), ft.get(ue) !== '"xyz"' && (ht = !1), ft.remove(ue)
			} catch {
				ht = !1
			}
			return ht
		},
		error: function(ue) {
			G.error("sessionStorage error: ", ue)
		},
		get: function(ue) {
			try {
				return T == null ? void 0 : T.sessionStorage.getItem(ue)
			} catch (Yi) {
				ft.error(Yi)
			}
			return null
		},
		parse: function(ue) {
			try {
				return JSON.parse(ft.get(ue)) || null
			} catch {}
			return null
		},
		set: function(ue, Yi) {
			try {
				T == null || T.sessionStorage.setItem(ue, JSON.stringify(Yi))
			} catch (ea) {
				ft.error(ea)
			}
		},
		remove: function(ue) {
			try {
				T == null || T.sessionStorage.removeItem(ue)
			} catch (Yi) {
				ft.error(Yi)
			}
		}
	},
	vt = ["localhost", "127.0.0.1"],
	pt = function(ue) {
		var Yi = L == null ? void 0 : L.createElement("a");
		return w(Yi) ? null : (Yi.href = ue, Yi)
	},
	gt = function(ue, Yi) {
		return !! function(ea) {
			try {
				new RegExp(ea)
			} catch {
				return !1
			}
			return !0
		}(Yi) && new RegExp(Yi).test(ue)
	},
	_t = function(ue) {
		var Yi, ea, ta = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "&",
			na = [];
		return Q(ue, function(ra, ia) {
			w(ra) || w(ia) || ia === "undefined" || (Yi = encodeURIComponent(function(aa) {
				return aa instanceof File
			}(ra) ? ra.name : ra.toString()), ea = encodeURIComponent(ia), na[na.length] = ea + "=" + Yi)
		}), na.join(ta)
	},
	mt = function(ue, Yi) {
		for (var ea, ta = ((ue.split("#")[0] || "").split("?")[1] || "").split("&"), na = 0; na < ta.length; na++) {
			var ra = ta[na].split("=");
			if (ra[0] === Yi) {
				ea = ra;
				break
			}
		}
		if (!m(ea) || ea.length < 2) return "";
		var ia = ea[1];
		try {
			ia = decodeURIComponent(ia)
		} catch {
			G.error("Skipping decoding for malformed query param: " + ia)
		}
		return ia.replace(/\+/g, " ")
	},
	yt = function(ue, Yi) {
		var ea = ue.match(new RegExp(Yi + "=([^&]*)"));
		return ea ? ea[1] : null
	},
	bt = "Mobile",
	kt = "iOS",
	wt = "Android",
	St = "Tablet",
	Et = wt + " " + St,
	It = "iPad",
	Rt = "Apple",
	Ft = Rt + " Watch",
	xt = "Safari",
	Pt = "BlackBerry",
	Tt = "Samsung",
	Ct = Tt + "Browser",
	$t = Tt + " Internet",
	Ot = "Chrome",
	Mt = Ot + " OS",
	At = Ot + " " + kt,
	Lt = "Internet Explorer",
	Dt = Lt + " " + bt,
	qt = "Opera",
	Nt = qt + " Mini",
	Bt = "Edge",
	Ht = "Microsoft " + Bt,
	Ut = "Firefox",
	jt = Ut + " " + kt,
	Gt = "Nintendo",
	Wt = "PlayStation",
	Vt = "Xbox",
	zt = wt + " " + bt,
	Qt = bt + " " + xt,
	Jt = "Windows",
	Yt = Jt + " Phone",
	Xt = "Nokia",
	Kt = "Ouya",
	Zt = "Generic",
	en = Zt + " " + bt.toLowerCase(),
	tn = Zt + " " + St.toLowerCase(),
	nn = "Konqueror",
	rn = "(\\d+(\\.\\d+)?)",
	sn = new RegExp("Version/" + rn),
	on = new RegExp(Vt, "i"),
	an = new RegExp(Wt + " \\w+", "i"),
	un = new RegExp(Gt + " \\w+", "i"),
	ln = new RegExp(Pt + "|PlayBook|BB10", "i"),
	cn = {
		"NT3.51": "NT 3.11",
		"NT4.0": "NT 4.0",
		"5.0": "2000",
		5.1: "XP",
		5.2: "XP",
		"6.0": "Vista",
		6.1: "7",
		6.2: "8",
		6.3: "8.1",
		6.4: "10",
		"10.0": "10"
	},
	dn = function(ue, Yi) {
		return Yi && Y(Yi, Rt) || function(ea) {
			return Y(ea, xt) && !Y(ea, Ot) && !Y(ea, wt)
		}(ue)
	},
	hn = function(ue, Yi) {
		return Yi = Yi || "", Y(ue, " OPR/") && Y(ue, "Mini") ? Nt : Y(ue, " OPR/") ? qt : ln.test(ue) ? Pt : Y(ue, "IE" + bt) || Y(ue, "WPDesktop") ? Dt : Y(ue, Ct) ? $t : Y(ue, Bt) || Y(ue, "Edg/") ? Ht : Y(ue, "FBIOS") ? "Facebook " + bt : Y(ue, "UCWEB") || Y(ue, "UCBrowser") ? "UC Browser" : Y(ue, "CriOS") ? At : Y(ue, "CrMo") ? Ot : Y(ue, wt) && Y(ue, xt) ? zt : Y(ue, Ot) ? Ot : Y(ue, "FxiOS") ? jt : Y(ue.toLowerCase(), nn.toLowerCase()) ? nn : dn(ue, Yi) ? Y(ue, bt) ? Qt : xt : Y(ue, Ut) ? Ut : Y(ue, "MSIE") || Y(ue, "Trident/") ? Lt : Y(ue, "Gecko") ? Ut : ""
	},
	fn = (o(rt = {}, Dt, [new RegExp("rv:" + rn)]), o(rt, Ht, [new RegExp(Bt + "?\\/" + rn)]), o(rt, Ot, [new RegExp("(" + Ot + "|CrMo)\\/" + rn)]), o(rt, At, [new RegExp("CriOS\\/" + rn)]), o(rt, "UC Browser", [new RegExp("(UCBrowser|UCWEB)\\/" + rn)]), o(rt, xt, [sn]), o(rt, Qt, [sn]), o(rt, qt, [new RegExp("(Opera|OPR)\\/" + rn)]), o(rt, Ut, [new RegExp(Ut + "\\/" + rn)]), o(rt, jt, [new RegExp("FxiOS\\/" + rn)]), o(rt, nn, [new RegExp("Konqueror[:/]?" + rn, "i")]), o(rt, Pt, [new RegExp(Pt + " " + rn), sn]), o(rt, zt, [new RegExp("android\\s" + rn, "i")]), o(rt, $t, [new RegExp(Ct + "\\/" + rn)]), o(rt, Lt, [new RegExp("(rv:|MSIE )" + rn)]), o(rt, "Mozilla", [new RegExp("rv:" + rn)]), rt),
	vn = [
		[new RegExp(Vt + "; " + Vt + " (.*?)[);]", "i"), function(ue) {
			return [Vt, ue && ue[1] || ""]
		}],
		[new RegExp(Gt, "i"), [Gt, ""]],
		[new RegExp(Wt, "i"), [Wt, ""]],
		[ln, [Pt, ""]],
		[new RegExp(Jt, "i"), function(ue, Yi) {
			if (/Phone/.test(Yi) || /WPDesktop/.test(Yi)) return [Yt, ""];
			if (new RegExp(bt).test(Yi) && !/IEMobile\b/.test(Yi)) return [Jt + " " + bt, ""];
			var ea = /Windows NT ([0-9.]+)/i.exec(Yi);
			if (ea && ea[1]) {
				var ta = ea[1],
					na = cn[ta] || "";
				return /arm/i.test(Yi) && (na = "RT"), [Jt, na]
			}
			return [Jt, ""]
		}],
		[/((iPhone|iPad|iPod).*?OS (\d+)_(\d+)_?(\d+)?|iPhone)/, function(ue) {
			if (ue && ue[3]) {
				var Yi = [ue[3], ue[4], ue[5] || "0"];
				return [kt, Yi.join(".")]
			}
			return [kt, ""]
		}],
		[/(watch.*\/(\d+\.\d+\.\d+)|watch os,(\d+\.\d+),)/i, function(ue) {
			var Yi = "";
			return ue && ue.length >= 3 && (Yi = w(ue[2]) ? ue[3] : ue[2]), ["watchOS", Yi]
		}],
		[new RegExp("(" + wt + " (\\d+)\\.(\\d+)\\.?(\\d+)?|" + wt + ")", "i"), function(ue) {
			if (ue && ue[2]) {
				var Yi = [ue[2], ue[3], ue[4] || "0"];
				return [wt, Yi.join(".")]
			}
			return [wt, ""]
		}],
		[/Mac OS X (\d+)[_.](\d+)[_.]?(\d+)?/i, function(ue) {
			var Yi = ["Mac OS X", ""];
			if (ue && ue[1]) {
				var ea = [ue[1], ue[2], ue[3] || "0"];
				Yi[1] = ea.join(".")
			}
			return Yi
		}],
		[/Mac/i, ["Mac OS X", ""]],
		[/CrOS/, [Mt, ""]],
		[/Linux|debian/i, ["Linux", ""]]
	],
	pn = function(ue) {
		return un.test(ue) ? Gt : an.test(ue) ? Wt : on.test(ue) ? Vt : new RegExp(Kt, "i").test(ue) ? Kt : new RegExp("(" + Yt + "|WPDesktop)", "i").test(ue) ? Yt : /iPad/.test(ue) ? It : /iPod/.test(ue) ? "iPod Touch" : /iPhone/.test(ue) ? "iPhone" : /(watch)(?: ?os[,/]|\d,\d\/)[\d.]+/i.test(ue) ? Ft : ln.test(ue) ? Pt : /(kobo)\s(ereader|touch)/i.test(ue) ? "Kobo" : new RegExp(Xt, "i").test(ue) ? Xt : /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i.test(ue) || /(kf[a-z]+)( bui|\)).+silk\//i.test(ue) ? "Kindle Fire" : /(Android|ZTE)/i.test(ue) ? !new RegExp(bt).test(ue) || /(9138B|TB782B|Nexus [97]|pixel c|HUAWEISHT|BTV|noble nook|smart ultra 6)/i.test(ue) ? /pixel[\daxl ]{1,6}/i.test(ue) && !/pixel c/i.test(ue) || /(huaweimed-al00|tah-|APA|SM-G92|i980|zte|U304AA)/i.test(ue) || /lmy47v/i.test(ue) && !/QTAQZ3/i.test(ue) ? wt : Et : wt : new RegExp("(pda|" + bt + ")", "i").test(ue) ? en : new RegExp(St, "i").test(ue) && !new RegExp(St + " pc", "i").test(ue) ? tn : ""
	},
	gn = "https?://(.*)",
	_n = ["utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term", "gclid", "gad_source", "gclsrc", "dclid", "gbraid", "wbraid", "fbclid", "msclkid", "twclid", "li_fat_id", "mc_cid", "igshid", "ttclid", "rdt_cid"],
	mn = {
		campaignParams: function(ue) {
			return L ? this._campaignParamsFromUrl(L.URL, ue) : {}
		},
		_campaignParamsFromUrl: function(ue, Yi) {
			var ea = _n.concat(Yi || []),
				ta = {};
			return Q(ea, function(na) {
				var ra = mt(ue, na);
				ra && (ta[na] = ra)
			}), ta
		},
		_searchEngine: function(ue) {
			return ue ? ue.search(gn + "google.([^/?]*)") === 0 ? "google" : ue.search(gn + "bing.com") === 0 ? "bing" : ue.search(gn + "yahoo.com") === 0 ? "yahoo" : ue.search(gn + "duckduckgo.com") === 0 ? "duckduckgo" : null : null
		},
		_searchInfoFromReferrer: function(ue) {
			var Yi = mn._searchEngine(ue),
				ea = Yi != "yahoo" ? "q" : "p",
				ta = {};
			if (!I(Yi)) {
				ta.$search_engine = Yi;
				var na = L ? mt(L.referrer, ea) : "";
				na.length && (ta.ph_keyword = na)
			}
			return ta
		},
		searchInfo: function() {
			var ue = L == null ? void 0 : L.referrer;
			return ue ? this._searchInfoFromReferrer(ue) : {}
		},
		browser: hn,
		browserVersion: function(ue, Yi) {
			var ea = hn(ue, Yi),
				ta = fn[ea];
			if (w(ta)) return null;
			for (var na = 0; na < ta.length; na++) {
				var ra = ta[na],
					ia = ue.match(ra);
				if (ia) return parseFloat(ia[ia.length - 2])
			}
			return null
		},
		browserLanguage: function() {
			return navigator.language || navigator.userLanguage
		},
		os: function(ue) {
			for (var Yi = 0; Yi < vn.length; Yi++) {
				var ea = u(vn[Yi], 2),
					ta = ea[0],
					na = ea[1],
					ra = ta.exec(ue),
					ia = ra && (y(na) ? na(ra, ue) : na);
				if (ia) return ia
			}
			return ["", ""]
		},
		device: pn,
		deviceType: function(ue) {
			var Yi = pn(ue);
			return Yi === It || Yi === Et || Yi === "Kobo" || Yi === "Kindle Fire" || Yi === tn ? St : Yi === Gt || Yi === Vt || Yi === Wt || Yi === Kt ? "Console" : Yi === Ft ? "Wearable" : Yi ? bt : "Desktop"
		},
		referrer: function() {
			return (L == null ? void 0 : L.referrer) || "$direct"
		},
		referringDomain: function() {
			var ue;
			return L != null && L.referrer && ((ue = pt(L.referrer)) === null || ue === void 0 ? void 0 : ue.host) || "$direct"
		},
		referrerInfo: function() {
			return {
				$referrer: this.referrer(),
				$referring_domain: this.referringDomain()
			}
		},
		initialPersonInfo: function() {
			return {
				r: this.referrer(),
				u: D == null ? void 0 : D.href
			}
		},
		initialPersonPropsFromInfo: function(ue) {
			var Yi, ea = ue.r,
				ta = ue.u,
				na = {
					$initial_referrer: ea,
					$initial_referring_domain: ea == null ? void 0 : ea == "$direct" ? "$direct" : (Yi = pt(ea)) === null || Yi === void 0 ? void 0 : Yi.host
				};
			if (ta) {
				na.$initial_current_url = ta;
				var ra = pt(ta);
				na.$initial_host = ra == null ? void 0 : ra.host, na.$initial_pathname = ra == null ? void 0 : ra.pathname, Q(this._campaignParamsFromUrl(ta), function(ia, aa) {
					na["$initial_" + ne(aa)] = ia
				})
			}
			return ea && Q(this._searchInfoFromReferrer(ea), function(ia, aa) {
				na["$initial_" + ne(aa)] = ia
			}), na
		},
		properties: function() {
			if (!H) return {};
			var ue = u(mn.os(H), 2),
				Yi = ue[0],
				ea = ue[1];
			return J(te({
				$os: Yi,
				$os_version: ea,
				$browser: mn.browser(H, navigator.vendor),
				$device: mn.device(H),
				$device_type: mn.deviceType(H)
			}), {
				$current_url: D == null ? void 0 : D.href,
				$host: D == null ? void 0 : D.host,
				$pathname: D == null ? void 0 : D.pathname,
				$raw_user_agent: H.length > 1e3 ? H.substring(0, 997) + "..." : H,
				$browser_version: mn.browserVersion(H, navigator.vendor),
				$browser_language: mn.browserLanguage(),
				$screen_height: T == null ? void 0 : T.screen.height,
				$screen_width: T == null ? void 0 : T.screen.width,
				$viewport_height: T == null ? void 0 : T.innerHeight,
				$viewport_width: T == null ? void 0 : T.innerWidth,
				$lib: "web",
				$lib_version: f.LIB_VERSION,
				$insert_id: Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10),
				$time: K() / 1e3
			})
		},
		people_properties: function() {
			if (!H) return {};
			var ue = u(mn.os(H), 2),
				Yi = ue[0],
				ea = ue[1];
			return J(te({
				$os: Yi,
				$os_version: ea,
				$browser: mn.browser(H, navigator.vendor)
			}), {
				$browser_version: mn.browserVersion(H, navigator.vendor)
			})
		}
	},
	yn = ["cookie", "localstorage", "localstorage+cookie", "sessionstorage", "memory"],
	bn = function() {
		function ue(Yi) {
			i(this, ue), this.config = Yi, this.props = {}, this.campaign_params_saved = !1, this.name = function(ea) {
				var ta = "";
				return ea.token && (ta = ea.token.replace(/\+/g, "PL").replace(/\//g, "SL").replace(/=/g, "EQ")), ea.persistence_name ? "ph_" + ea.persistence_name : "ph_" + ta + "_posthog"
			}(Yi), this.storage = this.buildStorage(Yi), this.load(), Yi.debug && G.info("Persistence loaded", Yi.persistence, t({}, this.props)), this.update_config(Yi, Yi), this.save()
		}
		return s(ue, [{
			key: "buildStorage",
			value: function(Yi) {
				yn.indexOf(Yi.persistence.toLowerCase()) === -1 && (G.critical("Unknown persistence type " + Yi.persistence + "; falling back to localStorage+cookie"), Yi.persistence = "localStorage+cookie");
				var ea = Yi.persistence.toLowerCase();
				return ea === "localstorage" && at.is_supported() ? at : ea === "localstorage+cookie" && lt.is_supported() ? lt : ea === "sessionstorage" && ft.is_supported() ? ft : ea === "memory" ? dt : ea === "cookie" ? st : lt.is_supported() ? lt : st
			}
		}, {
			key: "properties",
			value: function() {
				var Yi = {};
				return Q(this.props, function(ea, ta) {
					if (ta === Ie && b(ea))
						for (var na = Object.keys(ea), ra = 0; ra < na.length; ra++) Yi["$feature/".concat(na[ra])] = ea[na[ra]];
					else aa = ta, oa = !1, (I(ia = Be) ? oa : M && ia.indexOf === M ? ia.indexOf(aa) != -1 : (Q(ia, function(la) {
						if (oa || (oa = la === aa)) return W
					}), oa)) || (Yi[ta] = ea);
					var ia, aa, oa
				}), Yi
			}
		}, {
			key: "load",
			value: function() {
				if (!this.disabled) {
					var Yi = this.storage.parse(this.name);
					Yi && (this.props = J({}, Yi))
				}
			}
		}, {
			key: "save",
			value: function() {
				this.disabled || this.storage.set(this.name, this.props, this.expire_days, this.cross_subdomain, this.secure, this.config.debug)
			}
		}, {
			key: "remove",
			value: function() {
				this.storage.remove(this.name, !1), this.storage.remove(this.name, !0)
			}
		}, {
			key: "clear",
			value: function() {
				this.remove(), this.props = {}
			}
		}, {
			key: "register_once",
			value: function(Yi, ea, ta) {
				var na = this;
				if (b(Yi)) {
					w(ea) && (ea = "None"), this.expire_days = w(ta) ? this.default_expiry : ta;
					var ra = !1;
					if (Q(Yi, function(ia, aa) {
							na.props.hasOwnProperty(aa) && na.props[aa] !== ea || (na.props[aa] = ia, ra = !0)
						}), ra) return this.save(), !0
				}
				return !1
			}
		}, {
			key: "register",
			value: function(Yi, ea) {
				var ta = this;
				if (b(Yi)) {
					this.expire_days = w(ea) ? this.default_expiry : ea;
					var na = !1;
					if (Q(Yi, function(ra, ia) {
							Yi.hasOwnProperty(ia) && ta.props[ia] !== ra && (ta.props[ia] = ra, na = !0)
						}), na) return this.save(), !0
				}
				return !1
			}
		}, {
			key: "unregister",
			value: function(Yi) {
				Yi in this.props && (delete this.props[Yi], this.save())
			}
		}, {
			key: "update_campaign_params",
			value: function() {
				this.campaign_params_saved || (this.register(mn.campaignParams(this.config.custom_campaign_params)), this.campaign_params_saved = !0)
			}
		}, {
			key: "update_search_keyword",
			value: function() {
				this.register(mn.searchInfo())
			}
		}, {
			key: "update_referrer_info",
			value: function() {
				this.register_once(mn.referrerInfo(), void 0)
			}
		}, {
			key: "set_initial_person_info",
			value: function() {
				this.props[Ae] || this.props[Le] || this.register_once(o({}, De, mn.initialPersonInfo()), void 0)
			}
		}, {
			key: "get_referrer_info",
			value: function() {
				return te({
					$referrer: this.props.$referrer,
					$referring_domain: this.props.$referring_domain
				})
			}
		}, {
			key: "get_initial_props",
			value: function() {
				var Yi = this,
					ea = {};
				Q([Le, Ae], function(ra) {
					var ia = Yi.props[ra];
					ia && Q(ia, function(aa, oa) {
						ea["$initial_" + ne(oa)] = aa
					})
				});
				var ta = this.props[De];
				if (ta) {
					var na = mn.initialPersonPropsFromInfo(ta);
					J(ea, na)
				}
				return ea
			}
		}, {
			key: "safe_merge",
			value: function(Yi) {
				return Q(this.props, function(ea, ta) {
					ta in Yi || (Yi[ta] = ea)
				}), Yi
			}
		}, {
			key: "update_config",
			value: function(Yi, ea) {
				if (this.default_expiry = this.expire_days = Yi.cookie_expiration, this.set_disabled(Yi.disable_persistence), this.set_cross_subdomain(Yi.cross_subdomain_cookie), this.set_secure(Yi.secure_cookie), Yi.persistence !== ea.persistence) {
					var ta = this.buildStorage(Yi),
						na = this.props;
					this.clear(), this.storage = ta, this.props = na, this.save()
				}
			}
		}, {
			key: "set_disabled",
			value: function(Yi) {
				this.disabled = Yi, this.disabled ? this.remove() : this.save()
			}
		}, {
			key: "set_cross_subdomain",
			value: function(Yi) {
				Yi !== this.cross_subdomain && (this.cross_subdomain = Yi, this.remove(), this.save())
			}
		}, {
			key: "get_cross_subdomain",
			value: function() {
				return !!this.cross_subdomain
			}
		}, {
			key: "set_secure",
			value: function(Yi) {
				Yi !== this.secure && (this.secure = Yi, this.remove(), this.save())
			}
		}, {
			key: "set_event_timer",
			value: function(Yi, ea) {
				var ta = this.props[de] || {};
				ta[Yi] = ea, this.props[de] = ta, this.save()
			}
		}, {
			key: "remove_event_timer",
			value: function(Yi) {
				var ea = (this.props[de] || {})[Yi];
				return w(ea) || (delete this.props[de][Yi], this.save()), ea
			}
		}, {
			key: "get_property",
			value: function(Yi) {
				return this.props[Yi]
			}
		}, {
			key: "set_property",
			value: function(Yi, ea) {
				this.props[Yi] = ea, this.save()
			}
		}]), ue
	}();

function kn(ue) {
	return JSON.stringify(ue, (Yi = [], function(ea, ta) {
		if (b(ta)) {
			for (; Yi.length > 0 && Yi.at(-1) !== this;) Yi.pop();
			return Yi.includes(ta) ? "[Circular]" : (Yi.push(ta), ta)
		}
		return ta
	})).length;
	var Yi
}
var wn = 2,
	Sn = 4;

function En(ue) {
	var Yi = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66060288e-1;
	if (ue.size >= Yi && ue.data.length > 1) {
		var ea = Math.floor(ue.data.length / 2),
			ta = ue.data.slice(0, ea),
			na = ue.data.slice(ea);
		return [En({
			size: kn(ta),
			data: ta,
			sessionId: ue.sessionId,
			windowId: ue.windowId
		}), En({
			size: kn(na),
			data: na,
			sessionId: ue.sessionId,
			windowId: ue.windowId
		})].flatMap(function(ra) {
			return ra
		})
	}
	return [ue]
}
var In = function(ue) {
		return ue[ue.DomContentLoaded = 0] = "DomContentLoaded", ue[ue.Load = 1] = "Load", ue[ue.FullSnapshot = 2] = "FullSnapshot", ue[ue.IncrementalSnapshot = 3] = "IncrementalSnapshot", ue[ue.Meta = 4] = "Meta", ue[ue.Custom = 5] = "Custom", ue[ue.Plugin = 6] = "Plugin", ue
	}(In || {}),
	Rn = function(ue) {
		return ue[ue.Mutation = 0] = "Mutation", ue[ue.MouseMove = 1] = "MouseMove", ue[ue.MouseInteraction = 2] = "MouseInteraction", ue[ue.Scroll = 3] = "Scroll", ue[ue.ViewportResize = 4] = "ViewportResize", ue[ue.Input = 5] = "Input", ue[ue.TouchMove = 6] = "TouchMove", ue[ue.MediaInteraction = 7] = "MediaInteraction", ue[ue.StyleSheetRule = 8] = "StyleSheetRule", ue[ue.CanvasMutation = 9] = "CanvasMutation", ue[ue.Font = 10] = "Font", ue[ue.Log = 11] = "Log", ue[ue.Drag = 12] = "Drag", ue[ue.StyleDeclaration = 13] = "StyleDeclaration", ue[ue.Selection = 14] = "Selection", ue[ue.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", ue[ue.CustomElement = 16] = "CustomElement", ue
	}(Rn || {});

function Fn(ue) {
	return ue ? V(ue).split(/\s+/) : []
}

function xn(ue) {
	var Yi = T == null ? void 0 : T.location.href;
	return !!(Yi && ue && ue.some(function(ea) {
		return Yi.match(ea)
	}))
}

function Pn(ue) {
	var Yi = "";
	switch (n(ue.className)) {
		case "string":
			Yi = ue.className;
			break;
		case "object":
			Yi = (ue.className && "baseVal" in ue.className ? ue.className.baseVal : null) || ue.getAttribute("class") || "";
			break;
		default:
			Yi = ""
	}
	return Fn(Yi)
}

function Tn(ue) {
	return R(ue) ? null : V(ue).split(/(\s+)/).filter(function(Yi) {
		return zn(Yi)
	}).join("").replace(/[\r\n]/g, " ").replace(/[ ]+/g, " ").substring(0, 255)
}

function Cn(ue) {
	var Yi = "";
	return Nn(ue) && !Bn(ue) && ue.childNodes && ue.childNodes.length && Q(ue.childNodes, function(ea) {
		var ta;
		Mn(ea) && ea.textContent && (Yi += (ta = Tn(ea.textContent)) !== null && ta !== void 0 ? ta : "")
	}), V(Yi)
}

function $n(ue) {
	return !!ue && ue.nodeType === 1
}

function On(ue, Yi) {
	return !!ue && !!ue.tagName && ue.tagName.toLowerCase() === Yi.toLowerCase()
}

function Mn(ue) {
	return !!ue && ue.nodeType === 3
}

function An(ue) {
	return !!ue && ue.nodeType === 11
}
var Ln = ["a", "button", "form", "input", "select", "textarea", "label"];

function Dn(ue) {
	var Yi = ue.parentNode;
	return !(!Yi || !$n(Yi)) && Yi
}

function qn(ue, Yi) {
	var ea = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0,
		ta = arguments.length > 3 ? arguments[3] : void 0,
		na = arguments.length > 4 ? arguments[4] : void 0;
	if (!T || !ue || On(ue, "html") || !$n(ue) || ea != null && ea.url_allowlist && !xn(ea.url_allowlist) || ea != null && ea.url_ignorelist && xn(ea.url_ignorelist)) return !1;
	if (ea != null && ea.dom_event_allowlist) {
		var ra = ea.dom_event_allowlist;
		if (ra && !ra.some(function(da) {
				return Yi.type === da
			})) return !1
	}
	for (var ia = !1, aa = [ue], oa = !0, la = ue; la.parentNode && !On(la, "body");)
		if (An(la.parentNode)) aa.push(la.parentNode.host), la = la.parentNode.host;
		else {
			if (!(oa = Dn(la))) break;
			if (ta || Ln.indexOf(oa.tagName.toLowerCase()) > -1) ia = !0;
			else {
				var sa = T.getComputedStyle(oa);
				sa && sa.getPropertyValue("cursor") === "pointer" && (ia = !0)
			}
			aa.push(oa), la = oa
		} if (! function(da, ha) {
			var pa = ha == null ? void 0 : ha.element_allowlist;
			if (w(pa)) return !0;
			var va, ba = h(da);
			try {
				var Ea = function() {
					var Ca = va.value;
					if (pa.some(function(ka) {
							return Ca.tagName.toLowerCase() === ka
						})) return {
						v: !0
					}
				};
				for (ba.s(); !(va = ba.n()).done;) {
					var Sa = Ea();
					if (n(Sa) === "object") return Sa.v
				}
			} catch (Ca) {
				ba.e(Ca)
			} finally {
				ba.f()
			}
			return !1
		}(aa, ea) || ! function(da, ha) {
			var pa = ha == null ? void 0 : ha.css_selector_allowlist;
			if (w(pa)) return !0;
			var va, ba = h(da);
			try {
				var Ea = function() {
					var Ca = va.value;
					if (pa.some(function(ka) {
							return Ca.matches(ka)
						})) return {
						v: !0
					}
				};
				for (ba.s(); !(va = ba.n()).done;) {
					var Sa = Ea();
					if (n(Sa) === "object") return Sa.v
				}
			} catch (Ca) {
				ba.e(Ca)
			} finally {
				ba.f()
			}
			return !1
		}(aa, ea)) return !1;
	var ca = T.getComputedStyle(ue);
	if (ca && ca.getPropertyValue("cursor") === "pointer" && Yi.type === "click") return !0;
	var ua = ue.tagName.toLowerCase();
	switch (ua) {
		case "html":
			return !1;
		case "form":
			return (na || ["submit"]).indexOf(Yi.type) >= 0;
		case "input":
		case "select":
		case "textarea":
			return (na || ["change", "click"]).indexOf(Yi.type) >= 0;
		default:
			return ia ? (na || ["click"]).indexOf(Yi.type) >= 0 : (na || ["click"]).indexOf(Yi.type) >= 0 && (Ln.indexOf(ua) > -1 || ue.getAttribute("contenteditable") === "true")
	}
}

function Nn(ue) {
	for (var Yi = ue; Yi.parentNode && !On(Yi, "body"); Yi = Yi.parentNode) {
		var ea = Pn(Yi);
		if (Y(ea, "ph-sensitive") || Y(ea, "ph-no-capture")) return !1
	}
	if (Y(Pn(ue), "ph-include")) return !0;
	var ta = ue.type || "";
	if (S(ta)) switch (ta.toLowerCase()) {
		case "hidden":
		case "password":
			return !1
	}
	var na = ue.name || ue.id || "";
	return !(S(na) && /^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i.test(na.replace(/[^a-zA-Z0-9]/g, "")))
}

function Bn(ue) {
	return !!(On(ue, "input") && !["button", "checkbox", "submit", "reset"].includes(ue.type) || On(ue, "select") || On(ue, "textarea") || ue.getAttribute("contenteditable") === "true")
}
var Hn = "(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11})",
	Un = new RegExp("^(?:".concat(Hn, ")$")),
	jn = new RegExp(Hn),
	Gn = "\\d{3}-?\\d{2}-?\\d{4}",
	Wn = new RegExp("^(".concat(Gn, ")$")),
	Vn = new RegExp("(".concat(Gn, ")"));

function zn(ue) {
	var Yi = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
	return !(R(ue) || S(ue) && (ue = V(ue), (Yi ? Un : jn).test((ue || "").replace(/[- ]/g, "")) || (Yi ? Wn : Vn).test(ue)))
}

function Qn(ue) {
	var Yi = Cn(ue);
	return zn(Yi = "".concat(Yi, " ").concat(Jn(ue)).trim()) ? Yi : ""
}

function Jn(ue) {
	var Yi = "";
	return ue && ue.childNodes && ue.childNodes.length && Q(ue.childNodes, function(ea) {
		var ta;
		if (ea && ((ta = ea.tagName) === null || ta === void 0 ? void 0 : ta.toLowerCase()) === "span") try {
			var na = Cn(ea);
			Yi = "".concat(Yi, " ").concat(na).trim(), ea.childNodes && ea.childNodes.length && (Yi = "".concat(Yi, " ").concat(Jn(ea)).trim())
		} catch (ra) {
			G.error(ra)
		}
	}), Yi
}

function Yn(ue) {
	return function(Yi) {
		var ea = Yi.map(function(ta) {
			var na, ra, ia = "";
			if (ta.tag_name && (ia += ta.tag_name), ta.attr_class) {
				ta.attr_class.sort();
				var aa, oa = h(ta.attr_class);
				try {
					for (oa.s(); !(aa = oa.n()).done;) {
						var la = aa.value;
						ia += ".".concat(la.replace(/"/g, ""))
					}
				} catch (ua) {
					oa.e(ua)
				} finally {
					oa.f()
				}
			}
			var sa = t(t(t(t({}, ta.text ? {
					text: ta.text
				} : {}), {}, {
					"nth-child": (na = ta.nth_child) !== null && na !== void 0 ? na : 0,
					"nth-of-type": (ra = ta.nth_of_type) !== null && ra !== void 0 ? ra : 0
				}, ta.href ? {
					href: ta.href
				} : {}), ta.attr_id ? {
					attr_id: ta.attr_id
				} : {}), ta.attributes),
				ca = {};
			return X(sa).sort(function(ua, da) {
				var ha = u(ua, 1)[0],
					pa = u(da, 1)[0];
				return ha.localeCompare(pa)
			}).forEach(function(ua) {
				var da = u(ua, 2),
					ha = da[0],
					pa = da[1];
				return ca[Xn(ha.toString())] = Xn(pa.toString())
			}), ia += ":", ia += X(sa).map(function(ua) {
				var da = u(ua, 2),
					ha = da[0],
					pa = da[1];
				return "".concat(ha, '="').concat(pa, '"')
			}).join("")
		});
		return ea.join(";")
	}(function(Yi) {
		return Yi.map(function(ea) {
			var ta, na, ra = {
				text: (ta = ea.$el_text) === null || ta === void 0 ? void 0 : ta.slice(0, 400),
				tag_name: ea.tag_name,
				href: (na = ea.attr__href) === null || na === void 0 ? void 0 : na.slice(0, 2048),
				attr_class: Kn(ea),
				attr_id: ea.attr__id,
				nth_child: ea.nth_child,
				nth_of_type: ea.nth_of_type,
				attributes: {}
			};
			return X(ea).filter(function(ia) {
				return u(ia, 1)[0].indexOf("attr__") === 0
			}).forEach(function(ia) {
				var aa = u(ia, 2),
					oa = aa[0],
					la = aa[1];
				return ra.attributes[oa] = la
			}), ra
		})
	}(ue))
}

function Xn(ue) {
	return ue.replace(/"|\\"/g, '\\"')
}

function Kn(ue) {
	var Yi = ue.attr__class;
	return Yi ? m(Yi) ? Yi : Fn(Yi) : void 0
}
var Zn = "[SessionRecording]",
	ei = "redacted",
	ti = {
		initiatorTypes: ["audio", "beacon", "body", "css", "early-hint", "embed", "fetch", "frame", "iframe", "icon", "image", "img", "input", "link", "navigation", "object", "ping", "script", "track", "video", "xmlhttprequest"],
		maskRequestFn: function(ue) {
			return ue
		},
		recordHeaders: !1,
		recordBody: !1,
		recordInitialRequests: !1,
		recordPerformance: !1,
		performanceEntryTypeToObserve: ["first-input", "navigation", "paint", "resource"],
		payloadSizeLimitBytes: 1e6,
		payloadHostDenyList: [".lr-ingest.io", ".ingest.sentry.io"]
	},
	ni = ["authorization", "x-forwarded-for", "authorization", "cookie", "set-cookie", "x-api-key", "x-real-ip", "remote-addr", "forwarded", "proxy-authorization", "x-csrf-token", "x-csrftoken", "x-xsrf-token"],
	ii = ["password", "secret", "passwd", "api_key", "apikey", "auth", "credentials", "mysql_pwd", "privatekey", "private_key", "token"],
	ri = ["/s/", "/e/", "/i/"];

function si(ue, Yi, ea, ta) {
	if (R(ue)) return ue;
	var na = (Yi == null ? void 0 : Yi["content-length"]) || function(ra) {
		return new Blob([ra]).size
	}(ue);
	return S(na) && (na = parseInt(na)), na > ea ? Zn + " ".concat(ta, " body too large to record (").concat(na, " bytes)") : ue
}

function oi(ue, Yi) {
	if (R(ue)) return ue;
	var ea = ue;
	return zn(ea, !1) || (ea = Zn + " " + Yi + " body " + ei), Q(ii, function(ta) {
		var na, ra;
		(na = ea) !== null && na !== void 0 && na.length && ((ra = ea) === null || ra === void 0 ? void 0 : ra.indexOf(ta)) !== -1 && (ea = Zn + " " + Yi + " body " + ei + " as might contain: " + ta)
	}), ea
}
var ai, ui = function(ue, Yi) {
		var ea, ta, na, ra = {
				payloadSizeLimitBytes: ti.payloadSizeLimitBytes,
				performanceEntryTypeToObserve: l(ti.performanceEntryTypeToObserve),
				payloadHostDenyList: [].concat(l(Yi.payloadHostDenyList || []), l(ti.payloadHostDenyList))
			},
			ia = ue.session_recording.recordHeaders !== !1 && Yi.recordHeaders,
			aa = ue.session_recording.recordBody !== !1 && Yi.recordBody,
			oa = ue.capture_performance !== !1 && Yi.recordPerformance,
			la = (ea = ra, na = Math.min(1e6, (ta = ea.payloadSizeLimitBytes) !== null && ta !== void 0 ? ta : 1e6), function(ua) {
				return ua != null && ua.requestBody && (ua.requestBody = si(ua.requestBody, ua.requestHeaders, na, "Request")), ua != null && ua.responseBody && (ua.responseBody = si(ua.responseBody, ua.responseHeaders, na, "Response")), ua
			}),
			sa = function(ua) {
				return la(function(pa) {
					var va = pt(pa.name);
					if (!(va && va.pathname && ri.some(function(ba) {
							return va.pathname.indexOf(ba) === 0
						}))) return pa
				}((ha = (da = ua).requestHeaders, R(ha) || Q(Object.keys(ha ?? {}), function(pa) {
					ni.includes(pa.toLowerCase()) && (ha[pa] = ei)
				}), da)));
				var da, ha
			},
			ca = y(ue.session_recording.maskNetworkRequestFn);
		return ca && y(ue.session_recording.maskCapturedNetworkRequestFn) && G.warn("Both `maskNetworkRequestFn` and `maskCapturedNetworkRequestFn` are defined. `maskNetworkRequestFn` will be ignored."), ca && (ue.session_recording.maskCapturedNetworkRequestFn = function(ua) {
			var da = ue.session_recording.maskNetworkRequestFn({
				url: ua.name
			});
			return t(t({}, ua), {}, {
				name: da == null ? void 0 : da.url
			})
		}), ra.maskRequestFn = y(ue.session_recording.maskCapturedNetworkRequestFn) ? function(ua) {
			var da, ha, pa, va = sa(ua);
			return va && (da = (ha = (pa = ue.session_recording).maskCapturedNetworkRequestFn) === null || ha === void 0 ? void 0 : ha.call(pa, va)) !== null && da !== void 0 ? da : void 0
		} : function(ua) {
			return function(da) {
				if (!w(da)) return da.requestBody = oi(da.requestBody, "Request"), da.responseBody = oi(da.responseBody, "Response"), da
			}(sa(ua))
		}, t(t(t({}, ti), ra), {}, {
			recordHeaders: ia,
			recordBody: aa,
			recordPerformance: oa,
			recordInitialRequests: oa
		})
	},
	li = s(function ue(Yi) {
		var ea, ta, na = this,
			ra = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
		i(this, ue), o(this, "bucketSize", 100), o(this, "refillRate", 10), o(this, "mutationBuckets", {}), o(this, "loggedTracker", {}), o(this, "refillBuckets", function() {
			Object.keys(na.mutationBuckets).forEach(function(ia) {
				na.mutationBuckets[ia] = na.mutationBuckets[ia] + na.refillRate, na.mutationBuckets[ia] >= na.bucketSize && delete na.mutationBuckets[ia]
			})
		}), o(this, "getNodeOrRelevantParent", function(ia) {
			var aa = na.rrweb.mirror.getNode(ia);
			if ((aa == null ? void 0 : aa.nodeName) !== "svg" && aa instanceof Element) {
				var oa = aa.closest("svg");
				if (oa) return [na.rrweb.mirror.getId(oa), oa]
			}
			return [ia, aa]
		}), o(this, "numberOfChanges", function(ia) {
			var aa, oa, la, sa, ca, ua, da, ha;
			return ((aa = (oa = ia.removes) === null || oa === void 0 ? void 0 : oa.length) !== null && aa !== void 0 ? aa : 0) + ((la = (sa = ia.attributes) === null || sa === void 0 ? void 0 : sa.length) !== null && la !== void 0 ? la : 0) + ((ca = (ua = ia.texts) === null || ua === void 0 ? void 0 : ua.length) !== null && ca !== void 0 ? ca : 0) + ((da = (ha = ia.adds) === null || ha === void 0 ? void 0 : ha.length) !== null && da !== void 0 ? da : 0)
		}), o(this, "throttleMutations", function(ia) {
			if (ia.type !== 3 || ia.data.source !== 0) return ia;
			var aa = ia.data,
				oa = na.numberOfChanges(aa);
			aa.attributes && (aa.attributes = aa.attributes.filter(function(sa) {
				var ca, ua, da, ha = u(na.getNodeOrRelevantParent(sa.id), 2),
					pa = ha[0],
					va = ha[1];
				return na.mutationBuckets[pa] === 0 ? !1 : (na.mutationBuckets[pa] = (ca = na.mutationBuckets[pa]) !== null && ca !== void 0 ? ca : na.bucketSize, na.mutationBuckets[pa] = Math.max(na.mutationBuckets[pa] - 1, 0), na.mutationBuckets[pa] === 0 && (na.loggedTracker[pa] || (na.loggedTracker[pa] = !0, (ua = (da = na.options).onBlockedNode) === null || ua === void 0 || ua.call(da, pa, va))), sa)
			}));
			var la = na.numberOfChanges(aa);
			return la !== 0 || oa === la ? ia : void 0
		}), this.rrweb = Yi, this.options = ra, this.refillRate = (ea = this.options.refillRate) !== null && ea !== void 0 ? ea : this.refillRate, this.bucketSize = (ta = this.options.bucketSize) !== null && ta !== void 0 ? ta : this.bucketSize, setInterval(function() {
			na.refillBuckets()
		}, 1e3)
	}),
	ci = 3e5,
	di = [Rn.MouseMove, Rn.MouseInteraction, Rn.Scroll, Rn.ViewportResize, Rn.Input, Rn.TouchMove, Rn.MediaInteraction, Rn.Drag],
	hi = function(ue) {
		return {
			rrwebMethod: ue,
			enqueuedAt: Date.now(),
			attempt: 1
		}
	},
	fi = "[SessionRecording]",
	vi = function() {
		function ue(Yi) {
			var ea = this;
			if (i(this, ue), o(this, "queuedRRWebEvents", []), o(this, "isIdle", !1), o(this, "_linkedFlagSeen", !1), o(this, "_lastActivityTimestamp", Date.now()), o(this, "_linkedFlag", null), o(this, "_forceAllowLocalhostNetworkCapture", !1), o(this, "_onBeforeUnload", function() {
					ea._flushBuffer()
				}), o(this, "_onOffline", function() {
					ea._tryAddCustomEvent("browser offline", {})
				}), o(this, "_onOnline", function() {
					ea._tryAddCustomEvent("browser online", {})
				}), o(this, "_onVisibilityChange", function() {
					if (L != null && L.visibilityState) {
						var ia = "window " + L.visibilityState;
						ea._tryAddCustomEvent(ia, {})
					}
				}), o(this, "_samplingSessionListener", null), this.instance = Yi, this._captureStarted = !1, this._endpoint = "/s/", this.stopRrweb = void 0, this.receivedDecide = !1, !this.instance.sessionManager) throw G.error(fi + " started without valid sessionManager"), new Error(fi + " started without valid sessionManager. This is a bug.");
			var ta = this.sessionManager.checkAndGetSessionAndWindowId(),
				na = ta.sessionId,
				ra = ta.windowId;
			this.sessionId = na, this.windowId = ra, this.buffer = this.clearBuffer(), this._setupSampling()
		}
		return s(ue, [{
			key: "rrwebRecord",
			get: function() {
				var Yi;
				return U == null || (Yi = U.rrweb) === null || Yi === void 0 ? void 0 : Yi.record
			}
		}, {
			key: "started",
			get: function() {
				return this._captureStarted
			}
		}, {
			key: "sessionManager",
			get: function() {
				if (!this.instance.sessionManager) throw new Error(fi + " must be started with a valid sessionManager.");
				return this.instance.sessionManager
			}
		}, {
			key: "fullSnapshotIntervalMillis",
			get: function() {
				var Yi;
				return ((Yi = this.instance.config.session_recording) === null || Yi === void 0 ? void 0 : Yi.full_snapshot_interval_millis) || ci
			}
		}, {
			key: "isSampled",
			get: function() {
				var Yi = this.instance.get_property(Ee);
				return x(Yi) ? Yi : null
			}
		}, {
			key: "sessionDuration",
			get: function() {
				var Yi, ea, ta = (Yi = this.buffer) === null || Yi === void 0 ? void 0 : Yi.data[((ea = this.buffer) === null || ea === void 0 ? void 0 : ea.data.length) - 1],
					na = this.sessionManager.checkAndGetSessionAndWindowId(!0).sessionStartTimestamp;
				return ta ? ta.timestamp - na : null
			}
		}, {
			key: "isRecordingEnabled",
			get: function() {
				var Yi = !!this.instance.get_property(_e),
					ea = !this.instance.config.disable_session_recording;
				return T && Yi && ea
			}
		}, {
			key: "isConsoleLogCaptureEnabled",
			get: function() {
				var Yi = !!this.instance.get_property(me),
					ea = this.instance.config.enable_recording_console_log;
				return ea ?? Yi
			}
		}, {
			key: "canvasRecording",
			get: function() {
				var Yi = this.instance.get_property(be);
				return Yi && Yi.fps && Yi.quality ? {
					enabled: Yi.enabled,
					fps: Yi.fps,
					quality: Yi.quality
				} : void 0
			}
		}, {
			key: "networkPayloadCapture",
			get: function() {
				var Yi, ea, ta = this.instance.get_property(ye),
					na = {
						recordHeaders: (Yi = this.instance.config.session_recording) === null || Yi === void 0 ? void 0 : Yi.recordHeaders,
						recordBody: (ea = this.instance.config.session_recording) === null || ea === void 0 ? void 0 : ea.recordBody
					},
					ra = (na == null ? void 0 : na.recordHeaders) || (ta == null ? void 0 : ta.recordHeaders),
					ia = (na == null ? void 0 : na.recordBody) || (ta == null ? void 0 : ta.recordBody),
					aa = b(this.instance.config.capture_performance) ? this.instance.config.capture_performance.network_timing : this.instance.config.capture_performance,
					oa = !!(x(aa) ? aa : ta != null && ta.capturePerformance);
				return ra || ia || oa ? {
					recordHeaders: ra,
					recordBody: ia,
					recordPerformance: oa
				} : void 0
			}
		}, {
			key: "sampleRate",
			get: function() {
				var Yi = this.instance.get_property(ke);
				return F(Yi) ? Yi : null
			}
		}, {
			key: "minimumDuration",
			get: function() {
				var Yi = this.instance.get_property(we);
				return F(Yi) ? Yi : null
			}
		}, {
			key: "status",
			get: function() {
				return this.receivedDecide ? this.isRecordingEnabled ? R(this._linkedFlag) || this._linkedFlagSeen ? x(this.isSampled) ? this.isSampled ? "sampled" : "disabled" : "active" : "buffering" : "disabled" : "buffering"
			}
		}, {
			key: "startIfEnabledOrStop",
			value: function() {
				this.isRecordingEnabled ? (this._startCapture(), T == null || T.addEventListener("beforeunload", this._onBeforeUnload), T == null || T.addEventListener("offline", this._onOffline), T == null || T.addEventListener("online", this._onOnline), T == null || T.addEventListener("visibilitychange", this._onVisibilityChange), G.info(fi + " started")) : (this.stopRecording(), this.clearBuffer())
			}
		}, {
			key: "stopRecording",
			value: function() {
				this._captureStarted && this.stopRrweb && (this.stopRrweb(), this.stopRrweb = void 0, this._captureStarted = !1, T == null || T.removeEventListener("beforeunload", this._onBeforeUnload), T == null || T.removeEventListener("offline", this._onOffline), T == null || T.removeEventListener("online", this._onOnline), T == null || T.removeEventListener("visibilitychange", this._onVisibilityChange), G.info(fi + " stopped"))
			}
		}, {
			key: "makeSamplingDecision",
			value: function(Yi) {
				var ea, ta = this.sessionId !== Yi,
					na = this.sampleRate;
				if (F(na)) {
					var ra, ia = this.isSampled,
						aa = ta || !x(ia);
					aa ? ra = Math.random() < na : ra = ia, !ra && aa && G.warn(fi + " Sample rate (".concat(na, ") has determined that this sessionId (").concat(Yi, ") will not be sent to the server.")), this._tryAddCustomEvent("samplingDecisionMade", {
						sampleRate: na
					}), (ea = this.instance.persistence) === null || ea === void 0 || ea.register(o({}, Ee, ra))
				} else {
					var oa;
					(oa = this.instance.persistence) === null || oa === void 0 || oa.register(o({}, Ee, null))
				}
			}
		}, {
			key: "afterDecideResponse",
			value: function(Yi) {
				var ea, ta, na, ra = this;
				if (this._persistDecideResponse(Yi), this._linkedFlag = ((ea = Yi.sessionRecording) === null || ea === void 0 ? void 0 : ea.linkedFlag) || null, (ta = Yi.sessionRecording) !== null && ta !== void 0 && ta.endpoint && (this._endpoint = (na = Yi.sessionRecording) === null || na === void 0 ? void 0 : na.endpoint), this._setupSampling(), !R(this._linkedFlag) && !this._linkedFlagSeen) {
					var ia = S(this._linkedFlag) ? this._linkedFlag : this._linkedFlag.flag,
						aa = S(this._linkedFlag) ? null : this._linkedFlag.variant;
					this.instance.onFeatureFlags(function(oa, la) {
						var sa = b(la) && ia in la,
							ca = aa ? la[ia] === aa : sa;
						if (ca) {
							var ua = {
									linkedFlag: ia,
									linkedVariant: aa
								},
								da = "linked flag matched";
							G.info(fi + " " + da, ua), ra._tryAddCustomEvent(da, ua)
						}
						ra._linkedFlagSeen = ca
					})
				}
				this.receivedDecide = !0, this.startIfEnabledOrStop()
			}
		}, {
			key: "_setupSampling",
			value: function() {
				var Yi = this;
				F(this.sampleRate) && I(this._samplingSessionListener) && (this._samplingSessionListener = this.sessionManager.onSessionId(function(ea) {
					Yi.makeSamplingDecision(ea)
				}))
			}
		}, {
			key: "_persistDecideResponse",
			value: function(Yi) {
				if (this.instance.persistence) {
					var ea = this.instance.persistence,
						ta = function() {
							var na, ra, ia, aa, oa, la, sa, ca, ua = (na = Yi.sessionRecording) === null || na === void 0 ? void 0 : na.sampleRate,
								da = R(ua) ? null : parseFloat(ua),
								ha = (ra = Yi.sessionRecording) === null || ra === void 0 ? void 0 : ra.minimumDurationMilliseconds;
							ea.register((o(ca = {}, _e, !!Yi.sessionRecording), o(ca, me, (ia = Yi.sessionRecording) === null || ia === void 0 ? void 0 : ia.consoleLogRecordingEnabled), o(ca, ye, t({
								capturePerformance: Yi.capturePerformance
							}, (aa = Yi.sessionRecording) === null || aa === void 0 ? void 0 : aa.networkPayloadCapture)), o(ca, be, {
								enabled: (oa = Yi.sessionRecording) === null || oa === void 0 ? void 0 : oa.recordCanvas,
								fps: (la = Yi.sessionRecording) === null || la === void 0 ? void 0 : la.canvasFps,
								quality: (sa = Yi.sessionRecording) === null || sa === void 0 ? void 0 : sa.canvasQuality
							}), o(ca, ke, da), o(ca, we, w(ha) ? null : ha), ca))
						};
					ta(), this.sessionManager.onSessionId(ta)
				}
			}
		}, {
			key: "log",
			value: function(Yi) {
				var ea, ta = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "log";
				(ea = this.instance.sessionRecording) === null || ea === void 0 || ea.onRRwebEmit({
					type: 6,
					data: {
						plugin: "rrweb/console@1",
						payload: {
							level: ta,
							trace: [],
							payload: [JSON.stringify(Yi)]
						}
					},
					timestamp: K()
				})
			}
		}, {
			key: "_startCapture",
			value: function() {
				var Yi = this;
				w(Object.assign) || this._captureStarted || this.instance.config.disable_session_recording || this.instance.consent.isOptedOut() || (this._captureStarted = !0, this.sessionManager.checkAndGetSessionAndWindowId(), this.rrwebRecord ? this._onScriptLoaded() : this.instance.requestRouter.loadScript("/static/recorder.js?v=".concat(f.LIB_VERSION), function(ea) {
					if (ea) return G.error(fi + " could not load recorder.js", ea);
					Yi._onScriptLoaded()
				}))
			}
		}, {
			key: "isInteractiveEvent",
			value: function(Yi) {
				var ea;
				return Yi.type === 3 && di.indexOf((ea = Yi.data) === null || ea === void 0 ? void 0 : ea.source) !== -1
			}
		}, {
			key: "_updateWindowAndSessionIds",
			value: function(Yi) {
				var ea = this.isInteractiveEvent(Yi);
				ea || this.isIdle || Yi.timestamp - this._lastActivityTimestamp > 3e5 && (this.isIdle = !0, clearTimeout(this._fullSnapshotTimer), this._flushBuffer());
				var ta = !1;
				if (ea && (this._lastActivityTimestamp = Yi.timestamp, this.isIdle && (this.isIdle = !1, this._tryAddCustomEvent("sessionNoLongerIdle", {
						reason: "user activity",
						type: Yi.type
					}), ta = !0)), !this.isIdle) {
					var na = this.sessionManager.checkAndGetSessionAndWindowId(!ea, Yi.timestamp),
						ra = na.windowId,
						ia = na.sessionId,
						aa = this.sessionId !== ia,
						oa = this.windowId !== ra;
					this.windowId = ra, this.sessionId = ia, (ta || [wn, Sn].indexOf(Yi.type) === -1 && (oa || aa || w(this._fullSnapshotTimer))) && this._tryTakeFullSnapshot()
				}
			}
		}, {
			key: "_tryRRWebMethod",
			value: function(Yi) {
				try {
					return Yi.rrwebMethod(), !0
				} catch (ea) {
					return this.queuedRRWebEvents.length < 10 ? this.queuedRRWebEvents.push({
						enqueuedAt: Yi.enqueuedAt || Date.now(),
						attempt: Yi.attempt++,
						rrwebMethod: Yi.rrwebMethod
					}) : G.warn(fi + " could not emit queued rrweb event.", ea, Yi), !1
				}
			}
		}, {
			key: "_tryAddCustomEvent",
			value: function(Yi, ea) {
				var ta = this;
				return this._tryRRWebMethod(hi(function() {
					return ta.rrwebRecord.addCustomEvent(Yi, ea)
				}))
			}
		}, {
			key: "_tryTakeFullSnapshot",
			value: function() {
				var Yi = this;
				return this._tryRRWebMethod(hi(function() {
					return Yi.rrwebRecord.takeFullSnapshot()
				}))
			}
		}, {
			key: "_onScriptLoaded",
			value: function() {
				for (var Yi, ea = this, ta = {
						blockClass: "ph-no-capture",
						blockSelector: void 0,
						ignoreClass: "ph-ignore-input",
						maskTextClass: "ph-mask",
						maskTextSelector: void 0,
						maskTextFn: void 0,
						maskAllInputs: !0,
						maskInputOptions: {
							password: !0
						},
						maskInputFn: void 0,
						slimDOMOptions: {},
						collectFonts: !1,
						inlineStylesheet: !0,
						recordCrossOriginIframes: !1
					}, na = this.instance.config.session_recording, ra = 0, ia = Object.entries(na || {}); ra < ia.length; ra++) {
					var aa = u(ia[ra], 2),
						oa = aa[0],
						la = aa[1];
					oa in ta && (oa === "maskInputOptions" ? ta.maskInputOptions = t({
						password: !0
					}, la) : ta[oa] = la)
				}
				if (this.canvasRecording && this.canvasRecording.enabled && (ta.recordCanvas = !0, ta.sampling = {
						canvas: this.canvasRecording.fps
					}, ta.dataURLOptions = {
						type: "image/webp",
						quality: this.canvasRecording.quality
					}), this.rrwebRecord) {
					this.mutationRateLimiter = (Yi = this.mutationRateLimiter) !== null && Yi !== void 0 ? Yi : new li(this.rrwebRecord, {
						onBlockedNode: function(ca, ua) {
							var da = "Too many mutations on node '".concat(ca, "'. Rate limiting. This could be due to SVG animations or something similar");
							G.info(da, {
								node: ua
							}), ea.log(fi + " " + da, "warn")
						}
					});
					var sa = this._gatherRRWebPlugins();
					this.stopRrweb = this.rrwebRecord(t({
						emit: function(ca) {
							ea.onRRwebEmit(ca)
						},
						plugins: sa
					}, ta)), this.instance._addCaptureHook(function(ca) {
						try {
							if (ca === "$pageview") {
								var ua = T ? ea._maskUrl(T.location.href) : "";
								if (!ua) return;
								ea._tryAddCustomEvent("$pageview", {
									href: ua
								})
							}
						} catch (da) {
							G.error("Could not add $pageview to rrweb session", da)
						}
					}), this._lastActivityTimestamp = Date.now(), this.isIdle = !1, this._tryAddCustomEvent("$session_options", {
						sessionRecordingOptions: ta,
						activePlugins: sa.map(function(ca) {
							return ca == null ? void 0 : ca.name
						})
					}), this._tryAddCustomEvent("$posthog_config", {
						config: this.instance.config
					})
				} else G.error(fi + "onScriptLoaded was called but rrwebRecord is not available. This indicates something has gone wrong.")
			}
		}, {
			key: "_scheduleFullSnapshot",
			value: function() {
				var Yi = this;
				if (this._fullSnapshotTimer && clearInterval(this._fullSnapshotTimer), !this.isIdle) {
					var ea = this.fullSnapshotIntervalMillis;
					ea && (this._fullSnapshotTimer = setInterval(function() {
						Yi._tryTakeFullSnapshot()
					}, ea))
				}
			}
		}, {
			key: "_gatherRRWebPlugins",
			value: function() {
				var Yi = [];
				return U.rrwebConsoleRecord && this.isConsoleLogCaptureEnabled && Yi.push(U.rrwebConsoleRecord.getRecordConsolePlugin()), this.networkPayloadCapture && y(U.getRecordNetworkPlugin) && (!vt.includes(location.hostname) || this._forceAllowLocalhostNetworkCapture ? Yi.push(U.getRecordNetworkPlugin(ui(this.instance.config, this.networkPayloadCapture))) : G.info(fi + " NetworkCapture not started because we are on localhost.")), Yi
			}
		}, {
			key: "onRRwebEmit",
			value: function(Yi) {
				if (this._processQueuedEvents(), Yi && b(Yi)) {
					if (Yi.type === In.Meta) {
						var ea = this._maskUrl(Yi.data.href);
						if (this._lastHref = ea, !ea) return;
						Yi.data.href = ea
					} else this._pageViewFallBack();
					Yi.type === In.FullSnapshot && this._scheduleFullSnapshot();
					var ta = this.mutationRateLimiter ? this.mutationRateLimiter.throttleMutations(Yi) : Yi;
					if (ta) {
						var na = function(aa) {
								var oa = aa;
								if (oa && b(oa) && oa.type === 6 && b(oa.data) && oa.data.plugin === "rrweb/console@1") {
									oa.data.payload.payload.length > 10 && (oa.data.payload.payload = oa.data.payload.payload.slice(0, 10), oa.data.payload.payload.push("...[truncated]"));
									for (var la = [], sa = 0; sa < oa.data.payload.payload.length; sa++) oa.data.payload.payload[sa] && oa.data.payload.payload[sa].length > 2e3 ? la.push(oa.data.payload.payload[sa].slice(0, 2e3) + "...[truncated]") : la.push(oa.data.payload.payload[sa]);
									return oa.data.payload.payload = la, aa
								}
								return aa
							}(ta),
							ra = kn(na);
						if (this._updateWindowAndSessionIds(na), !this.isIdle || na.type === In.Custom) {
							var ia = {
								$snapshot_bytes: ra,
								$snapshot_data: na,
								$session_id: this.sessionId,
								$window_id: this.windowId
							};
							this.status !== "disabled" ? this._captureSnapshotBuffered(ia) : this.clearBuffer()
						}
					}
				}
			}
		}, {
			key: "_pageViewFallBack",
			value: function() {
				if (!this.instance.config.capture_pageview && T) {
					var Yi = this._maskUrl(T.location.href);
					this._lastHref !== Yi && (this._tryAddCustomEvent("$url_changed", {
						href: Yi
					}), this._lastHref = Yi)
				}
			}
		}, {
			key: "_processQueuedEvents",
			value: function() {
				var Yi = this;
				if (this.queuedRRWebEvents.length) {
					var ea = l(this.queuedRRWebEvents);
					this.queuedRRWebEvents = [], ea.forEach(function(ta) {
						Date.now() - ta.enqueuedAt <= 2e3 && Yi._tryRRWebMethod(ta)
					})
				}
			}
		}, {
			key: "_maskUrl",
			value: function(Yi) {
				var ea = this.instance.config.session_recording;
				if (ea.maskNetworkRequestFn) {
					var ta, na = {
						url: Yi
					};
					return (ta = na = ea.maskNetworkRequestFn(na)) === null || ta === void 0 ? void 0 : ta.url
				}
				return Yi
			}
		}, {
			key: "clearBuffer",
			value: function() {
				return this.buffer = {
					size: 0,
					data: [],
					sessionId: this.sessionId,
					windowId: this.windowId
				}, this.buffer
			}
		}, {
			key: "_flushBuffer",
			value: function() {
				var Yi = this;
				this.flushBufferTimer && (clearTimeout(this.flushBufferTimer), this.flushBufferTimer = void 0);
				var ea = this.minimumDuration,
					ta = this.sessionDuration,
					na = F(ta) && ta >= 0,
					ra = F(ea) && na && ta < ea;
				return this.status === "buffering" || ra ? (this.flushBufferTimer = setTimeout(function() {
					Yi._flushBuffer()
				}, 2e3), this.buffer) : (this.buffer.data.length > 0 && En(this.buffer).forEach(function(ia) {
					Yi._captureSnapshot({
						$snapshot_bytes: ia.size,
						$snapshot_data: ia.data,
						$session_id: ia.sessionId,
						$window_id: ia.windowId
					})
				}), this.clearBuffer())
			}
		}, {
			key: "_captureSnapshotBuffered",
			value: function(Yi) {
				var ea, ta = this,
					na = 2 + (((ea = this.buffer) === null || ea === void 0 ? void 0 : ea.data.length) || 0);
				(this.buffer.size + Yi.$snapshot_bytes + na > 943718.4 || this.buffer.sessionId !== this.sessionId) && (this.buffer = this._flushBuffer()), this.buffer.size += Yi.$snapshot_bytes, this.buffer.data.push(Yi.$snapshot_data), this.flushBufferTimer || (this.flushBufferTimer = setTimeout(function() {
					ta._flushBuffer()
				}, 2e3))
			}
		}, {
			key: "_captureSnapshot",
			value: function(Yi) {
				this.instance.capture("$snapshot", Yi, {
					_url: this.instance.requestRouter.endpointFor("api", this._endpoint),
					_noTruncate: !0,
					_batchKey: "recordings",
					skip_client_rate_limiting: !0
				})
			}
		}, {
			key: "overrideLinkedFlag",
			value: function() {
				this._linkedFlagSeen = !0
			}
		}]), ue
	}(),
	pi = function() {
		function ue(Yi) {
			i(this, ue), this.instance = Yi, this.instance.decideEndpointWasHit = this.instance._hasBootstrappedFeatureFlags()
		}
		return s(ue, [{
			key: "call",
			value: function() {
				var Yi = this,
					ea = {
						token: this.instance.config.token,
						distinct_id: this.instance.get_distinct_id(),
						groups: this.instance.getGroups(),
						person_properties: this.instance.get_property(Fe),
						group_properties: this.instance.get_property(xe),
						disable_flags: this.instance.config.advanced_disable_feature_flags || this.instance.config.advanced_disable_feature_flags_on_first_load || void 0
					};
				this.instance._send_request({
					method: "POST",
					url: this.instance.requestRouter.endpointFor("api", "/decide/?v=3"),
					data: ea,
					compression: this.instance.config.disable_compression ? void 0 : re.Base64,
					timeout: this.instance.config.feature_flag_request_timeout_ms,
					callback: function(ta) {
						return Yi.parseDecideResponse(ta.json)
					}
				})
			}
		}, {
			key: "parseDecideResponse",
			value: function(Yi) {
				var ea = this;
				this.instance.featureFlags.setReloadingPaused(!1), this.instance.featureFlags._startReloadTimer();
				var ta = !Yi;
				if (this.instance.config.advanced_disable_feature_flags_on_first_load || this.instance.config.advanced_disable_feature_flags || this.instance.featureFlags.receivedFeatureFlags(Yi ?? {}, ta), ta) G.error("Failed to fetch feature flags from PostHog.");
				else {
					if (!L || !L.body) return G.info("document not ready yet, trying again in 500 milliseconds..."), void setTimeout(function() {
						ea.parseDecideResponse(Yi)
					}, 500);
					if (this.instance._afterDecideResponse(Yi), Yi.siteApps)
						if (this.instance.config.opt_in_site_apps) {
							var na, ra = h(Yi.siteApps);
							try {
								var ia = function() {
									var aa = na.value,
										oa = aa.id,
										la = aa.url,
										sa = ea.instance.requestRouter.endpointFor("api", la);
									U["__$$ph_site_app_".concat(oa)] = ea.instance, ea.instance.requestRouter.loadScript(sa, function(ca) {
										if (ca) return G.error("Error while initializing PostHog app with config id ".concat(oa), ca)
									})
								};
								for (ra.s(); !(na = ra.n()).done;) ia()
							} catch (aa) {
								ra.e(aa)
							} finally {
								ra.f()
							}
						} else Yi.siteApps.length > 0 && G.error('PostHog site apps are disabled. Enable the "opt_in_site_apps" config to proceed.')
				}
			}
		}]), ue
	}(),
	gi = T != null && T.location ? yt(T.location.hash, "__posthog") || yt(location.hash, "state") : null,
	_i = "_postHogToolbarParams";
(function(ue) {
	ue[ue.UNINITIALIZED = 0] = "UNINITIALIZED", ue[ue.LOADING = 1] = "LOADING", ue[ue.LOADED = 2] = "LOADED"
})(ai || (ai = {}));
var mi = function() {
		function ue(Yi) {
			i(this, ue), this.instance = Yi
		}
		return s(ue, [{
			key: "setToolbarState",
			value: function(Yi) {
				U.ph_toolbar_state = Yi
			}
		}, {
			key: "getToolbarState",
			value: function() {
				var Yi;
				return (Yi = U.ph_toolbar_state) !== null && Yi !== void 0 ? Yi : ai.UNINITIALIZED
			}
		}, {
			key: "maybeLoadToolbar",
			value: function() {
				var Yi, ea, ta = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0,
					na = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0,
					ra = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
				if (!T || !L) return !1;
				ta = (Yi = ta) !== null && Yi !== void 0 ? Yi : T.location, ra = (ea = ra) !== null && ea !== void 0 ? ea : T.history;
				try {
					if (!na) {
						try {
							T.localStorage.setItem("test", "test"), T.localStorage.removeItem("test")
						} catch {
							return !1
						}
						na = T == null ? void 0 : T.localStorage
					}
					var ia, aa = gi || yt(ta.hash, "__posthog") || yt(ta.hash, "state"),
						oa = aa ? Z(function() {
							return JSON.parse(atob(decodeURIComponent(aa)))
						}) || Z(function() {
							return JSON.parse(decodeURIComponent(aa))
						}) : null;
					return oa && oa.action === "ph_authorize" ? ((ia = oa).source = "url", ia && Object.keys(ia).length > 0 && (oa.desiredHash ? ta.hash = oa.desiredHash : ra ? ra.replaceState(ra.state, "", ta.pathname + ta.search) : ta.hash = "")) : ((ia = JSON.parse(na.getItem(_i) || "{}")).source = "localstorage", delete ia.userIntent), !(!ia.token || this.instance.config.token !== ia.token) && (this.loadToolbar(ia), !0)
				} catch {
					return !1
				}
			}
		}, {
			key: "_callLoadToolbar",
			value: function(Yi) {
				(U.ph_load_toolbar || U.ph_load_editor)(Yi, this.instance)
			}
		}, {
			key: "loadToolbar",
			value: function(Yi) {
				var ea = this,
					ta = !(L == null || !L.getElementById(Ne));
				if (!T || ta) return !1;
				var na = this.instance.requestRouter.region === "custom" && this.instance.config.advanced_disable_toolbar_metrics,
					ra = t(t({
						token: this.instance.config.token
					}, Yi), {}, {
						apiURL: this.instance.requestRouter.endpointFor("ui")
					}, na ? {
						instrument: !1
					} : {});
				if (T.localStorage.setItem(_i, JSON.stringify(t(t({}, ra), {}, {
						source: void 0
					}))), this.getToolbarState() === ai.LOADED) this._callLoadToolbar(ra);
				else if (this.getToolbarState() === ai.UNINITIALIZED) {
					this.setToolbarState(ai.LOADING);
					var ia = 3e5,
						aa = Math.floor(Date.now() / ia) * ia;
					this.instance.requestRouter.loadScript("/static/toolbar.js?t=".concat(aa), function(oa) {
						if (oa) return G.error("Failed to load toolbar", oa), void ea.setToolbarState(ai.UNINITIALIZED);
						ea.setToolbarState(ai.LOADED), ea._callLoadToolbar(ra)
					}), oe(T, "turbolinks:load", function() {
						ea.setToolbarState(ai.UNINITIALIZED), ea.loadToolbar(ra)
					})
				}
				return !0
			}
		}, {
			key: "_loadEditor",
			value: function(Yi) {
				return this.loadToolbar(Yi)
			}
		}, {
			key: "maybeLoadEditor",
			value: function() {
				var Yi = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0,
					ea = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0,
					ta = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
				return this.maybeLoadToolbar(Yi, ea, ta)
			}
		}]), ue
	}(),
	yi = function() {
		function ue(Yi) {
			i(this, ue), o(this, "isPaused", !0), o(this, "queue", []), o(this, "flushTimeoutMs", 3e3), this.sendRequest = Yi
		}
		return s(ue, [{
			key: "enqueue",
			value: function(Yi) {
				this.queue.push(Yi), this.flushTimeout || this.setFlushTimeout()
			}
		}, {
			key: "unload",
			value: function() {
				var Yi = this;
				this.clearFlushTimeout();
				var ea = this.queue.length > 0 ? this.formatQueue() : {},
					ta = Object.values(ea);
				[].concat(l(ta.filter(function(na) {
					return na.url.indexOf("/e") === 0
				})), l(ta.filter(function(na) {
					return na.url.indexOf("/e") !== 0
				}))).map(function(na) {
					Yi.sendRequest(t(t({}, na), {}, {
						transport: "sendBeacon"
					}))
				})
			}
		}, {
			key: "enable",
			value: function() {
				this.isPaused = !1, this.setFlushTimeout()
			}
		}, {
			key: "setFlushTimeout",
			value: function() {
				var Yi = this;
				this.isPaused || (this.flushTimeout = setTimeout(function() {
					if (Yi.clearFlushTimeout(), Yi.queue.length > 0) {
						var ea = Yi.formatQueue(),
							ta = function(ra) {
								var ia = ea[ra],
									aa = new Date().getTime();
								ia.data && m(ia.data) && Q(ia.data, function(oa) {
									oa.offset = Math.abs(oa.timestamp - aa), delete oa.timestamp
								}), Yi.sendRequest(ia)
							};
						for (var na in ea) ta(na)
					}
				}, this.flushTimeoutMs))
			}
		}, {
			key: "clearFlushTimeout",
			value: function() {
				clearTimeout(this.flushTimeout), this.flushTimeout = void 0
			}
		}, {
			key: "formatQueue",
			value: function() {
				var Yi = {};
				return Q(this.queue, function(ea) {
					var ta, na = ea,
						ra = (na ? na.batchKey : null) || na.url;
					w(Yi[ra]) && (Yi[ra] = t(t({}, na), {}, {
						data: []
					})), (ta = Yi[ra].data) === null || ta === void 0 || ta.push(na.data)
				}), this.queue = [], Yi
			}
		}]), ue
	}(),
	bi = Uint8Array,
	ki = Uint16Array,
	wi = Uint32Array,
	Si = new bi([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
	Ei = new bi([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
	Ii = new bi([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
	Ri = function(ue, Yi) {
		for (var ea = new ki(31), ta = 0; ta < 31; ++ta) ea[ta] = Yi += 1 << ue[ta - 1];
		var na = new wi(ea[30]);
		for (ta = 1; ta < 30; ++ta)
			for (var ra = ea[ta]; ra < ea[ta + 1]; ++ra) na[ra] = ra - ea[ta] << 5 | ta;
		return [ea, na]
	},
	Fi = Ri(Si, 2),
	xi = Fi[0],
	Pi = Fi[1];
xi[28] = 258, Pi[258] = 28;
for (var Ti = Ri(Ei, 0)[1], Ci = new ki(32768), $i = 0; $i < 32768; ++$i) {
	var Oi = (43690 & $i) >>> 1 | (21845 & $i) << 1;
	Oi = (61680 & (Oi = (52428 & Oi) >>> 2 | (13107 & Oi) << 2)) >>> 4 | (3855 & Oi) << 4, Ci[$i] = ((65280 & Oi) >>> 8 | (255 & Oi) << 8) >>> 1
}
var Mi = function(ue, Yi, ea) {
		for (var ta = ue.length, na = 0, ra = new ki(Yi); na < ta; ++na) ++ra[ue[na] - 1];
		var ia, aa = new ki(Yi);
		for (na = 0; na < Yi; ++na) aa[na] = aa[na - 1] + ra[na - 1] << 1;
		for (ia = new ki(ta), na = 0; na < ta; ++na) ia[na] = Ci[aa[ue[na] - 1]++] >>> 15 - ue[na];
		return ia
	},
	Ai = new bi(288);
for ($i = 0; $i < 144; ++$i) Ai[$i] = 8;
for ($i = 144; $i < 256; ++$i) Ai[$i] = 9;
for ($i = 256; $i < 280; ++$i) Ai[$i] = 7;
for ($i = 280; $i < 288; ++$i) Ai[$i] = 8;
var Li = new bi(32);
for ($i = 0; $i < 32; ++$i) Li[$i] = 5;
var Di = Mi(Ai, 9),
	qi = Mi(Li, 5),
	Ni = function(ue) {
		return (ue / 8 >> 0) + (7 & ue && 1)
	},
	Bi = function(ue, Yi, ea) {
		(ea == null || ea > ue.length) && (ea = ue.length);
		var ta = new(ue instanceof ki ? ki : ue instanceof wi ? wi : bi)(ea - Yi);
		return ta.set(ue.subarray(Yi, ea)), ta
	},
	Hi = function(ue, Yi, ea) {
		ea <<= 7 & Yi;
		var ta = Yi / 8 >> 0;
		ue[ta] |= ea, ue[ta + 1] |= ea >>> 8
	},
	Ui = function(ue, Yi, ea) {
		ea <<= 7 & Yi;
		var ta = Yi / 8 >> 0;
		ue[ta] |= ea, ue[ta + 1] |= ea >>> 8, ue[ta + 2] |= ea >>> 16
	},
	ji = function(ue, Yi) {
		for (var ea = [], ta = 0; ta < ue.length; ++ta) ue[ta] && ea.push({
			s: ta,
			f: ue[ta]
		});
		var na = ea.length,
			ra = ea.slice();
		if (!na) return [new bi(0), 0];
		if (na == 1) {
			var ia = new bi(ea[0].s + 1);
			return ia[ea[0].s] = 1, [ia, 1]
		}
		ea.sort(function(ka, Pa) {
			return ka.f - Pa.f
		}), ea.push({
			s: -1,
			f: 25001
		});
		var aa = ea[0],
			oa = ea[1],
			la = 0,
			sa = 1,
			ca = 2;
		for (ea[0] = {
				s: -1,
				f: aa.f + oa.f,
				l: aa,
				r: oa
			}; sa != na - 1;) aa = ea[ea[la].f < ea[ca].f ? la++ : ca++], oa = ea[la != sa && ea[la].f < ea[ca].f ? la++ : ca++], ea[sa++] = {
			s: -1,
			f: aa.f + oa.f,
			l: aa,
			r: oa
		};
		var ua = ra[0].s;
		for (ta = 1; ta < na; ++ta) ra[ta].s > ua && (ua = ra[ta].s);
		var da = new ki(ua + 1),
			ha = Gi(ea[sa - 1], da, 0);
		if (ha > Yi) {
			ta = 0;
			var pa = 0,
				va = ha - Yi,
				ba = 1 << va;
			for (ra.sort(function(ka, Pa) {
					return da[Pa.s] - da[ka.s] || ka.f - Pa.f
				}); ta < na; ++ta) {
				var Ea = ra[ta].s;
				if (!(da[Ea] > Yi)) break;
				pa += ba - (1 << ha - da[Ea]), da[Ea] = Yi
			}
			for (pa >>>= va; pa > 0;) {
				var Sa = ra[ta].s;
				da[Sa] < Yi ? pa -= 1 << Yi - da[Sa]++ - 1 : ++ta
			}
			for (; ta >= 0 && pa; --ta) {
				var Ca = ra[ta].s;
				da[Ca] == Yi && (--da[Ca], ++pa)
			}
			ha = Yi
		}
		return [new bi(da), ha]
	},
	Gi = function ue(Yi, ea, ta) {
		return Yi.s == -1 ? Math.max(ue(Yi.l, ea, ta + 1), ue(Yi.r, ea, ta + 1)) : ea[Yi.s] = ta
	},
	Wi = function(ue) {
		for (var Yi = ue.length; Yi && !ue[--Yi];);
		for (var ea = new ki(++Yi), ta = 0, na = ue[0], ra = 1, ia = function(oa) {
				ea[ta++] = oa
			}, aa = 1; aa <= Yi; ++aa)
			if (ue[aa] == na && aa != Yi) ++ra;
			else {
				if (!na && ra > 2) {
					for (; ra > 138; ra -= 138) ia(32754);
					ra > 2 && (ia(ra > 10 ? ra - 11 << 5 | 28690 : ra - 3 << 5 | 12305), ra = 0)
				} else if (ra > 3) {
					for (ia(na), --ra; ra > 6; ra -= 6) ia(8304);
					ra > 2 && (ia(ra - 3 << 5 | 8208), ra = 0)
				}
				for (; ra--;) ia(na);
				ra = 1, na = ue[aa]
			} return [ea.subarray(0, ta), Yi]
	},
	Vi = function(ue, Yi) {
		for (var ea = 0, ta = 0; ta < Yi.length; ++ta) ea += ue[ta] * Yi[ta];
		return ea
	},
	zi = function(ue, Yi, ea) {
		var ta = ea.length,
			na = Ni(Yi + 2);
		ue[na] = 255 & ta, ue[na + 1] = ta >>> 8, ue[na + 2] = 255 ^ ue[na], ue[na + 3] = 255 ^ ue[na + 1];
		for (var ra = 0; ra < ta; ++ra) ue[na + ra + 4] = ea[ra];
		return 8 * (na + 4 + ta)
	},
	Qi = function(ue, Yi, ea, ta, na, ra, ia, aa, oa, la, sa) {
		Hi(Yi, sa++, ea), ++na[256];
		for (var ca = ji(na, 15), ua = ca[0], da = ca[1], ha = ji(ra, 15), pa = ha[0], va = ha[1], ba = Wi(ua), Ea = ba[0], Sa = ba[1], Ca = Wi(pa), ka = Ca[0], Pa = Ca[1], ja = new ki(19), Za = 0; Za < Ea.length; ++Za) ja[31 & Ea[Za]]++;
		for (Za = 0; Za < ka.length; ++Za) ja[31 & ka[Za]]++;
		for (var Ga = ji(ja, 7), Ja = Ga[0], Ua = Ga[1], xa = 19; xa > 4 && !Ja[Ii[xa - 1]]; --xa);
		var ma, fa, ga, wa, Ma = la + 5 << 3,
			Aa = Vi(na, Ai) + Vi(ra, Li) + ia,
			Ra = Vi(na, ua) + Vi(ra, pa) + ia + 14 + 3 * xa + Vi(ja, Ja) + (2 * ja[16] + 3 * ja[17] + 7 * ja[18]);
		if (Ma <= Aa && Ma <= Ra) return zi(Yi, sa, ue.subarray(oa, oa + la));
		if (Hi(Yi, sa, 1 + (Ra < Aa)), sa += 2, Ra < Aa) {
			ma = Mi(ua, da), fa = ua, ga = Mi(pa, va), wa = pa;
			var Ta = Mi(Ja, Ua);
			for (Hi(Yi, sa, Sa - 257), Hi(Yi, sa + 5, Pa - 1), Hi(Yi, sa + 10, xa - 4), sa += 14, Za = 0; Za < xa; ++Za) Hi(Yi, sa + 3 * Za, Ja[Ii[Za]]);
			sa += 3 * xa;
			for (var La = [Ea, ka], ya = 0; ya < 2; ++ya) {
				var Ba = La[ya];
				for (Za = 0; Za < Ba.length; ++Za) {
					var io = 31 & Ba[Za];
					Hi(Yi, sa, Ta[io]), sa += Ja[io], io > 15 && (Hi(Yi, sa, Ba[Za] >>> 5 & 127), sa += Ba[Za] >>> 12)
				}
			}
		} else ma = Di, fa = Ai, ga = qi, wa = Li;
		for (Za = 0; Za < aa; ++Za)
			if (ta[Za] > 255) {
				io = ta[Za] >>> 18 & 31, Ui(Yi, sa, ma[io + 257]), sa += fa[io + 257], io > 7 && (Hi(Yi, sa, ta[Za] >>> 23 & 31), sa += Si[io]);
				var oo = 31 & ta[Za];
				Ui(Yi, sa, ga[oo]), sa += wa[oo], oo > 3 && (Ui(Yi, sa, ta[Za] >>> 5 & 8191), sa += Ei[oo])
			} else Ui(Yi, sa, ma[ta[Za]]), sa += fa[ta[Za]];
		return Ui(Yi, sa, ma[256]), sa + fa[256]
	},
	Ji = new wi([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
	Xi = function() {
		for (var ue = new wi(256), Yi = 0; Yi < 256; ++Yi) {
			for (var ea = Yi, ta = 9; --ta;) ea = (1 & ea && 3988292384) ^ ea >>> 1;
			ue[Yi] = ea
		}
		return ue
	}(),
	Ki = function(ue, Yi, ea, ta, na) {
		return function(ra, ia, aa, oa, la, sa) {
			var ca = ra.length,
				ua = new bi(oa + ca + 5 * (1 + Math.floor(ca / 7e3)) + la),
				da = ua.subarray(oa, ua.length - la),
				ha = 0;
			if (!ia || ca < 8)
				for (var pa = 0; pa <= ca; pa += 65535) {
					var va = pa + 65535;
					va < ca ? ha = zi(da, ha, ra.subarray(pa, va)) : (da[pa] = sa, ha = zi(da, ha, ra.subarray(pa, ca)))
				} else {
					for (var ba = Ji[ia - 1], Ea = ba >>> 13, Sa = 8191 & ba, Ca = (1 << aa) - 1, ka = new ki(32768), Pa = new ki(Ca + 1), ja = Math.ceil(aa / 3), Za = 2 * ja, Ga = function(fo) {
							return (ra[fo] ^ ra[fo + 1] << ja ^ ra[fo + 2] << Za) & Ca
						}, Ja = new wi(25e3), Ua = new ki(288), xa = new ki(32), ma = 0, fa = 0, ga = (pa = 0, 0), wa = 0, Ma = 0; pa < ca; ++pa) {
						var Aa = Ga(pa),
							Ra = 32767 & pa,
							Ta = Pa[Aa];
						if (ka[Ra] = Ta, Pa[Aa] = Ra, wa <= pa) {
							var La = ca - pa;
							if ((ma > 7e3 || ga > 24576) && La > 423) {
								ha = Qi(ra, da, 0, Ja, Ua, xa, fa, ga, Ma, pa - Ma, ha), ga = ma = fa = 0, Ma = pa;
								for (var ya = 0; ya < 286; ++ya) Ua[ya] = 0;
								for (ya = 0; ya < 30; ++ya) xa[ya] = 0
							}
							var Ba = 2,
								io = 0,
								oo = Sa,
								ao = Ra - Ta & 32767;
							if (La > 2 && Aa == Ga(pa - ao))
								for (var Ia = Math.min(Ea, La) - 1, Na = Math.min(32767, pa), za = Math.min(258, La); ao <= Na && --oo && Ra != Ta;) {
									if (ra[pa + Ba] == ra[pa + Ba - ao]) {
										for (var ro = 0; ro < za && ra[pa + ro] == ra[pa + ro - ao]; ++ro);
										if (ro > Ba) {
											if (Ba = ro, io = ao, ro > Ia) break;
											var Va = Math.min(ao, ro - 2),
												Wa = 0;
											for (ya = 0; ya < Va; ++ya) {
												var qa = pa - ao + ya + 32768 & 32767,
													Ka = qa - ka[qa] + 32768 & 32767;
												Ka > Wa && (Wa = Ka, Ta = qa)
											}
										}
									}
									ao += (Ra = Ta) - (Ta = ka[Ra]) + 32768 & 32767
								}
							if (io) {
								Ja[ga++] = 268435456 | Pi[Ba] << 18 | Ti[io];
								var lo = 31 & Pi[Ba],
									yo = 31 & Ti[io];
								fa += Si[lo] + Ei[yo], ++Ua[257 + lo], ++xa[yo], wa = pa + Ba, ++ma
							} else Ja[ga++] = ra[pa], ++Ua[ra[pa]]
						}
					}
					ha = Qi(ra, da, sa, Ja, Ua, xa, fa, ga, Ma, pa - Ma, ha)
				}
			return Bi(ua, 0, oa + Ni(ha) + la)
		}(ue, Yi.level == null ? 6 : Yi.level, Yi.mem == null ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(ue.length)))) : 12 + Yi.mem, ea, ta, !na)
	},
	Zi = function(ue, Yi, ea) {
		for (; ea; ++Yi) ue[Yi] = ea, ea >>>= 8
	};

function er(ue, Yi) {
	Yi === void 0 && (Yi = {});
	var ea = function() {
			var aa = 4294967295;
			return {
				p: function(oa) {
					for (var la = aa, sa = 0; sa < oa.length; ++sa) la = Xi[255 & la ^ oa[sa]] ^ la >>> 8;
					aa = la
				},
				d: function() {
					return 4294967295 ^ aa
				}
			}
		}(),
		ta = ue.length;
	ea.p(ue);
	var na, ra = Ki(ue, Yi, 10 + ((na = Yi).filename && na.filename.length + 1 || 0), 8),
		ia = ra.length;
	return function(aa, oa) {
		var la = oa.filename;
		if (aa[0] = 31, aa[1] = 139, aa[2] = 8, aa[8] = oa.level < 2 ? 4 : oa.level == 9 ? 2 : 0, aa[9] = 3, oa.mtime != 0 && Zi(aa, 4, Math.floor(new Date(oa.mtime || Date.now()) / 1e3)), la) {
			aa[3] = 8;
			for (var sa = 0; sa <= la.length; ++sa) aa[sa + 10] = la.charCodeAt(sa)
		}
	}(ra, Yi), Zi(ra, ia - 8, ea.d()), Zi(ra, ia - 4, ta), ra
}
var tr = !!N || !!q,
	nr = "text/plain",
	ir = function(ue, Yi) {
		var ea = u(ue.split("?"), 2),
			ta = ea[0],
			na = ea[1],
			ra = t({}, Yi);
		na == null || na.split("&").forEach(function(aa) {
			var oa = u(aa.split("="), 1)[0];
			delete ra[oa]
		});
		var ia = _t(ra);
		return ia = ia ? (na ? na + "&" : "") + ia : na, "".concat(ta, "?").concat(ia)
	},
	rr = function(ue) {
		return "data=" + encodeURIComponent(typeof ue == "string" ? ue : JSON.stringify(ue))
	},
	sr = function(ue) {
		var Yi = ue.data,
			ea = ue.compression;
		if (Yi) {
			if (ea === re.GZipJS) {
				var ta = er(function(ra, ia) {
					var aa = ra.length;
					if (typeof TextEncoder < "u") return new TextEncoder().encode(ra);
					for (var oa = new bi(ra.length + (ra.length >>> 1)), la = 0, sa = function(ha) {
							oa[la++] = ha
						}, ca = 0; ca < aa; ++ca) {
						if (la + 5 > oa.length) {
							var ua = new bi(la + 8 + (aa - ca << 1));
							ua.set(oa), oa = ua
						}
						var da = ra.charCodeAt(ca);
						da < 128 || ia ? sa(da) : da < 2048 ? (sa(192 | da >>> 6), sa(128 | 63 & da)) : da > 55295 && da < 57344 ? (sa(240 | (da = 65536 + (1047552 & da) | 1023 & ra.charCodeAt(++ca)) >>> 18), sa(128 | da >>> 12 & 63), sa(128 | da >>> 6 & 63), sa(128 | 63 & da)) : (sa(224 | da >>> 12), sa(128 | da >>> 6 & 63), sa(128 | 63 & da))
					}
					return Bi(oa, 0, la)
				}(JSON.stringify(Yi)), {
					mtime: 0
				});
				return {
					contentType: nr,
					body: new Blob([ta], {
						type: nr
					})
				}
			}
			if (ea === re.Base64) {
				var na = function(ra) {
					var ia, aa, oa, la, sa, ca = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
						ua = 0,
						da = 0,
						ha = "",
						pa = [];
					if (!ra) return ra;
					ra = se(ra);
					do ia = (sa = ra.charCodeAt(ua++) << 16 | ra.charCodeAt(ua++) << 8 | ra.charCodeAt(ua++)) >> 18 & 63, aa = sa >> 12 & 63, oa = sa >> 6 & 63, la = 63 & sa, pa[da++] = ca.charAt(ia) + ca.charAt(aa) + ca.charAt(oa) + ca.charAt(la); while (ua < ra.length);
					switch (ha = pa.join(""), ra.length % 3) {
						case 1:
							ha = ha.slice(0, -2) + "==";
							break;
						case 2:
							ha = ha.slice(0, -1) + "="
					}
					return ha
				}(JSON.stringify(Yi));
				return {
					contentType: "application/x-www-form-urlencoded",
					body: rr(na)
				}
			}
			return {
				contentType: "application/json",
				body: JSON.stringify(Yi)
			}
		}
	},
	or = [];
N && or.push({
	transport: "XHR",
	method: function(ue) {
		var Yi, ea = new N;
		ea.open(ue.method || "GET", ue.url, !0);
		var ta = (Yi = sr(ue)) !== null && Yi !== void 0 ? Yi : {},
			na = ta.contentType,
			ra = ta.body;
		Q(ue.headers, function(ia, aa) {
			ea.setRequestHeader(aa, ia)
		}), na && ea.setRequestHeader("Content-Type", na), ue.timeout && (ea.timeout = ue.timeout), ea.withCredentials = !0, ea.onreadystatechange = function() {
			if (ea.readyState === 4) {
				var ia, aa = {
					statusCode: ea.status,
					text: ea.responseText
				};
				if (ea.status === 200) try {
					aa.json = JSON.parse(ea.responseText)
				} catch {}(ia = ue.callback) === null || ia === void 0 || ia.call(ue, aa)
			}
		}, ea.send(ra)
	}
}), q && or.push({
	transport: "fetch",
	method: function(ue) {
		var Yi, ea, ta = (Yi = sr(ue)) !== null && Yi !== void 0 ? Yi : {},
			na = ta.contentType,
			ra = ta.body,
			ia = new Headers;
		Q(ue.headers, function(sa, ca) {
			ia.append(ca, sa)
		}), na && ia.append("Content-Type", na);
		var aa = ue.url,
			oa = null;
		if (B) {
			var la = new B;
			oa = {
				signal: la.signal,
				timeout: setTimeout(function() {
					return la.abort()
				}, ue.timeout)
			}
		}
		q(aa, {
			method: (ue == null ? void 0 : ue.method) || "GET",
			headers: ia,
			keepalive: ue.method === "POST",
			body: ra,
			signal: (ea = oa) === null || ea === void 0 ? void 0 : ea.signal
		}).then(function(sa) {
			return sa.text().then(function(ca) {
				var ua, da = {
					statusCode: sa.status,
					text: ca
				};
				if (sa.status === 200) try {
					da.json = JSON.parse(ca)
				} catch (ha) {
					G.error(ha)
				}(ua = ue.callback) === null || ua === void 0 || ua.call(ue, da)
			})
		}).catch(function(sa) {
			var ca;
			G.error(sa), (ca = ue.callback) === null || ca === void 0 || ca.call(ue, {
				statusCode: 0,
				text: sa
			})
		}).finally(function() {
			return oa ? clearTimeout(oa.timeout) : null
		})
	}
}), A != null && A.sendBeacon && or.push({
	transport: "sendBeacon",
	method: function(ue) {
		var Yi = ir(ue.url, {
			beacon: "1"
		});
		try {
			var ea, ta = (ea = sr(ue)) !== null && ea !== void 0 ? ea : {},
				na = ta.contentType,
				ra = ta.body,
				ia = typeof ra == "string" ? new Blob([ra], {
					type: na
				}) : ra;
			A.sendBeacon(Yi, ia)
		} catch {}
	}
});
var ar = ["retriesPerformedSoFar"],
	ur, lr = function() {
		function ue(Yi) {
			var ea = this;
			i(this, ue), o(this, "isPolling", !1), o(this, "pollIntervalMs", 3e3), o(this, "queue", []), this.instance = Yi, this.queue = [], this.areWeOnline = !0, !w(T) && "onLine" in T.navigator && (this.areWeOnline = T.navigator.onLine, T.addEventListener("online", function() {
				ea.areWeOnline = !0, ea.flush()
			}), T.addEventListener("offline", function() {
				ea.areWeOnline = !1
			}))
		}
		return s(ue, [{
			key: "retriableRequest",
			value: function(Yi) {
				var ea = this,
					ta = Yi.retriesPerformedSoFar,
					na = a(Yi, ar);
				F(ta) && ta > 0 && (na.url = ir(na.url, {
					retry_count: ta
				})), this.instance._send_request(t(t({}, na), {}, {
					callback: function(ra) {
						var ia;
						ra.statusCode !== 200 && (ra.statusCode < 400 || ra.statusCode >= 500) && (ta ?? 0) < 10 ? ea.enqueue(t({
							retriesPerformedSoFar: ta
						}, na)) : (ia = na.callback) === null || ia === void 0 || ia.call(na, ra)
					}
				}))
			}
		}, {
			key: "enqueue",
			value: function(Yi) {
				var ea = Yi.retriesPerformedSoFar || 0;
				Yi.retriesPerformedSoFar = ea + 1;
				var ta = function(ia) {
						var aa = 3e3 * Math.pow(2, ia),
							oa = aa / 2,
							la = Math.min(18e5, aa),
							sa = (Math.random() - .5) * (la - oa);
						return Math.ceil(la + sa)
					}(ea),
					na = Date.now() + ta;
				this.queue.push({
					retryAt: na,
					requestOptions: Yi
				});
				var ra = "Enqueued failed request for retry in ".concat(ta);
				navigator.onLine || (ra += " (Browser is offline)"), G.warn(ra), this.isPolling || (this.isPolling = !0, this.poll())
			}
		}, {
			key: "poll",
			value: function() {
				var Yi = this;
				this.poller && clearTimeout(this.poller), this.poller = setTimeout(function() {
					Yi.areWeOnline && Yi.queue.length > 0 && Yi.flush(), Yi.poll()
				}, this.pollIntervalMs)
			}
		}, {
			key: "flush",
			value: function() {
				var Yi = Date.now(),
					ea = [],
					ta = this.queue.filter(function(aa) {
						return aa.retryAt < Yi || (ea.push(aa), !1)
					});
				if (this.queue = ea, ta.length > 0) {
					var na, ra = h(ta);
					try {
						for (ra.s(); !(na = ra.n()).done;) {
							var ia = na.value.requestOptions;
							this.retriableRequest(ia)
						}
					} catch (aa) {
						ra.e(aa)
					} finally {
						ra.f()
					}
				}
			}
		}, {
			key: "unload",
			value: function() {
				this.poller && (clearTimeout(this.poller), this.poller = void 0);
				var Yi, ea = h(this.queue);
				try {
					for (ea.s(); !(Yi = ea.n()).done;) {
						var ta = Yi.value.requestOptions;
						try {
							this.instance._send_request(t(t({}, ta), {}, {
								transport: "sendBeacon"
							}))
						} catch (na) {
							G.error(na)
						}
					}
				} catch (na) {
					ea.e(na)
				} finally {
					ea.f()
				}
				this.queue = []
			}
		}]), ue
	}(),
	cr = 1800,
	dr = function() {
		function ue(Yi, ea, ta, na) {
			var ra;
			i(this, ue), o(this, "_sessionIdChangedHandlers", []), this.config = Yi, this.persistence = ea, this._windowId = void 0, this._sessionId = void 0, this._sessionStartTimestamp = null, this._sessionActivityTimestamp = null, this._sessionIdGenerator = ta || Ke, this._windowIdGenerator = na || Ke;
			var ia = Yi.persistence_name || Yi.token,
				aa = Yi.session_idle_timeout_seconds || cr;
			if (F(aa) ? aa > cr ? G.warn("session_idle_timeout_seconds cannot be  greater than 30 minutes. Using 30 minutes instead.") : aa < 60 && G.warn("session_idle_timeout_seconds cannot be less than 60 seconds. Using 60 seconds instead.") : (G.warn("session_idle_timeout_seconds must be a number. Defaulting to 30 minutes."), aa = cr), this._sessionTimeoutMs = 1e3 * Math.min(Math.max(aa, 60), cr), this._window_id_storage_key = "ph_" + ia + "_window_id", this._primary_window_exists_storage_key = "ph_" + ia + "_primary_window_exists", this._canUseSessionStorage()) {
				var oa = ft.parse(this._window_id_storage_key),
					la = ft.parse(this._primary_window_exists_storage_key);
				oa && !la ? this._windowId = oa : ft.remove(this._window_id_storage_key), ft.set(this._primary_window_exists_storage_key, !0)
			}
			if ((ra = this.config.bootstrap) !== null && ra !== void 0 && ra.sessionID) try {
				var sa = function(ca) {
					var ua = ca.replace(/-/g, "");
					if (ua.length !== 32) throw new Error("Not a valid UUID");
					if (ua[12] !== "7") throw new Error("Not a UUIDv7");
					return parseInt(ua.substring(0, 12), 16)
				}(this.config.bootstrap.sessionID);
				this._setSessionId(this.config.bootstrap.sessionID, new Date().getTime(), sa)
			} catch (ca) {
				G.error("Invalid sessionID in bootstrap", ca)
			}
			this._listenToReloadWindow()
		}
		return s(ue, [{
			key: "onSessionId",
			value: function(Yi) {
				var ea = this;
				return w(this._sessionIdChangedHandlers) && (this._sessionIdChangedHandlers = []), this._sessionIdChangedHandlers.push(Yi), this._sessionId && Yi(this._sessionId, this._windowId),
					function() {
						ea._sessionIdChangedHandlers = ea._sessionIdChangedHandlers.filter(function(ta) {
							return ta !== Yi
						})
					}
			}
		}, {
			key: "_canUseSessionStorage",
			value: function() {
				return this.config.persistence !== "memory" && !this.persistence.disabled && ft.is_supported()
			}
		}, {
			key: "_setWindowId",
			value: function(Yi) {
				Yi !== this._windowId && (this._windowId = Yi, this._canUseSessionStorage() && ft.set(this._window_id_storage_key, Yi))
			}
		}, {
			key: "_getWindowId",
			value: function() {
				return this._windowId ? this._windowId : this._canUseSessionStorage() ? ft.parse(this._window_id_storage_key) : null
			}
		}, {
			key: "_setSessionId",
			value: function(Yi, ea, ta) {
				Yi === this._sessionId && ea === this._sessionActivityTimestamp && ta === this._sessionStartTimestamp || (this._sessionStartTimestamp = ta, this._sessionActivityTimestamp = ea, this._sessionId = Yi, this.persistence.register(o({}, Se, [ea, Yi, ta])))
			}
		}, {
			key: "_getSessionId",
			value: function() {
				if (this._sessionId && this._sessionActivityTimestamp && this._sessionStartTimestamp) return [this._sessionActivityTimestamp, this._sessionId, this._sessionStartTimestamp];
				var Yi = this.persistence.props[Se];
				return m(Yi) && Yi.length === 2 && Yi.push(Yi[0]), Yi || [0, null, 0]
			}
		}, {
			key: "resetSessionId",
			value: function() {
				this._setSessionId(null, null, null)
			}
		}, {
			key: "_listenToReloadWindow",
			value: function() {
				var Yi = this;
				T == null || T.addEventListener("beforeunload", function() {
					Yi._canUseSessionStorage() && ft.remove(Yi._primary_window_exists_storage_key)
				})
			}
		}, {
			key: "checkAndGetSessionAndWindowId",
			value: function() {
				var Yi = arguments.length > 0 && arguments[0] !== void 0 && arguments[0],
					ea = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null) || new Date().getTime(),
					ta = u(this._getSessionId(), 3),
					na = ta[0],
					ra = ta[1],
					ia = ta[2],
					aa = this._getWindowId(),
					oa = ia && ia > 0 && Math.abs(ea - ia) > 864e5,
					la = !1,
					sa = !ra,
					ca = !Yi && Math.abs(ea - na) > this._sessionTimeoutMs;
				sa || ca || oa ? (ra = this._sessionIdGenerator(), aa = this._windowIdGenerator(), G.info("[SessionId] new session ID generated", {
					sessionId: ra,
					windowId: aa,
					changeReason: {
						noSessionId: sa,
						activityTimeout: ca,
						sessionPastMaximumLength: oa
					}
				}), ia = ea, la = !0) : aa || (aa = this._windowIdGenerator(), la = !0);
				var ua = na === 0 || !Yi || oa ? ea : na,
					da = ia === 0 ? new Date().getTime() : ia;
				return this._setWindowId(aa), this._setSessionId(ra, ua, da), la && this._sessionIdChangedHandlers.forEach(function(ha) {
					return ha(ra, aa)
				}), {
					sessionId: ra,
					windowId: aa,
					sessionStartTimestamp: da
				}
			}
		}]), ue
	}();
(function(ue) {
	ue.US = "us", ue.EU = "eu", ue.CUSTOM = "custom"
})(ur || (ur = {}));
var hr = "i.posthog.com",
	fr = function() {
		function ue(Yi) {
			i(this, ue), o(this, "_regionCache", {}), this.instance = Yi
		}
		return s(ue, [{
			key: "apiHost",
			get: function() {
				var Yi = this.instance.config.api_host.trim().replace(/\/$/, "");
				return Yi === "https://app.posthog.com" ? "https://us.i.posthog.com" : Yi
			}
		}, {
			key: "uiHost",
			get: function() {
				var Yi, ea = (Yi = this.instance.config.ui_host) === null || Yi === void 0 ? void 0 : Yi.replace(/\/$/, "");
				return ea || (ea = this.apiHost.replace(".".concat(hr), ".posthog.com")), ea === "https://app.posthog.com" ? "https://us.posthog.com" : ea
			}
		}, {
			key: "region",
			get: function() {
				return this._regionCache[this.apiHost] || (/https:\/\/(app|us|us-assets)(\.i)?\.posthog\.com/i.test(this.apiHost) ? this._regionCache[this.apiHost] = ur.US : /https:\/\/(eu|eu-assets)(\.i)?\.posthog\.com/i.test(this.apiHost) ? this._regionCache[this.apiHost] = ur.EU : this._regionCache[this.apiHost] = ur.CUSTOM), this._regionCache[this.apiHost]
			}
		}, {
			key: "endpointFor",
			value: function(Yi) {
				var ea = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
				if (ea && (ea = ea[0] === "/" ? ea : "/".concat(ea)), Yi === "ui") return this.uiHost + ea;
				if (this.region === ur.CUSTOM) return this.apiHost + ea;
				var ta = hr + ea;
				switch (Yi) {
					case "assets":
						return "https://".concat(this.region, "-assets.").concat(ta);
					case "api":
						return "https://".concat(this.region, ".").concat(ta)
				}
			}
		}, {
			key: "loadScript",
			value: function(Yi, ea) {
				if (this.instance.config.disable_external_dependency_loading) return G.warn("".concat(Yi, " was requested but loading of external scripts is disabled.")), ea("Loading of external scripts is disabled");
				var ta = Yi[0] === "/" ? this.endpointFor("assets", Yi) : Yi,
					na = function() {
						if (!L) return ea("document not found");
						var ra = L.createElement("script");
						ra.type = "text/javascript", ra.src = ta, ra.onload = function(oa) {
							return ea(void 0, oa)
						}, ra.onerror = function(oa) {
							return ea(oa)
						};
						var ia, aa = L.querySelectorAll("body > script");
						aa.length > 0 ? (ia = aa[0].parentNode) === null || ia === void 0 || ia.insertBefore(ra, aa[0]) : L.body.appendChild(ra)
					};
				L != null && L.body ? na() : L == null || L.addEventListener("DOMContentLoaded", na)
			}
		}]), ue
	}(),
	vr = "posthog-js";

function pr(ue) {
	var Yi = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
		ea = Yi.organization,
		ta = Yi.projectId,
		na = Yi.prefix,
		ra = Yi.severityAllowList,
		ia = ra === void 0 ? ["error"] : ra;
	return function(aa) {
		var oa, la, sa, ca, ua;
		if (!(ia === "*" || ia.includes(aa.level)) || !ue.__loaded) return aa;
		aa.tags || (aa.tags = {});
		var da = ue.requestRouter.endpointFor("ui", "/project/".concat(ue.config.token, "/person/").concat(ue.get_distinct_id()));
		aa.tags["PostHog Person URL"] = da, ue.sessionRecordingStarted() && (aa.tags["PostHog Recording URL"] = ue.get_session_replay_url({
			withTimestamp: !0
		}));
		var ha = ((oa = aa.exception) === null || oa === void 0 ? void 0 : oa.values) || [],
			pa = {
				$exception_message: ((la = ha[0]) === null || la === void 0 ? void 0 : la.value) || aa.message,
				$exception_type: (sa = ha[0]) === null || sa === void 0 ? void 0 : sa.type,
				$exception_personURL: da,
				$exception_level: aa.level,
				$sentry_event_id: aa.event_id,
				$sentry_exception: aa.exception,
				$sentry_exception_message: ((ca = ha[0]) === null || ca === void 0 ? void 0 : ca.value) || aa.message,
				$sentry_exception_type: (ua = ha[0]) === null || ua === void 0 ? void 0 : ua.type,
				$sentry_tags: aa.tags,
				$level: aa.level
			};
		return ea && ta && (pa.$sentry_url = (na || "https://sentry.io/organizations/") + ea + "/issues/?project=" + ta + "&query=" + aa.event_id), ue.exceptions.sendExceptionEvent(pa), aa
	}
}
var gr = s(function ue(Yi, ea, ta, na, ra) {
	i(this, ue), this.name = vr, this.setupOnce = function(ia) {
		ia(pr(Yi, {
			organization: ea,
			projectId: ta,
			prefix: na,
			severityAllowList: ra
		}))
	}
});

function _r(ue, Yi) {
	var ea = ue.config.segment;
	if (!ea) return Yi();
	(function(ta, na) {
		var ra = ta.config.segment;
		if (!ra) return na();
		var ia = function(oa) {
				var la = function() {
					return oa.anonymousId() || Ke()
				};
				ta.config.get_device_id = la, oa.id() && (ta.register({
					distinct_id: oa.id(),
					$device_id: la()
				}), ta.persistence.set_property($e, "identified")), na()
			},
			aa = ra.user();
		"then" in aa && y(aa.then) ? aa.then(function(oa) {
			return ia(oa)
		}) : ia(aa)
	})(ue, function() {
		ea.register(function(ta) {
			Promise && Promise.resolve || G.warn("This browser does not have Promise support, and can not use the segment integration");
			var na = function(ra, ia) {
				var aa;
				if (!ia) return ra;
				ra.event.userId || ra.event.anonymousId === ta.get_distinct_id() || (G.info("Segment integration does not have a userId set, resetting PostHog"), ta.reset()), ra.event.userId && ra.event.userId !== ta.get_distinct_id() && (G.info("Segment integration has a userId set, identifying with PostHog"), ta.identify(ra.event.userId));
				var oa = ta._calculate_event_properties(ia, (aa = ra.event.properties) !== null && aa !== void 0 ? aa : {}, new Date);
				return ra.event.properties = Object.assign({}, oa, ra.event.properties), ra
			};
			return {
				name: "PostHog JS",
				type: "enrichment",
				version: "1.0.0",
				isLoaded: function() {
					return !0
				},
				load: function() {
					return Promise.resolve()
				},
				track: function(ra) {
					return na(ra, ra.event.event)
				},
				page: function(ra) {
					return na(ra, "$pageview")
				},
				identify: function(ra) {
					return na(ra, "$identify")
				},
				screen: function(ra) {
					return na(ra, "$screen")
				}
			}
		}(ue)).then(function() {
			Yi()
		})
	})
}
var mr, yr, br, kr = function() {
	function ue(Yi) {
		i(this, ue), this._instance = Yi
	}
	return s(ue, [{
		key: "doPageView",
		value: function(Yi) {
			var ea, ta = this._previousPageViewProperties(Yi);
			return this._currentPath = (ea = T == null ? void 0 : T.location.pathname) !== null && ea !== void 0 ? ea : "", this._instance.scrollManager.resetContext(), this._prevPageviewTimestamp = Yi, ta
		}
	}, {
		key: "doPageLeave",
		value: function(Yi) {
			return this._previousPageViewProperties(Yi)
		}
	}, {
		key: "_previousPageViewProperties",
		value: function(Yi) {
			var ea = this._currentPath,
				ta = this._prevPageviewTimestamp,
				na = this._instance.scrollManager.getContext();
			if (!ta) return {};
			var ra = {};
			if (na) {
				var ia = na.maxScrollHeight,
					aa = na.lastScrollY,
					oa = na.maxScrollY,
					la = na.maxContentHeight,
					sa = na.lastContentY,
					ca = na.maxContentY;
				w(ia) || w(aa) || w(oa) || w(la) || w(sa) || w(ca) || (ia = Math.ceil(ia), aa = Math.ceil(aa), oa = Math.ceil(oa), la = Math.ceil(la), sa = Math.ceil(sa), ca = Math.ceil(ca), ra = {
					$prev_pageview_last_scroll: aa,
					$prev_pageview_last_scroll_percentage: ia <= 1 ? 1 : wr(aa / ia, 0, 1),
					$prev_pageview_max_scroll: oa,
					$prev_pageview_max_scroll_percentage: ia <= 1 ? 1 : wr(oa / ia, 0, 1),
					$prev_pageview_last_content: sa,
					$prev_pageview_last_content_percentage: la <= 1 ? 1 : wr(sa / la, 0, 1),
					$prev_pageview_max_content: ca,
					$prev_pageview_max_content_percentage: la <= 1 ? 1 : wr(ca / la, 0, 1)
				})
			}
			return ea && (ra.$prev_pageview_pathname = ea), ta && (ra.$prev_pageview_duration = (Yi.getTime() - ta.getTime()) / 1e3), ra
		}
	}]), ue
}();

function wr(ue, Yi, ea) {
	return Math.max(Yi, Math.min(ue, ea))
}(function(ue) {
	ue.Popover = "popover", ue.API = "api", ue.Widget = "widget"
})(mr || (mr = {})),
function(ue) {
	ue.Open = "open", ue.MultipleChoice = "multiple_choice", ue.SingleChoice = "single_choice", ue.Rating = "rating", ue.Link = "link"
}(yr || (yr = {})),
function(ue) {
	ue.NextQuestion = "next_question", ue.End = "end", ue.ResponseBased = "response_based", ue.SpecificQuestion = "specific_question"
}(br || (br = {}));
var Sr = function() {
		function ue() {
			i(this, ue), o(this, "events", {}), this.events = {}
		}
		return s(ue, [{
			key: "on",
			value: function(Yi, ea) {
				var ta = this;
				return this.events[Yi] || (this.events[Yi] = []), this.events[Yi].push(ea),
					function() {
						ta.events[Yi] = ta.events[Yi].filter(function(na) {
							return na !== ea
						})
					}
			}
		}, {
			key: "emit",
			value: function(Yi, ea) {
				var ta, na = h(this.events[Yi] || []);
				try {
					for (na.s(); !(ta = na.n()).done;)(0, ta.value)(ea)
				} catch (aa) {
					na.e(aa)
				} finally {
					na.f()
				}
				var ra, ia = h(this.events["*"] || []);
				try {
					for (ia.s(); !(ra = ia.n()).done;)(0, ra.value)(Yi, ea)
				} catch (aa) {
					ia.e(aa)
				} finally {
					ia.f()
				}
			}
		}]), ue
	}(),
	Er = function() {
		function ue(Yi) {
			var ea = this;
			i(this, ue), o(this, "_debugEventEmitter", new Sr), o(this, "checkStep", function(ta, na) {
				return ea.checkStepEvent(ta, na) && ea.checkStepUrl(ta, na) && ea.checkStepElement(ta, na)
			}), o(this, "checkStepEvent", function(ta, na) {
				return na == null || !na.event || (ta == null ? void 0 : ta.event) === (na == null ? void 0 : na.event)
			}), this.instance = Yi, this.actionEvents = new Set, this.actionRegistry = new Set
		}
		return s(ue, [{
			key: "init",
			value: function() {
				var Yi, ea = this;
				if (!w((Yi = this.instance) === null || Yi === void 0 ? void 0 : Yi._addCaptureHook)) {
					var ta;
					(ta = this.instance) === null || ta === void 0 || ta._addCaptureHook(function(na, ra) {
						ea.on(na, ra)
					})
				}
			}
		}, {
			key: "register",
			value: function(Yi) {
				var ea, ta, na = this;
				if (!w((ea = this.instance) === null || ea === void 0 ? void 0 : ea._addCaptureHook) && (Yi.forEach(function(aa) {
						var oa, la;
						(oa = na.actionRegistry) === null || oa === void 0 || oa.add(aa), (la = aa.steps) === null || la === void 0 || la.forEach(function(sa) {
							var ca;
							(ca = na.actionEvents) === null || ca === void 0 || ca.add((sa == null ? void 0 : sa.event) || "")
						})
					}), (ta = this.instance) !== null && ta !== void 0 && ta.autocapture)) {
					var ra, ia = new Set;
					Yi.forEach(function(aa) {
						var oa;
						(oa = aa.steps) === null || oa === void 0 || oa.forEach(function(la) {
							la != null && la.selector && ia.add(la == null ? void 0 : la.selector)
						})
					}), (ra = this.instance) === null || ra === void 0 || ra.autocapture.setElementSelectors(ia)
				}
			}
		}, {
			key: "on",
			value: function(Yi, ea) {
				var ta, na = this;
				ea != null && Yi.length != 0 && (this.actionEvents.has(Yi) || this.actionEvents.has(ea == null ? void 0 : ea.event)) && this.actionRegistry && ((ta = this.actionRegistry) === null || ta === void 0 ? void 0 : ta.size) > 0 && this.actionRegistry.forEach(function(ra) {
					na.checkAction(ea, ra) && na._debugEventEmitter.emit("actionCaptured", ra.name)
				})
			}
		}, {
			key: "_addActionHook",
			value: function(Yi) {
				this.onAction("actionCaptured", function(ea) {
					return Yi(ea)
				})
			}
		}, {
			key: "checkAction",
			value: function(Yi, ea) {
				if ((ea == null ? void 0 : ea.steps) == null) return !1;
				var ta, na = h(ea.steps);
				try {
					for (na.s(); !(ta = na.n()).done;) {
						var ra = ta.value;
						if (this.checkStep(Yi, ra)) return !0
					}
				} catch (ia) {
					na.e(ia)
				} finally {
					na.f()
				}
				return !1
			}
		}, {
			key: "onAction",
			value: function(Yi, ea) {
				return this._debugEventEmitter.on(Yi, ea)
			}
		}, {
			key: "checkStepUrl",
			value: function(Yi, ea) {
				if (ea != null && ea.url) {
					var ta, na = Yi == null || (ta = Yi.properties) === null || ta === void 0 ? void 0 : ta.$current_url;
					if (!na || typeof na != "string" || !ue.matchString(na, ea == null ? void 0 : ea.url, (ea == null ? void 0 : ea.url_matching) || "contains")) return !1
				}
				return !0
			}
		}, {
			key: "checkStepElement",
			value: function(Yi, ea) {
				if ((ea != null && ea.href || ea != null && ea.tag_name || ea != null && ea.text) && !this.getElementsList(Yi).some(function(ra) {
						return !(ea != null && ea.href && !ue.matchString(ra.href || "", ea == null ? void 0 : ea.href, (ea == null ? void 0 : ea.href_matching) || "exact")) && (ea == null || !ea.tag_name || ra.tag_name === (ea == null ? void 0 : ea.tag_name)) && !(ea != null && ea.text && !ue.matchString(ra.text || "", ea == null ? void 0 : ea.text, (ea == null ? void 0 : ea.text_matching) || "exact") && !ue.matchString(ra.$el_text || "", ea == null ? void 0 : ea.text, (ea == null ? void 0 : ea.text_matching) || "exact"))
					})) return !1;
				if (ea != null && ea.selector) {
					var ta, na = Yi == null || (ta = Yi.properties) === null || ta === void 0 ? void 0 : ta.$element_selectors;
					if (!na || !na.includes(ea == null ? void 0 : ea.selector)) return !1
				}
				return !0
			}
		}, {
			key: "getElementsList",
			value: function(Yi) {
				return (Yi == null ? void 0 : Yi.properties.$elements) == null ? [] : Yi == null ? void 0 : Yi.properties.$elements
			}
		}], [{
			key: "matchString",
			value: function(Yi, ea, ta) {
				switch (ta) {
					case "regex":
						return !!T && gt(Yi, ea);
					case "exact":
						return ea === Yi;
					case "contains":
						var na = ue.escapeStringRegexp(ea).replace(/_/g, ".").replace(/%/g, ".*");
						return gt(Yi, na);
					default:
						return !1
				}
			}
		}, {
			key: "escapeStringRegexp",
			value: function(Yi) {
				return Yi.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d")
			}
		}]), ue
	}(),
	Ir = function() {
		function ue(Yi) {
			i(this, ue), this.instance = Yi, this.eventToSurveys = new Map, this.actionToSurveys = new Map
		}
		return s(ue, [{
			key: "register",
			value: function(Yi) {
				var ea;
				w((ea = this.instance) === null || ea === void 0 ? void 0 : ea._addCaptureHook) || (this.setupEventBasedSurveys(Yi), this.setupActionBasedSurveys(Yi))
			}
		}, {
			key: "setupActionBasedSurveys",
			value: function(Yi) {
				var ea = this,
					ta = Yi.filter(function(na) {
						var ra, ia, aa, oa;
						return ((ra = na.conditions) === null || ra === void 0 ? void 0 : ra.actions) && ((ia = na.conditions) === null || ia === void 0 || (aa = ia.actions) === null || aa === void 0 || (oa = aa.values) === null || oa === void 0 ? void 0 : oa.length) > 0
					});
				ta.length !== 0 && (this.actionMatcher == null && (this.actionMatcher = new Er(this.instance), this.actionMatcher.init(), this.actionMatcher._addActionHook(function(na) {
					ea.onAction(na)
				})), ta.forEach(function(na) {
					var ra, ia, aa, oa, la, sa, ca, ua, da, ha;
					na.conditions && (ra = na.conditions) !== null && ra !== void 0 && ra.actions && (ia = na.conditions) !== null && ia !== void 0 && (aa = ia.actions) !== null && aa !== void 0 && aa.values && ((oa = na.conditions) === null || oa === void 0 || (la = oa.actions) === null || la === void 0 || (sa = la.values) === null || sa === void 0 ? void 0 : sa.length) > 0 && ((ca = ea.actionMatcher) === null || ca === void 0 || ca.register(na.conditions.actions.values), (ua = na.conditions) === null || ua === void 0 || (da = ua.actions) === null || da === void 0 || (ha = da.values) === null || ha === void 0 || ha.forEach(function(pa) {
						if (pa && pa.name) {
							var va = ea.actionToSurveys.get(pa.name);
							va && va.push(na.id), ea.actionToSurveys.set(pa.name, va || [na.id])
						}
					}))
				}))
			}
		}, {
			key: "setupEventBasedSurveys",
			value: function(Yi) {
				var ea, ta = this;
				Yi.filter(function(na) {
					var ra, ia, aa, oa;
					return ((ra = na.conditions) === null || ra === void 0 ? void 0 : ra.events) && ((ia = na.conditions) === null || ia === void 0 || (aa = ia.events) === null || aa === void 0 || (oa = aa.values) === null || oa === void 0 ? void 0 : oa.length) > 0
				}).length !== 0 && ((ea = this.instance) === null || ea === void 0 || ea._addCaptureHook(function(na, ra) {
					ta.onEvent(na, ra)
				}), Yi.forEach(function(na) {
					var ra, ia, aa;
					(ra = na.conditions) === null || ra === void 0 || (ia = ra.events) === null || ia === void 0 || (aa = ia.values) === null || aa === void 0 || aa.forEach(function(oa) {
						if (oa && oa.name) {
							var la = ta.eventToSurveys.get(oa.name);
							la && la.push(na.id), ta.eventToSurveys.set(oa.name, la || [na.id])
						}
					})
				}))
			}
		}, {
			key: "onEvent",
			value: function(Yi, ea) {
				var ta, na, ra = ((ta = this.instance) === null || ta === void 0 || (na = ta.persistence) === null || na === void 0 ? void 0 : na.props[Te]) || [];
				if (ue.SURVEY_SHOWN_EVENT_NAME == Yi && ea && ra.length > 0) {
					var ia, aa = ea == null || (ia = ea.properties) === null || ia === void 0 ? void 0 : ia.$survey_id;
					if (aa) {
						var oa = ra.indexOf(aa);
						oa >= 0 && (ra.splice(oa, 1), this._updateActivatedSurveys(ra))
					}
				} else this.eventToSurveys.has(Yi) && this._updateActivatedSurveys(ra.concat(this.eventToSurveys.get(Yi) || []))
			}
		}, {
			key: "onAction",
			value: function(Yi) {
				var ea, ta, na = ((ea = this.instance) === null || ea === void 0 || (ta = ea.persistence) === null || ta === void 0 ? void 0 : ta.props[Te]) || [];
				this.actionToSurveys.has(Yi) && this._updateActivatedSurveys(na.concat(this.actionToSurveys.get(Yi) || []))
			}
		}, {
			key: "_updateActivatedSurveys",
			value: function(Yi) {
				var ea, ta;
				(ea = this.instance) === null || ea === void 0 || (ta = ea.persistence) === null || ta === void 0 || ta.register(o({}, Te, l(new Set(Yi))))
			}
		}, {
			key: "getSurveys",
			value: function() {
				var Yi, ea, ta = (Yi = this.instance) === null || Yi === void 0 || (ea = Yi.persistence) === null || ea === void 0 ? void 0 : ea.props[Te];
				return ta || []
			}
		}, {
			key: "getEventToSurveys",
			value: function() {
				return this.eventToSurveys
			}
		}, {
			key: "_getActionMatcher",
			value: function() {
				return this.actionMatcher
			}
		}]), ue
	}();
o(Ir, "SURVEY_SHOWN_EVENT_NAME", "survey shown");
var Rr = "[Surveys]",
	Fr = {
		icontains: function(ue) {
			return !!T && T.location.href.toLowerCase().indexOf(ue.toLowerCase()) > -1
		},
		not_icontains: function(ue) {
			return !!T && T.location.href.toLowerCase().indexOf(ue.toLowerCase()) === -1
		},
		regex: function(ue) {
			return !!T && gt(T.location.href, ue)
		},
		not_regex: function(ue) {
			return !!T && !gt(T.location.href, ue)
		},
		exact: function(ue) {
			return (T == null ? void 0 : T.location.href) === ue
		},
		is_not: function(ue) {
			return (T == null ? void 0 : T.location.href) !== ue
		}
	},
	xr = function() {
		function ue(Yi) {
			i(this, ue), this.instance = Yi, this._surveyEventReceiver = null
		}
		return s(ue, [{
			key: "afterDecideResponse",
			value: function(Yi) {
				this._decideServerResponse = !!Yi.surveys, this.loadIfEnabled()
			}
		}, {
			key: "loadIfEnabled",
			value: function() {
				var Yi = this,
					ea = U == null ? void 0 : U.extendPostHogWithSurveys;
				this.instance.config.disable_surveys || !this._decideServerResponse || ea || (this._surveyEventReceiver == null && (this._surveyEventReceiver = new Ir(this.instance)), this.instance.requestRouter.loadScript("/static/surveys.js", function(ta) {
					if (ta) return G.error(Rr, "Could not load surveys script", ta);
					Yi._surveyManager = U.extendPostHogWithSurveys(Yi.instance)
				}))
			}
		}, {
			key: "getSurveys",
			value: function(Yi) {
				var ea = this,
					ta = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
				if (this.instance.config.disable_surveys) return Yi([]);
				this._surveyEventReceiver == null && (this._surveyEventReceiver = new Ir(this.instance));
				var na = this.instance.get_property(Pe);
				if (na && !ta) return Yi(na);
				this.instance._send_request({
					url: this.instance.requestRouter.endpointFor("api", "/api/surveys/?token=".concat(this.instance.config.token)),
					method: "GET",
					transport: "XHR",
					callback: function(ra) {
						var ia;
						if (ra.statusCode !== 200 || !ra.json) return Yi([]);
						var aa, oa = ra.json.surveys || [],
							la = oa.filter(function(sa) {
								var ca, ua, da, ha, pa, va, ba, Ea, Sa, Ca, ka, Pa;
								return ((ca = sa.conditions) === null || ca === void 0 ? void 0 : ca.events) && ((ua = sa.conditions) === null || ua === void 0 || (da = ua.events) === null || da === void 0 ? void 0 : da.values) && ((ha = sa.conditions) === null || ha === void 0 || (pa = ha.events) === null || pa === void 0 || (va = pa.values) === null || va === void 0 ? void 0 : va.length) > 0 || ((ba = sa.conditions) === null || ba === void 0 ? void 0 : ba.actions) && ((Ea = sa.conditions) === null || Ea === void 0 || (Sa = Ea.actions) === null || Sa === void 0 ? void 0 : Sa.values) && ((Ca = sa.conditions) === null || Ca === void 0 || (ka = Ca.actions) === null || ka === void 0 || (Pa = ka.values) === null || Pa === void 0 ? void 0 : Pa.length) > 0
							});
						return la.length > 0 && ((aa = ea._surveyEventReceiver) === null || aa === void 0 || aa.register(la)), (ia = ea.instance.persistence) === null || ia === void 0 || ia.register(o({}, Pe, oa)), Yi(oa)
					}
				})
			}
		}, {
			key: "getActiveMatchingSurveys",
			value: function(Yi) {
				var ea = this,
					ta = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
				this.getSurveys(function(na) {
					var ra, ia = na.filter(function(la) {
							return !(!la.start_date || la.end_date)
						}).filter(function(la) {
							var sa, ca, ua, da;
							if (!la.conditions) return !0;
							var ha = (sa = la.conditions) === null || sa === void 0 || !sa.url || Fr[(ca = (ua = la.conditions) === null || ua === void 0 ? void 0 : ua.urlMatchType) !== null && ca !== void 0 ? ca : "icontains"](la.conditions.url),
								pa = (da = la.conditions) === null || da === void 0 || !da.selector || (L == null ? void 0 : L.querySelector(la.conditions.selector));
							return ha && pa
						}),
						aa = (ra = ea._surveyEventReceiver) === null || ra === void 0 ? void 0 : ra.getSurveys(),
						oa = ia.filter(function(la) {
							var sa, ca, ua, da, ha, pa, va, ba, Ea, Sa;
							if (!la.linked_flag_key && !la.targeting_flag_key && !la.internal_targeting_flag_key) return !0;
							var Ca = !la.linked_flag_key || ea.instance.featureFlags.isFeatureEnabled(la.linked_flag_key),
								ka = !la.targeting_flag_key || ea.instance.featureFlags.isFeatureEnabled(la.targeting_flag_key),
								Pa = ((sa = la.conditions) === null || sa === void 0 ? void 0 : sa.events) && ((ca = la.conditions) === null || ca === void 0 || (ua = ca.events) === null || ua === void 0 ? void 0 : ua.values) && ((da = la.conditions) === null || da === void 0 || (ha = da.events) === null || ha === void 0 ? void 0 : ha.values.length) > 0,
								ja = ((pa = la.conditions) === null || pa === void 0 ? void 0 : pa.actions) && ((va = la.conditions) === null || va === void 0 || (ba = va.actions) === null || ba === void 0 ? void 0 : ba.values) && ((Ea = la.conditions) === null || Ea === void 0 || (Sa = Ea.actions) === null || Sa === void 0 ? void 0 : Sa.values.length) > 0,
								Za = !Pa && !ja || (aa == null ? void 0 : aa.includes(la.id)),
								Ga = ea._canActivateRepeatedly(la),
								Ja = !(la.internal_targeting_flag_key && !Ga) || ea.instance.featureFlags.isFeatureEnabled(la.internal_targeting_flag_key);
							return Ca && ka && Ja && Za
						});
					return Yi(oa)
				}, ta)
			}
		}, {
			key: "getNextSurveyStep",
			value: function(Yi, ea, ta) {
				var na, ra = Yi.questions[ea],
					ia = ea + 1;
				if ((na = ra.branching) === null || na === void 0 || !na.type) return ea === Yi.questions.length - 1 ? br.End : ia;
				if (ra.branching.type === br.End) return br.End;
				if (ra.branching.type === br.SpecificQuestion) {
					if (Number.isInteger(ra.branching.index)) return ra.branching.index
				} else if (ra.branching.type === br.ResponseBased) {
					if (ra.type === yr.SingleChoice) {
						var aa, oa, la = ra.choices.indexOf("".concat(ta));
						if ((aa = ra.branching) !== null && aa !== void 0 && (oa = aa.responseValues) !== null && oa !== void 0 && oa.hasOwnProperty(la)) {
							var sa = ra.branching.responseValues[la];
							return Number.isInteger(sa) ? sa : sa === br.End ? br.End : ia
						}
					} else if (ra.type === yr.Rating) {
						var ca, ua;
						if (typeof ta != "number" || !Number.isInteger(ta)) throw new Error("The response type must be an integer");
						var da = function(pa, va) {
							if (va === 3) {
								if (pa < 1 || pa > 3) throw new Error("The response must be in range 1-3");
								return pa === 1 ? "negative" : pa === 2 ? "neutral" : "positive"
							}
							if (va === 5) {
								if (pa < 1 || pa > 5) throw new Error("The response must be in range 1-5");
								return pa <= 2 ? "negative" : pa === 3 ? "neutral" : "positive"
							}
							if (va === 10) {
								if (pa < 0 || pa > 10) throw new Error("The response must be in range 0-10");
								return pa <= 6 ? "detractors" : pa <= 8 ? "passives" : "promoters"
							}
							throw new Error("The scale must be one of: 3, 5, 10")
						}(ta, ra.scale);
						if ((ca = ra.branching) !== null && ca !== void 0 && (ua = ca.responseValues) !== null && ua !== void 0 && ua.hasOwnProperty(da)) {
							var ha = ra.branching.responseValues[da];
							return Number.isInteger(ha) ? ha : ha === br.End ? br.End : ia
						}
					}
					return ia
				}
				return G.warn(Rr, "Falling back to next question index due to unexpected branching type"), ia
			}
		}, {
			key: "_canActivateRepeatedly",
			value: function(Yi) {
				return R(U.__PosthogExtensions__.canActivateRepeatedly) && G.warn(Rr, "canActivateRepeatedly is not defined, must init before calling"), U.__PosthogExtensions__.canActivateRepeatedly(Yi)
			}
		}, {
			key: "canRenderSurvey",
			value: function(Yi) {
				var ea = this;
				R(this._surveyManager) ? G.warn(Rr, "canActivateRepeatedly is not defined, must init before calling") : this.getSurveys(function(ta) {
					var na = ta.filter(function(ra) {
						return ra.id === Yi
					})[0];
					ea._surveyManager.canRenderSurvey(na)
				})
			}
		}, {
			key: "renderSurvey",
			value: function(Yi, ea) {
				var ta = this;
				R(this._surveyManager) ? G.warn(Rr, "canActivateRepeatedly is not defined, must init before calling") : this.getSurveys(function(na) {
					var ra = na.filter(function(ia) {
						return ia.id === Yi
					})[0];
					ta._surveyManager.renderSurvey(ra, L == null ? void 0 : L.querySelector(ea))
				})
			}
		}]), ue
	}(),
	Pr = function() {
		function ue(Yi) {
			var ea, ta, na = this;
			i(this, ue), o(this, "serverLimits", {}), o(this, "lastEventRateLimited", !1), o(this, "checkForLimiting", function(ra) {
				var ia = ra.text;
				if (ia && ia.length) try {
					(JSON.parse(ia).quota_limited || []).forEach(function(aa) {
						G.info("[RateLimiter] ".concat(aa || "events", " is quota limited.")), na.serverLimits[aa] = new Date().getTime() + 6e4
					})
				} catch (aa) {
					return void G.warn('[RateLimiter] could not rate limit - continuing. Error: "'.concat(aa == null ? void 0 : aa.message, '"'), {
						text: ia
					})
				}
			}), this.instance = Yi, this.captureEventsPerSecond = ((ea = Yi.config.rate_limiting) === null || ea === void 0 ? void 0 : ea.events_per_second) || 10, this.captureEventsBurstLimit = Math.max(((ta = Yi.config.rate_limiting) === null || ta === void 0 ? void 0 : ta.events_burst_limit) || 10 * this.captureEventsPerSecond, this.captureEventsPerSecond), this.lastEventRateLimited = this.clientRateLimitContext(!0).isRateLimited
		}
		return s(ue, [{
			key: "clientRateLimitContext",
			value: function() {
				var Yi, ea, ta, na = arguments.length > 0 && arguments[0] !== void 0 && arguments[0],
					ra = new Date().getTime(),
					ia = (Yi = (ea = this.instance.persistence) === null || ea === void 0 ? void 0 : ea.get_property(Me)) !== null && Yi !== void 0 ? Yi : {
						tokens: this.captureEventsBurstLimit,
						last: ra
					};
				ia.tokens += (ra - ia.last) / 1e3 * this.captureEventsPerSecond, ia.last = ra, ia.tokens > this.captureEventsBurstLimit && (ia.tokens = this.captureEventsBurstLimit);
				var aa = ia.tokens < 1;
				return aa || na || (ia.tokens = Math.max(0, ia.tokens - 1)), !aa || this.lastEventRateLimited || na || this.instance.capture("$$client_ingestion_warning", {
					$$client_ingestion_warning_message: "posthog-js client rate limited. Config is set to ".concat(this.captureEventsPerSecond, " events per second and ").concat(this.captureEventsBurstLimit, " events burst limit.")
				}, {
					skip_client_rate_limiting: !0
				}), this.lastEventRateLimited = aa, (ta = this.instance.persistence) === null || ta === void 0 || ta.set_property(Me, ia), {
					isRateLimited: aa,
					remainingTokens: ia.tokens
				}
			}
		}, {
			key: "isServerRateLimited",
			value: function(Yi) {
				var ea = this.serverLimits[Yi || "events"] || !1;
				return ea !== !1 && new Date().getTime() < ea
			}
		}]), ue
	}(),
	Tr = function() {
		return t({
			initialPathName: (D == null ? void 0 : D.pathname) || "",
			referringDomain: mn.referringDomain()
		}, mn.campaignParams())
	},
	Cr = function() {
		function ue(Yi, ea, ta) {
			var na = this;
			i(this, ue), o(this, "_onSessionIdCallback", function(ra) {
				var ia = na._getStoredProps();
				if (!ia || ia.sessionId !== ra) {
					var aa = {
						sessionId: ra,
						props: na._sessionSourceParamGenerator()
					};
					na._persistence.register(o({}, Oe, aa))
				}
			}), this._sessionIdManager = Yi, this._persistence = ea, this._sessionSourceParamGenerator = ta || Tr, this._sessionIdManager.onSessionId(this._onSessionIdCallback)
		}
		return s(ue, [{
			key: "_getStoredProps",
			value: function() {
				return this._persistence.props[Oe]
			}
		}, {
			key: "getSessionProps",
			value: function() {
				var Yi, ea = (Yi = this._getStoredProps()) === null || Yi === void 0 ? void 0 : Yi.props;
				return ea ? {
					$client_session_initial_referring_host: ea.referringDomain,
					$client_session_initial_pathname: ea.initialPathName,
					$client_session_initial_utm_source: ea.utm_source,
					$client_session_initial_utm_campaign: ea.utm_campaign,
					$client_session_initial_utm_medium: ea.utm_medium,
					$client_session_initial_utm_content: ea.utm_content,
					$client_session_initial_utm_term: ea.utm_term
				} : {}
			}
		}]), ue
	}(),
	$r = ["ahrefsbot", "ahrefssiteaudit", "applebot", "baiduspider", "bingbot", "bingpreview", "bot.htm", "bot.php", "crawler", "deepscan", "duckduckbot", "facebookexternal", "facebookcatalog", "gptbot", "http://yandex.com/bots", "hubspot", "ia_archiver", "linkedinbot", "mj12bot", "msnbot", "nessus", "petalbot", "pinterest", "prerender", "rogerbot", "screaming frog", "semrushbot", "sitebulb", "slurp", "turnitin", "twitterbot", "vercelbot", "yahoo! slurp", "yandexbot", "headlesschrome", "cypress", "Google-HotelAdsVerifier", "adsbot-google", "apis-google", "duplexweb-google", "feedfetcher-google", "google favicon", "google web preview", "google-read-aloud", "googlebot", "googleweblight", "mediapartners-google", "storebot-google", "Bytespider;"],
	Or = function(ue, Yi) {
		if (!ue) return !1;
		var ea = ue.toLowerCase();
		return $r.concat(Yi || []).some(function(ta) {
			var na = ta.toLowerCase();
			return ea.indexOf(na) !== -1
		})
	},
	Mr = function() {
		function ue() {
			i(this, ue), this.clicks = []
		}
		return s(ue, [{
			key: "isRageClick",
			value: function(Yi, ea, ta) {
				var na = this.clicks[this.clicks.length - 1];
				if (na && Math.abs(Yi - na.x) + Math.abs(ea - na.y) < 30 && ta - na.timestamp < 1e3) {
					if (this.clicks.push({
							x: Yi,
							y: ea,
							timestamp: ta
						}), this.clicks.length === 3) return !0
				} else this.clicks = [{
					x: Yi,
					y: ea,
					timestamp: ta
				}];
				return !1
			}
		}]), ue
	}();

function Ar(ue) {
	var Yi;
	return ue.id === Ne || !((Yi = ue.closest) === null || Yi === void 0 || !Yi.call(ue, "#" + Ne))
}
var Lr = function() {
		function ue(Yi) {
			var ea, ta = this;
			i(this, ue), o(this, "rageclicks", new Mr), o(this, "_enabledServerSide", !1), o(this, "_initialized", !1), o(this, "_flushInterval", null), this.instance = Yi, this._enabledServerSide = !((ea = this.instance.persistence) === null || ea === void 0 || !ea.props[fe]), T == null || T.addEventListener("beforeunload", function() {
				ta.flush()
			})
		}
		return s(ue, [{
			key: "flushIntervalMilliseconds",
			get: function() {
				var Yi = 5e3;
				return b(this.instance.config.capture_heatmaps) && this.instance.config.capture_heatmaps.flush_interval_milliseconds && (Yi = this.instance.config.capture_heatmaps.flush_interval_milliseconds), Yi
			}
		}, {
			key: "isEnabled",
			get: function() {
				return w(this.instance.config.capture_heatmaps) ? w(this.instance.config.enable_heatmaps) ? this._enabledServerSide : this.instance.config.enable_heatmaps : this.instance.config.capture_heatmaps !== !1
			}
		}, {
			key: "startIfEnabled",
			value: function() {
				if (this.isEnabled) {
					if (this._initialized) return;
					G.info("[heatmaps] starting..."), this._setupListeners(), this._flushInterval = setInterval(this.flush.bind(this), this.flushIntervalMilliseconds)
				} else {
					var Yi;
					clearInterval((Yi = this._flushInterval) !== null && Yi !== void 0 ? Yi : void 0), this.getAndClearBuffer()
				}
			}
		}, {
			key: "afterDecideResponse",
			value: function(Yi) {
				var ea = !!Yi.heatmaps;
				this.instance.persistence && this.instance.persistence.register(o({}, fe, ea)), this._enabledServerSide = ea, this.startIfEnabled()
			}
		}, {
			key: "getAndClearBuffer",
			value: function() {
				var Yi = this.buffer;
				return this.buffer = void 0, Yi
			}
		}, {
			key: "_setupListeners",
			value: function() {
				var Yi = this;
				T && L && (oe(L, "click", function(ea) {
					return Yi._onClick(ea || (T == null ? void 0 : T.event))
				}, !1, !0), oe(L, "mousemove", function(ea) {
					return Yi._onMouseMove(ea || (T == null ? void 0 : T.event))
				}, !1, !0), this._initialized = !0)
			}
		}, {
			key: "_getProperties",
			value: function(Yi, ea) {
				var ta = this.instance.scrollManager.scrollY(),
					na = this.instance.scrollManager.scrollX(),
					ra = this.instance.scrollManager.scrollElement(),
					ia = function(aa, oa, la) {
						for (var sa = aa; sa && !On(sa, "body");) {
							if (sa === la) return !1;
							if (Y(oa, T == null ? void 0 : T.getComputedStyle(sa).position)) return !0;
							sa = Dn(sa)
						}
						return !1
					}(Yi.target, ["fixed", "sticky"], ra);
				return {
					x: Yi.clientX + (ia ? 0 : na),
					y: Yi.clientY + (ia ? 0 : ta),
					target_fixed: ia,
					type: ea
				}
			}
		}, {
			key: "_onClick",
			value: function(Yi) {
				var ea;
				if (!Ar(Yi.target)) {
					var ta = this._getProperties(Yi, "click");
					(ea = this.rageclicks) !== null && ea !== void 0 && ea.isRageClick(Yi.clientX, Yi.clientY, new Date().getTime()) && this._capture(t(t({}, ta), {}, {
						type: "rageclick"
					})), this._capture(ta)
				}
			}
		}, {
			key: "_onMouseMove",
			value: function(Yi) {
				var ea = this;
				Ar(Yi.target) || (clearTimeout(this._mouseMoveTimeout), this._mouseMoveTimeout = setTimeout(function() {
					ea._capture(ea._getProperties(Yi, "mousemove"))
				}, 500))
			}
		}, {
			key: "_capture",
			value: function(Yi) {
				if (T) {
					var ea = T.location.href;
					this.buffer = this.buffer || {}, this.buffer[ea] || (this.buffer[ea] = []), this.buffer[ea].push(Yi)
				}
			}
		}, {
			key: "flush",
			value: function() {
				this.buffer && !k(this.buffer) && this.instance.capture("$$heatmap", {
					$heatmap_data: this.getAndClearBuffer()
				})
			}
		}]), ue
	}(),
	Dr = function() {
		function ue(Yi) {
			var ea = this;
			i(this, ue), o(this, "_updateScrollData", function() {
				var ta, na, ra, ia;
				ea.context || (ea.context = {});
				var aa = ea.scrollElement(),
					oa = ea.scrollY(),
					la = aa ? Math.max(0, aa.scrollHeight - aa.clientHeight) : 0,
					sa = oa + ((aa == null ? void 0 : aa.clientHeight) || 0),
					ca = (aa == null ? void 0 : aa.scrollHeight) || 0;
				ea.context.lastScrollY = Math.ceil(oa), ea.context.maxScrollY = Math.max(oa, (ta = ea.context.maxScrollY) !== null && ta !== void 0 ? ta : 0), ea.context.maxScrollHeight = Math.max(la, (na = ea.context.maxScrollHeight) !== null && na !== void 0 ? na : 0), ea.context.lastContentY = sa, ea.context.maxContentY = Math.max(sa, (ra = ea.context.maxContentY) !== null && ra !== void 0 ? ra : 0), ea.context.maxContentHeight = Math.max(ca, (ia = ea.context.maxContentHeight) !== null && ia !== void 0 ? ia : 0)
			}), this.instance = Yi
		}
		return s(ue, [{
			key: "getContext",
			value: function() {
				return this.context
			}
		}, {
			key: "resetContext",
			value: function() {
				var Yi = this.context;
				return setTimeout(this._updateScrollData, 0), Yi
			}
		}, {
			key: "startMeasuringScrollPosition",
			value: function() {
				T == null || T.addEventListener("scroll", this._updateScrollData, !0), T == null || T.addEventListener("scrollend", this._updateScrollData, !0), T == null || T.addEventListener("resize", this._updateScrollData)
			}
		}, {
			key: "scrollElement",
			value: function() {
				if (!this.instance.config.scroll_root_selector) return T == null ? void 0 : T.document.documentElement;
				var Yi, ea = h(m(this.instance.config.scroll_root_selector) ? this.instance.config.scroll_root_selector : [this.instance.config.scroll_root_selector]);
				try {
					for (ea.s(); !(Yi = ea.n()).done;) {
						var ta = Yi.value,
							na = T == null ? void 0 : T.document.querySelector(ta);
						if (na) return na
					}
				} catch (ra) {
					ea.e(ra)
				} finally {
					ea.f()
				}
			}
		}, {
			key: "scrollY",
			value: function() {
				if (this.instance.config.scroll_root_selector) {
					var Yi = this.scrollElement();
					return Yi && Yi.scrollTop || 0
				}
				return T && (T.scrollY || T.pageYOffset || T.document.documentElement.scrollTop) || 0
			}
		}, {
			key: "scrollX",
			value: function() {
				if (this.instance.config.scroll_root_selector) {
					var Yi = this.scrollElement();
					return Yi && Yi.scrollLeft || 0
				}
				return T && (T.scrollX || T.pageXOffset || T.document.documentElement.scrollLeft) || 0
			}
		}]), ue
	}(),
	qr = "$copy_autocapture";

function Nr(ue, Yi) {
	return Yi.length > ue ? Yi.slice(0, ue) + "..." : Yi
}
var Br, Hr = function() {
		function ue(Yi) {
			i(this, ue), o(this, "_initialized", !1), o(this, "_isDisabledServerSide", null), o(this, "rageclicks", new Mr), o(this, "_elementsChainAsString", !1), this.instance = Yi, this._elementSelectors = null
		}
		return s(ue, [{
			key: "config",
			get: function() {
				var Yi, ea, ta = b(this.instance.config.autocapture) ? this.instance.config.autocapture : {};
				return ta.url_allowlist = (Yi = ta.url_allowlist) === null || Yi === void 0 ? void 0 : Yi.map(function(na) {
					return new RegExp(na)
				}), ta.url_ignorelist = (ea = ta.url_ignorelist) === null || ea === void 0 ? void 0 : ea.map(function(na) {
					return new RegExp(na)
				}), ta
			}
		}, {
			key: "_addDomEventHandlers",
			value: function() {
				var Yi = this;
				if (this.isBrowserSupported()) {
					if (T && L) {
						var ea = function(na) {
								na = na || (T == null ? void 0 : T.event);
								try {
									Yi._captureEvent(na)
								} catch (ra) {
									G.error("Failed to capture event", ra)
								}
							},
							ta = function(na) {
								na = na || (T == null ? void 0 : T.event), Yi._captureEvent(na, qr)
							};
						oe(L, "submit", ea, !1, !0), oe(L, "change", ea, !1, !0), oe(L, "click", ea, !1, !0), this.config.capture_copied_text && (oe(L, "copy", ta, !1, !0), oe(L, "cut", ta, !1, !0))
					}
				} else G.info("Disabling Automatic Event Collection because this browser is not supported")
			}
		}, {
			key: "startIfEnabled",
			value: function() {
				this.isEnabled && !this._initialized && (this._addDomEventHandlers(), this._initialized = !0)
			}
		}, {
			key: "afterDecideResponse",
			value: function(Yi) {
				Yi.elementsChainAsString && (this._elementsChainAsString = Yi.elementsChainAsString), this.instance.persistence && this.instance.persistence.register(o({}, he, !!Yi.autocapture_opt_out)), this._isDisabledServerSide = !!Yi.autocapture_opt_out, this.startIfEnabled()
			}
		}, {
			key: "setElementSelectors",
			value: function(Yi) {
				this._elementSelectors = Yi
			}
		}, {
			key: "getElementSelectors",
			value: function(Yi) {
				var ea, ta = [];
				return (ea = this._elementSelectors) === null || ea === void 0 || ea.forEach(function(na) {
					var ra = L == null ? void 0 : L.querySelectorAll(na);
					ra == null || ra.forEach(function(ia) {
						Yi === ia && ta.push(na)
					})
				}), ta
			}
		}, {
			key: "isEnabled",
			get: function() {
				var Yi, ea, ta = (Yi = this.instance.persistence) === null || Yi === void 0 ? void 0 : Yi.props[he],
					na = this._isDisabledServerSide;
				if (I(na) && !x(ta) && !this.instance.config.advanced_disable_decide) return !1;
				var ra = (ea = this._isDisabledServerSide) !== null && ea !== void 0 ? ea : !!ta;
				return !!this.instance.config.autocapture && !ra
			}
		}, {
			key: "_previousElementSibling",
			value: function(Yi) {
				if (Yi.previousElementSibling) return Yi.previousElementSibling;
				var ea = Yi;
				do ea = ea.previousSibling; while (ea && !$n(ea));
				return ea
			}
		}, {
			key: "_getAugmentPropertiesFromElement",
			value: function(Yi) {
				if (!Nn(Yi)) return {};
				var ea = {};
				return Q(Yi.attributes, function(ta) {
					if (ta.name && ta.name.indexOf("data-ph-capture-attribute") === 0) {
						var na = ta.name.replace("data-ph-capture-attribute-", ""),
							ra = ta.value;
						na && ra && zn(ra) && (ea[na] = ra)
					}
				}), ea
			}
		}, {
			key: "_getPropertiesFromElement",
			value: function(Yi, ea, ta) {
				var na, ra = Yi.tagName.toLowerCase(),
					ia = {
						tag_name: ra
					};
				Ln.indexOf(ra) > -1 && !ta && (ra.toLowerCase() === "a" || ra.toLowerCase() === "button" ? ia.$el_text = Nr(1024, Qn(Yi)) : ia.$el_text = Nr(1024, Cn(Yi)));
				var aa = Pn(Yi);
				aa.length > 0 && (ia.classes = aa.filter(function(ua) {
					return ua !== ""
				}));
				var oa = (na = this.config) === null || na === void 0 ? void 0 : na.element_attribute_ignorelist;
				Q(Yi.attributes, function(ua) {
					var da;
					if ((!Bn(Yi) || ["name", "id", "class", "aria-label"].indexOf(ua.name) !== -1) && (oa == null || !oa.includes(ua.name)) && !ea && zn(ua.value) && (da = ua.name, !S(da) || da.substring(0, 10) !== "_ngcontent" && da.substring(0, 7) !== "_nghost")) {
						var ha = ua.value;
						ua.name === "class" && (ha = Fn(ha).join(" ")), ia["attr__" + ua.name] = Nr(1024, ha)
					}
				});
				for (var la = 1, sa = 1, ca = Yi; ca = this._previousElementSibling(ca);) la++, ca.tagName === Yi.tagName && sa++;
				return ia.nth_child = la, ia.nth_of_type = sa, ia
			}
		}, {
			key: "_getDefaultProperties",
			value: function(Yi) {
				return {
					$event_type: Yi,
					$ce_version: 1
				}
			}
		}, {
			key: "_getEventTarget",
			value: function(Yi) {
				return w(Yi.target) ? Yi.srcElement || null : (ea = Yi.target) !== null && ea !== void 0 && ea.shadowRoot ? Yi.composedPath()[0] || null : Yi.target || null;
				var ea
			}
		}, {
			key: "_captureEvent",
			value: function(Yi) {
				var ea = this,
					ta = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "$autocapture";
				if (this.isEnabled) {
					var na, ra = this._getEventTarget(Yi);
					Mn(ra) && (ra = ra.parentNode || null), ta === "$autocapture" && Yi.type === "click" && Yi instanceof MouseEvent && this.instance.config.rageclick && (na = this.rageclicks) !== null && na !== void 0 && na.isRageClick(Yi.clientX, Yi.clientY, new Date().getTime()) && this._captureEvent(Yi, "$rageclick");
					var ia = ta === qr;
					if (ra && qn(ra, Yi, this.config, ia, ia ? ["copy", "cut"] : void 0)) {
						for (var aa, oa, la = [ra], sa = ra; sa.parentNode && !On(sa, "body");) An(sa.parentNode) ? (la.push(sa.parentNode.host), sa = sa.parentNode.host) : (la.push(sa.parentNode), sa = sa.parentNode);
						var ca, ua, da = [],
							ha = {},
							pa = !1;
						if (Q(la, function(Ga) {
								var Ja = Nn(Ga);
								Ga.tagName.toLowerCase() === "a" && (ca = Ga.getAttribute("href"), ca = Ja && zn(ca) && ca), Y(Pn(Ga), "ph-no-capture") && (pa = !0), da.push(ea._getPropertiesFromElement(Ga, ea.instance.config.mask_all_element_attributes, ea.instance.config.mask_all_text));
								var Ua = ea._getAugmentPropertiesFromElement(Ga);
								J(ha, Ua)
							}), this.instance.config.mask_all_text || (ra.tagName.toLowerCase() === "a" || ra.tagName.toLowerCase() === "button" ? da[0].$el_text = Qn(ra) : da[0].$el_text = Cn(ra)), ca) {
							var va, ba;
							da[0].attr__href = ca;
							var Ea = (va = pt(ca)) === null || va === void 0 ? void 0 : va.host,
								Sa = T == null || (ba = T.location) === null || ba === void 0 ? void 0 : ba.host;
							Ea && Sa && Ea !== Sa && (ua = ca)
						}
						if (pa) return !1;
						var Ca = J(this._getDefaultProperties(Yi.type), this._elementsChainAsString ? {
								$elements_chain: Yn(da)
							} : {
								$elements: da
							}, (aa = da[0]) !== null && aa !== void 0 && aa.$el_text ? {
								$el_text: (oa = da[0]) === null || oa === void 0 ? void 0 : oa.$el_text
							} : {}, ua && Yi.type === "click" ? {
								$external_click_url: ua
							} : {}, ha),
							ka = this.getElementSelectors(ra);
						if (ka && ka.length > 0 && (Ca.$element_selectors = ka), ta === qr) {
							var Pa, ja = Tn(T == null || (Pa = T.getSelection()) === null || Pa === void 0 ? void 0 : Pa.toString()),
								Za = Yi.type || "clipboard";
							if (!ja) return !1;
							Ca.$selected_content = ja, Ca.$copy_type = Za
						}
						return this.instance.capture(ta, Ca), !0
					}
				}
			}
		}, {
			key: "isBrowserSupported",
			value: function() {
				return y(L == null ? void 0 : L.querySelectorAll)
			}
		}]), ue
	}(),
	Ur = function() {
		function ue(Yi) {
			var ea = this;
			i(this, ue), o(this, "_restoreXHRPatch", void 0), o(this, "_restoreFetchPatch", void 0), o(this, "_startCapturing", function() {
				w(ea._restoreXHRPatch) && U.postHogTracingHeadersPatchFns._patchXHR(ea.instance.sessionManager), w(ea._restoreFetchPatch) && U.postHogTracingHeadersPatchFns._patchFetch(ea.instance.sessionManager)
			}), this.instance = Yi
		}
		return s(ue, [{
			key: "_loadScript",
			value: function(Yi) {
				U.postHogTracingHeadersPatchFns && Yi(), this.instance.requestRouter.loadScript("/static/tracing-headers.js?v=".concat(f.LIB_VERSION), function(ea) {
					if (ea) return G.error("[TRACING-HEADERS] failed to load script", ea);
					Yi()
				})
			}
		}, {
			key: "startIfEnabledOrStop",
			value: function() {
				var Yi, ea;
				this.instance.config.__add_tracing_headers ? this._loadScript(this._startCapturing) : ((Yi = this._restoreXHRPatch) === null || Yi === void 0 || Yi.call(this), (ea = this._restoreFetchPatch) === null || ea === void 0 || ea.call(this), this._restoreXHRPatch = void 0, this._restoreFetchPatch = void 0)
			}
		}]), ue
	}();
(function(ue) {
	ue[ue.PENDING = -1] = "PENDING", ue[ue.DENIED = 0] = "DENIED", ue[ue.GRANTED = 1] = "GRANTED"
})(Br || (Br = {}));
var jr = function() {
		function ue(Yi) {
			i(this, ue), this.instance = Yi
		}
		return s(ue, [{
			key: "config",
			get: function() {
				return this.instance.config
			}
		}, {
			key: "consent",
			get: function() {
				return this.getDnt() ? Br.DENIED : this.storedConsent
			}
		}, {
			key: "isOptedOut",
			value: function() {
				return this.consent === Br.DENIED || this.consent === Br.PENDING && this.config.opt_out_capturing_by_default
			}
		}, {
			key: "isOptedIn",
			value: function() {
				return !this.isOptedOut()
			}
		}, {
			key: "optInOut",
			value: function(Yi) {
				this.storage.set(this.storageKey, Yi ? 1 : 0, this.config.cookie_expiration, this.config.cross_subdomain_cookie, this.config.secure_cookie)
			}
		}, {
			key: "reset",
			value: function() {
				this.storage.remove(this.storageKey, this.config.cross_subdomain_cookie)
			}
		}, {
			key: "storageKey",
			get: function() {
				var Yi = this.instance.config,
					ea = Yi.token;
				return (Yi.opt_out_capturing_cookie_prefix || "__ph_opt_in_out_") + ea
			}
		}, {
			key: "storedConsent",
			get: function() {
				var Yi = this.storage.get(this.storageKey);
				return Yi === "1" ? Br.GRANTED : Yi === "0" ? Br.DENIED : Br.PENDING
			}
		}, {
			key: "storage",
			get: function() {
				if (!this._storage) {
					var Yi = this.config.opt_out_capturing_persistence_type;
					this._storage = Yi === "localStorage" ? at : st;
					var ea = Yi === "localStorage" ? st : at;
					ea.get(this.storageKey) && (this._storage.get(this.storageKey) || this.optInOut(ea.get(this.storageKey) === "1"), ea.remove(this.storageKey, this.config.cross_subdomain_cookie))
				}
				return this._storage
			}
		}, {
			key: "getDnt",
			value: function() {
				return !!this.config.respect_dnt && !!ae([A == null ? void 0 : A.doNotTrack, A == null ? void 0 : A.msDoNotTrack, U.doNotTrack], function(Yi) {
					return Y([!0, 1, "1", "yes"], Yi)
				})
			}
		}]), ue
	}(),
	Gr = "[Exception Autocapture]",
	Wr = function() {
		function ue(Yi) {
			var ea, ta = this;
			i(this, ue), o(this, "originalOnUnhandledRejectionHandler", void 0), o(this, "startCapturing", function() {
				if (T && ta.isEnabled && !ta.hasHandlers && !ta.isCapturing) {
					var na = T.posthogErrorWrappingFunctions.wrapOnError,
						ra = T.posthogErrorWrappingFunctions.wrapUnhandledRejection;
					if (na && ra) try {
						ta.unwrapOnError = na(ta.captureException.bind(ta)), ta.unwrapUnhandledRejection = ra(ta.captureException.bind(ta))
					} catch (ia) {
						G.error(Gr + " failed to start", ia), ta.stopCapturing()
					} else G.error(Gr + " failed to load error wrapping functions - cannot start")
				}
			}), this.instance = Yi, this.remoteEnabled = !((ea = this.instance.persistence) === null || ea === void 0 || !ea.props[ve]), this.startIfEnabled()
		}
		return s(ue, [{
			key: "isEnabled",
			get: function() {
				var Yi;
				return (Yi = this.remoteEnabled) !== null && Yi !== void 0 && Yi
			}
		}, {
			key: "isCapturing",
			get: function() {
				var Yi;
				return !(T == null || (Yi = T.onerror) === null || Yi === void 0 || !Yi.__POSTHOG_INSTRUMENTED__)
			}
		}, {
			key: "hasHandlers",
			get: function() {
				return this.originalOnUnhandledRejectionHandler || this.unwrapOnError
			}
		}, {
			key: "startIfEnabled",
			value: function() {
				this.isEnabled && !this.isCapturing && (G.info(Gr + " enabled, starting..."), this.loadScript(this.startCapturing))
			}
		}, {
			key: "loadScript",
			value: function(Yi) {
				this.hasHandlers && Yi(), this.instance.requestRouter.loadScript("/static/exception-autocapture.js?v=".concat(f.LIB_VERSION), function(ea) {
					if (ea) return G.error(Gr + " failed to load script", ea);
					Yi()
				})
			}
		}, {
			key: "stopCapturing",
			value: function() {
				var Yi, ea;
				(Yi = this.unwrapOnError) === null || Yi === void 0 || Yi.call(this), (ea = this.unwrapUnhandledRejection) === null || ea === void 0 || ea.call(this)
			}
		}, {
			key: "afterDecideResponse",
			value: function(Yi) {
				var ea = Yi.autocaptureExceptions;
				this.remoteEnabled = !!ea || !1, this.instance.persistence && this.instance.persistence.register(o({}, ve, this.remoteEnabled)), this.startIfEnabled()
			}
		}, {
			key: "captureException",
			value: function(Yi) {
				var ea = this.instance.requestRouter.endpointFor("ui");
				Yi.$exception_personURL = "".concat(ea, "/project/").concat(this.instance.config.token, "/person/").concat(this.instance.get_distinct_id()), this.instance.exceptions.sendExceptionEvent(Yi)
			}
		}]), ue
	}(),
	Vr = 9e5,
	zr = "[Web Vitals]",
	Qr = function() {
		function ue(Yi) {
			var ea, ta = this;
			i(this, ue), o(this, "_enabledServerSide", !1), o(this, "_initialized", !1), o(this, "buffer", {
				url: void 0,
				metrics: [],
				firstMetricTimestamp: void 0
			}), o(this, "_flushToCapture", function() {
				clearTimeout(ta._delayedFlushTimer), ta.buffer.metrics.length !== 0 && (ta.instance.capture("$web_vitals", ta.buffer.metrics.reduce(function(na, ra) {
					var ia;
					return t(t({}, na), {}, (o(ia = {}, "$web_vitals_".concat(ra.name, "_event"), t({}, ra)), o(ia, "$web_vitals_".concat(ra.name, "_value"), ra.value), ia))
				}, {})), ta.buffer = {
					url: void 0,
					metrics: [],
					firstMetricTimestamp: void 0
				})
			}), o(this, "_addToBuffer", function(na) {
				var ra, ia = (ra = ta.instance.sessionManager) === null || ra === void 0 ? void 0 : ra.checkAndGetSessionAndWindowId(!0);
				if (w(ia)) G.error(zr + "Could not read session ID. Dropping metrics!");
				else {
					ta.buffer = ta.buffer || {
						url: void 0,
						metrics: [],
						firstMetricTimestamp: void 0
					};
					var aa = ta._currentURL();
					w(aa) || (R(na == null ? void 0 : na.name) || R(na == null ? void 0 : na.value) ? G.error(zr + "Invalid metric received", na) : ta._maxAllowedValue && na.value >= ta._maxAllowedValue ? G.error(zr + "Ignoring metric with value >= " + ta._maxAllowedValue, na) : (ta.buffer.url !== aa && (ta._flushToCapture(), ta._delayedFlushTimer = setTimeout(ta._flushToCapture, 8e3)), w(ta.buffer.url) && (ta.buffer.url = aa), ta.buffer.firstMetricTimestamp = w(ta.buffer.firstMetricTimestamp) ? Date.now() : ta.buffer.firstMetricTimestamp, ta.buffer.metrics.push(t(t({}, na), {}, {
						$current_url: aa,
						$session_id: ia.sessionId,
						$window_id: ia.windowId,
						timestamp: Date.now()
					})), ta.buffer.metrics.length === 4 && ta._flushToCapture()))
				}
			}), o(this, "_startCapturing", function() {
				var na = U.postHogWebVitalsCallbacks,
					ra = na.onLCP,
					ia = na.onCLS,
					aa = na.onFCP,
					oa = na.onINP;
				ra && ia && aa && oa ? (ra(ta._addToBuffer), ia(ta._addToBuffer), aa(ta._addToBuffer), oa(ta._addToBuffer), ta._initialized = !0) : G.error(zr + "web vitals callbacks not loaded - not starting")
			}), this.instance = Yi, this._enabledServerSide = !((ea = this.instance.persistence) === null || ea === void 0 || !ea.props[ge]), this.startIfEnabled()
		}
		return s(ue, [{
			key: "_maxAllowedValue",
			get: function() {
				var Yi = b(this.instance.config.capture_performance) && F(this.instance.config.capture_performance.__web_vitals_max_value) ? this.instance.config.capture_performance.__web_vitals_max_value : Vr;
				return 0 < Yi && Yi <= 6e4 ? Vr : Yi
			}
		}, {
			key: "isEnabled",
			get: function() {
				var Yi = b(this.instance.config.capture_performance) ? this.instance.config.capture_performance.web_vitals : void 0;
				return x(Yi) ? Yi : this._enabledServerSide
			}
		}, {
			key: "startIfEnabled",
			value: function() {
				this.isEnabled && !this._initialized && (G.info(zr + " enabled, starting..."), this.loadScript(this._startCapturing))
			}
		}, {
			key: "afterDecideResponse",
			value: function(Yi) {
				var ea = b(Yi.capturePerformance) && !!Yi.capturePerformance.web_vitals;
				this.instance.persistence && this.instance.persistence.register(o({}, ge, ea)), this._enabledServerSide = ea, this.startIfEnabled()
			}
		}, {
			key: "loadScript",
			value: function(Yi) {
				T.postHogWebVitalsCallbacks && Yi(), this.instance.requestRouter.loadScript("/static/web-vitals.js?v=".concat(f.LIB_VERSION), function(ea) {
					ea ? G.error(zr + " failed to load script", ea) : Yi()
				})
			}
		}, {
			key: "_currentURL",
			value: function() {
				var Yi = T ? T.location.href : void 0;
				return Yi || G.error(zr + "Could not determine current URL"), Yi
			}
		}]), ue
	}(),
	Jr = "/e/",
	Yr = function() {
		function ue(Yi) {
			var ea;
			i(this, ue), this.instance = Yi, this._endpointSuffix = ((ea = this.instance.persistence) === null || ea === void 0 ? void 0 : ea.props[pe]) || Jr
		}
		return s(ue, [{
			key: "endpoint",
			get: function() {
				return this.instance.requestRouter.endpointFor("api", this._endpointSuffix)
			}
		}, {
			key: "afterDecideResponse",
			value: function(Yi) {
				var ea = Yi.autocaptureExceptions;
				this._endpointSuffix = b(ea) && ea.endpoint || Jr, this.instance.persistence && this.instance.persistence.register(o({}, pe, this._endpointSuffix))
			}
		}, {
			key: "sendExceptionEvent",
			value: function(Yi) {
				this.instance.capture("$exception", Yi, {
					_noTruncate: !0,
					_batchKey: "exceptionEvent",
					_url: this.endpoint
				})
			}
		}]), ue
	}(),
	Xr = {},
	Kr = function() {},
	Zr = "posthog",
	es = !tr && (H == null ? void 0 : H.indexOf("MSIE")) === -1 && (H == null ? void 0 : H.indexOf("Mozilla")) === -1,
	ts = function() {
		var ue, Yi, ea;
		return {
			api_host: "https://us.i.posthog.com",
			ui_host: null,
			token: "",
			autocapture: !0,
			rageclick: !0,
			cross_subdomain_cookie: (Yi = L == null ? void 0 : L.location, ea = Yi == null ? void 0 : Yi.hostname, !!S(ea) && ea.split(".").slice(-2).join(".") !== "herokuapp.com"),
			persistence: "localStorage+cookie",
			persistence_name: "",
			loaded: Kr,
			store_google: !0,
			custom_campaign_params: [],
			custom_blocked_useragents: [],
			save_referrer: !0,
			capture_pageview: !0,
			capture_pageleave: "if_capture_pageview",
			debug: D && S(D == null ? void 0 : D.search) && D.search.indexOf("__posthog_debug=true") !== -1 || !1,
			verbose: !1,
			cookie_expiration: 365,
			upgrade: !1,
			disable_session_recording: !1,
			disable_persistence: !1,
			disable_surveys: !1,
			enable_recording_console_log: void 0,
			secure_cookie: (T == null || (ue = T.location) === null || ue === void 0 ? void 0 : ue.protocol) === "https:",
			ip: !0,
			opt_out_capturing_by_default: !1,
			opt_out_persistence_by_default: !1,
			opt_out_useragent_filter: !1,
			opt_out_capturing_persistence_type: "localStorage",
			opt_out_capturing_cookie_prefix: null,
			opt_in_site_apps: !1,
			property_denylist: [],
			respect_dnt: !1,
			sanitize_properties: null,
			request_headers: {},
			inapp_protocol: "//",
			inapp_link_new_window: !1,
			request_batching: !0,
			properties_string_max_length: 65535,
			session_recording: {},
			mask_all_element_attributes: !1,
			mask_all_text: !1,
			advanced_disable_decide: !1,
			advanced_disable_feature_flags: !1,
			advanced_disable_feature_flags_on_first_load: !1,
			advanced_disable_toolbar_metrics: !1,
			feature_flag_request_timeout_ms: 3e3,
			on_request_error: function(ta) {
				var na = "Bad HTTP status: " + ta.statusCode + " " + ta.text;
				G.error(na)
			},
			get_device_id: function(ta) {
				return ta
			},
			_onCapture: Kr,
			capture_performance: void 0,
			name: "posthog",
			bootstrap: {},
			disable_compression: !1,
			session_idle_timeout_seconds: 1800,
			person_profiles: "always",
			__add_tracing_headers: !1
		}
	},
	ns = function(ue) {
		var Yi = {};
		w(ue.process_person) || (Yi.person_profiles = ue.process_person), w(ue.xhr_headers) || (Yi.request_headers = ue.xhr_headers), w(ue.cookie_name) || (Yi.persistence_name = ue.cookie_name), w(ue.disable_cookie) || (Yi.disable_persistence = ue.disable_cookie);
		var ea = J({}, Yi, ue);
		return m(ue.property_blacklist) && (w(ue.property_denylist) ? ea.property_denylist = ue.property_blacklist : m(ue.property_denylist) ? ea.property_denylist = [].concat(l(ue.property_blacklist), l(ue.property_denylist)) : G.error("Invalid value for property_denylist config: " + ue.property_denylist)), ea
	},
	is = function() {
		function ue() {
			i(this, ue), o(this, "__forceAllowLocalhost", !1)
		}
		return s(ue, [{
			key: "_forceAllowLocalhost",
			get: function() {
				return this.__forceAllowLocalhost
			},
			set: function(Yi) {
				G.error("WebPerformanceObserver is deprecated and has no impact on network capture. Use `_forceAllowLocalhostNetworkCapture` on `posthog.sessionRecording`"), this.__forceAllowLocalhost = Yi
			}
		}]), ue
	}(),
	rs = function() {
		function ue() {
			var Yi = this;
			i(this, ue), o(this, "webPerformance", new is), o(this, "version", f.LIB_VERSION), o(this, "_internalEventEmitter", new Sr), this.config = ts(), this.decideEndpointWasHit = !1, this.SentryIntegration = gr, this.sentryIntegration = function(ea) {
				return function(ta, na) {
					var ra = pr(ta, na);
					return {
						name: vr,
						processEvent: function(ia) {
							return ra(ia)
						}
					}
				}(Yi, ea)
			}, this.__request_queue = [], this.__loaded = !1, this.analyticsDefaultEndpoint = "/e/", this._initialPageviewCaptured = !1, this.featureFlags = new We(this), this.toolbar = new mi(this), this.scrollManager = new Dr(this), this.pageViewManager = new kr(this), this.surveys = new xr(this), this.exceptions = new Yr(this), this.rateLimiter = new Pr(this), this.requestRouter = new fr(this), this.consent = new jr(this), this.people = {
				set: function(ea, ta, na) {
					var ra = S(ea) ? o({}, ea, ta) : ea;
					Yi.setPersonProperties(ra), na == null || na({})
				},
				set_once: function(ea, ta, na) {
					var ra = S(ea) ? o({}, ea, ta) : ea;
					Yi.setPersonProperties(void 0, ra), na == null || na({})
				}
			}, this.on("eventCaptured", function(ea) {
				return G.info("send", ea)
			})
		}
		return s(ue, [{
			key: "init",
			value: function(Yi, ea, ta) {
				if (ta && ta !== Zr) {
					var na, ra = (na = Xr[ta]) !== null && na !== void 0 ? na : new ue;
					return ra._init(Yi, ea, ta), Xr[ta] = ra, Xr[Zr][ta] = ra, ra
				}
				return this._init(Yi, ea, ta)
			}
		}, {
			key: "_init",
			value: function(Yi) {
				var ea, ta, na = this,
					ra = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
					ia = arguments.length > 2 ? arguments[2] : void 0;
				if (w(Yi) || E(Yi)) return G.critical("PostHog was initialized without a token. This likely indicates a misconfiguration. Please check the first argument passed to posthog.init()"), this;
				if (this.__loaded) return G.warn("You have already initialized PostHog! Re-initializing is a no-op"), this;
				this.__loaded = !0, this.config = {}, this._triggered_notifs = [], this.set_config(J({}, ts(), ns(ra), {
					name: ia,
					token: Yi
				})), this.config.on_xhr_error && G.error("[posthog] on_xhr_error is deprecated. Use on_request_error instead"), this.compression = ra.disable_compression ? void 0 : re.GZipJS, this.persistence = new bn(this.config), this.sessionPersistence = this.config.persistence === "sessionStorage" ? this.persistence : new bn(t(t({}, this.config), {}, {
					persistence: "sessionStorage"
				}));
				var aa = t({}, this.persistence.props),
					oa = t({}, this.sessionPersistence.props);
				if (this._requestQueue = new yi(function(Ea) {
						return na._send_retriable_request(Ea)
					}), this._retryQueue = new lr(this), this.__request_queue = [], this.sessionManager = new dr(this.config, this.persistence), this.sessionPropsManager = new Cr(this.sessionManager, this.persistence), new Ur(this).startIfEnabledOrStop(), this.sessionRecording = new vi(this), this.sessionRecording.startIfEnabledOrStop(), this.config.disable_scroll_properties || this.scrollManager.startMeasuringScrollPosition(), this.autocapture = new Hr(this), this.autocapture.startIfEnabled(), this.surveys.loadIfEnabled(), this.heatmaps = new Lr(this), this.heatmaps.startIfEnabled(), this.webVitalsAutocapture = new Qr(this), this.exceptionObserver = new Wr(this), this.exceptionObserver.startIfEnabled(), f.DEBUG = f.DEBUG || this.config.debug, f.DEBUG && G.info("Starting in debug mode", {
						this: this,
						config: ra,
						thisC: t({}, this.config),
						p: aa,
						s: oa
					}), this._sync_opt_out_with_persistence(), ((ea = ra.bootstrap) === null || ea === void 0 ? void 0 : ea.distinctID) !== void 0) {
					var la, sa, ca = this.config.get_device_id(Ke()),
						ua = (la = ra.bootstrap) !== null && la !== void 0 && la.isIdentifiedID ? ca : ra.bootstrap.distinctID;
					this.persistence.set_property($e, (sa = ra.bootstrap) !== null && sa !== void 0 && sa.isIdentifiedID ? "identified" : "anonymous"), this.register({
						distinct_id: ra.bootstrap.distinctID,
						$device_id: ua
					})
				}
				if (this._hasBootstrappedFeatureFlags()) {
					var da, ha, pa = Object.keys(((da = ra.bootstrap) === null || da === void 0 ? void 0 : da.featureFlags) || {}).filter(function(Ea) {
							var Sa, Ca;
							return !((Sa = ra.bootstrap) === null || Sa === void 0 || (Ca = Sa.featureFlags) === null || Ca === void 0 || !Ca[Ea])
						}).reduce(function(Ea, Sa) {
							var Ca, ka;
							return Ea[Sa] = ((Ca = ra.bootstrap) === null || Ca === void 0 || (ka = Ca.featureFlags) === null || ka === void 0 ? void 0 : ka[Sa]) || !1, Ea
						}, {}),
						va = Object.keys(((ha = ra.bootstrap) === null || ha === void 0 ? void 0 : ha.featureFlagPayloads) || {}).filter(function(Ea) {
							return pa[Ea]
						}).reduce(function(Ea, Sa) {
							var Ca, ka, Pa, ja;
							return (Ca = ra.bootstrap) !== null && Ca !== void 0 && (ka = Ca.featureFlagPayloads) !== null && ka !== void 0 && ka[Sa] && (Ea[Sa] = (Pa = ra.bootstrap) === null || Pa === void 0 || (ja = Pa.featureFlagPayloads) === null || ja === void 0 ? void 0 : ja[Sa]), Ea
						}, {});
					this.featureFlags.receivedFeatureFlags({
						featureFlags: pa,
						featureFlagPayloads: va
					})
				}
				if (!this.get_distinct_id()) {
					var ba = this.config.get_device_id(Ke());
					this.register_once({
						distinct_id: ba,
						$device_id: ba
					}, ""), this.persistence.set_property($e, "anonymous")
				}
				return T == null || (ta = T.addEventListener) === null || ta === void 0 || ta.call(T, "onpagehide" in self ? "pagehide" : "unload", this._handle_unload.bind(this)), this.toolbar.maybeLoadToolbar(), ra.segment ? _r(this, function() {
					return na._loaded()
				}) : this._loaded(), y(this.config._onCapture) && this.on("eventCaptured", function(Ea) {
					return na.config._onCapture(Ea.event, Ea)
				}), this
			}
		}, {
			key: "_afterDecideResponse",
			value: function(Yi) {
				var ea, ta, na, ra, ia, aa, oa, la;
				this.compression = void 0, Yi.supportedCompression && !this.config.disable_compression && (this.compression = Y(Yi.supportedCompression, re.GZipJS) ? re.GZipJS : Y(Yi.supportedCompression, re.Base64) ? re.Base64 : void 0), (ea = Yi.analytics) !== null && ea !== void 0 && ea.endpoint && (this.analyticsDefaultEndpoint = Yi.analytics.endpoint), (ta = this.sessionRecording) === null || ta === void 0 || ta.afterDecideResponse(Yi), (na = this.autocapture) === null || na === void 0 || na.afterDecideResponse(Yi), (ra = this.heatmaps) === null || ra === void 0 || ra.afterDecideResponse(Yi), (ia = this.surveys) === null || ia === void 0 || ia.afterDecideResponse(Yi), (aa = this.webVitalsAutocapture) === null || aa === void 0 || aa.afterDecideResponse(Yi), (oa = this.exceptions) === null || oa === void 0 || oa.afterDecideResponse(Yi), (la = this.exceptionObserver) === null || la === void 0 || la.afterDecideResponse(Yi)
			}
		}, {
			key: "_loaded",
			value: function() {
				var Yi = this,
					ea = this.config.advanced_disable_decide;
				ea || this.featureFlags.setReloadingPaused(!0);
				try {
					this.config.loaded(this)
				} catch (ta) {
					G.critical("`loaded` function failed", ta)
				}
				this._start_queue_if_opted_in(), this.config.capture_pageview && setTimeout(function() {
					Yi.consent.isOptedIn() && Yi._captureInitialPageview()
				}, 1), ea || (new pi(this).call(), this.featureFlags.resetRequestQueue())
			}
		}, {
			key: "_start_queue_if_opted_in",
			value: function() {
				var Yi;
				this.has_opted_out_capturing() || this.config.request_batching && ((Yi = this._requestQueue) === null || Yi === void 0 || Yi.enable())
			}
		}, {
			key: "_dom_loaded",
			value: function() {
				var Yi = this;
				this.has_opted_out_capturing() || z(this.__request_queue, function(ea) {
					return Yi._send_retriable_request(ea)
				}), this.__request_queue = [], this._start_queue_if_opted_in()
			}
		}, {
			key: "_handle_unload",
			value: function() {
				var Yi, ea;
				this.config.request_batching ? (this._shouldCapturePageleave() && this.capture("$pageleave"), (Yi = this._requestQueue) === null || Yi === void 0 || Yi.unload(), (ea = this._retryQueue) === null || ea === void 0 || ea.unload()) : this._shouldCapturePageleave() && this.capture("$pageleave", null, {
					transport: "sendBeacon"
				})
			}
		}, {
			key: "_send_request",
			value: function(Yi) {
				var ea = this;
				this.__loaded && (es ? this.__request_queue.push(Yi) : this.rateLimiter.isServerRateLimited(Yi.batchKey) || (Yi.transport = Yi.transport || this.config.api_transport, Yi.url = ir(Yi.url, {
					ip: this.config.ip ? 1 : 0
				}), Yi.headers = t({}, this.config.request_headers), Yi.compression = Yi.compression === "best-available" ? this.compression : Yi.compression, function(ta) {
					var na, ra, ia, aa = t({}, ta);
					aa.timeout = aa.timeout || 6e4, aa.url = ir(aa.url, {
						_: new Date().getTime().toString(),
						ver: f.LIB_VERSION,
						compression: aa.compression
					});
					var oa = (na = aa.transport) !== null && na !== void 0 ? na : "XHR",
						la = (ra = (ia = ae(or, function(sa) {
							return sa.transport === oa
						})) === null || ia === void 0 ? void 0 : ia.method) !== null && ra !== void 0 ? ra : or[0].method;
					if (!la) throw new Error("No available transport method");
					la(aa)
				}(t(t({}, Yi), {}, {
					callback: function(ta) {
						var na, ra, ia;
						ea.rateLimiter.checkForLimiting(ta), ta.statusCode >= 400 && ((ra = (ia = ea.config).on_request_error) === null || ra === void 0 || ra.call(ia, ta)), (na = Yi.callback) === null || na === void 0 || na.call(Yi, ta)
					}
				}))))
			}
		}, {
			key: "_send_retriable_request",
			value: function(Yi) {
				this._retryQueue ? this._retryQueue.retriableRequest(Yi) : this._send_request(Yi)
			}
		}, {
			key: "_execute_array",
			value: function(Yi) {
				var ea, ta = this,
					na = [],
					ra = [],
					ia = [];
				z(Yi, function(oa) {
					oa && (ea = oa[0], m(ea) ? ia.push(oa) : y(oa) ? oa.call(ta) : m(oa) && ea === "alias" ? na.push(oa) : m(oa) && ea.indexOf("capture") !== -1 && y(ta[ea]) ? ia.push(oa) : ra.push(oa))
				});
				var aa = function(oa, la) {
					z(oa, function(sa) {
						if (m(sa[0])) {
							var ca = la;
							Q(sa, function(ua) {
								ca = ca[ua[0]].apply(ca, ua.slice(1))
							})
						} else this[sa[0]].apply(this, sa.slice(1))
					}, la)
				};
				aa(na, this), aa(ra, this), aa(ia, this)
			}
		}, {
			key: "_hasBootstrappedFeatureFlags",
			value: function() {
				var Yi, ea;
				return ((Yi = this.config.bootstrap) === null || Yi === void 0 ? void 0 : Yi.featureFlags) && Object.keys((ea = this.config.bootstrap) === null || ea === void 0 ? void 0 : ea.featureFlags).length > 0 || !1
			}
		}, {
			key: "push",
			value: function(Yi) {
				this._execute_array([Yi])
			}
		}, {
			key: "capture",
			value: function(Yi, ea, ta) {
				var na;
				if (this.__loaded && this.persistence && this.sessionPersistence && this._requestQueue) {
					if (!this.consent.isOptedOut())
						if (!w(Yi) && S(Yi)) {
							if (this.config.opt_out_useragent_filter || !this._is_bot()) {
								var ra = ta != null && ta.skip_client_rate_limiting ? void 0 : this.rateLimiter.clientRateLimitContext();
								if (ra == null || !ra.isRateLimited) {
									this.sessionPersistence.update_search_keyword(), this.config.store_google && this.sessionPersistence.update_campaign_params(), this.config.save_referrer && this.sessionPersistence.update_referrer_info(), (this.config.store_google || this.config.save_referrer) && this.persistence.set_initial_person_info();
									var ia = new Date,
										aa = (ta == null ? void 0 : ta.timestamp) || ia,
										oa = {
											uuid: Ke(),
											event: Yi,
											properties: this._calculate_event_properties(Yi, ea || {}, aa)
										};
									ra && (oa.properties.$lib_rate_limit_remaining_tokens = ra.remainingTokens), ta != null && ta.$set && (oa.$set = ta == null ? void 0 : ta.$set);
									var la = this._calculate_set_once_properties(ta == null ? void 0 : ta.$set_once);
									la && (oa.$set_once = la), (oa = ie(oa, ta != null && ta._noTruncate ? null : this.config.properties_string_max_length)).timestamp = aa, w(ta == null ? void 0 : ta.timestamp) || (oa.properties.$event_time_override_provided = !0, oa.properties.$event_time_override_system_time = ia);
									var sa = t(t({}, oa.properties.$set), oa.$set);
									k(sa) || this.setPersonPropertiesForFlags(sa), this._internalEventEmitter.emit("eventCaptured", oa);
									var ca = {
										method: "POST",
										url: (na = ta == null ? void 0 : ta._url) !== null && na !== void 0 ? na : this.requestRouter.endpointFor("api", this.analyticsDefaultEndpoint),
										data: oa,
										compression: "best-available",
										batchKey: ta == null ? void 0 : ta._batchKey
									};
									return !this.config.request_batching || ta && (ta == null || !ta._batchKey) || ta != null && ta.send_instantly ? this._send_retriable_request(ca) : this._requestQueue.enqueue(ca), oa
								}
								G.critical("This capture call is ignored due to client rate limiting.")
							}
						} else G.error("No event name provided to posthog.capture")
				} else G.uninitializedWarning("posthog.capture")
			}
		}, {
			key: "_addCaptureHook",
			value: function(Yi) {
				this.on("eventCaptured", function(ea) {
					return Yi(ea.event, ea)
				})
			}
		}, {
			key: "_calculate_event_properties",
			value: function(Yi, ea, ta) {
				if (ta = ta || new Date, !this.persistence || !this.sessionPersistence) return ea;
				var na = this.persistence.remove_event_timer(Yi),
					ra = t({}, ea);
				if (ra.token = this.config.token, Yi === "$snapshot") {
					var ia = t(t({}, this.persistence.properties()), this.sessionPersistence.properties());
					return ra.distinct_id = ia.distinct_id, (!S(ra.distinct_id) && !F(ra.distinct_id) || E(ra.distinct_id)) && G.error("Invalid distinct_id for replay event. This indicates a bug in your implementation"), ra
				}
				var aa = mn.properties();
				if (this.sessionManager) {
					var oa = this.sessionManager.checkAndGetSessionAndWindowId(),
						la = oa.sessionId,
						sa = oa.windowId;
					ra.$session_id = la, ra.$window_id = sa
				}
				if (this.requestRouter.region === ur.CUSTOM && (ra.$lib_custom_api_host = this.config.api_host), this.sessionPropsManager && this.config.__preview_send_client_session_params && (Yi === "$pageview" || Yi === "$pageleave" || Yi === "$autocapture")) {
					var ca = this.sessionPropsManager.getSessionProps();
					ra = J(ra, ca)
				}
				if (!this.config.disable_scroll_properties) {
					var ua = {};
					Yi === "$pageview" ? ua = this.pageViewManager.doPageView(ta) : Yi === "$pageleave" && (ua = this.pageViewManager.doPageLeave(ta)), ra = J(ra, ua)
				}
				if (Yi === "$pageview" && L && (ra.title = L.title), !w(na)) {
					var da = ta.getTime() - na;
					ra.$duration = parseFloat((da / 1e3).toFixed(3))
				}
				H && this.config.opt_out_useragent_filter && (ra.$browser_type = this._is_bot() ? "bot" : "browser"), (ra = J({}, aa, this.persistence.properties(), this.sessionPersistence.properties(), ra)).$is_identified = this._isIdentified(), m(this.config.property_denylist) ? Q(this.config.property_denylist, function(pa) {
					delete ra[pa]
				}) : G.error("Invalid value for property_denylist config: " + this.config.property_denylist + " or property_blacklist config: " + this.config.property_blacklist);
				var ha = this.config.sanitize_properties;
				return ha && (ra = ha(ra, Yi)), ra.$process_person_profile = this._hasPersonProcessing(), ra
			}
		}, {
			key: "_calculate_set_once_properties",
			value: function(Yi) {
				if (!this.persistence || !this._hasPersonProcessing()) return Yi;
				var ea = J({}, this.persistence.get_initial_props(), Yi || {});
				return k(ea) ? void 0 : ea
			}
		}, {
			key: "register",
			value: function(Yi, ea) {
				var ta;
				(ta = this.persistence) === null || ta === void 0 || ta.register(Yi, ea)
			}
		}, {
			key: "register_once",
			value: function(Yi, ea, ta) {
				var na;
				(na = this.persistence) === null || na === void 0 || na.register_once(Yi, ea, ta)
			}
		}, {
			key: "register_for_session",
			value: function(Yi) {
				var ea;
				(ea = this.sessionPersistence) === null || ea === void 0 || ea.register(Yi)
			}
		}, {
			key: "unregister",
			value: function(Yi) {
				var ea;
				(ea = this.persistence) === null || ea === void 0 || ea.unregister(Yi)
			}
		}, {
			key: "unregister_for_session",
			value: function(Yi) {
				var ea;
				(ea = this.sessionPersistence) === null || ea === void 0 || ea.unregister(Yi)
			}
		}, {
			key: "_register_single",
			value: function(Yi, ea) {
				this.register(o({}, Yi, ea))
			}
		}, {
			key: "getFeatureFlag",
			value: function(Yi, ea) {
				return this.featureFlags.getFeatureFlag(Yi, ea)
			}
		}, {
			key: "getFeatureFlagPayload",
			value: function(Yi) {
				var ea = this.featureFlags.getFeatureFlagPayload(Yi);
				try {
					return JSON.parse(ea)
				} catch {
					return ea
				}
			}
		}, {
			key: "isFeatureEnabled",
			value: function(Yi, ea) {
				return this.featureFlags.isFeatureEnabled(Yi, ea)
			}
		}, {
			key: "reloadFeatureFlags",
			value: function() {
				this.featureFlags.reloadFeatureFlags()
			}
		}, {
			key: "updateEarlyAccessFeatureEnrollment",
			value: function(Yi, ea) {
				this.featureFlags.updateEarlyAccessFeatureEnrollment(Yi, ea)
			}
		}, {
			key: "getEarlyAccessFeatures",
			value: function(Yi) {
				var ea = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
				return this.featureFlags.getEarlyAccessFeatures(Yi, ea)
			}
		}, {
			key: "on",
			value: function(Yi, ea) {
				return this._internalEventEmitter.on(Yi, ea)
			}
		}, {
			key: "onFeatureFlags",
			value: function(Yi) {
				return this.featureFlags.onFeatureFlags(Yi)
			}
		}, {
			key: "onSessionId",
			value: function(Yi) {
				var ea, ta;
				return (ea = (ta = this.sessionManager) === null || ta === void 0 ? void 0 : ta.onSessionId(Yi)) !== null && ea !== void 0 ? ea : function() {}
			}
		}, {
			key: "getSurveys",
			value: function(Yi) {
				var ea = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
				this.surveys.getSurveys(Yi, ea)
			}
		}, {
			key: "getActiveMatchingSurveys",
			value: function(Yi) {
				var ea = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
				this.surveys.getActiveMatchingSurveys(Yi, ea)
			}
		}, {
			key: "renderSurvey",
			value: function(Yi, ea) {
				this.surveys.renderSurvey(Yi, ea)
			}
		}, {
			key: "canRenderSurvey",
			value: function(Yi) {
				this.surveys.canRenderSurvey(Yi)
			}
		}, {
			key: "getNextSurveyStep",
			value: function(Yi, ea, ta) {
				return this.surveys.getNextSurveyStep(Yi, ea, ta)
			}
		}, {
			key: "identify",
			value: function(Yi, ea, ta) {
				if (!this.__loaded || !this.persistence) return G.uninitializedWarning("posthog.identify");
				if (F(Yi) && (Yi = Yi.toString(), G.warn("The first argument to posthog.identify was a number, but it should be a string. It has been converted to a string.")), Yi) {
					if (["distinct_id", "distinctid"].includes(Yi.toLowerCase())) G.critical('The string "'.concat(Yi, '" was set in posthog.identify which indicates an error. This ID should be unique to the user and not a hardcoded string.'));
					else if (this._requirePersonProcessing("posthog.identify")) {
						var na = this.get_distinct_id();
						if (this.register({
								$user_id: Yi
							}), !this.get_property("$device_id")) {
							var ra = na;
							this.register_once({
								$had_persisted_distinct_id: !0,
								$device_id: ra
							}, "")
						}
						Yi !== na && Yi !== this.get_property(ce) && (this.unregister(ce), this.register({
							distinct_id: Yi
						}));
						var ia = (this.persistence.get_property($e) || "anonymous") === "anonymous";
						Yi !== na && ia ? (this.persistence.set_property($e, "identified"), this.setPersonPropertiesForFlags(ea || {}, !1), this.capture("$identify", {
							distinct_id: Yi,
							$anon_distinct_id: na
						}, {
							$set: ea || {},
							$set_once: ta || {}
						}), this.featureFlags.setAnonymousDistinctId(na)) : (ea || ta) && this.setPersonProperties(ea, ta), Yi !== na && (this.reloadFeatureFlags(), this.unregister(Ce))
					}
				} else G.error("Unique user id has not been set in posthog.identify")
			}
		}, {
			key: "setPersonProperties",
			value: function(Yi, ea) {
				(Yi || ea) && this._requirePersonProcessing("posthog.setPersonProperties") && (this.setPersonPropertiesForFlags(Yi || {}), this.capture("$set", {
					$set: Yi || {},
					$set_once: ea || {}
				}))
			}
		}, {
			key: "group",
			value: function(Yi, ea, ta) {
				if (Yi && ea) {
					if (this._requirePersonProcessing("posthog.group")) {
						var na = this.getGroups();
						na[Yi] !== ea && this.resetGroupPropertiesForFlags(Yi), this.register({
							$groups: t(t({}, na), {}, o({}, Yi, ea))
						}), ta && (this.capture("$groupidentify", {
							$group_type: Yi,
							$group_key: ea,
							$group_set: ta
						}), this.setGroupPropertiesForFlags(o({}, Yi, ta))), na[Yi] === ea || ta || this.reloadFeatureFlags()
					}
				} else G.error("posthog.group requires a group type and group key")
			}
		}, {
			key: "resetGroups",
			value: function() {
				this.register({
					$groups: {}
				}), this.resetGroupPropertiesForFlags(), this.reloadFeatureFlags()
			}
		}, {
			key: "setPersonPropertiesForFlags",
			value: function(Yi) {
				var ea = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
				this._requirePersonProcessing("posthog.setPersonPropertiesForFlags") && this.featureFlags.setPersonPropertiesForFlags(Yi, ea)
			}
		}, {
			key: "resetPersonPropertiesForFlags",
			value: function() {
				this.featureFlags.resetPersonPropertiesForFlags()
			}
		}, {
			key: "setGroupPropertiesForFlags",
			value: function(Yi) {
				var ea = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
				this._requirePersonProcessing("posthog.setGroupPropertiesForFlags") && this.featureFlags.setGroupPropertiesForFlags(Yi, ea)
			}
		}, {
			key: "resetGroupPropertiesForFlags",
			value: function(Yi) {
				this.featureFlags.resetGroupPropertiesForFlags(Yi)
			}
		}, {
			key: "reset",
			value: function(Yi) {
				var ea, ta, na, ra;
				if (G.info("reset"), !this.__loaded) return G.uninitializedWarning("posthog.reset");
				var ia = this.get_property("$device_id");
				this.consent.reset(), (ea = this.persistence) === null || ea === void 0 || ea.clear(), (ta = this.sessionPersistence) === null || ta === void 0 || ta.clear(), (na = this.persistence) === null || na === void 0 || na.set_property($e, "anonymous"), (ra = this.sessionManager) === null || ra === void 0 || ra.resetSessionId();
				var aa = this.config.get_device_id(Ke());
				this.register_once({
					distinct_id: aa,
					$device_id: Yi ? aa : ia
				}, "")
			}
		}, {
			key: "get_distinct_id",
			value: function() {
				return this.get_property("distinct_id")
			}
		}, {
			key: "getGroups",
			value: function() {
				return this.get_property("$groups") || {}
			}
		}, {
			key: "get_session_id",
			value: function() {
				var Yi, ea;
				return (Yi = (ea = this.sessionManager) === null || ea === void 0 ? void 0 : ea.checkAndGetSessionAndWindowId(!0).sessionId) !== null && Yi !== void 0 ? Yi : ""
			}
		}, {
			key: "get_session_replay_url",
			value: function(Yi) {
				if (!this.sessionManager) return "";
				var ea = this.sessionManager.checkAndGetSessionAndWindowId(!0),
					ta = ea.sessionId,
					na = ea.sessionStartTimestamp,
					ra = this.requestRouter.endpointFor("ui", "/project/".concat(this.config.token, "/replay/").concat(ta));
				if (Yi != null && Yi.withTimestamp && na) {
					var ia, aa = (ia = Yi.timestampLookBack) !== null && ia !== void 0 ? ia : 10;
					if (!na) return ra;
					var oa = Math.max(Math.floor((new Date().getTime() - na) / 1e3) - aa, 0);
					ra += "?t=".concat(oa)
				}
				return ra
			}
		}, {
			key: "alias",
			value: function(Yi, ea) {
				return Yi === this.get_property(le) ? (G.critical("Attempting to create alias for existing People user - aborting."), -2) : this._requirePersonProcessing("posthog.alias") ? (w(ea) && (ea = this.get_distinct_id()), Yi !== ea ? (this._register_single(ce, Yi), this.capture("$create_alias", {
					alias: Yi,
					distinct_id: ea
				})) : (G.warn("alias matches current distinct_id - skipping api call."), this.identify(Yi), -1)) : void 0
			}
		}, {
			key: "set_config",
			value: function(Yi) {
				var ea, ta, na, ra, ia = t({}, this.config);
				b(Yi) && (J(this.config, ns(Yi)), (ea = this.persistence) === null || ea === void 0 || ea.update_config(this.config, ia), this.sessionPersistence = this.config.persistence === "sessionStorage" ? this.persistence : new bn(t(t({}, this.config), {}, {
					persistence: "sessionStorage"
				})), at.is_supported() && at.get("ph_debug") === "true" && (this.config.debug = !0), this.config.debug && (f.DEBUG = !0, G.info("set_config", {
					config: Yi,
					oldConfig: ia,
					newConfig: t({}, this.config)
				})), (ta = this.sessionRecording) === null || ta === void 0 || ta.startIfEnabledOrStop(), (na = this.autocapture) === null || na === void 0 || na.startIfEnabled(), (ra = this.heatmaps) === null || ra === void 0 || ra.startIfEnabled(), this.surveys.loadIfEnabled(), this._sync_opt_out_with_persistence())
			}
		}, {
			key: "startSessionRecording",
			value: function(Yi) {
				var ea, ta = x(Yi) && Yi;
				if (ta || Yi != null && Yi.sampling) {
					var na, ra, ia = (na = this.sessionManager) === null || na === void 0 ? void 0 : na.checkAndGetSessionAndWindowId();
					(ra = this.persistence) === null || ra === void 0 || ra.register(o({}, Ee, !0)), G.info("Session recording started with sampling override for session: ", ia == null ? void 0 : ia.sessionId)
				}(ta || Yi != null && Yi.linked_flag) && ((ea = this.sessionRecording) === null || ea === void 0 || ea.overrideLinkedFlag(), G.info("Session recording started with linked_flags override")), this.set_config({
					disable_session_recording: !1
				})
			}
		}, {
			key: "stopSessionRecording",
			value: function() {
				this.set_config({
					disable_session_recording: !0
				})
			}
		}, {
			key: "sessionRecordingStarted",
			value: function() {
				var Yi;
				return !((Yi = this.sessionRecording) === null || Yi === void 0 || !Yi.started)
			}
		}, {
			key: "captureException",
			value: function(Yi, ea) {
				var ta = y(U.parseErrorAsProperties) ? U.parseErrorAsProperties([Yi.message, void 0, void 0, void 0, Yi]) : t({
					$exception_type: Yi.name,
					$exception_message: Yi.message,
					$exception_level: "error"
				}, ea);
				this.exceptions.sendExceptionEvent(ta)
			}
		}, {
			key: "loadToolbar",
			value: function(Yi) {
				return this.toolbar.loadToolbar(Yi)
			}
		}, {
			key: "get_property",
			value: function(Yi) {
				var ea;
				return (ea = this.persistence) === null || ea === void 0 ? void 0 : ea.props[Yi]
			}
		}, {
			key: "getSessionProperty",
			value: function(Yi) {
				var ea;
				return (ea = this.sessionPersistence) === null || ea === void 0 ? void 0 : ea.props[Yi]
			}
		}, {
			key: "toString",
			value: function() {
				var Yi, ea = (Yi = this.config.name) !== null && Yi !== void 0 ? Yi : Zr;
				return ea !== Zr && (ea = Zr + "." + ea), ea
			}
		}, {
			key: "_isIdentified",
			value: function() {
				var Yi, ea;
				return ((Yi = this.persistence) === null || Yi === void 0 ? void 0 : Yi.get_property($e)) === "identified" || ((ea = this.sessionPersistence) === null || ea === void 0 ? void 0 : ea.get_property($e)) === "identified"
			}
		}, {
			key: "_hasPersonProcessing",
			value: function() {
				var Yi, ea, ta, na;
				return !(this.config.person_profiles === "never" || this.config.person_profiles === "identified_only" && !this._isIdentified() && k(this.getGroups()) && ((Yi = this.persistence) === null || Yi === void 0 || (ea = Yi.props) === null || ea === void 0 || !ea[ce]) && ((ta = this.persistence) === null || ta === void 0 || (na = ta.props) === null || na === void 0 || !na[qe]))
			}
		}, {
			key: "_shouldCapturePageleave",
			value: function() {
				return this.config.capture_pageleave === !0 || this.config.capture_pageleave === "if_capture_pageview" && this.config.capture_pageview
			}
		}, {
			key: "createPersonProfile",
			value: function() {
				this._hasPersonProcessing() || this._requirePersonProcessing("posthog.createPersonProfile") && this.setPersonProperties({}, {})
			}
		}, {
			key: "_requirePersonProcessing",
			value: function(Yi) {
				return this.config.person_profiles === "never" ? (G.error(Yi + ' was called, but process_person is set to "never". This call will be ignored.'), !1) : (this._register_single(qe, !0), !0)
			}
		}, {
			key: "_sync_opt_out_with_persistence",
			value: function() {
				var Yi, ea, ta, na, ra = this.consent.isOptedOut(),
					ia = this.config.opt_out_persistence_by_default,
					aa = this.config.disable_persistence || ra && !!ia;
				((Yi = this.persistence) === null || Yi === void 0 ? void 0 : Yi.disabled) !== aa && ((ta = this.persistence) === null || ta === void 0 || ta.set_disabled(aa)), ((ea = this.sessionPersistence) === null || ea === void 0 ? void 0 : ea.disabled) !== aa && ((na = this.sessionPersistence) === null || na === void 0 || na.set_disabled(aa))
			}
		}, {
			key: "opt_in_capturing",
			value: function(Yi) {
				var ea;
				this.consent.optInOut(!0), this._sync_opt_out_with_persistence(), (w(Yi == null ? void 0 : Yi.captureEventName) || Yi != null && Yi.captureEventName) && this.capture((ea = Yi == null ? void 0 : Yi.captureEventName) !== null && ea !== void 0 ? ea : "$opt_in", Yi == null ? void 0 : Yi.captureProperties, {
					send_instantly: !0
				}), this.config.capture_pageview && this._captureInitialPageview()
			}
		}, {
			key: "opt_out_capturing",
			value: function() {
				this.consent.optInOut(!1), this._sync_opt_out_with_persistence()
			}
		}, {
			key: "has_opted_in_capturing",
			value: function() {
				return this.consent.isOptedIn()
			}
		}, {
			key: "has_opted_out_capturing",
			value: function() {
				return this.consent.isOptedOut()
			}
		}, {
			key: "clear_opt_in_out_capturing",
			value: function() {
				this.consent.reset(), this._sync_opt_out_with_persistence()
			}
		}, {
			key: "_is_bot",
			value: function() {
				return A ? function(Yi, ea) {
					if (!Yi) return !1;
					var ta = Yi.userAgent;
					if (ta && Or(ta, ea)) return !0;
					try {
						var na = Yi == null ? void 0 : Yi.userAgentData;
						if (na != null && na.brands && na.brands.some(function(ra) {
								return Or(ra == null ? void 0 : ra.brand, ea)
							})) return !0
					} catch {}
					return !!Yi.webdriver
				}(A, this.config.custom_blocked_useragents) : void 0
			}
		}, {
			key: "_captureInitialPageview",
			value: function() {
				L && !this._initialPageviewCaptured && (this._initialPageviewCaptured = !0, this.capture("$pageview", {
					title: L.title
				}, {
					send_instantly: !0
				}))
			}
		}, {
			key: "debug",
			value: function(Yi) {
				Yi === !1 ? (T == null || T.console.log("You've disabled debug mode."), localStorage && localStorage.removeItem("ph_debug"), this.set_config({
					debug: !1
				})) : (T == null || T.console.log("You're now in debug mode. All calls to PostHog will be logged in your console.\nYou can disable this with `posthog.debug(false)`."), localStorage && localStorage.setItem("ph_debug", "true"), this.set_config({
					debug: !0
				}))
			}
		}]), ue
	}();
(function(ue, Yi) {
	for (var ea = 0; ea < Yi.length; ea++) ue.prototype[Yi[ea]] = ee(ue.prototype[Yi[ea]])
})(rs, ["identify"]);
var ss, os = (ss = Xr[Zr] = new rs, function() {
	function ue() {
		ue.done || (ue.done = !0, es = !1, Q(Xr, function(Yi) {
			Yi._dom_loaded()
		}))
	}
	L != null && L.addEventListener && (L.readyState === "complete" ? ue() : L.addEventListener("DOMContentLoaded", ue, !1)), T && oe(T, "load", ue, !0)
}(), ss);
const activate = {
		mounted(ue, Yi) {
			ue._clickHandler = () => Yi.value(), ue.addEventListener("click", ue._clickHandler), ue._keyupHandler = ea => {
				(ea.key === "Enter" || ea.key === " ") && Yi.value()
			}, ue.addEventListener("keyup", ue._keyupHandler)
		},
		unmounted(ue) {
			ue.removeEventListener("click", ue._clickHandler), ue.removeEventListener("keyup", ue._keyupHandler), delete ue._clickHandler, delete ue._keyupHandler
		}
	},
	clickOutside = {
		mounted(ue, Yi) {
			ue._clickOutsideEvent = ea => {
				ue !== ea.target && !ue.contains(ea.target) && Yi.value(ea)
			}, document.addEventListener("click", ue._clickOutsideEvent)
		},
		unmounted(ue) {
			document.removeEventListener("click", ue._clickOutsideEvent), delete ue._clickOutsideEvent
		}
	},
	horizontalWheelScroll = {
		mounted(ue) {
			ue._wheelHandler = Yi => {
				if (!Yi.deltaY) return;
				const ea = Yi.currentTarget.scrollLeft,
					ta = Yi.currentTarget.scrollWidth - ea - Yi.currentTarget.clientWidth;
				Yi.deltaY > 0 && ta === 0 || Yi.deltaY < 0 && ea === 0 || (Yi.currentTarget.scrollLeft += Yi.deltaY + Yi.deltaX, Yi.preventDefault())
			}, ue.addEventListener("wheel", ue._wheelHandler)
		},
		unmounted(ue) {
			ue.removeEventListener("wheel", ue._wheelHandler), delete ue._wheelHandler
		}
	},
	logoMiniUrl = "data:image/svg+xml,%3csvg%20width='45'%20height='44'%20viewBox='0%200%2045%2044'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M19.0883%2012.9062H24.541V20.25H19.0883V12.9062Z'%20fill='white'/%3e%3cpath%20d='M19.0883%2023.9219H26.3586V27.5938H22.7234V31.2656H19.0883V23.9219Z'%20fill='white'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M22.7234%201.89062H19.0883V5.5625H7.375V38.6094H19.0883V42.2812H22.7234V38.6094H34.0328V34.9375H37.668V9.23438H34.0328V5.5625H22.7234V1.89062ZM34.0328%2031.2656H30.3977V34.9375H11.0102V9.23438H30.3977V12.9062H34.0328V20.25H30.3977V23.9219H34.0328V31.2656Z'%20fill='white'/%3e%3c/svg%3e";
var define_process_env_default$1 = {};
const isImage = ue => ue instanceof HTMLImageElement ? !0 : (define_process_env_default$1.dev && console.error("Element is not an image"), !1),
	imgLoader = {
		mounted(ue, Yi) {
			isImage(ue) && (ue.complete || (ue.style.opacity = "0", ue.style.transition = "opacity 0.2s ease", ue.onload = () => ue.style.opacity = "1", ue.onerror = () => {
				Yi.value.onError && Yi.value.onError()
			}))
		}
	},
	imgError = {
		mounted(ue, Yi) {
			isImage(ue) && (ue.onerror = () => ue.src = Yi.value ?? logoMiniUrl)
		}
	};
var define_process_env_default = {};
const sanitizeUrlFromTgHash = ue => {
		const Yi = ue.indexOf("#tgWebAppData=");
		return Yi === -1 ? ue : ue.slice(0, Yi)
	},
	posthogSanitizeProperties = ue => {
		const Yi = [ue];
		for (; Yi.length > 0;) {
			const ea = Yi.pop();
			ea && typeof ea == "object" && Object.entries(ea).forEach(([ta, na]) => {
				typeof na == "string" ? ea[ta] = sanitizeUrlFromTgHash(na) : typeof na == "object" && na && Yi.push(na)
			})
		}
		return ue
	},
	_0_init_OCK4y3SbNS = defineNuxtPlugin(ue => {
		useLogger()._flow.init(), ue.vueApp.directive("activate", activate), ue.vueApp.directive("img-loader", imgLoader), ue.vueApp.directive("img-error", imgError), ue.vueApp.directive("click-outside", clickOutside), ue.vueApp.directive("horizontal-wheel-scroll", horizontalWheelScroll);
		const Yi = (() => {
				const {
					SENTRY_DSN: ta,
					ENVIRONMENT: na
				} = useRuntimeConfig().public;
				if (!ta) return;
				const ra = na === "prod";
				return init({
					app: ue.vueApp,
					dsn: ta,
					release: define_process_env_default.COMMIT_HASH,
					environment: na,
					integrations: [browserTracingIntegration({
						router: useRouter()
					}), replayIntegration$1({
						maskAllText: !1,
						maskAllInputs: !1
					})],
					sampleRate: ra ? .01 : 1,
					tracesSampleRate: ra ? .01 : 1,
					replaysSessionSampleRate: ra ? 0 : 1,
					replaysOnErrorSampleRate: ra ? 0 : 1,
					normalizeDepth: 10,
					beforeSend(ia, aa) {
						var la;
						const oa = (la = aa.originalException) == null ? void 0 : la.message;
						return oa && (oa.includes("Unable to preload CSS") || oa.includes('[GET] "/_dist/builds/meta/') || oa.includes("Java object is gone") || oa.includes("error loading dynamically imported module")) ? null : ia
					}
				}), Sentry
			})(),
			ea = (() => {
				const {
					POSTHOG_API_KEY: ta,
					POSTHOG_HOST: na
				} = useRuntimeConfig().public;
				return !ta || !na ? void 0 : os.init(ta, {
					api_host: na,
					autocapture: !1,
					capture_pageview: !1,
					capture_pageleave: !1,
					person_profiles: "identified_only",
					loaded: ia => !1,
					sanitize_properties: posthogSanitizeProperties
				})
			})();
		return {
			provide: {
				sentry: Yi,
				posthog: ea
			}
		}
	});
(function() {
	var ue = {},
		Yi = "";
	try {
		Yi = location.hash.toString()
	} catch {}
	var ea = oa(Yi),
		ta = ba("initParams");
	if (ta)
		for (var na in ta) typeof ea[na] > "u" && (ea[na] = ta[na]);
	va("initParams", ea);
	var ra = !1,
		ia;
	try {
		if (ra = window.parent != null && window != window.parent, ra) {
			window.addEventListener("message", function(Ea) {
				if (Ea.source === window.parent) {
					try {
						var Sa = JSON.parse(Ea.data)
					} catch {
						return
					}
					if (!(!Sa || !Sa.eventType))
						if (Sa.eventType == "set_custom_style") Ea.origin === "https://web.telegram.org" && (ia.innerHTML = Sa.eventData);
						else if (Sa.eventType == "reload_iframe") {
						try {
							window.parent.postMessage(JSON.stringify({
								eventType: "iframe_will_reload"
							}), "*")
						} catch {}
						location.reload()
					} else ua(Sa.eventType, Sa.eventData)
				}
			}), ia = document.createElement("style"), document.head.appendChild(ia);
			try {
				window.parent.postMessage(JSON.stringify({
					eventType: "iframe_ready",
					eventData: {
						reload_supported: !0
					}
				}), "*")
			} catch {}
		}
	} catch {}

	function aa(Ea) {
		try {
			return Ea = Ea.replace(/\+/g, "%20"), decodeURIComponent(Ea)
		} catch {
			return Ea
		}
	}

	function oa(Ea) {
		Ea = Ea.replace(/^#/, "");
		var Sa = {};
		if (!Ea.length) return Sa;
		if (Ea.indexOf("=") < 0 && Ea.indexOf("?") < 0) return Sa._path = aa(Ea), Sa;
		var Ca = Ea.indexOf("?");
		if (Ca >= 0) {
			var ka = Ea.substr(0, Ca);
			Sa._path = aa(ka), Ea = Ea.substr(Ca + 1)
		}
		var Pa = la(Ea);
		for (var ja in Pa) Sa[ja] = Pa[ja];
		return Sa
	}

	function la(Ea) {
		var Sa = {};
		if (!Ea.length) return Sa;
		var Ca = Ea.split("&"),
			ka, Pa, ja, Za;
		for (ka = 0; ka < Ca.length; ka++) Pa = Ca[ka].split("="), ja = aa(Pa[0]), Za = Pa[1] == null ? null : aa(Pa[1]), Sa[ja] = Za;
		return Sa
	}

	function sa(Ea, Sa) {
		var Ca = Ea.indexOf("#");
		if (Ca < 0) return Ea + "#" + Sa;
		var ka = Ea.substr(Ca + 1);
		return ka.indexOf("=") >= 0 || ka.indexOf("?") >= 0 ? Ea + "&" + Sa : ka.length > 0 ? Ea + "?" + Sa : Ea + Sa
	}

	function ca(Ea, Sa, Ca) {
		if (Sa || (Sa = function() {}), Ca === void 0 && (Ca = ""), console.log("[Telegram.WebView] > postEvent", Ea, Ca), window.TelegramWebviewProxy !== void 0) TelegramWebviewProxy.postEvent(Ea, JSON.stringify(Ca)), Sa();
		else if (window.external && "notify" in window.external) window.external.notify(JSON.stringify({
			eventType: Ea,
			eventData: Ca
		})), Sa();
		else if (ra) try {
			var ka = "https://web.telegram.org";
			ka = "*", window.parent.postMessage(JSON.stringify({
				eventType: Ea,
				eventData: Ca
			}), ka), Sa()
		} catch (Pa) {
			Sa(Pa)
		} else Sa({
			notAvailable: !0
		})
	}

	function ua(Ea, Sa) {
		console.log("[Telegram.WebView] < receiveEvent", Ea, Sa), da(Ea, function(Ca) {
			Ca(Ea, Sa)
		})
	}

	function da(Ea, Sa) {
		var Ca = ue[Ea];
		if (!(Ca === void 0 || !Ca.length))
			for (var ka = 0; ka < Ca.length; ka++) try {
				Sa(Ca[ka])
			} catch {}
	}

	function ha(Ea, Sa) {
		ue[Ea] === void 0 && (ue[Ea] = []);
		var Ca = ue[Ea].indexOf(Sa);
		Ca === -1 && ue[Ea].push(Sa)
	}

	function pa(Ea, Sa) {
		if (ue[Ea] !== void 0) {
			var Ca = ue[Ea].indexOf(Sa);
			Ca !== -1 && ue[Ea].splice(Ca, 1)
		}
	}

	function va(Ea, Sa) {
		try {
			return window.sessionStorage.setItem("__telegram__" + Ea, JSON.stringify(Sa)), !0
		} catch {}
		return !1
	}

	function ba(Ea) {
		try {
			return JSON.parse(window.sessionStorage.getItem("__telegram__" + Ea))
		} catch {}
		return null
	}
	window.Telegram || (window.Telegram = {}), window.Telegram.WebView = {
		initParams: ea,
		isIframe: ra,
		onEvent: ha,
		offEvent: pa,
		postEvent: ca,
		receiveEvent: ua,
		callEventCallbacks: da
	}, window.Telegram.Utils = {
		urlSafeDecode: aa,
		urlParseQueryString: la,
		urlParseHashParams: oa,
		urlAppendHashParams: sa,
		sessionStorageSet: va,
		sessionStorageGet: ba
	}, window.TelegramGameProxy_receiveEvent = ua, window.TelegramGameProxy = {
		receiveEvent: ua
	}
})();
(function() {
	var ue = window.Telegram.Utils,
		Yi = window.Telegram.WebView,
		ea = Yi.initParams,
		ta = Yi.isIframe,
		na = {},
		ra = "",
		ia = {},
		aa = {},
		oa = "light",
		la = "6.0",
		sa = "unknown";
	if (ea.tgWebAppData && ea.tgWebAppData.length) {
		ra = ea.tgWebAppData, ia = ue.urlParseQueryString(ra);
		for (var ca in ia) {
			var ua = ia[ca];
			try {
				(ua.substr(0, 1) == "{" && ua.substr(-1) == "}" || ua.substr(0, 1) == "[" && ua.substr(-1) == "]") && (ia[ca] = JSON.parse(ua))
			} catch {}
		}
	}
	if (ea.tgWebAppThemeParams && ea.tgWebAppThemeParams.length) {
		var da = ea.tgWebAppThemeParams;
		try {
			var ha = JSON.parse(da);
			ha && Ga(ha)
		} catch {}
	}
	var ha = ue.sessionStorageGet("themeParams");
	ha && Ga(ha), ea.tgWebAppVersion && (la = ea.tgWebAppVersion), ea.tgWebAppPlatform && (sa = ea.tgWebAppPlatform);

	function pa(go, Ha) {
		Ha.theme_params && (Ga(Ha.theme_params), window.Telegram.WebApp.MainButton.setParams({}), window.Telegram.WebApp.SecondaryButton.setParams({}), ao(), Va(), yo(), ka("themeChanged"))
	}
	var va = window.innerHeight;

	function ba(go, Ha) {
		Ha.height && (window.removeEventListener("resize", Ea), ga(Ha))
	}

	function Ea(go) {
		va != window.innerHeight && (va = window.innerHeight, ka("viewportChanged", {
			isStateStable: !0
		}))
	}

	function Sa(go) {
		if (!(go.metaKey || go.ctrlKey)) {
			for (var Ha = go.target; Ha.tagName != "A" && Ha.parentNode;) Ha = Ha.parentNode;
			Ha.tagName == "A" && Ha.target != "_blank" && (Ha.protocol == "http:" || Ha.protocol == "https:") && Ha.hostname == "t.me" && (na.openTgLink(Ha.href), go.preventDefault())
		}
	}

	function Ca(go) {
		return go.toString().replace(/^\s+|\s+$/g, "")
	}

	function ka(go) {
		var Ha = Array.prototype.slice.call(arguments);
		go = Ha.shift(), Yi.callEventCallbacks("webview:" + go, function(Fa) {
			Fa.apply(na, Ha)
		})
	}

	function Pa(go, Ha) {
		Yi.onEvent("webview:" + go, Ha)
	}

	function ja(go, Ha) {
		Yi.offEvent("webview:" + go, Ha)
	}

	function Za(go, Ha) {
		var Fa = document.documentElement;
		Fa && Fa.style && Fa.style.setProperty && Fa.style.setProperty("--tg-" + go, Ha)
	}

	function Ga(go) {
		go.bg_color == "#1c1c1d" && go.bg_color == go.secondary_bg_color && (go.secondary_bg_color = "#2c2c2e");
		var Ha;
		for (var Fa in go)(Ha = fo(go[Fa])) && (aa[Fa] = Ha, Fa == "bg_color" && (oa = vo(Ha) ? "dark" : "light", Za("color-scheme", oa)), Fa = "theme-" + Fa.split("_").join("-"), Za(Fa, Ha));
		ue.sessionStorageSet("themeParams", aa)
	}
	var Ja = {};

	function Ua(go) {
		for (var Ha = 100; --Ha;) {
			for (var Fa = "", Ya = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", $a = Ya.length, no = 0; no < go; no++) Fa += Ya[Math.floor(Math.random() * $a)];
			if (!Ja[Fa]) return Ja[Fa] = {}, Fa
		}
		throw Error("WebAppCallbackIdGenerateFailed")
	}
	var xa = !1,
		ma = !1,
		fa = !0;

	function ga(go) {
		typeof go < "u" && (fa = !!go.is_expanded, xa = go.height, go.is_state_stable && (ma = go.height), ka("viewportChanged", {
			isStateStable: !!go.is_state_stable
		}));
		var Ha, Fa;
		xa !== !1 ? Ha = xa - Ao + "px" : Ha = Ao ? "calc(100vh - " + Ao + "px)" : "100vh", ma !== !1 ? Fa = ma - Ao + "px" : Fa = Ao ? "calc(100vh - " + Ao + "px)" : "100vh", Za("viewport-height", Ha), Za("viewport-stable-height", Fa)
	}
	var wa = !1;

	function Ma(go) {
		if (!Xa("6.2")) {
			console.warn("[Telegram.WebApp] Closing confirmation is not supported in version " + la);
			return
		}
		wa = !!go, Yi.postEvent("web_app_setup_closing_behavior", !1, {
			need_confirmation: wa
		})
	}
	var Aa = !0;

	function Ra(go) {
		if (!Xa("7.7")) {
			console.warn("[Telegram.WebApp] Changing swipes behavior is not supported in version " + la);
			return
		}
		Aa = !!go, Yi.postEvent("web_app_setup_swipe_behavior", !1, {
			allow_vertical_swipe: Aa
		})
	}
	var Ta = "bg_color",
		La = null;

	function ya() {
		return Ta == "secondary_bg_color" ? aa.secondary_bg_color : Ta == "bg_color" ? aa.bg_color : La
	}

	function Ba(go) {
		if (!Xa("6.1")) {
			console.warn("[Telegram.WebApp] Header color is not supported in version " + la);
			return
		}
		Xa("6.9") || (aa.bg_color && aa.bg_color == go ? go = "bg_color" : aa.secondary_bg_color && aa.secondary_bg_color == go && (go = "secondary_bg_color"));
		var Ha = null,
			Fa = null;
		if (go == "bg_color" || go == "secondary_bg_color") Fa = go;
		else if (Xa("6.9") && (Ha = fo(go), !Ha)) throw console.error("[Telegram.WebApp] Header color format is invalid", go), Error("WebAppHeaderColorInvalid");
		if (!Xa("6.9") && Fa != "bg_color" && Fa != "secondary_bg_color") throw console.error("[Telegram.WebApp] Header color key should be one of Telegram.WebApp.themeParams.bg_color, Telegram.WebApp.themeParams.secondary_bg_color, 'bg_color', 'secondary_bg_color'", go), Error("WebAppHeaderColorKeyInvalid");
		Ta = Fa, La = Ha, ao()
	}
	var io = null,
		oo = null;

	function ao() {
		(io != Ta || oo != La) && (io = Ta, oo = La, oo ? Yi.postEvent("web_app_set_header_color", !1, {
			color: La
		}) : Yi.postEvent("web_app_set_header_color", !1, {
			color_key: Ta
		}))
	}
	var Ia = "bg_color";

	function Na() {
		return Ia == "secondary_bg_color" ? aa.secondary_bg_color : Ia == "bg_color" ? aa.bg_color : Ia
	}

	function za(go) {
		if (!Xa("6.1")) {
			console.warn("[Telegram.WebApp] Background color is not supported in version " + la);
			return
		}
		var Ha;
		if (go == "bg_color" || go == "secondary_bg_color") Ha = go;
		else if (Ha = fo(go), !Ha) throw console.error("[Telegram.WebApp] Background color format is invalid", go), Error("WebAppBackgroundColorInvalid");
		Ia = Ha, Va()
	}
	var ro = null;

	function Va() {
		var go = Na();
		ro != go && (ro = go, Yi.postEvent("web_app_set_background_color", !1, {
			color: go
		}))
	}
	var Wa = "bottom_bar_bg_color";

	function qa() {
		return Wa == "bottom_bar_bg_color" ? aa.bottom_bar_bg_color || aa.secondary_bg_color || "#ffffff" : Wa == "secondary_bg_color" ? aa.secondary_bg_color : Wa == "bg_color" ? aa.bg_color : Wa
	}

	function Ka(go) {
		if (!Xa("7.10")) {
			console.warn("[Telegram.WebApp] Bottom bar color is not supported in version " + la);
			return
		}
		var Ha;
		if (go == "bg_color" || go == "secondary_bg_color" || go == "bottom_bar_bg_color") Ha = go;
		else if (Ha = fo(go), !Ha) throw console.error("[Telegram.WebApp] Bottom bar color format is invalid", go), Error("WebAppBottomBarColorInvalid");
		Wa = Ha, yo(), window.Telegram.WebApp.SecondaryButton.setParams({})
	}
	var lo = null;

	function yo() {
		var go = qa();
		lo != go && (lo = go, Yi.postEvent("web_app_set_bottom_bar_color", !1, {
			color: go
		})), ea.tgWebAppDebug && jo()
	}

	function fo(go) {
		go += "";
		var Ha;
		if (Ha = /^\s*#([0-9a-f]{6})\s*$/i.exec(go)) return "#" + Ha[1].toLowerCase();
		if (Ha = /^\s*#([0-9a-f])([0-9a-f])([0-9a-f])\s*$/i.exec(go)) return ("#" + Ha[1] + Ha[1] + Ha[2] + Ha[2] + Ha[3] + Ha[3]).toLowerCase();
		if (Ha = /^\s*rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+\.{0,1}\d*))?\)\s*$/.exec(go)) {
			var Fa = parseInt(Ha[1]),
				Ya = parseInt(Ha[2]),
				$a = parseInt(Ha[3]);
			return Fa = (Fa < 16 ? "0" : "") + Fa.toString(16), Ya = (Ya < 16 ? "0" : "") + Ya.toString(16), $a = ($a < 16 ? "0" : "") + $a.toString(16), "#" + Fa + Ya + $a
		}
		return !1
	}

	function vo(go) {
		go = go.replace(/[\s#]/g, ""), go.length == 3 && (go = go[0] + go[0] + go[1] + go[1] + go[2] + go[2]);
		var Ha = parseInt(go.substr(0, 2), 16),
			Fa = parseInt(go.substr(2, 2), 16),
			Ya = parseInt(go.substr(4, 2), 16),
			$a = Math.sqrt(.299 * (Ha * Ha) + .587 * (Fa * Fa) + .114 * (Ya * Ya));
		return $a < 120
	}

	function so(go, Ha) {
		typeof go != "string" && (go = ""), typeof Ha != "string" && (Ha = ""), go = go.replace(/^\s+|\s+$/g, "").split("."), Ha = Ha.replace(/^\s+|\s+$/g, "").split(".");
		var Fa = Math.max(go.length, Ha.length),
			Ya, $a, no;
		for (Ya = 0; Ya < Fa; Ya++)
			if ($a = parseInt(go[Ya]) || 0, no = parseInt(Ha[Ya]) || 0, $a != no) return $a > no ? 1 : -1;
		return 0
	}

	function Xa(go) {
		return so(la, go) >= 0
	}

	function to(go) {
		if (window.Blob) try {
			return new Blob([go]).size
		} catch {}
		for (var Ha = go.length, Fa = go.length - 1; Fa >= 0; Fa--) {
			var Ya = go.charCodeAt(Fa);
			Ya > 127 && Ya <= 2047 ? Ha++ : Ya > 2047 && Ya <= 65535 && (Ha += 2), Ya >= 56320 && Ya <= 57343 && Fa--
		}
		return Ha
	}
	var ho = function() {
			var go = !1,
				Ha = {};
			Object.defineProperty(Ha, "isVisible", {
				set: function(xo) {
					mo({
						is_visible: xo
					})
				},
				get: function() {
					return go
				},
				enumerable: !0
			});
			var Fa = null;
			Yi.onEvent("back_button_pressed", Ya);

			function Ya() {
				ka("backButtonClicked")
			}

			function $a() {
				return {
					is_visible: go
				}
			}

			function no(xo) {
				return typeof xo > "u" && (xo = $a()), JSON.stringify(xo)
			}

			function Co() {
				return Xa("6.1") ? !0 : (console.warn("[Telegram.WebApp] BackButton is not supported in version " + la), !1)
			}

			function co() {
				var xo = $a(),
					ko = no(xo);
				Fa !== ko && (Fa = ko, Yi.postEvent("web_app_setup_back_button", !1, xo))
			}

			function mo(xo) {
				return Co() && (typeof xo.is_visible < "u" && (go = !!xo.is_visible), co()), Ha
			}
			return Ha.onClick = function(xo) {
				return Co() && Pa("backButtonClicked", xo), Ha
			}, Ha.offClick = function(xo) {
				return Co() && ja("backButtonClicked", xo), Ha
			}, Ha.show = function() {
				return mo({
					is_visible: !0
				})
			}, Ha.hide = function() {
				return mo({
					is_visible: !1
				})
			}, Ha
		}(),
		Eo = null,
		wo = {},
		Ao = 0;
	if (ea.tgWebAppDebug) {
		Eo = document.createElement("tg-bottom-bar");
		var _o = {
			display: "flex",
			gap: "7px",
			font: "600 14px/18px sans-serif",
			width: "100%",
			background: qa(),
			position: "fixed",
			left: "0",
			right: "0",
			bottom: "0",
			margin: "0",
			padding: "7px",
			textAlign: "center",
			boxSizing: "border-box",
			zIndex: "10000"
		};
		for (var Lo in _o) Eo.style[Lo] = _o[Lo];
		document.addEventListener("DOMContentLoaded", function go(Ha) {
			document.removeEventListener("DOMContentLoaded", go), document.body.appendChild(Eo)
		});
		var Fo = document.createElement("style");
		Fo.innerHTML = 'tg-bottom-button.shine { position: relative; overflow: hidden; } tg-bottom-button.shine:before { content:""; position: absolute; top: 0; width: 100%; height: 100%; background: linear-gradient(120deg, transparent, rgba(255, 255, 255, .2), transparent); animation: tg-bottom-button-shine 5s ease-in-out infinite; } @-webkit-keyframes tg-bottom-button-shine { 0% {left: -100%;} 12%,100% {left: 100%}} @keyframes tg-bottom-button-shine { 0% {left: -100%;} 12%,100% {left: 100%}}', Eo.appendChild(Fo)
	}

	function jo() {
		var go = wo.main._bottomButton,
			Ha = wo.secondary._bottomButton;
		go.isVisible || Ha.isVisible ? (Eo.style.display = "flex", Ao = 58, go.isVisible && Ha.isVisible && (Ha.position == "top" ? (Eo.style.flexDirection = "column-reverse", Ao += 51) : Ha.position == "bottom" ? (Eo.style.flexDirection = "column", Ao += 51) : Ha.position == "left" ? Eo.style.flexDirection = "row-reverse" : Ha.position == "right" && (Eo.style.flexDirection = "row"))) : (Eo.style.display = "none", Ao = 0), Eo.style.background = qa(), document.documentElement && (document.documentElement.style.boxSizing = "border-box", document.documentElement.style.paddingBottom = Ao + "px"), ga()
	}
	var eo = function(go) {
			var Ha = go == "main";
			if (Ha) var Fa = "web_app_setup_main_button",
				Ya = "main_button_pressed",
				$a = "mainButtonClicked",
				no = "Continue",
				Co = function() {
					return aa.button_color || "#2481cc"
				},
				co = function() {
					return aa.button_text_color || "#ffffff"
				};
			else var Fa = "web_app_setup_secondary_button",
				Ya = "secondary_button_pressed",
				$a = "secondaryButtonClicked",
				no = "Cancel",
				Co = function() {
					return qa()
				},
				co = function() {
					return aa.button_color || "#2481cc"
				};
			var mo = !1,
				xo = !0,
				ko = !1,
				$o = !1,
				Ss = go,
				Xo = no,
				ms = !1,
				gs = !1,
				ys = "left",
				Vo = {};
			Object.defineProperty(Vo, "type", {
				get: function() {
					return Ss
				},
				enumerable: !0
			}), Object.defineProperty(Vo, "text", {
				set: function(Mo) {
					Vo.setParams({
						text: Mo
					})
				},
				get: function() {
					return Xo
				},
				enumerable: !0
			}), Object.defineProperty(Vo, "color", {
				set: function(Mo) {
					Vo.setParams({
						color: Mo
					})
				},
				get: function() {
					return ms || Co()
				},
				enumerable: !0
			}), Object.defineProperty(Vo, "textColor", {
				set: function(Mo) {
					Vo.setParams({
						text_color: Mo
					})
				},
				get: function() {
					return gs || co()
				},
				enumerable: !0
			}), Object.defineProperty(Vo, "isVisible", {
				set: function(Mo) {
					Vo.setParams({
						is_visible: Mo
					})
				},
				get: function() {
					return mo
				},
				enumerable: !0
			}), Object.defineProperty(Vo, "isProgressVisible", {
				get: function() {
					return $o
				},
				enumerable: !0
			}), Object.defineProperty(Vo, "isActive", {
				set: function(Mo) {
					Vo.setParams({
						is_active: Mo
					})
				},
				get: function() {
					return xo
				},
				enumerable: !0
			}), Object.defineProperty(Vo, "hasShineEffect", {
				set: function(Mo) {
					Vo.setParams({
						has_shine_effect: Mo
					})
				},
				get: function() {
					return ko
				},
				enumerable: !0
			}), Ha || Object.defineProperty(Vo, "position", {
				set: function(Mo) {
					Vo.setParams({
						position: Mo
					})
				},
				get: function() {
					return ys
				},
				enumerable: !0
			});
			var cs = null;
			Yi.onEvent(Ya, hs);
			var Zo = null;
			if (ea.tgWebAppDebug) {
				Zo = document.createElement("tg-bottom-button");
				var us = {
					display: "none",
					width: "100%",
					height: "44px",
					borderRadius: "0",
					background: "no-repeat right center",
					padding: "13px 15px",
					textAlign: "center",
					boxSizing: "border-box"
				};
				for (var Jo in us) Zo.style[Jo] = us[Jo];
				Eo.appendChild(Zo), Zo.addEventListener("click", hs, !1), Zo._bottomButton = Vo, wo[go] = Zo
			}

			function hs() {
				xo && ka($a)
			}

			function Qo() {
				var Mo = Vo.color,
					Uo = Vo.textColor;
				if (mo) {
					var Do = {
						is_visible: !0,
						is_active: xo,
						is_progress_visible: $o,
						text: Xo,
						color: Mo,
						text_color: Uo,
						has_shine_effect: ko && xo && !$o
					};
					Ha || (Do.position = ys)
				} else var Do = {
					is_visible: !1
				};
				return Do
			}

			function fs(Mo) {
				return typeof Mo > "u" && (Mo = Qo()), JSON.stringify(Mo)
			}

			function ds() {
				var Mo = Qo(),
					Uo = fs(Mo);
				cs !== Uo && (cs = Uo, Yi.postEvent(Fa, !1, Mo), ea.tgWebAppDebug && Yo(Mo))
			}

			function Yo(Mo) {
				Mo.is_visible ? (Zo.style.display = "block", Zo.style.opacity = Mo.is_active ? "1" : "0.8", Zo.style.cursor = Mo.is_active ? "pointer" : "auto", Zo.disabled = !Mo.is_active, Zo.innerText = Mo.text, Zo.className = Mo.has_shine_effect ? "shine" : "", Zo.style.backgroundImage = Mo.is_progress_visible ? "url('data:image/svg+xml," + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewport="0 0 48 48" width="48px" height="48px"><circle cx="50%" cy="50%" stroke="' + Mo.text_color + '" stroke-width="2.25" stroke-linecap="round" fill="none" stroke-dashoffset="106" r="9" stroke-dasharray="56.52" rotate="-90"><animate attributeName="stroke-dashoffset" attributeType="XML" dur="360s" from="0" to="12500" repeatCount="indefinite"></animate><animateTransform attributeName="transform" attributeType="XML" type="rotate" dur="1s" from="-90 24 24" to="630 24 24" repeatCount="indefinite"></animateTransform></circle></svg>') + "')" : "none", Zo.style.backgroundColor = Mo.color, Zo.style.color = Mo.text_color) : Zo.style.display = "none", jo()
			}

			function Bo(Mo) {
				if (typeof Mo.text < "u") {
					var Uo = Ca(Mo.text);
					if (!Uo.length) throw console.error("[Telegram.WebApp] Bottom button text is required", Mo.text), Error("WebAppBottomButtonParamInvalid");
					if (Uo.length > 64) throw console.error("[Telegram.WebApp] Bottom button text is too long", Uo), Error("WebAppBottomButtonParamInvalid");
					Xo = Uo
				}
				if (typeof Mo.color < "u")
					if (Mo.color === !1 || Mo.color === null) ms = !1;
					else {
						var Do = fo(Mo.color);
						if (!Do) throw console.error("[Telegram.WebApp] Bottom button color format is invalid", Mo.color), Error("WebAppBottomButtonParamInvalid");
						ms = Do
					} if (typeof Mo.text_color < "u")
					if (Mo.text_color === !1 || Mo.text_color === null) gs = !1;
					else {
						var qo = fo(Mo.text_color);
						if (!qo) throw console.error("[Telegram.WebApp] Bottom button text color format is invalid", Mo.text_color), Error("WebAppBottomButtonParamInvalid");
						gs = qo
					} if (typeof Mo.is_visible < "u") {
					if (Mo.is_visible && !Vo.text.length) throw console.error("[Telegram.WebApp] Bottom button text is required"), Error("WebAppBottomButtonParamInvalid");
					mo = !!Mo.is_visible
				}
				if (typeof Mo.has_shine_effect < "u" && (ko = !!Mo.has_shine_effect), !Ha && typeof Mo.position < "u") {
					if (Mo.position != "left" && Mo.position != "right" && Mo.position != "top" && Mo.position != "bottom") throw console.error("[Telegram.WebApp] Bottom button posiition is invalid", Mo.position), Error("WebAppBottomButtonParamInvalid");
					ys = Mo.position
				}
				return typeof Mo.is_active < "u" && (xo = !!Mo.is_active), ds(), Vo
			}
			return Vo.setText = function(Mo) {
				return Vo.setParams({
					text: Mo
				})
			}, Vo.onClick = function(Mo) {
				return Pa($a, Mo), Vo
			}, Vo.offClick = function(Mo) {
				return ja($a, Mo), Vo
			}, Vo.show = function() {
				return Vo.setParams({
					is_visible: !0
				})
			}, Vo.hide = function() {
				return Vo.setParams({
					is_visible: !1
				})
			}, Vo.enable = function() {
				return Vo.setParams({
					is_active: !0
				})
			}, Vo.disable = function() {
				return Vo.setParams({
					is_active: !1
				})
			}, Vo.showProgress = function(Mo) {
				return xo = !!Mo, $o = !0, ds(), Vo
			}, Vo.hideProgress = function() {
				return Vo.isActive || (xo = !0), $o = !1, ds(), Vo
			}, Vo.setParams = Bo, Vo
		},
		Oa = eo("main"),
		Da = eo("secondary"),
		Qa = function() {
			var go = !1,
				Ha = {};
			Object.defineProperty(Ha, "isVisible", {
				set: function(xo) {
					mo({
						is_visible: xo
					})
				},
				get: function() {
					return go
				},
				enumerable: !0
			});
			var Fa = null;
			Yi.onEvent("settings_button_pressed", Ya);

			function Ya() {
				ka("settingsButtonClicked")
			}

			function $a() {
				return {
					is_visible: go
				}
			}

			function no(xo) {
				return typeof xo > "u" && (xo = $a()), JSON.stringify(xo)
			}

			function Co() {
				return Xa("6.10") ? !0 : (console.warn("[Telegram.WebApp] SettingsButton is not supported in version " + la), !1)
			}

			function co() {
				var xo = $a(),
					ko = no(xo);
				Fa !== ko && (Fa = ko, Yi.postEvent("web_app_setup_settings_button", !1, xo))
			}

			function mo(xo) {
				return Co() && (typeof xo.is_visible < "u" && (go = !!xo.is_visible), co()), Ha
			}
			return Ha.onClick = function(xo) {
				return Co() && Pa("settingsButtonClicked", xo), Ha
			}, Ha.offClick = function(xo) {
				return Co() && ja("settingsButtonClicked", xo), Ha
			}, Ha.show = function() {
				return mo({
					is_visible: !0
				})
			}, Ha.hide = function() {
				return mo({
					is_visible: !1
				})
			}, Ha
		}(),
		uo = function() {
			var go = {};

			function Ha(Fa) {
				if (!Xa("6.1")) return console.warn("[Telegram.WebApp] HapticFeedback is not supported in version " + la), go;
				if (Fa.type == "impact") {
					if (Fa.impact_style != "light" && Fa.impact_style != "medium" && Fa.impact_style != "heavy" && Fa.impact_style != "rigid" && Fa.impact_style != "soft") throw console.error("[Telegram.WebApp] Haptic impact style is invalid", Fa.impact_style), Error("WebAppHapticImpactStyleInvalid")
				} else if (Fa.type == "notification") {
					if (Fa.notification_type != "error" && Fa.notification_type != "success" && Fa.notification_type != "warning") throw console.error("[Telegram.WebApp] Haptic notification type is invalid", Fa.notification_type), Error("WebAppHapticNotificationTypeInvalid")
				} else if (Fa.type != "selection_change") throw console.error("[Telegram.WebApp] Haptic feedback type is invalid", Fa.type), Error("WebAppHapticFeedbackTypeInvalid");
				return Yi.postEvent("web_app_trigger_haptic_feedback", !1, Fa), go
			}
			return go.impactOccurred = function(Fa) {
				return Ha({
					type: "impact",
					impact_style: Fa
				})
			}, go.notificationOccurred = function(Fa) {
				return Ha({
					type: "notification",
					notification_type: Fa
				})
			}, go.selectionChanged = function() {
				return Ha({
					type: "selection_change"
				})
			}, go
		}(),
		bo = function() {
			var go = {};

			function Ha(Fa, Ya, $a) {
				if (!Xa("6.9")) throw console.error("[Telegram.WebApp] CloudStorage is not supported in version " + la), Error("WebAppMethodUnsupported");
				return as(Fa, Ya, $a), go
			}
			return go.setItem = function(Fa, Ya, $a) {
				return Ha("saveStorageValue", {
					key: Fa,
					value: Ya
				}, $a)
			}, go.getItem = function(Fa, Ya) {
				return go.getItems([Fa], Ya ? function($a, no) {
					$a ? Ya($a) : Ya(null, no[Fa])
				} : null)
			}, go.getItems = function(Fa, Ya) {
				return Ha("getStorageValues", {
					keys: Fa
				}, Ya)
			}, go.removeItem = function(Fa, Ya) {
				return go.removeItems([Fa], Ya)
			}, go.removeItems = function(Fa, Ya) {
				return Ha("deleteStorageValues", {
					keys: Fa
				}, Ya)
			}, go.getKeys = function(Fa) {
				return Ha("getStorageKeys", {}, Fa)
			}, go
		}(),
		So = function() {
			var go = !1,
				Ha = !1,
				Fa = "unknown",
				Ya = !1,
				$a = !1,
				no = !1,
				Co = "",
				co = {};
			Object.defineProperty(co, "isInited", {
				get: function() {
					return go
				},
				enumerable: !0
			}), Object.defineProperty(co, "isBiometricAvailable", {
				get: function() {
					return go && Ha
				},
				enumerable: !0
			}), Object.defineProperty(co, "biometricType", {
				get: function() {
					return Fa || "unknown"
				},
				enumerable: !0
			}), Object.defineProperty(co, "isAccessRequested", {
				get: function() {
					return Ya
				},
				enumerable: !0
			}), Object.defineProperty(co, "isAccessGranted", {
				get: function() {
					return Ya && $a
				},
				enumerable: !0
			}), Object.defineProperty(co, "isBiometricTokenSaved", {
				get: function() {
					return no
				},
				enumerable: !0
			}), Object.defineProperty(co, "deviceId", {
				get: function() {
					return Co || ""
				},
				enumerable: !0
			});
			var mo = {
					callbacks: []
				},
				xo = !1,
				ko = !1,
				$o = !1;
			Yi.onEvent("biometry_info_received", Ss), Yi.onEvent("biometry_auth_requested", Xo), Yi.onEvent("biometry_token_updated", ms);

			function Ss(Vo, cs) {
				if (go = !0, cs.available ? (Ha = !0, Fa = cs.type || "unknown", cs.access_requested ? (Ya = !0, $a = !!cs.access_granted, no = !!cs.token_saved) : (Ya = !1, $a = !1, no = !1)) : (Ha = !1, Fa = "unknown", Ya = !1, $a = !1, no = !1), Co = cs.device_id || "", mo.callbacks.length > 0)
					for (var Zo = 0; Zo < mo.callbacks.length; Zo++) {
						var us = mo.callbacks[Zo];
						us()
					}
				if (xo) {
					var Jo = xo;
					xo = !1, Jo.callback && Jo.callback($a)
				}
				ka("biometricManagerUpdated")
			}

			function Xo(Vo, cs) {
				var Zo = cs.status == "authorized",
					us = cs.token || "";
				if (ko) {
					var Jo = ko;
					ko = !1, Jo.callback && Jo.callback(Zo, Zo ? us : null)
				}
				ka("biometricAuthRequested", Zo ? {
					isAuthenticated: !0,
					biometricToken: us
				} : {
					isAuthenticated: !1
				})
			}

			function ms(Vo, cs) {
				var Zo = !1;
				if (Ha && Ya && (cs.status == "updated" ? (no = !0, Zo = !0) : cs.status == "removed" && (no = !1, Zo = !0)), $o) {
					var us = $o;
					$o = !1, us.callback && us.callback(Zo)
				}
				ka("biometricTokenUpdated", {
					isUpdated: Zo
				})
			}

			function gs() {
				return Xa("7.2") ? !0 : (console.warn("[Telegram.WebApp] BiometricManager is not supported in version " + la), !1)
			}

			function ys() {
				if (!go) throw console.error("[Telegram.WebApp] BiometricManager should be inited before using."), Error("WebAppBiometricManagerNotInited");
				return !0
			}
			return co.init = function(Vo) {
				return !gs() || go || (Vo && mo.callbacks.push(Vo), Yi.postEvent("web_app_biometry_get_info", !1)), co
			}, co.requestAccess = function(Vo, cs) {
				if (!gs()) return co;
				if (ys(), !Ha) throw console.error("[Telegram.WebApp] Biometrics is not available on this device."), Error("WebAppBiometricManagerBiometricsNotAvailable");
				if (xo) throw console.error("[Telegram.WebApp] Access is already requested"), Error("WebAppBiometricManagerAccessRequested");
				var Zo = {};
				if (typeof Vo.reason < "u") {
					var us = Ca(Vo.reason);
					if (us.length > 128) throw console.error("[Telegram.WebApp] Biometric reason is too long", us), Error("WebAppBiometricRequestAccessParamInvalid");
					us.length > 0 && (Zo.reason = us)
				}
				return xo = {
					callback: cs
				}, Yi.postEvent("web_app_biometry_request_access", !1, Zo), co
			}, co.authenticate = function(Vo, cs) {
				if (!gs()) return co;
				if (ys(), !Ha) throw console.error("[Telegram.WebApp] Biometrics is not available on this device."), Error("WebAppBiometricManagerBiometricsNotAvailable");
				if (!$a) throw console.error("[Telegram.WebApp] Biometric access was not granted by the user."), Error("WebAppBiometricManagerBiometricAccessNotGranted");
				if (ko) throw console.error("[Telegram.WebApp] Authentication request is already in progress."), Error("WebAppBiometricManagerAuthenticationRequested");
				var Zo = {};
				if (typeof Vo.reason < "u") {
					var us = Ca(Vo.reason);
					if (us.length > 128) throw console.error("[Telegram.WebApp] Biometric reason is too long", us), Error("WebAppBiometricRequestAccessParamInvalid");
					us.length > 0 && (Zo.reason = us)
				}
				return ko = {
					callback: cs
				}, Yi.postEvent("web_app_biometry_request_auth", !1, Zo), co
			}, co.updateBiometricToken = function(Vo, cs) {
				if (!gs()) return co;
				if (Vo = Vo || "", Vo.length > 1024) throw console.error("[Telegram.WebApp] Token is too long", Vo), Error("WebAppBiometricManagerTokenInvalid");
				if (ys(), !Ha) throw console.error("[Telegram.WebApp] Biometrics is not available on this device."), Error("WebAppBiometricManagerBiometricsNotAvailable");
				if (!$a) throw console.error("[Telegram.WebApp] Biometric access was not granted by the user."), Error("WebAppBiometricManagerBiometricAccessNotGranted");
				if ($o) throw console.error("[Telegram.WebApp] Token request is already in progress."), Error("WebAppBiometricManagerTokenUpdateRequested");
				return $o = {
					callback: cs
				}, Yi.postEvent("web_app_biometry_update_token", !1, {
					token: Vo
				}), co
			}, co.openSettings = function() {
				if (!gs()) return co;
				if (ys(), !Ha) throw console.error("[Telegram.WebApp] Biometrics is not available on this device."), Error("WebAppBiometricManagerBiometricsNotAvailable");
				if (!Ya) throw console.error("[Telegram.WebApp] Biometric access was not requested yet."), Error("WebAppBiometricManagerBiometricsAccessNotRequested");
				return $a ? (console.warn("[Telegram.WebApp] Biometric access was granted by the user, no need to go to settings."), co) : (Yi.postEvent("web_app_biometry_open_settings", !1), co)
			}, co
		}(),
		Wo = {};

	function Po(go, Ha) {
		if (Ha.slug && Wo[Ha.slug]) {
			var Fa = Wo[Ha.slug];
			delete Wo[Ha.slug], Fa.callback && Fa.callback(Ha.status), ka("invoiceClosed", {
				url: Fa.url,
				status: Ha.status
			})
		}
	}
	var Ro = !1;

	function Ho(go, Ha) {
		if (Ro) {
			var Fa = Ro;
			Ro = !1;
			var Ya = null;
			typeof Ha.button_id < "u" && (Ya = Ha.button_id), Fa.callback && Fa.callback(Ya), ka("popupClosed", {
				button_id: Ya
			})
		}
	}
	var Oo = !1;

	function No(go, Ha) {
		if (Oo) {
			var Fa = Oo,
				Ya = null;
			typeof Ha.data < "u" && (Ya = Ha.data), Fa.callback && Fa.callback(Ya) && (Oo = !1, Yi.postEvent("web_app_close_scan_qr_popup", !1)), ka("qrTextReceived", {
				data: Ya
			})
		}
	}

	function ps(go, Ha) {
		Oo = !1, ka("scanQrPopupClosed")
	}

	function Ko(go, Ha) {
		if (Ha.req_id && Ja[Ha.req_id]) {
			var Fa = Ja[Ha.req_id];
			delete Ja[Ha.req_id];
			var Ya = null;
			typeof Ha.data < "u" && (Ya = Ha.data), Fa.callback && Fa.callback(Ya), ka("clipboardTextReceived", {
				data: Ya
			})
		}
	}
	var Go = !1;

	function bs(go, Ha) {
		if (Go) {
			var Fa = Go;
			Go = !1, Fa.callback && Fa.callback(Ha.status == "allowed"), ka("writeAccessRequested", {
				status: Ha.status
			})
		}
	}

	function vs(go, Ha) {
		var Fa, Ya, $a = 0,
			no = function() {
				as("getRequestedContact", {}, function(co, mo) {
					mo && mo.length ? (clearTimeout(Ya), go(mo)) : ($a += 50, Fa = setTimeout(no, $a))
				})
			},
			Co = function() {
				clearTimeout(Fa), go("")
			};
		Ya = setTimeout(Co, Ha), no()
	}
	var ls = !1;

	function Es(go, Ha) {
		if (ls) {
			var Fa = ls;
			ls = !1;
			var Ya = Ha.status == "sent",
				$a = {
					status: Ha.status
				};
			Ya ? vs(function(no) {
				if (no && no.length) {
					$a.response = no, $a.responseUnsafe = ue.urlParseQueryString(no);
					for (var Co in $a.responseUnsafe) {
						var co = $a.responseUnsafe[Co];
						try {
							(co.substr(0, 1) == "{" && co.substr(-1) == "}" || co.substr(0, 1) == "[" && co.substr(-1) == "]") && ($a.responseUnsafe[Co] = JSON.parse(co))
						} catch {}
					}
				}
				Fa.callback && Fa.callback(Ya, $a), ka("contactRequested", $a)
			}, 3e3) : (Fa.callback && Fa.callback(Ya, $a), ka("contactRequested", $a))
		}
	}

	function ws(go, Ha) {
		if (Ha.req_id && Ja[Ha.req_id]) {
			var Fa = Ja[Ha.req_id];
			delete Ja[Ha.req_id];
			var Ya = null,
				$a = null;
			typeof Ha.result < "u" && (Ya = Ha.result), typeof Ha.error < "u" && ($a = Ha.error), Fa.callback && Fa.callback($a, Ya)
		}
	}

	function as(go, Ha, Fa) {
		if (!Xa("6.9")) throw console.error("[Telegram.WebApp] Method invokeCustomMethod is not supported in version " + la), Error("WebAppMethodUnsupported");
		var Ya = Ua(16),
			$a = {
				req_id: Ya,
				method: go,
				params: Ha || {}
			};
		Ja[Ya] = {
			callback: Fa
		}, Yi.postEvent("web_app_invoke_custom_method", !1, $a)
	}
	window.Telegram || (window.Telegram = {}), Object.defineProperty(na, "initData", {
		get: function() {
			return ra
		},
		enumerable: !0
	}), Object.defineProperty(na, "initDataUnsafe", {
		get: function() {
			return ia
		},
		enumerable: !0
	}), Object.defineProperty(na, "version", {
		get: function() {
			return la
		},
		enumerable: !0
	}), Object.defineProperty(na, "platform", {
		get: function() {
			return sa
		},
		enumerable: !0
	}), Object.defineProperty(na, "colorScheme", {
		get: function() {
			return oa
		},
		enumerable: !0
	}), Object.defineProperty(na, "themeParams", {
		get: function() {
			return aa
		},
		enumerable: !0
	}), Object.defineProperty(na, "isExpanded", {
		get: function() {
			return fa
		},
		enumerable: !0
	}), Object.defineProperty(na, "viewportHeight", {
		get: function() {
			return (xa === !1 ? window.innerHeight : xa) - Ao
		},
		enumerable: !0
	}), Object.defineProperty(na, "viewportStableHeight", {
		get: function() {
			return (ma === !1 ? window.innerHeight : ma) - Ao
		},
		enumerable: !0
	}), Object.defineProperty(na, "isClosingConfirmationEnabled", {
		set: function(go) {
			Ma(go)
		},
		get: function() {
			return wa
		},
		enumerable: !0
	}), Object.defineProperty(na, "isVerticalSwipesEnabled", {
		set: function(go) {
			Ra(go)
		},
		get: function() {
			return Aa
		},
		enumerable: !0
	}), Object.defineProperty(na, "headerColor", {
		set: function(go) {
			Ba(go)
		},
		get: function() {
			return ya()
		},
		enumerable: !0
	}), Object.defineProperty(na, "backgroundColor", {
		set: function(go) {
			za(go)
		},
		get: function() {
			return Na()
		},
		enumerable: !0
	}), Object.defineProperty(na, "bottomBarColor", {
		set: function(go) {
			Ka(go)
		},
		get: function() {
			return qa()
		},
		enumerable: !0
	}), Object.defineProperty(na, "BackButton", {
		value: ho,
		enumerable: !0
	}), Object.defineProperty(na, "MainButton", {
		value: Oa,
		enumerable: !0
	}), Object.defineProperty(na, "SecondaryButton", {
		value: Da,
		enumerable: !0
	}), Object.defineProperty(na, "SettingsButton", {
		value: Qa,
		enumerable: !0
	}), Object.defineProperty(na, "HapticFeedback", {
		value: uo,
		enumerable: !0
	}), Object.defineProperty(na, "CloudStorage", {
		value: bo,
		enumerable: !0
	}), Object.defineProperty(na, "BiometricManager", {
		value: So,
		enumerable: !0
	}), na.setHeaderColor = function(go) {
		na.headerColor = go
	}, na.setBackgroundColor = function(go) {
		na.backgroundColor = go
	}, na.setBottomBarColor = function(go) {
		na.bottomBarColor = go
	}, na.enableClosingConfirmation = function() {
		na.isClosingConfirmationEnabled = !0
	}, na.disableClosingConfirmation = function() {
		na.isClosingConfirmationEnabled = !1
	}, na.enableVerticalSwipes = function() {
		na.isVerticalSwipesEnabled = !0
	}, na.disableVerticalSwipes = function() {
		na.isVerticalSwipesEnabled = !1
	}, na.isVersionAtLeast = function(go) {
		return Xa(go)
	}, na.onEvent = function(go, Ha) {
		Pa(go, Ha)
	}, na.offEvent = function(go, Ha) {
		ja(go, Ha)
	}, na.sendData = function(go) {
		if (!go || !go.length) throw console.error("[Telegram.WebApp] Data is required", go), Error("WebAppDataInvalid");
		if (to(go) > 4096) throw console.error("[Telegram.WebApp] Data is too long", go), Error("WebAppDataInvalid");
		Yi.postEvent("web_app_data_send", !1, {
			data: go
		})
	}, na.switchInlineQuery = function(go, Ha) {
		if (!Xa("6.6")) throw console.error("[Telegram.WebApp] Method switchInlineQuery is not supported in version " + la), Error("WebAppMethodUnsupported");
		if (!ea.tgWebAppBotInline) throw console.error("[Telegram.WebApp] Inline mode is disabled for this bot. Read more about inline mode: https://core.telegram.org/bots/inline"), Error("WebAppInlineModeDisabled");
		if (go = go || "", go.length > 256) throw console.error("[Telegram.WebApp] Inline query is too long", go), Error("WebAppInlineQueryInvalid");
		var Fa = [];
		if (Ha) {
			if (!Array.isArray(Ha)) throw console.error("[Telegram.WebApp] Choose chat types should be an array", Ha), Error("WebAppInlineChooseChatTypesInvalid");
			for (var Ya = {
					users: 1,
					bots: 1,
					groups: 1,
					channels: 1
				}, $a = 0; $a < Ha.length; $a++) {
				var no = Ha[$a];
				if (!Ya[no]) throw console.error("[Telegram.WebApp] Choose chat type is invalid", no), Error("WebAppInlineChooseChatTypeInvalid");
				Ya[no] != 2 && (Ya[no] = 2, Fa.push(no))
			}
		}
		Yi.postEvent("web_app_switch_inline_query", !1, {
			query: go,
			chat_types: Fa
		})
	}, na.openLink = function(Ya, Ha) {
		var Fa = document.createElement("A");
		if (Fa.href = Ya, Fa.protocol != "http:" && Fa.protocol != "https:") throw console.error("[Telegram.WebApp] Url protocol is not supported", Ya), Error("WebAppTgUrlInvalid");
		var Ya = Fa.href;
		if (Ha = Ha || {}, Xa("6.1")) {
			var $a = {
				url: Ya
			};
			Xa("6.4") && Ha.try_instant_view && ($a.try_instant_view = !0), Xa("7.6") && Ha.try_browser && ($a.try_browser = Ha.try_browser), Yi.postEvent("web_app_open_link", !1, $a)
		} else window.open(Ya, "_blank")
	}, na.openTelegramLink = function(go) {
		var Ha = document.createElement("A");
		if (Ha.href = go, Ha.protocol != "http:" && Ha.protocol != "https:") throw console.error("[Telegram.WebApp] Url protocol is not supported", go), Error("WebAppTgUrlInvalid");
		if (Ha.hostname != "t.me") throw console.error("[Telegram.WebApp] Url host is not supported", go), Error("WebAppTgUrlInvalid");
		var Fa = Ha.pathname + Ha.search;
		ta || Xa("6.1") ? Yi.postEvent("web_app_open_tg_link", !1, {
			path_full: Fa
		}) : location.href = "https://t.me" + Fa
	}, na.openInvoice = function(go, Ha) {
		var Fa = document.createElement("A"),
			Ya, $a;
		if (Fa.href = go, Fa.protocol != "http:" && Fa.protocol != "https:" || Fa.hostname != "t.me" || !(Ya = Fa.pathname.match(/^\/(\$|invoice\/)([A-Za-z0-9\-_=]+)$/)) || !($a = Ya[2])) throw console.error("[Telegram.WebApp] Invoice url is invalid", go), Error("WebAppInvoiceUrlInvalid");
		if (!Xa("6.1")) throw console.error("[Telegram.WebApp] Method openInvoice is not supported in version " + la), Error("WebAppMethodUnsupported");
		if (Wo[$a]) throw console.error("[Telegram.WebApp] Invoice is already opened"), Error("WebAppInvoiceOpened");
		Wo[$a] = {
			url: go,
			callback: Ha
		}, Yi.postEvent("web_app_open_invoice", !1, {
			slug: $a
		})
	}, na.showPopup = function(go, Ha) {
		if (!Xa("6.2")) throw console.error("[Telegram.WebApp] Method showPopup is not supported in version " + la), Error("WebAppMethodUnsupported");
		if (Ro) throw console.error("[Telegram.WebApp] Popup is already opened"), Error("WebAppPopupOpened");
		var Fa = "",
			Ya = "",
			$a = [],
			no = {};
		if (typeof go.title < "u") {
			if (Fa = Ca(go.title), Fa.length > 64) throw console.error("[Telegram.WebApp] Popup title is too long", Fa), Error("WebAppPopupParamInvalid");
			Fa.length > 0 && (no.title = Fa)
		}
		if (typeof go.message < "u" && (Ya = Ca(go.message)), !Ya.length) throw console.error("[Telegram.WebApp] Popup message is required", go.message), Error("WebAppPopupParamInvalid");
		if (Ya.length > 256) throw console.error("[Telegram.WebApp] Popup message is too long", Ya), Error("WebAppPopupParamInvalid");
		if (no.message = Ya, typeof go.buttons < "u") {
			if (!Array.isArray(go.buttons)) throw console.error("[Telegram.WebApp] Popup buttons should be an array", go.buttons), Error("WebAppPopupParamInvalid");
			for (var Co = 0; Co < go.buttons.length; Co++) {
				var co = go.buttons[Co],
					mo = {},
					xo = "";
				if (typeof co.id < "u" && (xo = co.id.toString(), xo.length > 64)) throw console.error("[Telegram.WebApp] Popup button id is too long", xo), Error("WebAppPopupParamInvalid");
				mo.id = xo;
				var ko = co.type;
				if (typeof ko > "u" && (ko = "default"), mo.type = ko, !(ko == "ok" || ko == "close" || ko == "cancel"))
					if (ko == "default" || ko == "destructive") {
						var $o = "";
						if (typeof co.text < "u" && ($o = Ca(co.text)), !$o.length) throw console.error("[Telegram.WebApp] Popup button text is required for type " + ko, co.text), Error("WebAppPopupParamInvalid");
						if ($o.length > 64) throw console.error("[Telegram.WebApp] Popup button text is too long", $o), Error("WebAppPopupParamInvalid");
						mo.text = $o
					} else throw console.error("[Telegram.WebApp] Popup button type is invalid", ko), Error("WebAppPopupParamInvalid");
				$a.push(mo)
			}
		} else $a.push({
			id: "",
			type: "close"
		});
		if ($a.length < 1) throw console.error("[Telegram.WebApp] Popup should have at least one button"), Error("WebAppPopupParamInvalid");
		if ($a.length > 3) throw console.error("[Telegram.WebApp] Popup should not have more than 3 buttons"), Error("WebAppPopupParamInvalid");
		no.buttons = $a, Ro = {
			callback: Ha
		}, Yi.postEvent("web_app_open_popup", !1, no)
	}, na.showAlert = function(go, Ha) {
		na.showPopup({
			message: go
		}, Ha ? function() {
			Ha()
		} : null)
	}, na.showConfirm = function(go, Ha) {
		na.showPopup({
			message: go,
			buttons: [{
				type: "ok",
				id: "ok"
			}, {
				type: "cancel"
			}]
		}, Ha ? function(Fa) {
			Ha(Fa == "ok")
		} : null)
	}, na.showScanQrPopup = function(go, Ha) {
		if (!Xa("6.4")) throw console.error("[Telegram.WebApp] Method showScanQrPopup is not supported in version " + la), Error("WebAppMethodUnsupported");
		if (Oo) throw console.error("[Telegram.WebApp] Popup is already opened"), Error("WebAppScanQrPopupOpened");
		var Fa = "",
			Ya = {};
		if (typeof go.text < "u") {
			if (Fa = Ca(go.text), Fa.length > 64) throw console.error("[Telegram.WebApp] Scan QR popup text is too long", Fa), Error("WebAppScanQrPopupParamInvalid");
			Fa.length > 0 && (Ya.text = Fa)
		}
		Oo = {
			callback: Ha
		}, Yi.postEvent("web_app_open_scan_qr_popup", !1, Ya)
	}, na.closeScanQrPopup = function() {
		if (!Xa("6.4")) throw console.error("[Telegram.WebApp] Method closeScanQrPopup is not supported in version " + la), Error("WebAppMethodUnsupported");
		Oo = !1, Yi.postEvent("web_app_close_scan_qr_popup", !1)
	}, na.readTextFromClipboard = function(go) {
		if (!Xa("6.4")) throw console.error("[Telegram.WebApp] Method readTextFromClipboard is not supported in version " + la), Error("WebAppMethodUnsupported");
		var Ha = Ua(16),
			Fa = {
				req_id: Ha
			};
		Ja[Ha] = {
			callback: go
		}, Yi.postEvent("web_app_read_text_from_clipboard", !1, Fa)
	}, na.requestWriteAccess = function(go) {
		if (!Xa("6.9")) throw console.error("[Telegram.WebApp] Method requestWriteAccess is not supported in version " + la), Error("WebAppMethodUnsupported");
		if (Go) throw console.error("[Telegram.WebApp] Write access is already requested"), Error("WebAppWriteAccessRequested");
		Go = {
			callback: go
		}, Yi.postEvent("web_app_request_write_access")
	}, na.requestContact = function(go) {
		if (!Xa("6.9")) throw console.error("[Telegram.WebApp] Method requestContact is not supported in version " + la), Error("WebAppMethodUnsupported");
		if (ls) throw console.error("[Telegram.WebApp] Contact is already requested"), Error("WebAppContactRequested");
		ls = {
			callback: go
		}, Yi.postEvent("web_app_request_phone")
	}, na.shareToStory = function(go, Ha) {
		if (Ha = Ha || {}, !Xa("7.8")) throw console.error("[Telegram.WebApp] Method shareToStory is not supported in version " + la), Error("WebAppMethodUnsupported");
		var Fa = document.createElement("A");
		if (Fa.href = go, Fa.protocol != "http:" && Fa.protocol != "https:") throw console.error("[Telegram.WebApp] Media url protocol is not supported", url), Error("WebAppMediaUrlInvalid");
		var Ya = {};
		if (Ya.media_url = Fa.href, typeof Ha.text < "u") {
			var $a = Ca(Ha.text);
			if ($a.length > 2048) throw console.error("[Telegram.WebApp] Text is too long", $a), Error("WebAppShareToStoryParamInvalid");
			$a.length > 0 && (Ya.text = $a)
		}
		if (typeof Ha.widget_link < "u") {
			if (Ha.widget_link = Ha.widget_link || {}, Fa.href = Ha.widget_link.url, Fa.protocol != "http:" && Fa.protocol != "https:") throw console.error("[Telegram.WebApp] Link protocol is not supported", url), Error("WebAppShareToStoryParamInvalid");
			var no = {
				url: Fa.href
			};
			if (typeof Ha.widget_link.name < "u") {
				var Co = Ca(Ha.widget_link.name);
				if (Co.length > 48) throw console.error("[Telegram.WebApp] Link name is too long", Co), Error("WebAppShareToStoryParamInvalid");
				Co.length > 0 && (no.name = Co)
			}
			Ya.widget_link = no
		}
		Yi.postEvent("web_app_share_to_story", !1, Ya)
	}, na.invokeCustomMethod = function(go, Ha, Fa) {
		as(go, Ha, Fa)
	}, na.ready = function() {
		Yi.postEvent("web_app_ready")
	}, na.expand = function() {
		Yi.postEvent("web_app_expand")
	}, na.close = function(go) {
		go = go || {};
		var Ha = {};
		Xa("7.6") && go.return_back && (Ha.return_back = !0), Yi.postEvent("web_app_close", !1, Ha)
	}, window.Telegram.WebApp = na, ao(), Va(), yo(), ga(), ea.tgWebAppShowSettings && Qa.show(), window.addEventListener("resize", Ea), ta && document.addEventListener("click", Sa), Yi.onEvent("theme_changed", pa), Yi.onEvent("viewport_changed", ba), Yi.onEvent("invoice_closed", Po), Yi.onEvent("popup_closed", Ho), Yi.onEvent("qr_text_received", No), Yi.onEvent("scan_qr_popup_closed", ps), Yi.onEvent("clipboard_text_received", Ko), Yi.onEvent("write_access_requested", bs), Yi.onEvent("phone_requested", Es), Yi.onEvent("custom_method_invoked", ws), Yi.postEvent("web_app_request_theme"), Yi.postEvent("web_app_request_viewport")
})();
var __defProp = Object.defineProperty,
	__decorateClass = (ue, Yi, ea, ta) => {
		for (var na = void 0, ra = ue.length - 1, ia; ra >= 0; ra--)(ia = ue[ra]) && (na = ia(Yi, ea, na) || na);
		return na && __defProp(Yi, ea, na), na
	};
class TelegramUser {
	constructor() {
		Io(this, "id");
		Io(this, "first_name");
		Io(this, "last_name");
		Io(this, "username");
		Io(this, "language_code");
		Io(this, "is_premium");
		Io(this, "added_to_attachment_menu");
		Io(this, "allows_write_to_pm")
	}
}
__decorateClass([Expose(), IsInt()], TelegramUser.prototype, "id");
__decorateClass([Expose(), IsString()], TelegramUser.prototype, "first_name");
__decorateClass([Expose(), IsOptional(), IsString()], TelegramUser.prototype, "last_name");
__decorateClass([Expose(), IsOptional(), IsString()], TelegramUser.prototype, "username");
__decorateClass([Expose(), IsOptional(), IsString()], TelegramUser.prototype, "language_code");
__decorateClass([Expose(), IsOptional(), IsBoolean()], TelegramUser.prototype, "is_premium");
__decorateClass([Expose(), IsOptional(), IsBoolean()], TelegramUser.prototype, "added_to_attachment_menu");
__decorateClass([Expose(), IsOptional(), IsBoolean()], TelegramUser.prototype, "allows_write_to_pm");
const _1_telegram_aaqfiERAzh = defineNuxtPlugin(async () => {
		var ia;
		let ue, Yi;
		const ea = (ia = window.Telegram) == null ? void 0 : ia.WebApp;
		if (!ea) throw err("Unable to load Telegram WebApp");
		ea.dataUnsafe = (() => {
			const aa = () => {
				try {
					const oa = sessionStorage.getItem("__telegram__initParams");
					if (!oa) return;
					const la = JSON.parse(oa);
					return typeof la.user != "string" ? void 0 : transform$1(TelegramUser, JSON.parse(la.user))
				} catch {
					return
				}
			};
			if (!ea.initDataUnsafe.user) {
				const oa = aa();
				if (oa) return {
					...ea.initDataUnsafe,
					user: oa
				}
			}
			return ea.initDataUnsafe
		})();
		const ta = (() => {
				if (ea.dataUnsafe.user) return ea.dataUnsafe.user.id.toString();
				const aa = (() => {
					const oa = sessionStorage.getItem("query_id");
					if (!oa) return;
					const sa = new URLSearchParams(oa).get("user");
					if (!sa) return;
					const ca = decodeURIComponent(sa);
					try {
						return JSON.parse(ca).id
					} catch {
						return
					}
				})();
				if (aa) return aa;
				throw err("User id is not defined")
			})(),
			na = "__tgid__";
		ea.storage = (() => {
			const aa = sa => `${ta}${na}${sa}`,
				oa = {
					set: (sa, ca) => localStorage.setItem(aa(sa), ca),
					get: sa => localStorage.getItem(aa(sa)) ?? void 0,
					remove: sa => localStorage.removeItem(aa(sa))
				};
			return {
				local: oa,
				cloud: {
					set: (sa, ca) => new Promise((ua, da) => {
						if (!ea.isVersionAtLeast("6.9") || !ea.CloudStorage) return ua(oa.set(sa, ca));
						ea.CloudStorage.setItem(aa(sa), ca, ha => ha ? da(ha) : ua())
					}),
					get: sa => new Promise((ca, ua) => {
						if (!ea.isVersionAtLeast("6.9") || !ea.CloudStorage) return ca(oa.get(sa));
						ea.CloudStorage.getItem(aa(sa), (da, ha) => da ? ua(da) : ca(ha ?? void 0))
					}),
					remove: sa => new Promise((ca, ua) => {
						if (!ea.isVersionAtLeast("6.9") || !ea.CloudStorage) return ca(oa.remove(sa));
						ea.CloudStorage.removeItem(aa(sa), da => da ? ua(da) : ca())
					})
				}
			}
		})(), ea.initData && ea.initData !== "query_id" && sessionStorage.setItem("query_id", ea.initData), ea.data = (() => {
			if (ea.initData === "query_id") {
				const aa = sessionStorage.getItem("query_id");
				if (aa) return aa
			}
			return ea.initData
		})(), ea.UrlQuery = {
			encode: aa => Object.entries(aa).map(([oa, la]) => `${oa}_${la}`).join("-"),
			decode: aa => aa.split("-").reduce((oa, la) => {
				const [sa, ...ca] = la.split("_");
				return sa && ca && (oa[sa] = ca.join("_")), oa
			}, {})
		}, ea.dataUnsafe.query = (() => {
			const aa = ea.dataUnsafe.start_param;
			return aa ? ea.UrlQuery.decode(aa) : {}
		})(), ea.showAlert = ea.showAlert, ea.shareLink = (aa, oa) => {
			const la = `https://t.me/share/url?url=${aa}&text=${encodeURIComponent(oa)}`;
			ea.openTelegramLink(la)
		}, ea.setColor = (aa = "#000000") => {
			ea.setBackgroundColor && ea.setBackgroundColor(aa), ea.isVersionAtLeast("6.9") && ea.setHeaderColor && ea.setHeaderColor(aa), window.document.documentElement.style.background = aa
		}, ea.popup = (aa, oa, la) => {
			const sa = la.map(ua => ({
					id: uuid(),
					type: ua.type,
					text: ua.label
				})),
				ca = ua => {
					const da = sa.findIndex(pa => pa.id === ua);
					if (da === -1) return;
					const ha = la[da];
					ha.onClick && ha.onClick()
				};
			ea.isVersionAtLeast("6.1") ? ea.showPopup({
				title: aa,
				message: oa,
				buttons: sa
			}, ca) : useApp().internal.showFallbackPopup(aa, oa, la)
		};
		const ra = async () => {
			const aa = localStorage,
				oa = ea.CloudStorage,
				la = {
					ours: ["query_id", "access_token", "refresh_token", "language_code", "__telegram__loader-watched", "pokras-hacked-welcome"],
					sensitive: ["access_token", "refresh_token"]
				};
			la.ours.forEach(da => aa.removeItem(da));
			const sa = da => la.sensitive.some(pa => da.endsWith(pa)) ? da.split(na)[0] !== ta : !1;
			Object.keys(aa).forEach(da => sa(da) && aa.removeItem(da));
			const ca = await new Promise((da, ha) => !ea.isVersionAtLeast("6.9") || !oa ? da([]) : oa.getKeys((pa, va) => pa ? ha(pa) : da(va))),
				ua = async da => await new Promise((ha, pa) => {
					if (!ea.isVersionAtLeast("6.9") || !oa) return ha();
					oa.removeItem(da, va => va ? pa(va) : ha())
				});
			await Promise.all(ca.map(async da => sa(da) && await ua(da)))
		};
		return [ue, Yi] = executeAsync(() => ra()), await ue, Yi(), ea.setColor(), ea.expand(), onNuxtReady(() => ea.ready()), watch(() => useRoute().meta.back, aa => {
			const oa = (() => {
				if (aa !== void 0) {
					if (typeof aa == "function") return aa;
					throw err("backFn should be a function, boolean or undefined")
				}
			})();
			useApp().internal.backFn.value = oa, oa ? (ea.BackButton.onClick(() => oa()), ea.BackButton.show()) : (ea.BackButton.hide(), ea.BackButton.onClick(() => {}))
		}, {
			immediate: !0
		}), {
			provide: {
				webApp: ea
			}
		}
	}),
	asyncInterval = async (ue, Yi, ea) => {
		let ta = 0,
			na, ra = new AbortController;
		const ia = () => {
				clearTimeout(na), na = void 0, ra.abort(), ra = new AbortController
			},
			aa = async () => {
				ia();
				const {
					signal: oa
				} = ra, la = await ue(oa);
				if (oa.aborted) return;
				const sa = (ea == null ? void 0 : ea.retryIf(la)) ?? !1 ? (ta += 1, ((ea == null ? void 0 : ea.retryDelay) ?? 1e3) * (2 ** ta - 1)) : (ta = 0, Yi);
				sa !== 0 && (na = setTimeout(aa, sa))
			};
		return await aa(), {
			destroy: ia,
			forceUpdate: aa
		}
	}, executeUntilOk = async (ue, Yi, ea = 1e3) => await new Promise(ta => {
		(async () => {
			for (;;) {
				const ra = await ue();
				if (Yi(ra)) return ta(ra);
				await awaitMs(ea)
			}
		})()
	}), setInterval$1 = window.setInterval, doRequestAndCalcTransferTime = async ue => {
		const Yi = performance.now();
		return {
			res: await ue(),
			transferTime: Math.round((performance.now() - Yi) / 2)
		}
	}, useBackendTime = () => {
		const ue = useState("$IeCFz7ezNv"),
			Yi = useState("$SzWpIEyJlV"),
			ea = useState("$jmuhGlxyLS"),
			ta = useState("$eBg7K8tnVJ"),
			na = async () => {
				const {
					res: sa,
					transferTime: ca
				} = await doRequestAndCalcTransferTime(() => client.getBackendTime());
				if (sa.err) {
					useLogger().warn("Unable to fetch backend time");
					return
				}
				return sa.data.now + ca
			}, ra = async () => {
				const sa = await na();
				return sa === void 0 ? (ue.value = void 0, !1) : (ue.value = sa - new Date().getTime(), !0)
			}, ia = sa => {
				if (ue.value !== void 0) return sa + ue.value
			}, aa = () => ia(new Date().getTime()), oa = async () => {
				Yi.value = await asyncInterval(ra, 6e4 * 2, {
					retryIf: sa => !sa
				}), ta.value = setInterval$1(() => ea.value = aa(), 100)
			}, la = () => {
				ue.value = void 0, ea.value = void 0, Yi.value && (Yi.value.destroy(), Yi.value = void 0), ta.value && (clearInterval(ta.value), ta.value = void 0)
			};
		return {
			isReady: computed(() => ue.value !== void 0),
			getTimestamp: ia,
			getCurrentTimestamp: aa,
			ms100ticker: computed(() => ea.value),
			_flow: {
				init: oa,
				destroy: la
			},
			_test: {
				getDelta: computed(() => ue.value),
				getBackendTime: na
			}
		}
	};
var COMPONENT_WRAPPER_TAG = (ue => (ue.LINK = "LINK", ue.BUTTON = "BUTTON", ue.SPAN = "SPAN", ue))(COMPONENT_WRAPPER_TAG || {}),
	BUTTON_TYPE = (ue => (ue.PRIMARY = "PRIMARY", ue.SECONDARY = "SECONDARY", ue.TERTIARY = "TERTIARY", ue.GHOST = "GHOST", ue.DROP = "DROP", ue.OUTLINE = "OUTLINE", ue))(BUTTON_TYPE || {}),
	BUTTON_SIZE = (ue => (ue.SMALL = "SMALL", ue.MEDIUM = "MEDIUM", ue.LARGE = "LARGE", ue))(BUTTON_SIZE || {}),
	SPINNER_TYPE = (ue => (ue.LIGHT = "LIGHT", ue.DARK = "DARK", ue))(SPINNER_TYPE || {}),
	INPUT_TYPE = (ue => (ue.TEXT = "TEXT", ue.PASSWORD = "PASSWORD", ue.EMAIL = "EMAIL", ue.AMOUNT = "AMOUNT", ue))(INPUT_TYPE || {}),
	INPUT_SIZE = (ue => (ue.LARGE = "LARGE", ue.COMPACT = "COMPACT", ue))(INPUT_SIZE || {}),
	INPUT_STATUS = (ue => (ue.REGULAR = "REGULAR", ue.SUCCESS = "SUCCESS", ue.ERROR = "ERROR", ue.LOADING = "LOADING", ue))(INPUT_STATUS || {}),
	TOP_ALERT_TYPE = (ue => (ue.NEUTRAL = "NEUTRAL", ue))(TOP_ALERT_TYPE || {}),
	BOTTOM_ALERT_TYPE = (ue => (ue.SUCCESS = "SUCCESS", ue.ERROR = "ERROR", ue))(BOTTOM_ALERT_TYPE || {}),
	FILE_TYPE = (ue => (ue.JPEG = "JPEG", ue.PNG = "PNG", ue))(FILE_TYPE || {});
const TABS_INJECTION_KEY = Symbol("tabsInjectionKey");
var TABS_TYPE = (ue => (ue.INLINE = "INLINE", ue.BUTTON = "BUTTON", ue))(TABS_TYPE || {});
const getMimeType = ue => {
	switch (ue) {
		case "JPEG":
			return "image/jpeg";
		case "PNG":
			return "image/png";
		default:
			throw err("Unknown file type")
	}
};
var FILE_UPLOAD_STATUS = (ue => (ue.UPLOADING = "UPLOADING", ue.SUCCESS = "SUCCESS", ue.ERROR = "ERROR", ue))(FILE_UPLOAD_STATUS || {});
class Timer {
	constructor(Yi, ea) {
		Io(this, "startedAt");
		Io(this, "timeout");
		this.callback = Yi, this.ttl = ea, this.run()
	}
	run() {
		this.startedAt = new Date().getTime(), this.timeout = setTimeout(this.callback, this.ttl)
	}
	pause() {
		this.ttl = this.ttl - (new Date().getTime() - this.startedAt), clearTimeout(this.timeout)
	}
}
const useAlert = () => {
		const ue = useNuxtApp().$webApp,
			Yi = useState(() => 0, "$Yt2eelBfiI"),
			ea = useState(() => [], "$QrMwFdKoWM"),
			ta = useState("$fYSqJ3PoyU"),
			na = (oa, la, sa) => {
				const ca = setTimeout(() => {
					ta.value = void 0, sa == null || sa.onLeave()
				}, 3e3);
				ta.value && clearTimeout(ta.value.timeout), ta.value = {
					message: oa,
					type: la,
					timeout: ca
				}
			},
			ra = () => (Yi.value += 1, Yi.value),
			ia = oa => ea.value = ea.value.filter(la => la.id !== oa),
			aa = (oa, la) => {
				const sa = ra(),
					ca = new Timer(() => ia(sa), 5e3);
				ea.value.push({
					id: sa,
					type: oa,
					message: la,
					timer: ca
				})
			};
		return {
			top: {
				neutral: oa => aa(TOP_ALERT_TYPE.NEUTRAL, oa)
			},
			bottom: {
				success: (oa, la) => {
					na(oa, BOTTOM_ALERT_TYPE.SUCCESS, la), ue.HapticFeedback.notificationOccurred("success")
				},
				error: (oa, la) => {
					na(oa, BOTTOM_ALERT_TYPE.ERROR, la), ue.HapticFeedback.notificationOccurred("error")
				}
			},
			internal: {
				topNotifications: ea,
				bottomNotification: ta
			}
		}
	},
	useStore = () => {
		const ue = async (ta, na) => {
			if (ta.value === void 0) {
				const ra = await na();
				ra.err || (ta.value = ra.data)
			}
			return ta.value
		}, Yi = useState("$ey0YhEm4Oc");
		return {
			getReferralToken: () => ue(Yi, async () => {
				const ta = await client.getFrensUsing();
				return ta.err ? {
					err: !0
				} : {
					err: !1,
					data: ta.data.referralToken
				}
			}),
			referralToken: computed(() => Yi.value)
		}
	},
	useMyTribe = ue => {
		const Yi = useState(() => !1, "$I0OgBew3sj"),
			ea = useState("$7lXzUMJusc"),
			ta = useState("$SkfiIZL7Dn"),
			na = useState("$0eHKJwcj3L"),
			ra = useState("$S8ApTja32g"),
			ia = useState("$D21Br2F2I9"),
			aa = useState("$cByeL48Uu8"),
			oa = useState("$C5xK8TO9Oy"),
			la = computed(() => {
				var Ja;
				return ((Ja = ta.value) == null ? void 0 : Ja.type) === "ok" ? ta.value.tribe : void 0
			}),
			sa = computed(() => aa.value),
			ca = async () => {
				const Ja = await client.getMyTribe(),
					[Ua, xa] = (() => {
						var ma, fa, ga;
						if (!Ja.err) return [{
							type: "ok",
							tribe: Ja.data
						}, !0];
						if (Ja.code) {
							if (Ja.code === 400) return [{
								type: "not_created",
								messages: ua(Ja.message, (fa = (ma = Ja.data) == null ? void 0 : ma.data) == null ? void 0 : fa.chatname),
								reset: ha
							}, !0];
							if (Ja.code === 404) return [{
								type: "not_found",
								canCreateTribe: (ga = Ja.data) == null ? void 0 : ga.canCreateTribe
							}, !0];
							if (Ja.code === 423) return [{
								type: "validating",
								cancel: pa
							}, !0];
							if (Ja.code === 424 || Ja.code >= 500) return [ta.value, !1]
						}
						return [void 0, !1]
					})();
				return ta.value = Ua, xa
			}, ua = (Ja, Ua) => {
				const xa = Ua ? `${Ua} ` : "";
				switch (Ja) {
					case TRIBE_CREATION_ERROR.NOT_ENOUGH_RIGHTS:
						return {
							notify: `Tribe not created because you're not the admin for ${xa}chat`, screen: `You're not the admin for ${Ua??"tribe"}. Use a chat link where you are to create a tribe.`
						};
					case TRIBE_CREATION_ERROR.CHAT_IS_NOT_FOUND:
						return {
							notify: `Tribe not created because chat ${xa}not found`, screen: `Chat ${xa}not found. Check spelling and try again.`
						};
					default:
						return {
							notify: "Tribe not created", screen: "Tribe not created"
						}
				}
			}, da = Ja => {
				useApp().makeConfetti();
				const Ua = Ja.tribeTitle ? `${Ja.tribeTitle} ` : "",
					xa = Ja.reason === "created" ? `You created ${Ua}tribe` : `You joined ${Ua}tribe`;
				useAlert().bottom.success(xa, {
					onLeave: () => {
						setTimeout(() => useAlert().bottom.success("Enjoy farming 10% faster"), 300)
					}
				})
			}, ha = async () => {
				(await client.resetMyTribeError()).err || (ta.value = {
					type: "not_found"
				})
			}, pa = async () => {
				var Ua;
				(await client.resetMyTribeError()).err || await ((Ua = na.value) == null ? void 0 : Ua.forceUpdate())
			}, va = () => {
				var Ja;
				return ((Ja = la.value) == null ? void 0 : Ja.role) === TRIBE_MEMBER_ROLE.OWNER
			}, ba = async Ja => {
				var ma;
				const Ua = va(),
					xa = await client.leaveTribe(Ja);
				return xa.err || (ta.value = {
					type: "not_found"
				}, aa.value = void 0, useAnalytics().tribes.tribeExit({
					type: Ua ? "owner" : "member"
				}), (ma = ia.value) == null || ma.forceUpdate()), xa
			}, Ea = () => {
				ta.value = {
					type: "validating",
					cancel: pa
				}
			}, Sa = async Ja => {
				var fa, ga;
				const Ua = va(),
					xa = (() => {
						let wa = useRoute().query.from;
						return wa = Array.isArray(wa) ? wa[0] : wa, wa && Object.values(ANALYTICS_TRIBE_CREATE_SOURCE).includes(wa) ? wa : ANALYTICS_TRIBE_CREATE_SOURCE.NONE
					})();
				(await client.joinTribe(Ja)).err || (useAnalytics().tribes.tribeJoined({
					type: Ua ? "owner" : "member",
					method: xa,
					name: Ja
				}), da({
					reason: "joined"
				}), await ((fa = na.value) == null ? void 0 : fa.forceUpdate()), await ((ga = oa.value) == null ? void 0 : ga.forceUpdate()))
			}, Ca = async () => {
				const Ja = await client.getTribesLeaderboard();
				return Ja.err ? !1 : (ra.value = Ja.data.items, !0)
			}, ka = async () => {
				if (!ta.value || ta.value.type !== "ok") return !0;
				const Ja = await client.getTribeUsersLeaderboard(ta.value.tribe.chatName);
				if (Ja.err) return !1;
				aa.value = Ja.data
			}, Pa = async () => {
				const Ja = await client.getMyTribeUsers();
				if (Ja.err) return;
				const Ua = useAuth().getters.mustGetUser.value.id;
				return Ja.data.items.filter(xa => xa.id !== Ua)
			};
		watch(ta, (Ja, Ua) => {
			if (Ja && (Ja.type === "ok" && (Ua == null ? void 0 : Ua.type) === "validating" && (da({
					reason: "created",
					tribeTitle: Ja.tribe.title
				}), ue != null && ue.onCreated && ue.onCreated()), Ja.type === "not_created" && (Ua === void 0 || Ua.type === "validating" || Ua.type === "not_found"))) {
				if (ue != null && ue.onCreateFail) {
					ue.onCreateFail(Ja.messages, Ja.reset);
					return
				}
				useAlert().bottom.error(Ja.messages.notify), Ja.reset()
			}
		});
		const ja = async () => {
			na.value = await asyncInterval(ca, 6e4, {
				retryIf: Ja => !Ja
			}), oa.value = await asyncInterval(ka, 6e4, {
				retryIf: Ja => !Ja
			}), useStore().getReferralToken(), ia.value = await asyncInterval(Ca, 0, {
				retryIf: Ja => !Ja,
				retryDelay: 5e3
			})
		}, Za = async () => {
			if (ea.value) return;
			const Ja = await client.getTribeValidationBot();
			if (Ja.err) throw err("Failed to get validation bot");
			ea.value = Ja.data
		};
		return {
			_lifetime: {
				isInitialized: Yi,
				init: ja,
				destroy: () => {
					na.value && (na.value.destroy(), na.value = void 0), ia.value && (ia.value.destroy(), ia.value = void 0), oa.value && (oa.value.destroy(), oa.value = void 0), ta.value = void 0, ea.value = void 0, ra.value = void 0
				},
				pages: ["index", "tribe"],
				pagesPattern: ["tribe-"]
			},
			myTribeRes: computed(() => ta.value),
			tribeValidationBot: computed(() => ea.value),
			tribeOrUndefined: la,
			usersLeaderboardOrUndefined: sa,
			canCreateTribe: computed(() => {
				var Ja;
				return ((Ja = ta.value) == null ? void 0 : Ja.type) === "not_found" && ta.value.canCreateTribe === !0
			}),
			leaderboard: computed(() => ra.value),
			getBot: Za,
			leaveMyTribe: ba,
			joinTribe: Sa,
			setMyTribeValidation: Ea,
			getMyTribeUsers: Pa
		}
	},
	useTribeSearch = () => {
		const ue = useState(() => !1, "$IjQqayHdaU"),
			Yi = useState("$eMtfdam84O"),
			ea = useState("$OpLbX6yuro"),
			ta = useState(() => "", "$0OXEdeuZgl"),
			na = useState(() => !1, "$MeFSJCtwem"),
			ra = useState("$7QdhMIv5pU"),
			ia = async () => {
				const ha = await client.getTribesSearch();
				return ha.err ? !1 : (Yi.value = ha.data.items, !0)
			}, aa = applyNewest(async ha => (na.value = !0, await client.getTribesSearch(ha)), ha => {
				na.value = !1, ra.value = ha.err ? void 0 : ha.data.items
			}), oa = computed(() => ta.value ? ANALYTICS_TRIBE_CREATE_SOURCE.DIRECT_SEARCH : ANALYTICS_TRIBE_CREATE_SOURCE.RANDOM_LIST), la = ha => {
				ha !== ta.value && (ta.value = ha, ta.value === "" ? (na.value = !1, ra.value = void 0) : aa(ta.value))
			}, sa = ha => [...Yi.value ?? [], ...ra.value ?? []].find(va => {
				if (ha.id) return va.id === ha.id;
				if (ha.chatName) return va.chatName === ha.chatName;
				throw err("getTribeFromCache: id or chatName must be provided")
			}), ca = async ha => {
				const pa = sa({
					chatName: ha
				});
				return pa ? {
					err: !1,
					data: pa
				} : await client.getTribeByChatName(ha)
			};
		return {
			_lifetime: {
				isInitialized: ue,
				init: async () => {
					ea.value = await asyncInterval(ia, 0, {
						retryIf: ha => !ha
					})
				},
				destroy: () => {
					ea.value && (ea.value.destroy(), ea.value = void 0), Yi.value = void 0, ta.value = "", na.value = !1, ra.value = void 0
				},
				pages: [],
				pagesPattern: ["tribe-join"]
			},
			searchLine: computed(() => ta.value),
			list: computed(() => ta.value === "" ? Yi.value : ra.value),
			search: la,
			isSearching: computed(() => na.value),
			joinTribeSource: oa,
			getTribeByChatName: ca
		}
	},
	useTribe = () => {
		const ue = useState(() => !1, "$N8FRQyfXbs"),
			Yi = useMyTribe(),
			ea = useTribeSearch(),
			ta = useState("$bYqsJSsYde"),
			na = computed(() => {
				const ca = useRoute().params.slug;
				return ca === void 0 ? "" : Array.isArray(ca) ? ca[0] : ca
			}),
			ra = computed(() => na.value === ""),
			ia = computed(() => {
				var ca;
				return ra.value ? Yi.tribeOrUndefined.value : (ca = ta.value) == null ? void 0 : ca.tribe
			}),
			aa = computed(() => {
				var ca;
				return ra.value ? Yi.usersLeaderboardOrUndefined.value : (ca = ta.value) == null ? void 0 : ca.usersLeaderboard
			}),
			oa = computed(() => ia.value instanceof TribeExtended ? ia.value : void 0);
		return {
			_lifetime: {
				isInitialized: ue,
				init: async () => {
					var da;
					if (na.value === ((da = Yi.tribeOrUndefined.value) == null ? void 0 : da.chatName)) {
						useRouter().replace({
							name: "tribe-slug",
							params: {
								slug: ""
							}
						});
						return
					}
					if (ra.value) return;
					const ca = await ea.getTribeByChatName(na.value);
					if (ca.err) {
						ca.code === 404 ? useAlert().bottom.error("Tribe not found") : useAlert().bottom.error("An error occurred"), useRouter().replace({
							name: "tribe-join"
						});
						return
					}
					const ua = await client.getTribeUsersLeaderboard(ca.data.chatName);
					if (ua.err) {
						useAlert().bottom.error("An error occurred");
						return
					}
					ta.value = {
						tribe: ca.data,
						usersLeaderboard: ua.data
					}
				},
				destroy: () => {
					ta.value = void 0
				},
				pages: ["tribe", "tribe-slug", "tribe-slug-leaderboard"],
				pagesPattern: []
			},
			tribe: ia,
			tribeExtended: oa,
			usersLeaderboard: aa,
			isMyTribe: ra,
			chatName: na
		}
	};
var FARMING_STATUS = (ue => (ue.READY = "READY", ue.ACTIVE = "ACTIVE", ue.DONE = "DONE", ue))(FARMING_STATUS || {});
const useBalance = () => {
		const ue = useBackendTime(),
			Yi = useState("$0olocQZxou"),
			ea = useState("$8HSoWIdCQh"),
			ta = useState("$I98rAojBPe"),
			na = async () => {
				const {
					res: ca,
					transferTime: ua
				} = await doRequestAndCalcTransferTime(() => client.getUserBalance());
				return ca.err ? (Yi.value = void 0, useLogger().warn("Unable to fetch balance with farming"), !1) : (ca.data.timestamp += ua, Yi.value = ca.data, !0)
			}, ra = async () => {
				const ca = await client.startFarming();
				if (ca.err) throw err("Unable to start farming");
				Yi.value && (Yi.value.farming = ca.data)
			}, ia = async () => {
				const {
					res: ca,
					transferTime: ua
				} = await doRequestAndCalcTransferTime(() => client.claimFarming());
				if (ca.err) throw err("Unable to claim farming");
				ca.data.timestamp += ua, Yi.value = ca.data, ta.value = setTimeout(() => {
					var da;
					return (da = ea.value) == null ? void 0 : da.forceUpdate()
				}, 1e4)
			}, aa = (ca, ua) => ({
				decimal: ca,
				formatted: formatBp(ca, ua)
			}), oa = computed(() => {
				var ba;
				const ca = ue.ms100ticker.value,
					ua = (ba = Yi.value) == null ? void 0 : ba.timestamp,
					da = Yi.value;
				if (ca === void 0 || ua === void 0 || da === void 0) return;
				const ha = da.farming;
				if (ha === void 0 || ca < ha.startTime) return {
					status: "READY"
				};
				if (ca > ha.endTime) {
					const Ea = ha.earningsRate.mul(ha.endTime - ha.startTime).div(1e3);
					return {
						status: "DONE",
						balance: aa(Ea, 3)
					}
				}
				const pa = (() => {
						const Ea = Math.max(ha.startTime, ua),
							Sa = Math.min(ha.endTime, ca),
							Ca = Math.max(0, Sa - Ea);
						if (Ca === 0) return ha.balance;
						const ka = ha.earningsRate.mul(Ca).div(1e3);
						return ha.balance.add(ka)
					})(),
					va = (ca - ha.startTime) / (ha.endTime - ha.startTime);
				return {
					status: "ACTIVE",
					balance: aa(pa, 3),
					progress: (va * 100).toFixed(2),
					timeLabel: getHHMmFromMs(ha.endTime - ca, "letters")
				}
			}), la = async () => {
				ea.value = await asyncInterval(na, 3e4, {
					retryIf: ca => !ca
				})
			}, sa = () => {
				Yi.value = void 0, ea.value && (ea.value.destroy(), ea.value = void 0), ta.value && (clearTimeout(ta.value), ta.value = void 0)
			};
		return {
			balanceVary: computed(() => Yi.value && aa(Yi.value.availableBalance)),
			activeFarming: oa,
			isFastFarmingEnabled: computed(() => {
				var ca;
				return ((ca = Yi.value) == null ? void 0 : ca.isFastFarmingEnabled) ?? !1
			}),
			playPasses: computed(() => {
				var ca;
				return (ca = Yi.value) == null ? void 0 : ca.playPasses
			}),
			updateBalance: () => {
				var ca;
				return (ca = ea.value) == null ? void 0 : ca.forceUpdate()
			},
			startFarming: ra,
			claimFarming: ia,
			_flow: {
				init: la,
				destroy: sa
			}
		}
	},
	useWallet = () => {
		const ue = useState(() => !1, "$G1gwMjyXrj"),
			Yi = useState("$obR1iGChVV"),
			ea = {
				status: "loading"
			},
			ta = useState(() => ea, "$qaEH2IhqYN"),
			na = useState("$7tH57fRtDp"),
			ra = useState("$1gLamTzAbz"),
			ia = useState("$uo1uKDJH8d"),
			aa = () => {
				var ba;
				const va = localStorage.getItem("ton-connect-storage_bridge-connection");
				if (!va) return !1;
				try {
					return !!((ba = JSON.parse(va)) != null && ba.connectionDetails)
				} catch {
					return !1
				}
			},
			oa = async () => {
				var Ea, Sa;
				const va = ((Ea = ra.value) == null ? void 0 : Ea.forceUpdate) ?? ca,
					ba = ((Sa = ia.value) == null ? void 0 : Sa.forceUpdate) ?? ua;
				await Promise.all([va(), ba()])
			}, la = (va, ba) => va.err ? va.code === 404 ? aa() ? {
				status: "must_reconnect"
			} : {
				status: "not_found"
			} : void 0 : {
				status: "connected",
				address: va.data.address,
				balanceStatus: va.data.status,
				balance: ba
			}, sa = async () => {
				var Ea;
				const va = await client.getConnectedWallet(),
					ba = la(va);
				if (ba) return {
					wallet: ba,
					isAvailable: !!((Ea = va.data) != null && Ea.isAvailable)
				}
			}, ca = async () => {
				const va = await client.getWalletBalance(),
					ba = la(va, va.err ? void 0 : va.data);
				return ba ? (ta.value = ba, !0) : !1
			}, ua = async () => {
				const va = await client.getWalletPointsBalance();
				return va.err ? !1 : (na.value = va.data, !0)
			}, da = async () => {
				const va = await client.isInDogsCohort();
				!va.err && va.data.eligible ? Yi.value = "dogs_drop" : Yi.value = "default"
			};
		return {
			_flow: {
				init: async () => {
					const va = mustGet(await executeUntilOk(sa, Ea => Ea !== void 0), "Initial wallet");
					if (ue.value = va.isAvailable, ta.value = va.wallet, !ue.value) return;
					ta.value.status === "connected" && ta.value.balanceStatus !== WALLET_BALANCE_STATUS.PENDING && await executeUntilOk(ca, Ea => Ea);
					const ba = 3e4;
					setTimeout(async () => {
						ra.value = await asyncInterval(ca, ba, {
							retryIf: Ea => !Ea
						})
					}, ba), ia.value = await asyncInterval(ua, ba, {
						retryIf: Ea => !Ea
					}), da()
				},
				destroy: () => {
					ra.value && (ra.value.destroy(), ra.value = void 0), ia.value && (ia.value.destroy(), ia.value = void 0), ta.value = ea, na.value = void 0, ue.value = !1
				}
			},
			wallet: computed(() => ta.value),
			points: computed(() => na.value),
			update: oa,
			isAvailable: computed(() => ue.value),
			walletNotification: readonly(Yi)
		}
	},
	useDailyReward = () => {
		const ue = useState("$CMswW0KcmJ"),
			Yi = async () => {
				const na = await client.getDailyReward();
				return na.err ? na.code === 404 : (ue.value = na.data, !0)
			}, ea = async () => {
				await executeUntilOk(Yi, na => na, 1e4), await awaitMs(1e3 - useLogger().getMsFromStart()), ue.value !== void 0 && useRoute().name !== "welcome" && useRoute().name !== "game" && useRouter().push({
					name: "daily-reward"
				})
			}, ta = () => {
				ue.value = void 0
			};
		return {
			reward: computed(() => ue.value),
			_flow: {
				init: ea,
				destroy: ta
			}
		}
	},
	_2_composables_edlohPLF2m = defineNuxtPlugin(async () => {
		let ue, Yi;
		useApp()._flow.init(), useLocale()._flow.init(), useFeatures()._flow.init(), useAnalytics()._flow.init(), [ue, Yi] = executeAsync(() => useAuth()._flow.init()), await ue, Yi(), useBackendTime()._flow.init();
		const ea = [useMyTribe()._lifetime, useTribeSearch()._lifetime, useTribe()._lifetime],
			ta = () => {
				useBalance()._flow.init(), useWallet()._flow.init(), useDailyReward()._flow.init()
			},
			na = () => {
				useBalance()._flow.destroy(), useWallet()._flow.destroy(), useDailyReward()._flow.destroy()
			};
		watch(() => useAuth().getters.getUser.value, ra => ra ? ta() : na(), {
			immediate: !0
		}), watch(() => [useRoute().name, useAuth().getters.getUser.value], ([ra, ia]) => {
			ea.forEach(aa => {
				if (typeof ra != "string") return;
				const oa = ia && (aa.pages.includes(ra) || aa.pagesPattern.some(la => ra.startsWith(la)));
				oa && !aa.isInitialized.value && (aa.init(), aa.isInitialized.value = !0), !oa && aa.isInitialized.value && (aa.destroy(), aa.isInitialized.value = !1)
			})
		}, {
			immediate: !0
		}), watch(() => [useRoute().meta.key, useRoute().name], () => nextTick(() => window.document.body.scrollTop = 0)), onNuxtReady(() => {
			const ra = ["tasks", "frens", "wallet"],
				ia = useNuxtApp().$webApp.dataUnsafe.query.to;
			ia && ra.includes(ia) && useRouter().push({
				name: ia
			});
			const aa = useNuxtApp().$webApp.dataUnsafe.query.tribe;
			aa && useRouter().push({
				name: "tribe-slug",
				params: {
					slug: aa
				},
				query: {
					from: ANALYTICS_TRIBE_CREATE_SOURCE.REFERRAL
				}
			})
		})
	}),
	plugins = [revive_payload_client_4sVQNw7RlN, unhead_KgADcZ0jPj, plugin, payload_client_yVLowv6hDl, navigation_repaint_client_bs2bWDGRIE, check_outdated_build_client_8vK7RkfGxZ, chunk_reload_client_UciE0i6zes, components_plugin_KR1HBZs4kY, prefetch_client_5tzzN0oIVL, switch_locale_path_ssr_5csfIgkrBP, i18n_sq1MuCrqbC, plugin_client_UYiXMU8ZyN, _0_init_OCK4y3SbNS, _1_telegram_aaqfiERAzh, _2_composables_edlohPLF2m],
	RouteProvider = defineComponent({
		props: {
			vnode: {
				type: Object,
				required: !0
			},
			route: {
				type: Object,
				required: !0
			},
			vnodeRef: Object,
			renderKey: String,
			trackRootNodes: Boolean
		},
		setup(ue) {
			const Yi = ue.renderKey,
				ea = ue.route,
				ta = {};
			for (const na in ue.route) Object.defineProperty(ta, na, {
				get: () => Yi === ue.renderKey ? ue.route[na] : ea[na],
				enumerable: !0
			});
			return provide(PageRouteSymbol, shallowReactive(ta)), () => h$2(ue.vnode, {
				ref: ue.vnodeRef
			})
		}
	}),
	__nuxt_component_0 = defineComponent({
		name: "NuxtPage",
		inheritAttrs: !1,
		props: {
			name: {
				type: String
			},
			transition: {
				type: [Boolean, Object],
				default: void 0
			},
			keepalive: {
				type: [Boolean, Object],
				default: void 0
			},
			route: {
				type: Object
			},
			pageKey: {
				type: [Function, String],
				default: null
			}
		},
		setup(ue, {
			attrs: Yi,
			slots: ea,
			expose: ta
		}) {
			const na = useNuxtApp(),
				ra = ref$1(),
				ia = inject(PageRouteSymbol, null);
			let aa;
			ta({
				pageRef: ra
			});
			const oa = inject(LayoutMetaSymbol, null);
			let la;
			const sa = na.deferHydration();
			if (na.isHydrating) {
				const ca = na.hooks.hookOnce("app:error", sa);
				useRouter().beforeEach(ca)
			}
			return ue.pageKey && watch(() => ue.pageKey, (ca, ua) => {
				ca !== ua && na.callHook("page:loading:start")
			}), () => h$2(RouterView, {
				name: ue.name,
				route: ue.route,
				...Yi
			}, {
				default: ca => {
					const ua = haveParentRoutesRendered(ia, ca.route, ca.Component),
						da = ia && ia.matched.length === ca.route.matched.length;
					if (!ca.Component) {
						if (la && !da) return la;
						sa();
						return
					}
					if (la && oa && !oa.isCurrent(ca.route)) return la;
					if (ua && ia && (!oa || oa != null && oa.isCurrent(ia))) return da ? la : null;
					const ha = generateRouteKey$1(ca, ue.pageKey);
					!na.isHydrating && !hasChildrenRoutes(ia, ca.route, ca.Component) && aa === ha && na.callHook("page:loading:end"), aa = ha;
					const pa = !!(ue.transition ?? ca.route.meta.pageTransition ?? appPageTransition),
						va = pa && _mergeTransitionProps([ue.transition, ca.route.meta.pageTransition, appPageTransition, {
							onAfterLeave: () => {
								na.callHook("page:transition:finish", ca.Component)
							}
						}].filter(Boolean)),
						ba = ue.keepalive ?? ca.route.meta.keepalive ?? appKeepalive;
					return la = _wrapIf(Transition, pa && va, wrapInKeepAlive(ba, h$2(Suspense, {
						suspensible: !0,
						onPending: () => na.callHook("page:start", ca.Component),
						onResolve: () => {
							nextTick(() => na.callHook("page:finish", ca.Component).then(() => na.callHook("page:loading:end")).finally(sa))
						}
					}, {
						default: () => {
							const Ea = h$2(RouteProvider, {
								key: ha || void 0,
								vnode: ea.default ? h$2(Fragment, void 0, ea.default(ca)) : ca.Component,
								route: ca.route,
								renderKey: ha || void 0,
								trackRootNodes: pa,
								vnodeRef: ra
							});
							return ba && (Ea.type.name = ca.Component.type.name || ca.Component.type.__name || "RouteProvider"), Ea
						}
					}))).default(), la
				}
			})
		}
	});

function _mergeTransitionProps(ue) {
	const Yi = ue.map(ea => ({
		...ea,
		onAfterLeave: ea.onAfterLeave ? toArray$1(ea.onAfterLeave) : void 0
	}));
	return defu(...Yi)
}

function haveParentRoutesRendered(ue, Yi, ea) {
	if (!ue) return !1;
	const ta = Yi.matched.findIndex(na => {
		var ra;
		return ((ra = na.components) == null ? void 0 : ra.default) === (ea == null ? void 0 : ea.type)
	});
	return !ta || ta === -1 ? !1 : Yi.matched.slice(0, ta).some((na, ra) => {
		var ia, aa, oa;
		return ((ia = na.components) == null ? void 0 : ia.default) !== ((oa = (aa = ue.matched[ra]) == null ? void 0 : aa.components) == null ? void 0 : oa.default)
	}) || ea && generateRouteKey$1({
		route: Yi,
		Component: ea
	}) !== generateRouteKey$1({
		route: ue,
		Component: ea
	})
}

function hasChildrenRoutes(ue, Yi, ea) {
	return ue ? Yi.matched.findIndex(na => {
		var ra;
		return ((ra = na.components) == null ? void 0 : ra.default) === (ea == null ? void 0 : ea.type)
	}) < Yi.matched.length - 1 : !1
}
const __vite_glob_0_0 = `<svg width="13" height="12" viewBox="0 0 13 12" fill="none" xmlns="http://www.w3.org/2000/svg">
<g id="Arrow / Caret_Down_SM">
<path id="Vector" d="M8 5.5L6.5 7L5 5.5" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
</svg>
`,
	__vite_glob_0_1 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g id="Style=Line">
<path id="Vector" d="M12 5V19M12 19L18 13M12 19L6 13" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
</svg>
`,
	__vite_glob_0_2 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M5 12H19M19 12L13 6M19 12L13 18" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_3 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g id="Style=Line">
<path id="Vector" d="M12 19V5M12 5L6 11M12 5L18 11" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
</svg>
`,
	__vite_glob_0_4 = `<svg width="60" height="60" viewBox="0 0 60 60" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect y="-0.00631714" width="60" height="60" rx="8" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M30.3454 9.42728H25.7103V14.0171H15.4102V46.146H25.7103V50.7359H30.3454V46.146H40.1306V41.5562H44.7656V32.3765H40.1306V27.7867H44.7656V18.607H40.1306V14.0171H30.3454V9.42728ZM25.7103 18.607H32.6629V27.7867H25.7103V18.607ZM25.7103 41.5562V32.3765H34.9805V36.9663H30.3454V41.5562H25.7103Z" fill="white"/>
</svg>
`,
	__vite_glob_0_5 = `<svg width="36" height="36" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="36" height="36" rx="18" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M18.5822 5.66016H15.8012V8.41406H9.62109V27.6914H15.8012V30.4453H18.5822V27.6914H24.4533V24.9375H27.2344V19.4297H24.4533V16.6758H27.2344V11.168H24.4533V8.41406H18.5822V5.66016ZM15.8012 11.168H19.9728V16.6758H15.8012V11.168ZM15.8012 24.9375V19.4297H21.3633V22.1836H18.5822V24.9375H15.8012Z" fill="white"/>
</svg>
`,
	__vite_glob_0_6 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M15 19L8 12L15 5" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_7 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g id="Style=Line">
<path id="Vector" d="M10 8L14 12L10 16" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
</svg>
`,
	__vite_glob_0_8 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g id="Style=Duotone">
<g id="Opacity" opacity="0.32">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21Z" fill="white"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15 10L11 14L9 12" fill="white"/>
</g>
<path id="Vector" d="M15 10L11 14L9 12M12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
</svg>
`,
	__vite_glob_0_9 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M15 10L11 14L9 12M12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_10 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.32">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21Z" fill="#F6BC2F"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15 10L11 14L9 12" fill="#F6BC2F"/>
</g>
<path d="M15 10L11 14L9 12M12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21Z" stroke="#F6BC2F" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_11 = `<svg width="14" height="15" viewBox="0 0 14 15" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.32">
<path d="M7 12.918C4.1005 12.918 1.75 10.5675 1.75 7.66797C1.75 4.76847 4.1005 2.41797 7 2.41797C9.8995 2.41797 12.25 4.76847 12.25 7.66797C12.25 10.5675 9.8995 12.918 7 12.918Z" fill="#DDDDDD"/>
<path d="M7.02928 10.5846V10.643H6.97095V10.5846H7.02928Z" fill="#DDDDDD"/>
</g>
<path d="M5.33545 5.96103C5.43508 5.65402 5.61759 5.38067 5.86296 5.17097C6.10832 4.96128 6.40721 4.8235 6.72599 4.77292C7.04477 4.72234 7.37113 4.76087 7.66935 4.88432C7.96758 5.00777 8.22585 5.2114 8.41561 5.47249C8.60537 5.73358 8.71905 6.04196 8.74442 6.36373C8.76979 6.6855 8.70571 7.0081 8.5592 7.29569C8.41269 7.58329 8.18963 7.82459 7.91444 7.99325C7.63924 8.1619 7.32277 8.25117 7 8.25117L7.00001 8.83463M7 12.918C4.1005 12.918 1.75 10.5675 1.75 7.66797C1.75 4.76847 4.1005 2.41797 7 2.41797C9.89949 2.41797 12.25 4.76847 12.25 7.66797C12.25 10.5675 9.89949 12.918 7 12.918ZM7.02905 10.5846V10.643L6.97095 10.643V10.5846H7.02905Z" stroke="#DDDDDD" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_12 = `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8 15C4.17745 15 1 11.8225 1 8C1 4.17059 4.17059 1 7.99314 1C11.8225 1 15 4.17059 15 8C15 11.8225 11.8294 15 8 15ZM8 13.8333C11.2392 13.8333 13.8333 11.2392 13.8333 8C13.8333 4.76078 11.2324 2.16667 7.99314 2.16667C4.75392 2.16667 2.17353 4.76078 2.17353 8C2.17353 11.2392 4.76078 13.8333 8 13.8333ZM4.98726 8.47353C4.98726 8.38431 5.02843 8.28824 5.10392 8.19902L8.86471 3.47745C9.15294 3.12745 9.61961 3.36765 9.4549 3.80686L8.21275 7.14216H10.5392C10.7176 7.14216 10.8549 7.26569 10.8549 7.43726C10.8549 7.52647 10.8137 7.62255 10.7382 7.7049L6.97745 12.4265C6.68922 12.7833 6.22255 12.5431 6.38726 12.1039L7.62941 8.76863H5.30294C5.12451 8.76863 4.98726 8.6451 4.98726 8.47353Z" fill="#C4F85C"/>
</svg>
`,
	__vite_glob_0_13 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 17C14.7614 17 17 14.7614 17 12C17 9.23858 14.7614 7 12 7C9.23858 7 7 9.23858 7 12C7 14.7614 9.23858 17 12 17Z" fill="#4B4B4B"/>
</svg>
`,
	__vite_glob_0_14 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g id="Style=Duotone">
<g id="Opacity" opacity="0.32">
<path d="M12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21Z" fill="white"/>
<path d="M12.0502 15.45V15.55H11.9502V15.45H12.0502Z" fill="white"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12 8.44995V12.45V8.44995Z" fill="white"/>
</g>
<path id="Vector" d="M12 8.4502V12.4502M12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21ZM12.0498 15.4502V15.5502L11.9502 15.5498V15.4502H12.0498Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
</svg>
`,
	__vite_glob_0_15 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g id="Style=Line">
<path id="Vector" d="M12 7V12H17M12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
</svg>
`,
	__vite_glob_0_16 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9 9L11.9999 11.9999M11.9999 11.9999L14.9999 14.9999M11.9999 11.9999L9 14.9999M11.9999 11.9999L14.9999 9M12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_17 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6 6L18 18" stroke="#F5F5F5" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M6 18L18 6" stroke="#F5F5F5" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M6 6L18 18" stroke="#F5F5F5" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M6 18L18 6" stroke="#F5F5F5" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_18 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="7.00001" y="7" width="14" height="14" rx="2" stroke="#F5F5F5" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M6.99997 16.9997H4.99997C3.8954 16.9997 2.99997 16.1043 2.99997 14.9997V4.99973C2.99997 3.89516 3.8954 2.99973 4.99997 2.99973H15C16.1045 2.99973 17 3.89516 17 4.99973V6.99973" stroke="#F5F5F5" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_19 = `<svg width="36" height="36" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg">
<g id="asset/dogs">
<rect width="36" height="36" rx="18" fill="black"/>
<path id="Spotty" d="M17.8226 11.1702C17.8238 11.1685 17.8244 11.1666 17.8246 11.1644C17.8247 11.1621 17.826 11.1608 17.8283 11.1605C17.9237 11.1477 18.0043 11.1408 18.0702 11.1396C18.1481 11.138 18.2531 11.1437 18.3854 11.1566C18.3916 11.1572 18.3965 11.1601 18.4 11.1652C18.4049 11.1726 18.4128 11.177 18.4219 11.1774C18.5484 11.1835 18.6491 11.1928 18.7241 11.2053C18.8801 11.2314 19.0407 11.2584 19.1984 11.3007C19.3255 11.3349 19.4484 11.3737 19.5768 11.3827C19.8673 11.4033 20.1526 11.3447 20.4263 11.2498C20.6859 11.1599 20.9388 11.0543 21.185 10.9329C21.3794 10.8369 21.5692 10.7423 21.7545 10.6491C21.8481 10.6019 21.9387 10.5546 22.0264 10.5071C22.5148 10.2426 22.9494 10.0185 23.33 9.83487C23.4795 9.76275 23.6617 9.67942 23.8767 9.58488C24.138 9.46992 24.4082 9.36562 24.6874 9.27199C24.7732 9.24322 24.8713 9.21355 24.9816 9.18298C25.4567 9.05127 25.969 8.96935 26.4621 9.01084C26.7736 9.03699 27.0673 9.11152 27.3432 9.23442C27.5202 9.31327 27.6974 9.42089 27.875 9.55727C28.0759 9.71166 28.2718 9.90628 28.4625 10.1411C28.5328 10.2275 28.5806 10.3248 28.606 10.433C28.625 10.5143 28.6351 10.6129 28.6362 10.7287C28.6378 10.8945 28.627 11.0366 28.6035 11.1549C28.5058 11.6495 28.2885 12.1276 28.0001 12.5301C27.6865 12.968 27.3059 13.3299 26.8583 13.6159C26.7751 13.6691 26.685 13.7226 26.588 13.7765C26.4426 13.8572 26.3038 13.9387 26.1544 14.0156C25.6845 14.2575 25.3181 14.4334 24.8926 14.6389C24.8606 14.6543 24.828 14.6716 24.7948 14.6909C24.7221 14.7333 24.6452 14.7667 24.5844 14.8237C24.5496 14.8565 24.5192 14.8926 24.4932 14.932C24.4242 15.0369 24.3657 15.1663 24.318 15.3202C24.2671 15.4839 24.2341 15.5962 24.219 15.6571C24.157 15.9056 24.0985 16.1721 24.0433 16.4565C23.9894 16.7345 23.9386 17.0082 23.8912 17.2775C23.801 17.7893 23.7165 18.2546 23.6378 18.6733C23.6156 18.7914 23.5952 18.9099 23.5714 19.0266C23.5495 19.1341 23.5356 19.2425 23.5122 19.348C23.4898 19.4498 23.4727 19.5551 23.4507 19.6539C23.4327 19.7351 23.4172 19.814 23.4041 19.8905C23.3992 19.9196 23.3924 19.9494 23.3836 19.98C23.3571 20.0714 23.3491 20.1687 23.3229 20.2577C23.2987 20.3401 23.2938 20.4267 23.2702 20.5089C23.2605 20.5427 23.252 20.5772 23.2446 20.6125C23.237 20.6495 23.2293 20.6847 23.2216 20.7181C23.1746 20.9238 23.122 21.1447 23.064 21.3807C23.019 21.5633 22.9772 21.7 22.9235 21.9039C22.9025 21.9841 22.8793 22.0654 22.854 22.1479C22.8305 22.2245 22.813 22.3012 22.7887 22.3777C22.7716 22.4312 22.7602 22.487 22.7414 22.5403C22.7339 22.5615 22.7268 22.5829 22.7201 22.6046C22.5346 23.1979 22.3382 23.7418 22.1307 24.2365C21.9686 24.6233 21.7724 25.0249 21.5421 25.4411C21.5134 25.493 21.4817 25.5433 21.4528 25.5955C21.3867 25.7147 21.3038 25.8511 21.2042 26.0049C21.0553 26.2348 20.8853 26.4666 20.6942 26.7003C20.6084 26.8053 20.512 26.9104 20.4205 27.0098C20.1193 27.3372 19.7835 27.6234 19.4131 27.8684C19.2428 27.9811 19.0644 28.082 18.8778 28.1714C18.4425 28.3795 17.9893 28.5179 17.5182 28.5865C17.3868 28.6056 17.3074 28.6167 17.2801 28.6197C17.1993 28.6285 17.1191 28.6338 17.0393 28.6357C16.904 28.6389 16.7881 28.6313 16.6583 28.5936C16.5422 28.5598 16.4466 28.5253 16.3713 28.49C16.2758 28.4452 16.1793 28.4008 16.0882 28.3488C15.8069 28.1883 15.5365 27.9954 15.2772 27.7699C15.2692 27.7631 15.2603 27.7564 15.2507 27.7498C15.2329 27.7382 15.2254 27.7171 15.2067 27.7046C15.1978 27.6985 15.1891 27.6918 15.1807 27.6845C15.1367 27.646 15.0935 27.6057 15.0511 27.5635C15.0426 27.5551 15.0367 27.5418 15.026 27.5361C15.005 27.5247 14.9905 27.5093 14.9825 27.4897C14.9794 27.4822 14.9739 27.4772 14.966 27.4748C14.9435 27.4677 14.9298 27.4526 14.925 27.4297C14.9227 27.4192 14.9163 27.4133 14.9056 27.4117C14.8836 27.4085 14.8713 27.3957 14.8686 27.3731C14.8681 27.369 14.8666 27.3649 14.8644 27.3613C14.8621 27.3578 14.8591 27.3547 14.8555 27.3523C14.8514 27.3497 14.8468 27.3483 14.8418 27.3481C14.838 27.3479 14.8342 27.3469 14.8309 27.3451C14.8275 27.3434 14.8245 27.341 14.8222 27.338C14.8167 27.3307 14.8125 27.3226 14.8094 27.3135C14.8011 27.2891 14.7815 27.2835 14.7662 27.2657C14.6098 27.0829 14.4901 26.916 14.4073 26.7651C14.3213 26.6082 14.2493 26.4322 14.169 26.2673C13.9361 25.7901 13.7226 25.2879 13.572 24.7846C13.5434 24.6887 13.5079 24.5561 13.4657 24.3867C13.4494 24.3209 13.4363 24.2561 13.4264 24.1926C13.413 24.1054 13.3882 24.021 13.3775 23.9335C13.367 23.8459 13.3551 23.7569 13.3419 23.6665C13.2946 23.3423 13.2948 23.0175 13.2937 22.6916C13.2935 22.6151 13.2883 22.5333 13.2781 22.4463C13.259 22.2829 13.2423 22.1143 13.2279 21.9406C13.1942 21.5324 13.16 21.1196 13.1254 20.7023C13.1169 20.5987 13.1075 20.4971 13.0972 20.3974C13.0758 20.1891 13.0596 19.9839 13.0335 19.7764C13.013 19.6129 12.997 19.4569 12.9697 19.294C12.958 19.2248 12.9462 19.1536 12.9343 19.0805C12.913 18.9502 12.8847 18.827 12.8495 18.711C12.8162 18.6012 12.7903 18.506 12.7717 18.4254C12.7081 18.1489 12.6386 17.8597 12.5633 17.558C12.5143 17.3616 12.4655 17.1632 12.417 16.9627C12.404 16.9086 12.3899 16.8556 12.3749 16.8036C12.3623 16.76 12.3485 16.7084 12.3336 16.6489C12.1946 16.0927 12.0536 15.5371 11.9105 14.9821C11.8658 14.8087 11.8267 14.6632 11.7932 14.5455C11.7871 14.5241 11.7787 14.5035 11.7681 14.4839C11.7362 14.425 11.7031 14.366 11.669 14.3068C11.6547 14.2823 11.6382 14.2593 11.6194 14.238C11.3956 13.9853 11.1289 13.7711 10.8635 13.5612C10.6528 13.3946 10.4416 13.2256 10.2299 13.0543C10.0033 12.8708 9.79295 12.6711 9.59875 12.4554C9.5502 12.4014 9.50442 12.3427 9.45895 12.2854C9.41004 12.2237 9.35373 12.1415 9.29002 12.0389C9.05893 11.6668 8.96594 11.2624 9.01105 10.8254C9.01701 10.768 9.026 10.7116 9.03802 10.6563C9.05359 10.5847 9.0613 10.5135 9.0818 10.443C9.13626 10.2558 9.2089 10.0704 9.29974 9.88661C9.40439 9.67525 9.54326 9.51458 9.74733 9.39992C9.86662 9.33294 10.0077 9.28104 10.1499 9.25509C10.2717 9.23291 10.3917 9.20244 10.5152 9.20485C10.6269 9.20717 10.7332 9.20797 10.8342 9.20727C10.903 9.20676 10.97 9.21124 11.0354 9.22069C11.1456 9.23658 11.249 9.25122 11.3455 9.2646C11.4592 9.28029 11.5825 9.31423 11.6954 9.34305C11.9042 9.39625 12.1116 9.46826 12.3176 9.55908C12.3659 9.58051 12.4105 9.60258 12.4515 9.62531C12.5124 9.65926 12.5761 9.68626 12.6354 9.72323C12.8532 9.8589 13.0604 10.0013 13.257 10.1505C13.3994 10.2585 13.5495 10.3792 13.7074 10.5127C13.9169 10.69 14.1155 10.861 14.3031 11.0255C14.4963 11.1949 14.6906 11.3598 14.886 11.5202C14.9107 11.5402 14.9373 11.565 14.97 11.5709C15.0243 11.5806 15.0669 11.5838 15.0979 11.5805C15.2347 11.566 15.3721 11.552 15.5102 11.5384C15.5879 11.5309 15.6597 11.5122 15.7373 11.5004C15.8384 11.4851 15.938 11.4675 16.0361 11.4476C16.2706 11.3999 16.545 11.3461 16.8592 11.286C16.9979 11.2595 17.1323 11.2456 17.2679 11.2212C17.447 11.1892 17.6229 11.1848 17.8012 11.1825C17.8053 11.1825 17.8095 11.1813 17.8132 11.1792C17.8169 11.177 17.8202 11.1739 17.8226 11.1702ZM22.0113 13.0252C22.0204 13.0259 22.029 13.0296 22.0356 13.0357C22.0423 13.0418 22.0466 13.0499 22.0479 13.0587C22.0617 13.1531 22.1044 13.2343 22.176 13.3024C22.2138 13.3384 22.2648 13.3681 22.3184 13.3544C22.3758 13.3398 22.4313 13.3199 22.485 13.2945C22.568 13.2554 22.6073 13.169 22.6253 13.0862C22.6558 12.9472 22.6578 12.7991 22.6578 12.6577C22.6578 12.4222 22.7122 12.1259 22.992 12.0647C23.0642 12.0488 23.1405 12.0325 23.2207 12.0158C23.2258 12.0147 23.2305 12.0124 23.2344 12.009C23.2383 12.0057 23.2413 12.0014 23.243 11.9966C23.2447 11.9918 23.2452 11.9867 23.2443 11.9817C23.2434 11.9767 23.2412 11.972 23.238 11.9681C23.1796 11.898 23.1382 11.8198 23.0559 11.769C23.0285 11.7521 23.0293 11.7208 23.0509 11.6999C23.0924 11.6596 23.1367 11.6224 23.1837 11.5881C23.2085 11.57 23.295 11.5009 23.2412 11.4677C23.1777 11.4285 23.1136 11.3845 23.0489 11.3358C22.9892 11.2909 22.9317 11.3082 22.8667 11.3315C22.8093 11.352 22.7655 11.3841 22.735 11.4277C22.7039 11.4722 22.6831 11.5244 22.6383 11.5571C22.6038 11.5822 22.5662 11.5964 22.5253 11.5997C22.4121 11.6087 22.2927 11.6244 22.1788 11.6225C22.0879 11.6208 21.9991 11.6109 21.9115 11.6392C21.887 11.6472 21.8636 11.6636 21.8414 11.6884C21.7878 11.7486 21.7042 11.8391 21.8052 11.9016C21.8458 11.9267 21.8874 11.9498 21.9302 11.9708C21.9966 12.0034 22.0498 12.0493 22.0954 12.1025C22.178 12.1989 22.2392 12.3788 22.1224 12.4709C22.0057 12.5628 21.8454 12.596 21.6914 12.6002C21.641 12.6017 21.5911 12.6108 21.5409 12.6159C21.5333 12.6166 21.5264 12.6202 21.5215 12.6258C21.5165 12.6314 21.514 12.6387 21.5143 12.6461C21.5216 12.7739 21.5882 12.9005 21.7069 12.959C21.8006 13.0052 21.9057 13.0177 22.0113 13.0252ZM19.3481 18.9268C19.3775 18.9632 19.4156 19.0009 19.4621 19.0399C19.6611 19.2068 19.8995 19.2977 20.1572 19.3459C20.1941 19.3527 20.2283 19.3671 20.2648 19.3733C20.3904 19.3943 20.5102 19.429 20.6373 19.447C20.6963 19.4553 20.7556 19.4633 20.8152 19.4709C20.9516 19.4884 21.0847 19.4858 21.2146 19.4629C21.3007 19.4479 21.3788 19.4272 21.4488 19.4009C21.64 19.3296 21.805 19.1627 21.9027 18.9947C22.0055 18.818 22.0901 18.6252 22.1566 18.4161C22.1993 18.2816 22.2289 18.1485 22.2454 18.0168C22.2656 17.8552 22.2633 17.6759 22.2122 17.5201C22.1475 17.3219 22.1205 17.1194 22.0879 16.9091C22.0664 16.7701 22.0243 16.6382 21.9615 16.5135C21.8594 16.3105 21.7484 16.1373 21.6282 15.9941C21.5011 15.8426 21.3315 15.7084 21.1417 15.6356C21.0614 15.6049 20.986 15.587 20.9154 15.5821C20.8209 15.5753 20.7354 15.5787 20.6591 15.592C20.5102 15.618 20.3601 15.6787 20.2089 15.7743C20.0353 15.8838 19.8795 16.0211 19.7415 16.186C19.5234 16.4467 19.3547 16.732 19.2354 17.042C19.1989 17.137 19.166 17.2341 19.1366 17.3335C19.0533 17.6157 19.0239 17.9016 19.0484 18.1912C19.0704 18.4497 19.1589 18.6835 19.3138 18.8925C19.3237 18.9058 19.3371 18.9135 19.3481 18.9268ZM15.7963 16.5072C15.6819 16.3808 15.5422 16.2805 15.3771 16.2064C15.1825 16.1192 14.9538 16.0961 14.7457 16.126C14.4043 16.1751 14.1123 16.3986 13.9605 16.6934C13.8002 17.0048 13.7398 17.3415 13.7795 17.7034C13.8069 17.9544 13.895 18.2242 14.0468 18.4199C14.1901 18.6047 14.3886 18.7519 14.6192 18.8138C14.688 18.8322 14.7648 18.8434 14.8493 18.8474C14.9438 18.8518 15.0264 18.849 15.0972 18.8388C15.2437 18.8178 15.384 18.7681 15.5181 18.6898C15.5743 18.6569 15.6272 18.6151 15.6782 18.5736C15.8132 18.4635 15.9181 18.3272 15.9928 18.1648C16.0512 18.038 16.0906 17.9283 16.1112 17.8357C16.1942 17.462 16.1464 17.1007 15.9677 16.7519C15.9245 16.6675 15.8674 16.5859 15.7963 16.5072ZM19.6691 25.9622C19.7193 25.6148 19.6804 25.2399 19.5386 24.9246C19.4387 24.7024 19.3055 24.5089 19.1389 24.344C18.7238 23.9332 18.1545 23.6734 17.5634 23.6505C17.1021 23.6324 16.6315 23.764 16.2485 24.0315C16.1012 24.1343 15.9618 24.2561 15.8305 24.3967C15.707 24.529 15.6144 24.6562 15.5528 24.7784C15.5099 24.8634 15.4693 24.9601 15.431 25.0687C15.4113 25.1242 15.4003 25.1812 15.3821 25.2372C15.3691 25.2774 15.3579 25.3195 15.3487 25.3634C15.3322 25.4429 15.3164 25.5225 15.3015 25.6023C15.2806 25.7148 15.2625 25.8767 15.2474 26.0879C15.2289 26.346 15.249 26.6057 15.3077 26.8671C15.3238 26.9391 15.3573 27.0335 15.408 27.1501C15.4173 27.1714 15.4278 27.1908 15.4395 27.2085C15.4697 27.2541 15.4903 27.3027 15.5238 27.3473C15.6565 27.5242 15.8207 27.6614 16.0162 27.7589C16.2613 27.8812 16.5498 27.9401 16.825 27.9454C16.9944 27.9486 17.1525 27.94 17.2994 27.9197C17.403 27.9054 17.5239 27.8807 17.662 27.8455C18.0728 27.7406 18.4584 27.5543 18.799 27.3027C18.8709 27.2496 18.9379 27.188 19.0039 27.1283C19.2209 26.9315 19.3891 26.7089 19.5085 26.4604C19.593 26.2845 19.6465 26.1184 19.6691 25.9622Z" fill="white"/>
</g>
</svg>
`,
	__vite_glob_0_20 = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M14.479 4.20503C14.4807 4.2025 14.4818 4.19968 14.4821 4.19656C14.4822 4.19315 14.4841 4.19122 14.4877 4.19077C14.6334 4.17191 14.7566 4.16158 14.8572 4.1598C14.9762 4.15757 15.1367 4.16596 15.3387 4.18498C15.3483 4.18587 15.3558 4.1901 15.3611 4.19768C15.3686 4.20859 15.3807 4.21506 15.3946 4.21572C15.5878 4.22464 15.7417 4.23838 15.8563 4.25694C16.0946 4.29549 16.34 4.33537 16.5809 4.39776C16.7751 4.44833 16.9628 4.50559 17.159 4.51896C17.6028 4.54926 18.0387 4.46282 18.4569 4.32267C18.8535 4.18988 19.2398 4.03384 19.6159 3.85456C19.9129 3.71285 20.203 3.57315 20.486 3.43546C20.629 3.36579 20.7675 3.29591 20.9014 3.2258C21.6477 2.83514 22.3116 2.5042 22.893 2.23297C23.1214 2.12647 23.3999 2.00341 23.7283 1.86378C24.1275 1.69401 24.5403 1.53997 24.9669 1.40169C25.0979 1.3592 25.2478 1.31539 25.4164 1.27023C26.1421 1.07572 26.9248 0.954737 27.6781 1.01601C28.1541 1.05463 28.6028 1.16469 29.0243 1.34621C29.2947 1.46266 29.5655 1.62159 29.8367 1.82301C30.1438 2.05102 30.443 2.33844 30.7344 2.68527C30.8417 2.81286 30.9148 2.95657 30.9536 3.1164C30.9826 3.23642 30.998 3.38198 30.9998 3.5531C31.0023 3.79789 30.9856 4.0077 30.9498 4.18253C30.8005 4.91288 30.4685 5.61896 30.0279 6.2134C29.5488 6.86013 28.9674 7.39464 28.2835 7.81694C28.1564 7.89551 28.0187 7.97461 27.8705 8.05422C27.6485 8.17342 27.4363 8.29374 27.2081 8.40737C26.4902 8.76453 25.9304 9.02432 25.2803 9.32778C25.2315 9.35051 25.1817 9.37613 25.131 9.40465C25.0199 9.46726 24.9023 9.5165 24.8096 9.60072C24.7564 9.64914 24.7099 9.70247 24.6702 9.76069C24.5647 9.91562 24.4754 10.1067 24.4024 10.334C24.3247 10.5758 24.2743 10.7416 24.2513 10.8315C24.1566 11.1985 24.0671 11.5921 23.9828 12.0121C23.9004 12.4227 23.8229 12.8269 23.7504 13.2247C23.6126 13.9806 23.4835 14.6677 23.3633 15.2861C23.3294 15.4605 23.2983 15.6354 23.2618 15.8079C23.2284 15.9665 23.2072 16.1267 23.1714 16.2824C23.1372 16.4328 23.1111 16.5884 23.0774 16.7343C23.0499 16.8542 23.0262 16.9706 23.0063 17.0837C22.9988 17.1266 22.9883 17.1706 22.975 17.2158C22.9345 17.3508 22.9222 17.4945 22.8822 17.626C22.8452 17.7476 22.8377 17.8755 22.8017 17.9969C22.7869 18.0468 22.7739 18.0979 22.7626 18.15C22.751 18.2045 22.7393 18.2565 22.7275 18.306C22.6556 18.6097 22.5753 18.9359 22.4866 19.2845C22.4178 19.5541 22.354 19.756 22.2721 20.0572C22.2399 20.1756 22.2045 20.2957 22.1659 20.4175C22.1299 20.5307 22.1033 20.6439 22.066 20.7568C22.0399 20.8359 22.0225 20.9184 21.9938 20.997C21.9823 21.0284 21.9715 21.06 21.9613 21.0919C21.6779 21.9682 21.3778 22.7715 21.0608 23.502C20.8131 24.0733 20.5133 24.6663 20.1615 25.2811C20.1177 25.3578 20.0692 25.432 20.0252 25.5091C19.9241 25.6851 19.7975 25.8866 19.6454 26.1138C19.4179 26.4533 19.1582 26.7956 18.8662 27.1407C18.735 27.2957 18.5878 27.451 18.448 27.5979C17.9878 28.0814 17.4748 28.504 16.9089 28.8659C16.6488 29.0322 16.3762 29.1813 16.0911 29.3132C15.4261 29.6207 14.7337 29.8251 14.014 29.9264C13.8132 29.9546 13.6919 29.971 13.6501 29.9754C13.5268 29.9883 13.4042 29.9962 13.2823 29.999C13.0756 30.0037 12.8985 29.9926 12.7002 29.9369C12.5228 29.887 12.3767 29.8359 12.2618 29.7838C12.1158 29.7176 11.9684 29.6521 11.8292 29.5753C11.3994 29.3383 10.9864 29.0534 10.5901 28.7204C10.5779 28.7103 10.5644 28.7004 10.5496 28.6907C10.5226 28.6736 10.511 28.6424 10.4825 28.6239C10.4689 28.615 10.4556 28.6051 10.4427 28.5942C10.3755 28.5374 10.3095 28.4778 10.2447 28.4156C10.2317 28.4031 10.2228 28.3835 10.2063 28.375C10.1743 28.3582 10.1522 28.3354 10.1399 28.3066C10.1352 28.2955 10.1268 28.2881 10.1147 28.2845C10.0803 28.274 10.0595 28.2518 10.0521 28.2179C10.0486 28.2025 10.0387 28.1936 10.0224 28.1914C9.98882 28.1867 9.96998 28.1677 9.9659 28.1344C9.96509 28.1282 9.96288 28.1223 9.95943 28.117C9.95597 28.1117 9.95136 28.1071 9.94588 28.1036C9.9396 28.0998 9.93262 28.0977 9.92492 28.0974C9.9191 28.0971 9.91341 28.0956 9.90825 28.0931C9.90308 28.0905 9.89857 28.0869 9.89502 28.0825C9.8867 28.0718 9.88018 28.0597 9.87547 28.0464C9.86276 28.0103 9.83285 28.002 9.80954 27.9757C9.57045 27.7057 9.38765 27.4593 9.26112 27.2365C9.12972 27.0048 9.01976 26.7447 8.89707 26.5012C8.54127 25.7965 8.21514 25.0548 7.98508 24.3115C7.94128 24.1699 7.88712 23.9741 7.8226 23.7239C7.79764 23.6266 7.77762 23.5311 7.76255 23.4372C7.74206 23.3084 7.70415 23.1839 7.68791 23.0546C7.67174 22.9253 7.6536 22.7938 7.63351 22.6603C7.56122 22.1815 7.56146 21.7018 7.55981 21.2205C7.55949 21.1075 7.55157 20.9867 7.53602 20.8582C7.50682 20.6168 7.48124 20.3679 7.45926 20.1114C7.40777 19.5085 7.35557 18.8989 7.30267 18.2826C7.28964 18.1296 7.27527 17.9795 7.25958 17.8323C7.22684 17.5246 7.20212 17.2216 7.16232 16.9152C7.13101 16.6737 7.10652 16.4433 7.06484 16.2027C7.04694 16.1005 7.02889 15.9954 7.01068 15.8874C6.97818 15.6949 6.93501 15.513 6.88117 15.3418C6.8303 15.1796 6.79067 15.039 6.76225 14.92C6.66508 14.5115 6.55896 14.0845 6.44389 13.6389C6.36901 13.3489 6.29452 13.0558 6.22042 12.7597C6.20049 12.6799 6.17906 12.6016 6.15614 12.5248C6.13683 12.4604 6.11579 12.3842 6.09303 12.2962C5.88063 11.4748 5.66517 10.6543 5.44665 9.83467C5.37836 9.57859 5.31863 9.36365 5.26745 9.18987C5.25803 9.15823 5.24524 9.12792 5.22907 9.09896C5.18025 9.01192 5.12978 8.92473 5.07766 8.83739C5.05584 8.80114 5.03056 8.76728 5.00184 8.73579C4.65993 8.36259 4.25255 8.0462 3.84706 7.73628C3.52509 7.49015 3.20241 7.24061 2.87902 6.98765C2.53287 6.71657 2.21145 6.42172 1.91475 6.10311C1.84058 6.02335 1.77064 5.93668 1.70117 5.85201C1.62645 5.76096 1.54042 5.6396 1.44309 5.48795C1.09004 4.93851 0.947967 4.34116 1.01688 3.69592C1.02599 3.6111 1.03972 3.52785 1.05809 3.44615C1.08187 3.34032 1.09365 3.23516 1.12497 3.1311C1.20817 2.85468 1.31915 2.58077 1.45793 2.3094C1.61782 1.99725 1.82998 1.75996 2.14175 1.59062C2.32401 1.4917 2.53947 1.41505 2.75681 1.37673C2.94284 1.34398 3.12627 1.29897 3.31489 1.30254C3.48553 1.30595 3.64801 1.30714 3.80232 1.3061C3.90735 1.30536 4.00978 1.31197 4.10962 1.32593C4.27806 1.3494 4.43599 1.37101 4.5834 1.39077C4.75718 1.41394 4.94556 1.46407 5.11793 1.50663C5.43692 1.5852 5.75379 1.69156 6.06854 1.82569C6.14232 1.85732 6.21053 1.88993 6.27317 1.9235C6.36618 1.97363 6.46343 2.01351 6.55409 2.0681C6.8869 2.26847 7.20345 2.4788 7.50376 2.69908C7.72134 2.85861 7.9507 3.03693 8.19182 3.23404C8.51191 3.49591 8.81528 3.74835 9.10194 3.99136C9.39707 4.24149 9.69392 4.48502 9.99251 4.72194C10.0302 4.75157 10.0709 4.78811 10.1208 4.7968C10.2037 4.81121 10.2689 4.81596 10.3163 4.81106C10.5252 4.78967 10.7352 4.76895 10.9462 4.7489C11.0649 4.73776 11.1746 4.71013 11.293 4.69275C11.4475 4.67017 11.5997 4.64418 11.7496 4.61477C12.1079 4.54436 12.527 4.46482 13.0071 4.37614C13.219 4.33693 13.4243 4.31643 13.6315 4.28034C13.9052 4.2331 14.1738 4.22664 14.4463 4.2233C14.4526 4.22323 14.4589 4.22153 14.4646 4.21834C14.4703 4.21515 14.4753 4.21057 14.479 4.20503ZM20.8783 6.94465C20.8922 6.94567 20.9053 6.95113 20.9155 6.96011C20.9257 6.9691 20.9324 6.98109 20.9344 6.99411C20.9554 7.13344 21.0206 7.25339 21.13 7.35394C21.1877 7.4072 21.2657 7.45109 21.3476 7.43081C21.4352 7.40927 21.5201 7.37979 21.6022 7.34236C21.7288 7.28465 21.7889 7.15698 21.8164 7.03466C21.8631 6.82946 21.8661 6.61066 21.8661 6.4019C21.8661 6.05409 21.9492 5.6165 22.3766 5.52605C22.487 5.50258 22.6035 5.47851 22.7261 5.45386C22.7338 5.45227 22.7411 5.44884 22.747 5.44388C22.753 5.43893 22.7575 5.43261 22.7602 5.42555C22.7628 5.41848 22.7635 5.4109 22.7621 5.40353C22.7608 5.39616 22.7575 5.38924 22.7525 5.38345C22.6632 5.27984 22.6001 5.16443 22.4744 5.08935C22.4324 5.06439 22.4336 5.01827 22.4666 4.9873C22.53 4.92789 22.5977 4.87285 22.6696 4.8222C22.7075 4.79546 22.8396 4.69342 22.7574 4.6444C22.6604 4.58647 22.5624 4.52156 22.4635 4.44967C22.3724 4.38327 22.2846 4.4089 22.1852 4.44321C22.0976 4.47351 22.0306 4.52089 21.9841 4.58536C21.9365 4.65109 21.9047 4.72818 21.8362 4.77653C21.7836 4.81351 21.7261 4.83446 21.6636 4.83936C21.4908 4.85273 21.3083 4.8759 21.1343 4.873C20.9953 4.87055 20.8597 4.85585 20.726 4.89773C20.6884 4.90947 20.6527 4.93368 20.6188 4.97037C20.5369 5.05927 20.4092 5.19295 20.5635 5.28519C20.6255 5.32233 20.6891 5.35642 20.7544 5.38746C20.8559 5.43559 20.9372 5.50332 21.0069 5.58197C21.1331 5.72434 21.2266 5.98993 21.0481 6.12606C20.8698 6.26175 20.6249 6.31077 20.3897 6.31701C20.3127 6.31923 20.2364 6.3326 20.1596 6.34018C20.1482 6.34125 20.1376 6.34647 20.13 6.35476C20.1225 6.36305 20.1186 6.37379 20.1191 6.38474C20.1302 6.57346 20.2319 6.76039 20.4132 6.84684C20.5564 6.91502 20.717 6.93351 20.8783 6.94465ZM16.8095 15.6604C16.8546 15.7141 16.9127 15.7698 16.9838 15.8275C17.2878 16.0739 17.6521 16.2082 18.0458 16.2793C18.1021 16.2894 18.1543 16.3107 18.2101 16.3199C18.402 16.3508 18.585 16.4021 18.7793 16.4286C18.8694 16.4409 18.96 16.4527 19.051 16.464C19.2593 16.4899 19.4627 16.4859 19.6611 16.4522C19.7927 16.4299 19.912 16.3994 20.0191 16.3606C20.311 16.2553 20.5632 16.0088 20.7125 15.7606C20.8695 15.4998 20.9988 15.215 21.1004 14.9062C21.1657 14.7076 21.2109 14.511 21.236 14.3164C21.2668 14.0778 21.2633 13.8131 21.1854 13.5829C21.0865 13.2902 21.0453 12.9912 20.9953 12.6806C20.9625 12.4753 20.8982 12.2806 20.8022 12.0964C20.6464 11.7965 20.4767 11.5408 20.2931 11.3292C20.0989 11.1055 19.8399 10.9073 19.5498 10.7999C19.4272 10.7544 19.3119 10.728 19.2041 10.7208C19.0597 10.7108 18.9291 10.7157 18.8125 10.7355C18.585 10.7738 18.3557 10.8635 18.1247 11.0046C17.8595 11.1664 17.6215 11.3691 17.4107 11.6127C17.0774 11.9977 16.8196 12.4191 16.6374 12.8769C16.5817 13.0171 16.5313 13.1606 16.4865 13.3073C16.3591 13.7241 16.3142 14.1463 16.3518 14.574C16.3854 14.9559 16.5205 15.3011 16.7572 15.6098C16.7723 15.6294 16.7928 15.6408 16.8095 15.6604ZM11.3832 12.087C11.2085 11.9003 10.995 11.7522 10.7427 11.6427C10.4456 11.514 10.0961 11.4799 9.77822 11.524C9.25664 11.5966 8.81042 11.9266 8.57847 12.362C8.33358 12.822 8.24143 13.3192 8.30203 13.8536C8.34394 14.2244 8.4784 14.6228 8.71034 14.9117C8.92933 15.1847 9.23263 15.4021 9.5849 15.4935C9.69008 15.5207 9.80726 15.5372 9.93646 15.5432C10.0807 15.5497 10.2069 15.5455 10.3151 15.5305C10.539 15.4994 10.7533 15.4261 10.9582 15.3103C11.0441 15.2618 11.1249 15.2001 11.2028 15.1388C11.4091 14.9761 11.5693 14.7749 11.6835 14.535C11.7726 14.3478 11.8329 14.1858 11.8643 14.049C11.9911 13.4971 11.9181 12.9635 11.6451 12.4484C11.5791 12.3238 11.4919 12.2033 11.3832 12.087ZM17.3 26.0507C17.3768 25.5376 17.3172 24.9839 17.1006 24.5182C16.948 24.1901 16.7445 23.9043 16.49 23.6609C15.8558 23.0542 14.986 22.6705 14.083 22.6366C13.3782 22.6099 12.6593 22.8042 12.0741 23.1992C11.849 23.3512 11.6361 23.531 11.4355 23.7386C11.2468 23.934 11.1054 24.1219 11.0112 24.3023C10.9457 24.4279 10.8837 24.5707 10.8251 24.731C10.795 24.813 10.7783 24.8972 10.7505 24.9799C10.7306 25.0393 10.7135 25.1015 10.6994 25.1664C10.6741 25.2837 10.6501 25.4013 10.6273 25.5191C10.5953 25.6853 10.5678 25.9244 10.5447 26.2363C10.5164 26.6174 10.5471 27.001 10.6368 27.3871C10.6614 27.4934 10.7125 27.6328 10.7901 27.8051C10.8042 27.8364 10.8202 27.8652 10.8381 27.8913C10.8843 27.9586 10.9158 28.0303 10.9669 28.0963C11.1697 28.3576 11.4205 28.5602 11.7192 28.7041C12.0937 28.8848 12.5345 28.9717 12.9548 28.9795C13.2137 28.9842 13.4553 28.9716 13.6796 28.9416C13.838 28.9205 14.0227 28.884 14.2337 28.832C14.8612 28.6771 15.4504 28.402 15.9708 28.0303C16.0805 27.9519 16.1829 27.861 16.2837 27.7728C16.6153 27.4822 16.8722 27.1534 17.0547 26.7864C17.1837 26.5266 17.2655 26.2814 17.3 26.0507Z" fill="white"/>
</svg>
`,
	__vite_glob_0_21 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9 9V6.2002C9 5.08009 9 4.51962 9.21799 4.0918C9.40973 3.71547 9.71547 3.40973 10.0918 3.21799C10.5196 3 11.0801 3 12.2002 3H17.8002C18.9203 3 19.4801 3 19.9079 3.21799C20.2842 3.40973 20.5905 3.71547 20.7822 4.0918C21.0002 4.51962 21.0002 5.07967 21.0002 6.19978V11.7998C21.0002 12.9199 21.0002 13.48 20.7822 13.9078C20.5905 14.2841 20.2839 14.5905 19.9076 14.7822C19.4802 15 18.921 15 17.8031 15H15M9 9H6.2002C5.08009 9 4.51962 9 4.0918 9.21799C3.71547 9.40973 3.40973 9.71547 3.21799 10.0918C3 10.5196 3 11.0801 3 12.2002V17.8002C3 18.9203 3 19.4801 3.21799 19.9079C3.40973 20.2842 3.71547 20.5905 4.0918 20.7822C4.5192 21 5.07899 21 6.19691 21H11.8036C12.9215 21 13.4805 21 13.9079 20.7822C14.2842 20.5905 14.5905 20.2839 14.7822 19.9076C15 19.4802 15 18.921 15 17.8031V15M9 9H11.8002C12.9203 9 13.4801 9 13.9079 9.21799C14.2842 9.40973 14.5905 9.71547 14.7822 10.0918C15 10.5192 15 11.079 15 12.1969L15 15" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_22 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g id="Style=Line">
<path id="Vector" d="M10.0002 5H8.2002C7.08009 5 6.51962 5 6.0918 5.21799C5.71547 5.40973 5.40973 5.71547 5.21799 6.0918C5 6.51962 5 7.08009 5 8.2002V15.8002C5 16.9203 5 17.4801 5.21799 17.9079C5.40973 18.2842 5.71547 18.5905 6.0918 18.7822C6.5192 19 7.07899 19 8.19691 19H15.8031C16.921 19 17.48 19 17.9074 18.7822C18.2837 18.5905 18.5905 18.2839 18.7822 17.9076C19 17.4802 19 16.921 19 15.8031V14M20 9V4M20 4H15M20 4L13 11" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
</svg>
`,
	__vite_glob_0_23 = `<svg width="375" height="1622" viewBox="0 0 375 1622" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M-25.7563 -218L27.4966 24.8729V-1.97327H27.7466V25.9017H67.4966V-1.97327H67.7466V25.9017H107.497V-1.97327H107.747V25.9017H147.497V-1.97327H147.747V25.9017H187.497V-1.97327H187.747V25.9017H227.497V-1.97327H227.747V25.9017H267.497V-1.97327H267.747V25.9017H307.497V-1.97327H307.747V25.9017H347.497V-1.97327H347.747V24.8729L400.999 -218L401.244 -217.946L347.747 26.0402V80.9167L359.997 27.2252V-1.97327H360.247V26.1295L394.5 -124.001L394.743 -123.945L360.247 27.2534V85.2501L409 -116.503L409.243 -116.444L360.247 86.3144V147.746L400.001 3.49353L400.242 3.55995L360.247 148.687V208.002L403.502 65.4905L403.741 65.5631L360.247 208.862V267.502L397.503 154.987L397.74 155.066L360.247 268.297V326.778L396.004 227.984L396.239 228.069L360.247 327.512V388.7L399.507 298.477L399.736 298.577L360.247 389.327V448.259L401.01 365.971L401.234 366.082L360.247 448.823V508.406L398.014 444.463L398.229 444.59L360.247 508.898V569.136L389.522 530.451L389.721 530.602L360.247 569.551V628.605L388.531 598.941L388.712 599.113L360.247 628.967V689.507L392.053 668.422L392.191 668.631L360.247 689.807V749.394L388.079 739.409L388.164 739.644L360.247 749.66V809.902H385.122V810.152L360.247 810.152V870.394L388.164 880.409L388.079 880.645L360.247 870.659V930.246L392.191 951.423L392.053 951.631L360.247 930.546V991.086L388.712 1020.94L388.531 1021.11L360.247 991.449V1050.5L389.721 1089.45L389.522 1089.6L360.247 1050.92V1111.16L398.229 1175.46L398.014 1175.59L360.247 1111.65V1171.23L401.234 1253.97L401.01 1254.08L360.247 1171.79V1230.73L399.736 1321.48L399.507 1321.58L360.247 1231.35V1292.54L396.239 1391.98L396.004 1392.07L360.247 1293.28V1351.76L397.74 1464.99L397.503 1465.07L360.247 1352.55V1411.19L403.741 1554.49L403.502 1554.56L360.247 1412.05V1471.37L400.242 1616.49L400.001 1616.56L360.247 1472.31V1533.74L409.243 1736.5L409 1736.56L360.247 1534.8V1592.8L394.743 1744L394.5 1744.05L360.247 1593.92V1622.03H359.997V1592.83L347.747 1539.14V1594.01L401.244 1838L400.999 1838.05L347.747 1595.18V1622.03H347.497V1594.15H307.747V1622.03H307.497V1594.15H267.747V1622.03H267.497V1594.15H227.747V1622.03H227.497V1594.15H187.747V1622.03H187.497V1594.15H147.747V1622.03H147.497V1594.15H107.747V1622.03H107.497V1594.15H67.7466V1622.03H67.4966V1594.15H27.7466V1622.03H27.4966V1595.18L-25.7563 1838.05L-26.0005 1838L27.4966 1594.01V1539.14L15.2466 1592.83V1622.03H14.9966V1593.92L-19.2565 1744.05L-19.5002 1744L14.9966 1592.8V1534.8L-33.757 1736.56L-34 1736.5L14.9966 1533.74V1472.31L-24.758 1616.56L-24.999 1616.49L14.9966 1471.37V1412.05L-28.2588 1554.56L-28.498 1554.49L14.9966 1411.19V1352.55L-22.2597 1465.07L-22.4971 1464.99L14.9966 1351.76V1293.28L-20.7608 1392.07L-20.9958 1391.98L14.9966 1292.54V1231.35L-24.2637 1321.58L-24.4929 1321.48L14.9966 1230.73V1171.79L-25.7665 1254.08L-25.9905 1253.97L14.9966 1171.23V1111.65L-22.7708 1175.59L-22.9861 1175.46L14.9966 1111.16V1050.92L-14.2787 1089.6L-14.478 1089.45L14.9966 1050.5V991.449L-13.2881 1021.11L-13.469 1020.94L14.9966 991.086V930.546L-16.8094 951.631L-16.9475 951.423L14.9966 930.246V870.659L-12.8362 880.645L-12.9207 880.409L14.9966 870.394V810.152L-9.87842 810.152V809.902H14.9966V749.66L-12.9207 739.644L-12.8362 739.409L14.9966 749.394V689.807L-16.9475 668.631L-16.8094 668.422L14.9966 689.507V628.967L-13.469 599.113L-13.2881 598.941L14.9966 628.605V569.551L-14.478 530.602L-14.2787 530.451L14.9966 569.136V508.898L-22.9861 444.59L-22.7708 444.463L14.9966 508.406V448.823L-25.9905 366.082L-25.7665 365.971L14.9966 448.259V389.327L-24.4929 298.577L-24.2637 298.477L14.9966 388.7V327.512L-20.9958 228.069L-20.7608 227.984L14.9966 326.778V268.297L-22.4971 155.066L-22.2597 154.987L14.9966 267.502V208.862L-28.498 65.5631L-28.2588 65.4905L14.9966 208.002V148.687L-24.999 3.55995L-24.758 3.49353L14.9966 147.746V86.3144L-34 -116.444L-33.757 -116.503L14.9966 85.2501V27.2534L-19.5002 -123.945L-19.2565 -124.001L14.9966 26.1295V-1.97327H15.2466V27.2252L27.4966 80.9167V26.0402L-26.0005 -217.946L-25.7563 -218ZM187.497 1593.9V1538.15H147.747V1593.9H187.497ZM187.497 1537.9V1482.15H147.747V1537.9H187.497ZM187.497 1481.9V1426.15H147.747V1481.9H187.497ZM187.497 1425.9V1370.15H147.747V1425.9H187.497ZM187.497 1369.9V1314.15H147.747V1369.9H187.497ZM187.497 1313.9V1258.15H147.747V1313.9H187.497ZM187.497 1257.9V1202.15H147.747V1257.9H187.497ZM187.497 1201.9V1146.15H147.747V1201.9H187.497ZM187.497 1145.9V1090.15H147.747V1145.9H187.497ZM187.497 1089.9V1034.15H147.747V1089.9H187.497ZM187.497 1033.9V978.152H147.747V1033.9H187.497ZM187.497 977.902V922.152H147.747V977.902H187.497ZM187.497 921.902V866.152H147.747V921.902H187.497ZM187.497 865.902V810.152H147.747V865.902H187.497ZM187.747 809.902H227.497V754.152H187.747V809.902ZM227.747 809.902H267.497V754.152H227.747V809.902ZM267.747 809.902H307.497V754.152H267.747V809.902ZM307.747 809.902H347.497V754.152H307.747V809.902ZM347.747 809.902H359.997V749.749L347.747 754.144V809.902ZM187.747 1593.9H227.497V1538.15H187.747V1593.9ZM187.747 1537.9H227.497V1482.15H187.747V1537.9ZM187.747 1481.9H227.497V1426.15H187.747V1481.9ZM187.747 1425.9H227.497V1370.15H187.747V1425.9ZM187.747 1369.9H227.497V1314.15H187.747V1369.9ZM187.747 1313.9H227.497V1258.15H187.747V1313.9ZM187.747 1257.9H227.497V1202.15H187.747V1257.9ZM187.747 1201.9H227.497V1146.15H187.747V1201.9ZM187.747 1145.9H227.497V1090.15H187.747V1145.9ZM187.747 1089.9H227.497V1034.15H187.747V1089.9ZM187.747 1033.9H227.497V978.152H187.747V1033.9ZM187.747 977.902H227.497V922.152H187.747V977.902ZM187.747 921.902H227.497V866.152H187.747V921.902ZM187.747 865.902H227.497V810.152L187.747 810.152V865.902ZM227.747 810.152V865.902H267.497V810.152H227.747ZM267.747 810.152V865.902H307.497V810.152H267.747ZM307.747 810.152V865.902H347.497V810.152H307.747ZM347.747 810.152V865.909L359.997 870.304V810.152H347.747ZM147.747 26.1517H187.497V81.9017H147.747V26.1517ZM147.747 82.1517H187.497V137.902H147.747V82.1517ZM147.747 138.152H187.497V193.902H147.747V138.152ZM147.747 194.152H187.497V249.902H147.747V194.152ZM147.747 250.152H187.497V305.902H147.747V250.152ZM147.747 306.152H187.497V361.902H147.747V306.152ZM147.747 362.152H187.497V417.902H147.747V362.152ZM147.747 418.152H187.497V473.902H147.747V418.152ZM147.747 474.152H187.497V529.902H147.747V474.152ZM147.747 530.152H187.497V585.902H147.747V530.152ZM147.747 586.152H187.497V641.902H147.747V586.152ZM147.747 642.152H187.497V697.902H147.747V642.152ZM147.747 698.152H187.497V753.902H147.747V698.152ZM147.747 754.152H187.497V809.902H147.747V754.152ZM187.747 81.9017V26.1517H227.497V81.9017H187.747ZM187.747 137.902V82.1517H227.497V137.902H187.747ZM187.747 193.902V138.152H227.497V193.902H187.747ZM187.747 249.902V194.152H227.497V249.902H187.747ZM187.747 305.902V250.152H227.497V305.902H187.747ZM187.747 361.902V306.152H227.497V361.902H187.747ZM187.747 417.902V362.152H227.497V417.902H187.747ZM187.747 473.902V418.152H227.497V473.902H187.747ZM187.747 529.902V474.152H227.497V529.902H187.747ZM187.747 585.902V530.152H227.497V585.902H187.747ZM187.747 641.902V586.152H227.497V641.902H187.747ZM187.747 697.902V642.152H227.497V697.902H187.747ZM187.747 753.902V698.152H227.497V753.902H187.747ZM15.2466 809.902H27.4966V754.144L15.2466 749.749V809.902ZM27.7466 809.902H67.4966V754.152H27.7466V809.902ZM67.7466 809.902H107.497V754.152H67.7466V809.902ZM107.747 809.902H147.497V754.152H107.747V809.902ZM15.2466 810.152V870.304L27.4966 865.909V810.152H15.2466ZM27.7466 810.152V865.902H67.4966V810.152H27.7466ZM67.7466 810.152V865.902H107.497V810.152H67.7466ZM107.747 810.152V865.902H147.497V810.152H107.747ZM15.2466 28.3491V86.2846L27.4966 136.978V82.0406L15.2466 28.3491ZM15.2466 148.653V87.3489L27.4966 138.042V193.103L15.2466 148.653ZM15.2466 149.594V208.825L27.4966 249.185V194.044L15.2466 149.594ZM15.2466 209.686L27.4966 250.045V305.252L15.2466 268.257V209.686ZM15.2466 269.052V327.469L27.4966 361.314V306.047L15.2466 269.052ZM15.2466 328.203L27.4966 362.048V417.426L15.2466 389.275V328.203ZM15.2466 389.901V448.764L27.4966 473.493V418.053L15.2466 389.901ZM15.2466 449.327L27.4966 474.056V529.569L15.2466 508.829V449.327ZM15.2466 509.321V569.467L27.4966 585.654V530.061L15.2466 509.321ZM15.2466 569.881L27.4966 586.069V641.715L15.2466 628.867V569.881ZM15.2466 629.229V689.673L27.4966 697.794V642.077L15.2466 629.229ZM15.2466 689.973L27.4966 698.094V753.878L15.2466 749.484V689.973ZM107.747 26.1517H147.497V81.9017H107.747V26.1517ZM67.7466 26.1517H107.497V81.9017H67.7466V26.1517ZM27.7466 26.1517H67.4966V81.9017H27.7466V26.1517ZM27.7466 82.1517V137.902H67.4966V82.1517H27.7466ZM67.7466 82.1517V137.902H107.497V82.1517H67.7466ZM107.747 82.1517V137.902H147.497V82.1517H107.747ZM107.747 138.152H147.497V193.902H107.747V138.152ZM67.7466 138.152H107.497V193.902H67.7466V138.152ZM27.7466 138.152H67.4966V193.902H27.7466V138.152ZM27.7466 194.152V249.902H67.4966V194.152H27.7466ZM67.7466 194.152V249.902H107.497V194.152H67.7466ZM107.747 194.152V249.902H147.497V194.152H107.747ZM107.747 250.152H147.497V305.902H107.747V250.152ZM67.7466 250.152H107.497V305.902H67.7466V250.152ZM27.7466 250.152H67.4966V305.902H27.7466V250.152ZM27.7466 306.152V361.902H67.4966V306.152H27.7466ZM67.7466 306.152V361.902H107.497V306.152H67.7466ZM107.747 306.152V361.902H147.497V306.152H107.747ZM107.747 362.152H147.497V417.902H107.747V362.152ZM67.7466 362.152H107.497V417.902H67.7466V362.152ZM27.7466 362.152H67.4966V417.902H27.7466V362.152ZM27.7466 418.152V473.902H67.4966V418.152H27.7466ZM67.7466 418.152V473.902H107.497V418.152H67.7466ZM107.747 418.152V473.902H147.497V418.152H107.747ZM107.747 474.152H147.497V529.902H107.747V474.152ZM67.7466 474.152H107.497V529.902H67.7466V474.152ZM27.7466 474.152H67.4966V529.902H27.7466V474.152ZM27.7466 530.152V585.902H67.4966V530.152H27.7466ZM67.7466 530.152V585.902H107.497V530.152H67.7466ZM107.747 530.152V585.902H147.497V530.152H107.747ZM107.747 586.152H147.497V641.902H107.747V586.152ZM67.7466 586.152H107.497V641.902H67.7466V586.152ZM27.7466 586.152H67.4966V641.902H27.7466V586.152ZM27.7466 642.152V697.902H67.4966V642.152H27.7466ZM67.7466 642.152V697.902H107.497V642.152H67.7466ZM107.747 642.152V697.902H147.497V642.152H107.747ZM107.747 698.152H147.497V753.902H107.747V698.152ZM67.7466 698.152H107.497V753.902H67.7466V698.152ZM27.7466 698.152H67.4966V753.902H27.7466V698.152ZM15.2466 1591.7V1533.77L27.4966 1483.08V1538.01L15.2466 1591.7ZM15.2466 1471.4V1532.7L27.4966 1482.01V1426.95L15.2466 1471.4ZM15.2466 1470.46V1411.23L27.4966 1370.87V1426.01L15.2466 1470.46ZM15.2466 1410.37L27.4966 1370.01V1314.8L15.2466 1351.8V1410.37ZM15.2466 1351V1292.59L27.4966 1258.74V1314.01L15.2466 1351ZM15.2466 1291.85L27.4966 1258.01V1202.63L15.2466 1230.78V1291.85ZM15.2466 1230.15V1171.29L27.4966 1146.56V1202L15.2466 1230.15ZM15.2466 1170.73L27.4966 1146V1090.48L15.2466 1111.22V1170.73ZM15.2466 1110.73V1050.59L27.4966 1034.4V1089.99L15.2466 1110.73ZM15.2466 1050.17L27.4966 1033.98V978.339L15.2466 991.187V1050.17ZM15.2466 990.824V930.381L27.4966 922.26V977.977L15.2466 990.824ZM15.2466 930.081L27.4966 921.96V866.175L15.2466 870.57V930.081ZM107.747 1593.9H147.497V1538.15H107.747V1593.9ZM67.7466 1593.9H107.497V1538.15H67.7466V1593.9ZM27.7466 1593.9H67.4966V1538.15H27.7466V1593.9ZM27.7466 1537.9V1482.15H67.4966V1537.9H27.7466ZM67.7466 1537.9V1482.15H107.497V1537.9H67.7466ZM107.747 1537.9V1482.15H147.497V1537.9H107.747ZM107.747 1481.9H147.497V1426.15H107.747V1481.9ZM67.7466 1481.9H107.497V1426.15H67.7466V1481.9ZM27.7466 1481.9H67.4966V1426.15H27.7466V1481.9ZM27.7466 1425.9V1370.15H67.4966V1425.9H27.7466ZM67.7466 1425.9V1370.15H107.497V1425.9H67.7466ZM107.747 1425.9V1370.15H147.497V1425.9H107.747ZM107.747 1369.9H147.497V1314.15H107.747V1369.9ZM67.7466 1369.9H107.497V1314.15H67.7466V1369.9ZM27.7466 1369.9H67.4966V1314.15H27.7466V1369.9ZM27.7466 1313.9V1258.15H67.4966V1313.9H27.7466ZM67.7466 1313.9V1258.15H107.497V1313.9H67.7466ZM107.747 1313.9V1258.15H147.497V1313.9H107.747ZM107.747 1257.9H147.497V1202.15H107.747V1257.9ZM67.7466 1257.9H107.497V1202.15H67.7466V1257.9ZM27.7466 1257.9H67.4966V1202.15H27.7466V1257.9ZM27.7466 1201.9V1146.15H67.4966V1201.9H27.7466ZM67.7466 1201.9V1146.15H107.497V1201.9H67.7466ZM107.747 1201.9V1146.15H147.497V1201.9H107.747ZM107.747 1145.9H147.497V1090.15H107.747V1145.9ZM67.7466 1145.9H107.497V1090.15H67.7466V1145.9ZM27.7466 1145.9H67.4966V1090.15H27.7466V1145.9ZM27.7466 1089.9V1034.15H67.4966V1089.9H27.7466ZM67.7466 1089.9V1034.15H107.497V1089.9H67.7466ZM107.747 1089.9V1034.15H147.497V1089.9H107.747ZM107.747 1033.9H147.497V978.152H107.747V1033.9ZM67.7466 1033.9H107.497V978.152H67.7466V1033.9ZM27.7466 1033.9H67.4966V978.152H27.7466V1033.9ZM27.7466 977.902V922.152H67.4966V977.902H27.7466ZM67.7466 977.902V922.152H107.497V977.902H67.7466ZM107.747 977.902V922.152H147.497V977.902H107.747ZM107.747 921.902H147.497V866.152H107.747V921.902ZM67.7466 921.902H107.497V866.152H67.7466V921.902ZM27.7466 921.902H67.4966V866.152H27.7466V921.902ZM359.997 86.2846V28.3491L347.747 82.0406V136.978L359.997 86.2846ZM359.997 87.3489V148.653L347.747 193.103V138.042L359.997 87.3489ZM359.997 208.825V149.594L347.747 194.044V249.185L359.997 208.825ZM347.747 250.045L359.997 209.686V268.257L347.747 305.252V250.045ZM359.997 327.469V269.052L347.747 306.047V361.314L359.997 327.469ZM347.747 362.048L359.997 328.203V389.275L347.747 417.426V362.048ZM359.997 448.764V389.901L347.747 418.053V473.493L359.997 448.764ZM347.747 474.056L359.997 449.327V508.829L347.747 529.569V474.056ZM359.997 569.467V509.321L347.747 530.061V585.654L359.997 569.467ZM347.747 586.069L359.997 569.881V628.867L347.747 641.715V586.069ZM359.997 689.673V629.229L347.747 642.077V697.794L359.997 689.673ZM347.747 698.094L359.997 689.973V749.484L347.747 753.878V698.094ZM227.747 26.1517H267.497V81.9017H227.747V26.1517ZM267.747 26.1517H307.497V81.9017H267.747V26.1517ZM307.747 26.1517H347.497V81.9017H307.747V26.1517ZM347.497 137.902V82.1517H307.747V137.902H347.497ZM307.497 137.902V82.1517H267.747V137.902H307.497ZM267.497 137.902V82.1517H227.747V137.902H267.497ZM227.747 138.152H267.497V193.902H227.747V138.152ZM267.747 138.152H307.497V193.902H267.747V138.152ZM307.747 138.152H347.497V193.902H307.747V138.152ZM347.497 249.902V194.152H307.747V249.902H347.497ZM307.497 249.902V194.152H267.747V249.902H307.497ZM267.497 249.902V194.152H227.747V249.902H267.497ZM227.747 250.152H267.497V305.902H227.747V250.152ZM267.747 250.152H307.497V305.902H267.747V250.152ZM307.747 250.152H347.497V305.902H307.747V250.152ZM347.497 361.902V306.152H307.747V361.902H347.497ZM307.497 361.902V306.152H267.747V361.902H307.497ZM267.497 361.902V306.152H227.747V361.902H267.497ZM227.747 362.152H267.497V417.902H227.747V362.152ZM267.747 362.152H307.497V417.902H267.747V362.152ZM307.747 362.152H347.497V417.902H307.747V362.152ZM347.497 473.902V418.152H307.747V473.902H347.497ZM307.497 473.902V418.152H267.747V473.902H307.497ZM267.497 473.902V418.152H227.747V473.902H267.497ZM227.747 474.152H267.497V529.902H227.747V474.152ZM267.747 474.152H307.497V529.902H267.747V474.152ZM307.747 474.152H347.497V529.902H307.747V474.152ZM347.497 585.902V530.152H307.747V585.902H347.497ZM307.497 585.902V530.152H267.747V585.902H307.497ZM267.497 585.902V530.152H227.747V585.902H267.497ZM227.747 586.152H267.497V641.902H227.747V586.152ZM267.747 586.152H307.497V641.902H267.747V586.152ZM307.747 586.152H347.497V641.902H307.747V586.152ZM347.497 697.902V642.152H307.747V697.902H347.497ZM307.497 697.902V642.152H267.747V697.902H307.497ZM267.497 697.902V642.152H227.747V697.902H267.497ZM227.747 698.152H267.497V753.902H227.747V698.152ZM267.747 698.152H307.497V753.902H267.747V698.152ZM307.747 698.152H347.497V753.902H307.747V698.152ZM359.997 1591.7V1533.77L347.747 1483.08V1538.01L359.997 1591.7ZM359.997 1471.4V1532.7L347.747 1482.01V1426.95L359.997 1471.4ZM359.997 1470.46V1411.23L347.747 1370.87V1426.01L359.997 1470.46ZM359.997 1410.37L347.747 1370.01V1314.8L359.997 1351.8V1410.37ZM359.997 1351V1292.59L347.747 1258.74V1314.01L359.997 1351ZM359.997 1291.85L347.747 1258.01V1202.63L359.997 1230.78V1291.85ZM359.997 1230.15V1171.29L347.747 1146.56V1202L359.997 1230.15ZM359.997 1170.73L347.747 1146V1090.48L359.997 1111.22V1170.73ZM359.997 1110.73V1050.59L347.747 1034.4V1089.99L359.997 1110.73ZM359.997 1050.17L347.747 1033.98V978.339L359.997 991.187V1050.17ZM359.997 990.824V930.381L347.747 922.26V977.977L359.997 990.824ZM359.997 930.081L347.747 921.96V866.175L359.997 870.57V930.081ZM267.497 1593.9H227.747V1538.15H267.497V1593.9ZM307.497 1593.9H267.747V1538.15H307.497V1593.9ZM347.497 1593.9H307.747V1538.15H347.497V1593.9ZM347.497 1537.9V1482.15H307.747V1537.9H347.497ZM307.497 1537.9V1482.15H267.747V1537.9H307.497ZM267.497 1537.9V1482.15H227.747V1537.9H267.497ZM267.497 1481.9H227.747V1426.15H267.497V1481.9ZM307.497 1481.9H267.747V1426.15H307.497V1481.9ZM347.497 1481.9H307.747V1426.15H347.497V1481.9ZM347.497 1425.9V1370.15H307.747V1425.9H347.497ZM307.497 1425.9V1370.15H267.747V1425.9H307.497ZM267.497 1425.9V1370.15H227.747V1425.9H267.497ZM267.497 1369.9H227.747V1314.15H267.497V1369.9ZM307.497 1369.9H267.747V1314.15H307.497V1369.9ZM347.497 1369.9H307.747V1314.15H347.497V1369.9ZM347.497 1313.9V1258.15H307.747V1313.9H347.497ZM307.497 1313.9V1258.15H267.747V1313.9H307.497ZM267.497 1313.9V1258.15H227.747V1313.9H267.497ZM267.497 1257.9H227.747V1202.15H267.497V1257.9ZM307.497 1257.9H267.747V1202.15H307.497V1257.9ZM347.497 1257.9H307.747V1202.15H347.497V1257.9ZM347.497 1201.9V1146.15H307.747V1201.9H347.497ZM307.497 1201.9V1146.15H267.747V1201.9H307.497ZM267.497 1201.9V1146.15H227.747V1201.9H267.497ZM267.497 1145.9H227.747V1090.15H267.497V1145.9ZM307.497 1145.9H267.747V1090.15H307.497V1145.9ZM347.497 1145.9H307.747V1090.15H347.497V1145.9ZM347.497 1089.9V1034.15H307.747V1089.9H347.497ZM307.497 1089.9V1034.15H267.747V1089.9H307.497ZM267.497 1089.9V1034.15H227.747V1089.9H267.497ZM267.497 1033.9H227.747V978.152H267.497V1033.9ZM307.497 1033.9H267.747V978.152H307.497V1033.9ZM347.497 1033.9H307.747V978.152H347.497V1033.9ZM347.497 977.902V922.152H307.747V977.902H347.497ZM307.497 977.902V922.152H267.747V977.902H307.497ZM267.497 977.902V922.152H227.747V977.902H267.497ZM267.497 921.902H227.747V866.152H267.497V921.902ZM307.497 921.902H267.747V866.152H307.497V921.902ZM347.497 921.902H307.747V866.152H347.497V921.902Z" fill="#2FC654"/>
</svg>
`,
	__vite_glob_0_24 = `<svg width="375" height="696" viewBox="0 0 375 696" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_4521_20075)">
<g style="mix-blend-mode:lighten">
<path d="M314.67 635.39L326.087 644.685L337.504 653.981L323.745 659.22L309.987 664.46L312.329 649.925L314.67 635.39Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M354.128 622.259L359.371 629.639L364.614 637.02L355.601 637.87L346.588 638.721L350.358 630.49L354.128 622.259Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M373.128 571.259L378.371 578.639L383.614 586.02L374.601 586.87L365.588 587.721L369.358 579.49L373.128 571.259Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M372.038 610.674L378.669 616.838L385.3 623.002L376.646 625.663L367.993 628.323L370.016 619.499L372.038 610.674Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M354.328 643.826L357.106 650.023L359.883 656.221L353.127 655.528L346.372 654.835L350.35 649.33L354.328 643.826Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M368.07 615.876L373.792 628.641L379.513 641.406L365.598 639.978L351.682 638.551L359.876 627.214L368.07 615.876Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M349.657 586.502L354.849 590.88L360.041 595.258L353.654 597.565L347.266 599.873L348.462 593.188L349.657 586.502Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M363.725 547.632L367.025 552.732L370.325 557.832L364.259 558.14L358.192 558.448L360.959 553.04L363.725 547.632Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M372.725 510.632L376.025 515.732L379.325 520.832L373.259 521.14L367.192 521.448L369.959 516.04L372.725 510.632Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M351.725 508.632L355.025 513.732L358.325 518.832L352.259 519.14L346.192 519.448L348.959 514.04L351.725 508.632Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M377.725 505.632L381.025 510.732L384.325 515.832L378.259 516.14L372.192 516.448L374.959 511.04L377.725 505.632Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M366.361 620.324L371.205 625.168L376.049 630.012L369.432 631.785L362.815 633.558L364.588 626.941L366.361 620.324Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M376.571 563.279L379.217 569.598L381.863 575.917L375.068 575.049L368.272 574.181L372.422 568.73L376.571 563.279Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M358.202 653.779L365.199 660.713L372.196 667.646L362.693 670.239L353.19 672.832L355.696 663.305L358.202 653.779Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M363.592 660.077L378.748 665.198L393.904 670.319L381.891 680.884L369.878 691.449L366.735 675.763L363.592 660.077Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M371.757 679.242L381.923 691.594L392.09 703.946L376.309 706.575L360.529 709.203L366.143 694.222L371.757 679.242Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M357.092 685.092L363.599 699.707L370.106 714.321L354.196 712.649L338.285 710.977L347.689 698.034L357.092 685.092Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M302.814 678.647L307.569 689.255L312.324 699.864L300.759 698.678L289.194 697.492L296.004 688.069L302.814 678.647Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M345.938 661.891L355.252 665.096L364.567 668.3L357.134 674.765L349.701 681.229L347.82 671.56L345.938 661.891Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M337.747 664.347L344.942 666.822L352.136 669.298L346.395 674.291L340.654 679.283L339.201 671.815L337.747 664.347Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M286.038 648.902L291.809 650.887L297.58 652.873L292.975 656.878L288.37 660.883L287.204 654.892L286.038 648.902Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M329.132 603.34L333.259 607.837L337.386 612.333L331.428 613.659L325.471 614.984L327.301 609.162L329.132 603.34Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M359.259 600.75L361.002 604.482L362.746 608.214L358.642 607.858L354.538 607.502L356.899 604.126L359.259 600.75Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M358.157 562.723L360.728 565.942L363.299 569.161L359.226 569.778L355.153 570.395L356.655 566.559L358.157 562.723Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M346.14 687.126L349.515 691.932L352.891 696.739L347.041 697.258L341.191 697.778L343.666 692.452L346.14 687.126Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M323.058 683.69L327.612 687.398L332.167 691.106L326.678 693.196L321.19 695.287L322.124 689.488L323.058 683.69Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M327.374 662.151L328.901 666.304L330.429 670.457L326.069 669.703L321.709 668.95L324.541 665.551L327.374 662.151Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M339.496 618.138L341.025 622.294L342.553 626.45L338.19 625.696L333.826 624.942L336.661 621.54L339.496 618.138Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M346.415 558.219L349.477 561.418L352.538 564.618L348.237 565.669L343.935 566.721L345.175 562.47L346.415 558.219Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M368.442 471.188L372.564 472.806L376.686 474.424L373.223 477.185L369.761 479.946L369.101 475.567L368.442 471.188Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M319.901 668.27L323.113 670.885L326.324 673.5L322.454 674.974L318.583 676.448L319.242 672.359L319.901 668.27Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M344.635 636.044L352.078 651.238L359.522 666.431L342.642 665.281L325.763 664.13L335.199 650.087L344.635 636.044Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M366.208 532.674L376.017 536.627L385.825 540.581L377.497 547.099L369.169 553.617L367.688 543.145L366.208 532.674Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M353.982 572.863L362.409 576.26L370.835 579.656L363.681 585.256L356.526 590.855L355.254 581.859L353.982 572.863Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M372.434 523.24L379.612 528.809L386.791 534.378L378.379 537.81L369.966 541.243L371.2 532.241L372.434 523.24Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M360.628 598.596L372.773 603.491L384.919 608.386L374.607 616.457L364.295 624.528L362.461 611.562L360.628 598.596Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M378.26 581.128L388 589.88L397.741 598.632L385.291 602.691L372.841 606.751L375.55 593.939L378.26 581.128Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M362.092 678.188L367.838 689.916L373.584 701.644L360.554 700.756L347.525 699.868L354.809 689.028L362.092 678.188Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M308.711 690.032L319.787 696.953L330.862 703.874L319.331 710.005L307.8 716.136L308.255 703.084L308.711 690.032Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M337.061 671.746L348.294 683.355L359.527 694.964L343.857 698.887L328.187 702.81L332.624 687.278L337.061 671.746Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M338.392 686.259L343.201 700.155L348.009 714.051L333.571 711.267L319.132 708.484L328.762 697.372L338.392 686.259Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M306.047 660.907L312.372 669.383L318.696 677.859L308.194 679.098L297.691 680.338L301.869 670.622L306.047 660.907Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M370.848 638.708L377.172 647.184L383.497 655.66L372.994 656.899L362.492 658.139L366.67 648.423L370.848 638.708Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M362.31 671.287L370.287 678.23L378.265 685.172L368.263 688.61L358.262 692.047L360.286 681.667L362.31 671.287Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M335.227 667.678L338.858 674.794L342.489 681.909L334.511 681.496L326.534 681.082L330.88 674.38L335.227 667.678Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M281.887 691.754L285.517 698.869L289.148 705.985L281.171 705.571L273.193 705.158L277.54 698.456L281.887 691.754Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M271.341 670.688L277.977 675.134L284.613 679.581L277.444 683.104L270.275 686.628L270.808 678.658L271.341 670.688Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M255.971 677.011L258.984 683.629L261.998 690.246L254.76 689.547L247.523 688.848L251.747 682.93L255.971 677.011Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M295.622 665.66L300.689 670.696L305.756 675.732L298.861 677.602L291.966 679.472L293.794 672.566L295.622 665.66Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M366.548 583.857L370.258 587.544L373.967 591.231L368.919 592.6L363.872 593.969L365.21 588.913L366.548 583.857Z" fill="#1AB7E8" fill-opacity="0.4"/>
</g>
<g style="mix-blend-mode:lighten">
<path d="M312.67 68.3761L324.087 59.0805L335.504 49.7849L321.745 44.5456L307.987 39.3062L310.329 53.8412L312.67 68.3761Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M352.128 81.507L357.371 74.1266L362.614 66.7462L353.601 65.8955L344.588 65.0449L348.358 73.276L352.128 81.507Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M371.128 132.507L376.371 125.127L381.614 117.746L372.601 116.896L363.588 116.045L367.358 124.276L371.128 132.507Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M370.038 93.0917L376.669 86.9276L383.3 80.7635L374.646 78.1032L365.993 75.4429L368.016 84.2673L370.038 93.0917Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M352.328 59.9398L355.106 53.7425L357.883 47.5453L351.127 48.2383L344.372 48.9313L348.35 54.4355L352.328 59.9398Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M366.07 87.8895L371.792 75.1247L377.513 62.36L363.598 63.7875L349.682 65.2149L357.876 76.5522L366.07 87.8895Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M347.657 117.263L352.849 112.886L358.041 108.508L351.654 106.2L345.266 103.893L346.462 110.578L347.657 117.263Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M361.725 156.134L365.025 151.034L368.325 145.934L362.259 145.626L356.192 145.318L358.959 150.726L361.725 156.134Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M370.725 193.134L374.025 188.034L377.325 182.934L371.259 182.626L365.192 182.318L367.959 187.726L370.725 193.134Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M349.725 195.134L353.025 190.034L356.325 184.934L350.259 184.626L344.192 184.318L346.959 189.726L349.725 195.134Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M375.725 198.134L379.025 193.034L382.325 187.934L376.259 187.626L370.192 187.318L372.959 192.726L375.725 198.134Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M364.361 83.4418L369.205 78.5977L374.049 73.7536L367.432 71.9806L360.815 70.2075L362.588 76.8246L364.361 83.4418Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M374.571 140.487L377.217 134.168L379.863 127.849L373.068 128.717L366.272 129.585L370.422 135.036L374.571 140.487Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M356.202 49.9867L363.199 43.0531L370.196 36.1195L360.693 33.5268L351.19 30.9341L353.696 40.4604L356.202 49.9867Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M361.592 43.6888L376.748 38.568L391.904 33.4472L379.891 22.882L367.878 12.3167L364.735 28.0027L361.592 43.6888Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M369.757 24.524L379.923 12.1718L390.09 -0.180359L374.309 -2.80867L358.529 -5.43698L364.143 9.5435L369.757 24.524Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M355.092 18.6741L361.599 4.0593L368.106 -10.5555L352.196 -8.88327L336.285 -7.21103L345.689 5.73154L355.092 18.6741Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M300.814 25.1192L305.569 14.5104L310.324 3.90168L298.759 5.08803L287.194 6.27437L294.004 15.6968L300.814 25.1192Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M343.938 41.8752L353.252 38.6704L362.567 35.4656L355.134 29.0014L347.701 22.5371L345.82 32.2062L343.938 41.8752Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M335.747 39.4189L342.942 36.9436L350.136 34.4682L344.395 29.4753L338.654 24.4824L337.201 31.9507L335.747 39.4189Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M284.038 54.8643L289.809 52.8787L295.58 50.893L290.975 46.8879L286.37 42.8827L285.204 48.8735L284.038 54.8643Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M327.132 100.426L331.259 95.9293L335.386 91.4327L329.428 90.1072L323.471 88.7817L325.301 94.6038L327.132 100.426Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M357.259 103.016L359.002 99.2841L360.746 95.5521L356.642 95.908L352.538 96.2639L354.899 99.64L357.259 103.016Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M356.157 141.042L358.728 137.824L361.299 134.605L357.226 133.988L353.153 133.371L354.655 137.207L356.157 141.042Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M344.14 16.64L347.515 11.8337L350.891 7.02733L345.041 6.5076L339.191 5.98786L341.666 11.3139L344.14 16.64Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M321.058 20.0758L325.612 16.3677L330.167 12.6595L324.678 10.5695L319.19 8.4794L320.124 14.2776L321.058 20.0758Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M325.374 41.6145L326.901 37.4619L328.429 33.3094L324.069 34.0628L319.709 34.8162L322.541 38.2153L325.374 41.6145Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M337.496 85.6279L339.025 81.4719L340.553 77.3158L336.19 78.0699L331.826 78.8239L334.661 82.2259L337.496 85.6279Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M344.415 145.547L347.477 142.348L350.538 139.148L346.237 138.096L341.935 137.045L343.175 141.296L344.415 145.547Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M366.442 232.578L370.564 230.96L374.686 229.342L371.223 226.581L367.761 223.82L367.101 228.199L366.442 232.578Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M317.901 35.4959L321.113 32.881L324.324 30.2661L320.454 28.7923L316.583 27.3184L317.242 31.4071L317.901 35.4959Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M342.635 67.7217L350.078 52.5282L357.522 37.3347L340.642 38.485L323.763 39.6354L333.199 53.6785L342.635 67.7217Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M364.208 171.092L374.017 167.139L383.825 163.185L375.497 156.667L367.169 150.149L365.688 160.621L364.208 171.092Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M351.982 130.902L360.409 127.506L368.835 124.11L361.681 118.51L354.526 112.91L353.254 121.906L351.982 130.902Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M370.434 180.526L377.612 174.957L384.791 169.388L376.379 165.956L367.966 162.523L369.2 171.525L370.434 180.526Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M358.628 105.17L370.773 100.275L382.919 95.3795L372.607 87.3087L362.295 79.2378L360.461 92.2039L358.628 105.17Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M376.26 122.638L386 113.886L395.741 105.134L383.291 101.075L370.841 97.0151L373.55 109.827L376.26 122.638Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M360.092 25.5778L365.838 13.8499L371.584 2.12197L358.554 3.00991L345.525 3.89785L352.809 14.7378L360.092 25.5778Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M306.711 13.7336L317.787 6.813L328.862 -0.107638L317.331 -6.23884L305.8 -12.37L306.255 0.681796L306.711 13.7336Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M335.061 32.0199L346.294 20.4111L357.527 8.80225L341.857 4.87886L326.187 0.955464L330.624 16.4877L335.061 32.0199Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M336.392 17.5065L341.201 3.61069L346.009 -10.2851L331.571 -7.50142L317.132 -4.71776L326.762 6.39435L336.392 17.5065Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M304.047 42.8587L310.372 34.3828L316.696 25.907L306.194 24.6676L295.691 23.4282L299.869 33.1434L304.047 42.8587Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M368.848 65.0579L375.172 56.582L381.497 48.1062L370.994 46.8668L360.492 45.6274L364.67 55.3427L368.848 65.0579Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M360.31 32.479L368.287 25.5363L376.265 18.5935L366.263 15.1562L356.262 11.719L358.286 22.099L360.31 32.479Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M333.227 36.0876L336.858 28.9723L340.489 21.857L332.511 22.2702L324.534 22.6835L328.88 29.3855L333.227 36.0876Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M279.887 12.0119L283.517 4.89664L287.148 -2.21866L279.171 -1.8054L271.193 -1.39213L275.54 5.3099L279.887 12.0119Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M269.341 33.0783L275.977 28.6318L282.613 24.1853L275.444 20.6614L268.275 17.1376L268.808 25.108L269.341 33.0783Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M253.971 26.7545L256.984 20.1374L259.998 13.5202L252.76 14.219L245.523 14.9177L249.747 20.8361L253.971 26.7545Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M293.622 38.1063L298.689 33.0703L303.756 28.0342L296.861 26.1643L289.966 24.2944L291.794 31.2003L293.622 38.1063Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M364.548 119.908L368.258 116.222L371.967 112.535L366.919 111.166L361.872 109.797L363.21 114.853L364.548 119.908Z" fill="#1AB7E8" fill-opacity="0.4"/>
</g>
<g style="mix-blend-mode:lighten">
<path d="M60.34 634.39L48.9233 643.685L37.5066 652.981L51.2652 658.22L65.0237 663.46L62.6819 648.925L60.34 634.39Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M20.8827 621.259L15.6394 628.639L10.3961 636.02L19.4094 636.87L28.4226 637.721L24.6527 629.49L20.8827 621.259Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M1.88267 570.259L-3.3606 577.639L-8.60387 585.02L0.409385 585.87L9.42264 586.721L5.65266 578.49L1.88267 570.259Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M2.97204 609.674L-3.65865 615.838L-10.2893 622.002L-1.63571 624.663L7.01792 627.323L4.99498 618.499L2.97204 609.674Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M20.6827 642.826L17.9049 649.023L15.1272 655.221L21.883 654.528L28.6389 653.835L24.6608 648.33L20.6827 642.826Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M6.94034 614.876L1.21889 627.641L-4.50255 640.406L9.41274 638.978L23.328 637.551L15.1342 626.214L6.94034 614.876Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M25.3534 585.502L20.1614 589.88L14.9695 594.258L21.3568 596.565L27.7441 598.873L26.5487 592.188L25.3534 585.502Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M11.2854 546.632L7.98538 551.732L4.68538 556.832L10.7518 557.14L16.8182 557.448L14.0518 552.04L11.2854 546.632Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M2.28539 509.632L-1.01462 514.732L-4.31462 519.832L1.75179 520.14L7.81821 520.448L5.0518 515.04L2.28539 509.632Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M23.2854 507.632L19.9854 512.732L16.6854 517.832L22.7518 518.14L28.8182 518.448L26.0518 513.04L23.2854 507.632Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M-2.71461 504.632L-6.01462 509.732L-9.31462 514.832L-3.24821 515.14L2.81821 515.448L0.0517993 510.04L-2.71461 504.632Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M8.6495 619.324L3.80544 624.168L-1.03862 629.012L5.57849 630.785L12.1956 632.558L10.4226 625.941L8.6495 619.324Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M-1.56043 562.279L-4.20656 568.598L-6.85268 574.917L-0.0573308 574.049L6.73802 573.181L2.58879 567.73L-1.56043 562.279Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M16.8085 652.779L9.81161 659.713L2.81472 666.646L12.3179 669.239L21.821 671.832L19.3147 662.305L16.8085 652.779Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M11.4189 659.077L-3.73734 664.198L-18.8935 669.319L-6.88072 679.884L5.1321 690.449L8.27548 674.763L11.4189 659.077Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M3.25384 678.242L-6.9126 690.594L-17.079 702.946L-1.29852 705.575L14.482 708.203L8.86792 693.222L3.25384 678.242Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M17.9185 684.092L11.4116 698.707L4.90462 713.321L20.8149 711.649L36.7251 709.977L27.3218 697.034L17.9185 684.092Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M72.1962 677.647L67.4411 688.255L62.686 698.864L74.251 697.678L85.816 696.492L79.0061 687.069L72.1962 677.647Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M29.0727 660.891L19.7582 664.096L10.4436 667.3L17.8764 673.765L25.3091 680.229L27.1909 670.56L29.0727 660.891Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M37.2631 663.347L30.0686 665.822L22.8742 668.298L28.6151 673.291L34.356 678.283L35.8096 670.815L37.2631 663.347Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M88.9724 647.902L83.2013 649.887L77.4301 651.873L82.0353 655.878L86.6405 659.883L87.8065 653.892L88.9724 647.902Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M45.8782 602.34L41.7515 606.837L37.6248 611.333L43.5823 612.659L49.5399 613.984L47.709 608.162L45.8782 602.34Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M15.7518 599.75L14.0081 603.482L12.2644 607.214L16.3682 606.858L20.4721 606.502L18.1119 603.126L15.7518 599.75Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M16.8533 561.723L14.2825 564.942L11.7117 568.161L15.7845 568.778L19.8573 569.395L18.3553 565.559L16.8533 561.723Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M28.8701 686.126L25.495 690.932L22.12 695.739L27.9699 696.258L33.8198 696.778L31.345 691.452L28.8701 686.126Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M51.9525 682.69L47.3982 686.398L42.8439 690.106L48.3324 692.196L53.8209 694.287L52.8867 688.488L51.9525 682.69Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M47.6369 661.151L46.1094 665.304L44.5819 669.457L48.9418 668.703L53.3018 667.95L50.4694 664.551L47.6369 661.151Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M35.5148 617.138L33.986 621.294L32.4572 625.45L36.8208 624.696L41.1844 623.942L38.3496 620.54L35.5148 617.138Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M28.5953 557.219L25.5338 560.418L22.4723 563.618L26.7739 564.669L31.0756 565.721L29.8354 561.47L28.5953 557.219Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M6.56913 470.188L2.44707 471.806L-1.67499 473.424L1.78739 476.185L5.24977 478.946L5.90945 474.567L6.56913 470.188Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M55.1096 667.27L51.898 669.885L48.6864 672.5L52.5568 673.974L56.4271 675.448L55.7683 671.359L55.1096 667.27Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M30.3758 635.044L22.9321 650.238L15.4884 665.431L32.3682 664.281L49.248 663.13L39.8119 649.087L30.3758 635.044Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M8.80275 531.674L-1.00604 535.627L-10.8148 539.581L-2.48674 546.099L5.84134 552.617L7.32204 542.145L8.80275 531.674Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M21.0287 571.863L12.602 575.26L4.17519 578.656L11.3299 584.256L18.4846 589.855L19.7567 580.859L21.0287 571.863Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M2.5767 522.24L-4.60183 527.809L-11.7804 533.378L-3.36815 536.81L5.04406 540.243L3.81038 531.241L2.5767 522.24Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M14.3828 597.596L2.23721 602.491L-9.90841 607.386L0.403745 615.457L10.7159 623.528L12.5494 610.562L14.3828 597.596Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M-3.24919 580.128L-12.9897 588.88L-22.7302 597.632L-10.2803 601.691L2.16954 605.751L-0.539821 592.939L-3.24919 580.128Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M12.9182 677.188L7.17235 688.916L1.42655 700.644L14.4561 699.756L27.4857 698.868L20.2019 688.028L12.9182 677.188Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M66.2993 689.032L55.224 695.953L44.1487 702.874L55.6798 709.005L67.2109 715.136L66.7551 702.084L66.2993 689.032Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M37.9492 670.746L26.7165 682.355L15.4838 693.964L31.1537 697.887L46.8236 701.81L42.3864 686.278L37.9492 670.746Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M36.6184 685.259L31.8099 699.155L27.0015 713.051L41.4398 710.267L55.8781 707.484L46.2483 696.372L36.6184 685.259Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M68.9635 659.907L62.6388 668.383L56.3142 676.859L66.8168 678.098L77.3194 679.338L73.1414 669.622L68.9635 659.907Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M4.16268 637.708L-2.16196 646.184L-8.4866 654.66L2.01602 655.899L12.5186 657.139L8.34067 647.423L4.16268 637.708Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M12.7005 670.287L4.72312 677.23L-3.25428 684.172L6.74705 687.61L16.7484 691.047L14.7244 680.667L12.7005 670.287Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M39.7836 666.678L36.1528 673.794L32.5219 680.909L40.4994 680.496L48.4768 680.082L44.1302 673.38L39.7836 666.678Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M93.1239 690.754L89.4931 697.869L85.8623 704.985L93.8397 704.571L101.817 704.158L97.4705 697.456L93.1239 690.754Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M103.67 669.688L97.0337 674.134L90.3976 678.581L97.5664 682.104L104.735 685.628L104.203 677.658L103.67 669.688Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M119.04 676.011L116.026 682.629L113.013 689.246L120.25 688.547L127.487 687.848L123.264 681.93L119.04 676.011Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M79.3882 664.66L74.3214 669.696L69.2547 674.732L76.1494 676.602L83.0441 678.472L81.2161 671.566L79.3882 664.66Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M8.46212 582.857L4.75296 586.544L1.04379 590.231L6.09112 591.6L11.1385 592.969L9.80029 587.913L8.46212 582.857Z" fill="#1AB7E8" fill-opacity="0.4"/>
</g>
<g style="mix-blend-mode:lighten">
<path d="M59.34 71.3761L47.9233 62.0805L36.5066 52.7849L50.2652 47.5456L64.0237 42.3062L61.6819 56.8412L59.34 71.3761Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M19.8827 84.507L14.6394 77.1266L9.39613 69.7462L18.4094 68.8955L27.4226 68.0449L23.6527 76.276L19.8827 84.507Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M0.882669 135.507L-4.3606 128.127L-9.60387 120.746L-0.590615 119.896L8.42264 119.045L4.65266 127.276L0.882669 135.507Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M1.97204 96.0917L-4.65865 89.9276L-11.2893 83.7635L-2.63571 81.1032L6.01792 78.4429L3.99498 87.2673L1.97204 96.0917Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M19.6827 62.9398L16.9049 56.7425L14.1272 50.5453L20.883 51.2383L27.6389 51.9313L23.6608 57.4355L19.6827 62.9398Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M5.94034 90.8895L0.218892 78.1247L-5.50255 65.36L8.41274 66.7875L22.328 68.2149L14.1342 79.5522L5.94034 90.8895Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M24.3534 120.263L19.1614 115.886L13.9695 111.508L20.3568 109.2L26.7441 106.893L25.5487 113.578L24.3534 120.263Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M10.2854 159.134L6.98538 154.034L3.68538 148.934L9.75179 148.626L15.8182 148.318L13.0518 153.726L10.2854 159.134Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M1.28539 196.134L-2.01462 191.034L-5.31462 185.934L0.751793 185.626L6.81821 185.318L4.0518 190.726L1.28539 196.134Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M22.2854 198.134L18.9854 193.034L15.6854 187.934L21.7518 187.626L27.8182 187.318L25.0518 192.726L22.2854 198.134Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M-3.71461 201.134L-7.01462 196.034L-10.3146 190.934L-4.24821 190.626L1.81821 190.318L-0.948201 195.726L-3.71461 201.134Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M7.6495 86.4418L2.80544 81.5977L-2.03862 76.7536L4.57849 74.9806L11.1956 73.2075L9.42255 79.8246L7.6495 86.4418Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M-2.56043 143.487L-5.20656 137.168L-7.85268 130.849L-1.05733 131.717L5.73802 132.585L1.58879 138.036L-2.56043 143.487Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M15.8085 52.9867L8.81161 46.0531L1.81472 39.1195L11.3179 36.5268L20.821 33.9341L18.3147 43.4604L15.8085 52.9867Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M10.4189 46.6888L-4.73734 41.568L-19.8935 36.4472L-7.88072 25.882L4.1321 15.3167L7.27548 31.0027L10.4189 46.6888Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M2.25384 27.524L-7.9126 15.1718L-18.079 2.81964L-2.29852 0.19133L13.482 -2.43698L7.86792 12.5435L2.25384 27.524Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M16.9185 21.6741L10.4116 7.0593L3.90462 -7.5555L19.8149 -5.88327L35.7251 -4.21103L26.3218 8.73154L16.9185 21.6741Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M71.1962 28.1192L66.4411 17.5104L61.686 6.90168L73.251 8.08803L84.816 9.27437L78.0061 18.6968L71.1962 28.1192Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M28.0727 44.8752L18.7582 41.6704L9.44365 38.4656L16.8764 32.0014L24.3091 25.5371L26.1909 35.2062L28.0727 44.8752Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M36.2631 42.4189L29.0686 39.9436L21.8742 37.4682L27.6151 32.4753L33.356 27.4824L34.8096 34.9507L36.2631 42.4189Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M87.9724 57.8643L82.2013 55.8787L76.4301 53.893L81.0353 49.8879L85.6405 45.8827L86.8065 51.8735L87.9724 57.8643Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M44.8782 103.426L40.7515 98.9293L36.6248 94.4327L42.5823 93.1072L48.5399 91.7817L46.709 97.6038L44.8782 103.426Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M14.7518 106.016L13.0081 102.284L11.2644 98.5521L15.3682 98.908L19.4721 99.2639L17.1119 102.64L14.7518 106.016Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M15.8533 144.042L13.2825 140.824L10.7117 137.605L14.7845 136.988L18.8573 136.371L17.3553 140.207L15.8533 144.042Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M27.8701 19.64L24.495 14.8337L21.12 10.0273L26.9699 9.5076L32.8198 8.98786L30.345 14.3139L27.8701 19.64Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M50.9525 23.0758L46.3982 19.3677L41.8439 15.6595L47.3324 13.5695L52.8209 11.4794L51.8867 17.2776L50.9525 23.0758Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M46.6369 44.6145L45.1094 40.4619L43.5819 36.3094L47.9418 37.0628L52.3018 37.8162L49.4694 41.2153L46.6369 44.6145Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M34.5148 88.6279L32.986 84.4719L31.4572 80.3158L35.8208 81.0699L40.1844 81.8239L37.3496 85.2259L34.5148 88.6279Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M27.5953 148.547L24.5338 145.348L21.4723 142.148L25.7739 141.096L30.0756 140.045L28.8354 144.296L27.5953 148.547Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M5.56913 235.578L1.44707 233.96L-2.67499 232.342L0.787387 229.581L4.24977 226.82L4.90945 231.199L5.56913 235.578Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M54.1096 38.4959L50.898 35.881L47.6864 33.2661L51.5568 31.7923L55.4271 30.3184L54.7683 34.4071L54.1096 38.4959Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M29.3758 70.7217L21.9321 55.5282L14.4884 40.3347L31.3682 41.485L48.248 42.6354L38.8119 56.6785L29.3758 70.7217Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M7.80275 174.092L-2.00604 170.139L-11.8148 166.185L-3.48674 159.667L4.84134 153.149L6.32204 163.621L7.80275 174.092Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M20.0287 133.902L11.602 130.506L3.17519 127.11L10.3299 121.51L17.4846 115.91L18.7567 124.906L20.0287 133.902Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M1.5767 183.526L-5.60183 177.957L-12.7804 172.388L-4.36815 168.956L4.04406 165.523L2.81038 174.525L1.5767 183.526Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M13.3828 108.17L1.23721 103.275L-10.9084 98.3795L-0.596255 90.3087L9.7159 82.2378L11.5494 95.2039L13.3828 108.17Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M-4.24919 125.638L-13.9897 116.886L-23.7302 108.134L-11.2803 104.075L1.16954 100.015L-1.53982 112.827L-4.24919 125.638Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M11.9182 28.5778L6.17235 16.8499L0.426551 5.12197L13.4561 6.00991L26.4857 6.89785L19.2019 17.7378L11.9182 28.5778Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M65.2993 16.7336L54.224 9.813L43.1487 2.89236L54.6798 -3.23884L66.2109 -9.37004L65.7551 3.6818L65.2993 16.7336Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M36.9492 35.0199L25.7165 23.4111L14.4838 11.8023L30.1537 7.87886L45.8236 3.95546L41.3864 19.4877L36.9492 35.0199Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M35.6184 20.5065L30.8099 6.61069L26.0015 -7.28509L40.4398 -4.50142L54.8781 -1.71776L45.2483 9.39435L35.6184 20.5065Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M67.9635 45.8587L61.6388 37.3828L55.3142 28.907L65.8168 27.6676L76.3194 26.4282L72.1414 36.1434L67.9635 45.8587Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M3.16268 68.0579L-3.16196 59.582L-9.4866 51.1062L1.01602 49.8668L11.5186 48.6274L7.34067 58.3427L3.16268 68.0579Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M11.7005 35.479L3.72312 28.5363L-4.25428 21.5935L5.74705 18.1562L15.7484 14.719L13.7244 25.099L11.7005 35.479Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M38.7836 39.0876L35.1528 31.9723L31.5219 24.857L39.4994 25.2702L47.4768 25.6835L43.1302 32.3855L38.7836 39.0876Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M92.1239 15.0119L88.4931 7.89664L84.8623 0.781339L92.8397 1.1946L100.817 1.60787L96.4705 8.3099L92.1239 15.0119Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M102.67 36.0783L96.0337 31.6318L89.3976 27.1853L96.5664 23.6614L103.735 20.1376L103.203 28.108L102.67 36.0783Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M118.04 29.7545L115.026 23.1374L112.013 16.5202L119.25 17.219L126.487 17.9177L122.264 23.8361L118.04 29.7545Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M78.3882 41.1063L73.3214 36.0703L68.2547 31.0342L75.1494 29.1643L82.0441 27.2944L80.2161 34.2003L78.3882 41.1063Z" fill="#1AB7E8" fill-opacity="0.4"/>
<path d="M7.46212 122.908L3.75296 119.222L0.0437886 115.535L5.09112 114.166L10.1385 112.797L8.80029 117.853L7.46212 122.908Z" fill="#1AB7E8" fill-opacity="0.4"/>
</g>
</g>
<defs>
<clipPath id="clip0_4521_20075">
<rect width="376" height="696" fill="white"/>
</clipPath>
</defs>
</svg>
`,
	__vite_glob_0_25 = `<svg width="100" height="44" viewBox="0 0 100 44" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="100" height="44" fill="#1AB7E8" fill-opacity="0.6"/>
<mask id="mask0_4521_20315" style="mask-type:alpha" maskUnits="userSpaceOnUse" x="0" y="0" width="100" height="44">
<rect width="100" height="44" fill="#D9D9D9"/>
</mask>
<g mask="url(#mask0_4521_20315)">
<rect width="9.59474" height="73.8563" transform="matrix(0.86261 0.50587 -0.494153 0.869375 44.7837 -17)" fill="white" fill-opacity="0.29"/>
<rect width="6.92511" height="73.8563" transform="matrix(0.86261 0.50587 -0.494153 0.869375 32.4961 -15.6133)" fill="white" fill-opacity="0.29"/>
</g>
<g filter="url(#filter0_f_4521_20315)">
<g style="mix-blend-mode:overlay">
<path d="M77.6392 30.1921C75.5752 30.1921 74.0152 29.5041 72.9592 28.1281C71.9192 26.7361 71.3992 24.7361 71.3992 22.1281V21.0721C71.3992 18.4641 71.9192 16.4721 72.9592 15.0961C74.0152 13.7041 75.5752 13.0081 77.6392 13.0081H78.6232C80.7192 13.0081 82.2872 13.6961 83.3272 15.0721C84.3672 16.4481 84.8872 18.4481 84.8872 21.0721V22.1281C84.8872 24.7521 84.3672 26.7521 83.3272 28.1281C82.2872 29.5041 80.7192 30.1921 78.6232 30.1921H77.6392ZM78.4792 27.0721C79.3112 27.0721 79.9832 26.7441 80.4952 26.0881C81.0072 25.4321 81.2632 24.4721 81.2632 23.2081V19.9921C81.2632 18.7281 81.0072 17.7681 80.4952 17.1121C79.9832 16.4401 79.3112 16.1041 78.4792 16.1041H77.8312C76.9832 16.1041 76.3032 16.4401 75.7912 17.1121C75.2792 17.7681 75.0232 18.7281 75.0232 19.9921V23.2081C75.0232 24.4721 75.2792 25.4321 75.7912 26.0881C76.3192 26.7441 76.9992 27.0721 77.8312 27.0721H78.4792ZM82.9192 15.1681L75.9832 28.5361L73.3912 27.8641L80.2552 14.6401L82.9192 15.1681Z" fill="white" fill-opacity="0.5"/>
</g>
<g style="mix-blend-mode:overlay">
<path d="M63.458 30.1921C62.29 30.1921 61.226 29.9761 60.266 29.5441C59.322 29.0961 58.57 28.4561 58.01 27.6241C57.45 26.7921 57.17 25.8161 57.17 24.6961H60.65C60.65 25.2081 60.77 25.6481 61.01 26.0161C61.266 26.3681 61.61 26.6321 62.042 26.8081C62.474 26.9841 62.954 27.0721 63.482 27.0721C64.33 27.0721 64.994 26.8801 65.474 26.4961C65.97 26.0961 66.218 25.5521 66.218 24.8641C66.218 24.2081 65.97 23.7041 65.474 23.3521C64.994 23.0001 64.33 22.8241 63.482 22.8241H61.898V19.8721H63.41C64.066 19.8721 64.594 19.6961 64.994 19.3441C65.394 18.9761 65.594 18.5201 65.594 17.9761C65.594 17.4001 65.378 16.9441 64.946 16.6081C64.53 16.2721 63.97 16.1041 63.266 16.1041C62.546 16.1041 61.962 16.3041 61.514 16.7041C61.082 17.1041 60.866 17.6481 60.866 18.3361H57.458C57.458 17.2801 57.706 16.3521 58.202 15.5521C58.714 14.7521 59.41 14.1281 60.29 13.6801C61.186 13.2321 62.21 13.0081 63.362 13.0081C64.45 13.0081 65.426 13.2081 66.29 13.6081C67.17 13.9921 67.858 14.5361 68.354 15.2401C68.85 15.9281 69.098 16.6961 69.098 17.5441C69.098 18.2961 68.906 19.0081 68.522 19.6801C68.154 20.3361 67.682 20.8241 67.106 21.1441C67.922 21.4321 68.57 21.8961 69.05 22.5361C69.546 23.1761 69.794 23.9681 69.794 24.9121C69.794 25.9521 69.522 26.8721 68.978 27.6721C68.434 28.4721 67.682 29.0961 66.722 29.5441C65.762 29.9761 64.674 30.1921 63.458 30.1921Z" fill="white" fill-opacity="0.5"/>
</g>
<g style="mix-blend-mode:overlay">
<path d="M53.4 18.072V21.528H49.8V18.072H53.4ZM53.4 26.544V30H49.8V26.544H53.4Z" fill="white" fill-opacity="0.5"/>
</g>
<g style="mix-blend-mode:overlay">
<path d="M39.54 30.1921C37.476 30.1921 35.916 29.5041 34.86 28.1281C33.82 26.7361 33.3 24.7361 33.3 22.1281V21.0721C33.3 18.4641 33.82 16.4721 34.86 15.0961C35.916 13.7041 37.476 13.0081 39.54 13.0081H40.524C42.62 13.0081 44.188 13.6961 45.228 15.0721C46.268 16.4481 46.788 18.4481 46.788 21.0721V22.1281C46.788 24.7521 46.268 26.7521 45.228 28.1281C44.188 29.5041 42.62 30.1921 40.524 30.1921H39.54ZM40.38 27.0721C41.212 27.0721 41.884 26.7441 42.396 26.0881C42.908 25.4321 43.164 24.4721 43.164 23.2081V19.9921C43.164 18.7281 42.908 17.7681 42.396 17.1121C41.884 16.4401 41.212 16.1041 40.38 16.1041H39.732C38.884 16.1041 38.204 16.4401 37.692 17.1121C37.18 17.7681 36.924 18.7281 36.924 19.9921V23.2081C36.924 24.4721 37.18 25.4321 37.692 26.0881C38.22 26.7441 38.9 27.0721 39.732 27.0721H40.38ZM44.82 15.1681L37.884 28.5361L35.292 27.8641L42.156 14.6401L44.82 15.1681Z" fill="white" fill-opacity="0.5"/>
</g>
<g style="mix-blend-mode:overlay">
<path d="M23.44 30.1921C21.376 30.1921 19.816 29.5041 18.76 28.1281C17.72 26.7361 17.2 24.7361 17.2 22.1281V21.0721C17.2 18.4641 17.72 16.4721 18.76 15.0961C19.816 13.7041 21.376 13.0081 23.44 13.0081H24.424C26.52 13.0081 28.088 13.6961 29.128 15.0721C30.168 16.4481 30.688 18.4481 30.688 21.0721V22.1281C30.688 24.7521 30.168 26.7521 29.128 28.1281C28.088 29.5041 26.52 30.1921 24.424 30.1921H23.44ZM24.28 27.0721C25.112 27.0721 25.784 26.7441 26.296 26.0881C26.808 25.4321 27.064 24.4721 27.064 23.2081V19.9921C27.064 18.7281 26.808 17.7681 26.296 17.1121C25.784 16.4401 25.112 16.1041 24.28 16.1041H23.632C22.784 16.1041 22.104 16.4401 21.592 17.1121C21.08 17.7681 20.824 18.7281 20.824 19.9921V23.2081C20.824 24.4721 21.08 25.4321 21.592 26.0881C22.12 26.7441 22.8 27.0721 23.632 27.0721H24.28ZM28.72 15.1681L21.784 28.5361L19.192 27.8641L26.056 14.6401L28.72 15.1681Z" fill="white" fill-opacity="0.5"/>
</g>
</g>
<defs>
<filter id="filter0_f_4521_20315" x="5.19995" y="1.00806" width="91.6872" height="41.184" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feGaussianBlur stdDeviation="6" result="effect1_foregroundBlur_4521_20315"/>
</filter>
</defs>
</svg>
`,
	__vite_glob_0_26 = `<svg width="344" height="144" viewBox="0 0 344 144" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.6">
<path d="M407.059 -8.27966L319.428 21.7965L24.5729 21.8005L-62.9277 -8.20457" stroke="#2FC654" stroke-width="0.25" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M407.059 72.5757L323.82 72.5036H24.5729L-62.9277 72.5827" stroke="#2FC654" stroke-width="0.25" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M407.059 153.432L319.434 123.209H24.5729L-62.9277 153.367" stroke="#2FC654" stroke-width="0.25" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M331.425 395.647V-250.904" stroke="#2FC654" stroke-width="0.25" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M24.5738 395.647V-250.904" stroke="#2FC654" stroke-width="0.25" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M319.428 395.647V-250.904" stroke="#2FC654" stroke-width="0.25" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M12.5653 395.647V-250.904" stroke="#2FC654" stroke-width="0.25" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M282.573 395.554V-251" stroke="#2FC654" stroke-width="0.25" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M135.146 395.554V-251" stroke="#2FC654" stroke-width="0.25" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M245.717 395.554V-251" stroke="#2FC654" stroke-width="0.25" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M208.86 395.554V-251" stroke="#2FC654" stroke-width="0.25" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M172.003 395.554V-251" stroke="#2FC654" stroke-width="0.25" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M98.289 395.554V-251" stroke="#2FC654" stroke-width="0.25" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M61.4316 395.554V-251" stroke="#2FC654" stroke-width="0.25" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M24.5738 395.554V-251" stroke="#2FC654" stroke-width="0.25" stroke-linecap="round" stroke-linejoin="round"/>
</g>
</svg>
`,
	__vite_glob_0_27 = `<svg width="25" height="24" viewBox="0 0 25 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 21C11.6118 21 11.3049 20.7202 11.2327 20.2959C10.3661 14.2929 9.58074 13.5617 3.73119 12.7763C3.30692 12.7222 3 12.4062 3 12C3 11.5938 3.30692 11.2688 3.73119 11.2237C9.58977 10.5737 10.4293 9.71615 11.2327 3.70411C11.2959 3.27984 11.6118 3 12 3C12.3972 3 12.7041 3.27984 12.7763 3.70411C13.5978 9.71615 14.4283 10.5466 20.2778 11.2237C20.7021 11.2688 21.009 11.5938 21.009 12C21.009 12.4062 20.6931 12.7312 20.2778 12.7763C14.4193 13.4263 13.5707 14.2748 12.7763 20.2959C12.7131 20.7111 12.3972 21 12 21Z" fill="white"/>
</svg>
`,
	__vite_glob_0_28 = `<svg width="45" height="44" viewBox="0 0 45 44" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M19.0883 12.9062H24.541V20.25H19.0883V12.9062Z" fill="white"/>
<path d="M19.0883 23.9219H26.3586V27.5938H22.7234V31.2656H19.0883V23.9219Z" fill="white"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M22.7234 1.89062H19.0883V5.5625H7.375V38.6094H19.0883V42.2812H22.7234V38.6094H34.0328V34.9375H37.668V9.23438H34.0328V5.5625H22.7234V1.89062ZM34.0328 31.2656H30.3977V34.9375H11.0102V9.23438H30.3977V12.9062H34.0328V20.25H30.3977V23.9219H34.0328V31.2656Z" fill="white"/>
</svg>
`,
	__vite_glob_0_29 = `<svg width="38" height="38" viewBox="0 0 38 38" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M19.284 1.63281H15.4729V5.50868H7.00391V32.6398H15.4729V36.5156H19.284V32.6398H27.3296V28.7639H31.1406V21.0122H27.3296V17.1363H31.1406V9.38455H27.3296V5.50868H19.284V1.63281ZM15.4729 9.38455H21.1895V17.1363H15.4729V9.38455ZM15.4729 28.7639V21.0122H23.0951V24.888H19.284V28.7639H15.4729Z" fill="white"/>
</svg>
`,
	__vite_glob_0_30 = `<svg width="256" height="256" viewBox="0 0 256 256" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M129.965 11H103.596V37.1111H45V219.889H103.596V246H129.965V219.889H185.632V193.778H212V141.556H185.632V115.444H212V63.2222H185.632V37.1111H129.965V11ZM103.596 63.2222H143.149V115.444H103.596V63.2222ZM103.596 193.778V141.556H156.333V167.667H129.965V193.778H103.596Z" fill="white"/>
</svg>
`,
	__vite_glob_0_31 = `<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_12954_39672)">
<path d="M20 40C31.0457 40 40 31.0457 40 20C40 8.95431 31.0457 0 20 0C8.95431 0 0 8.95431 0 20C0 31.0457 8.95431 40 20 40Z" fill="black"/>
<path d="M39.75 20C39.75 30.9076 30.9076 39.75 20 39.75C9.09238 39.75 0.25 30.9076 0.25 20C0.25 9.09238 9.09238 0.25 20 0.25C30.9076 0.25 39.75 9.09238 39.75 20Z" stroke="white" stroke-opacity="0.2" stroke-width="0.5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.5575 24.4099C13.9835 24.4099 13.6246 23.7998 13.9112 23.3114L19.0053 14.6289V24.4099H14.5575ZM20.9946 24.4099V14.6289L26.0888 23.3114C26.3754 23.7998 26.0164 24.4099 25.4425 24.4099H20.9946ZM12.1876 22.3358C11.1368 24.1268 12.4529 26.3638 14.5575 26.3638H25.4425C27.5471 26.3638 28.8632 24.1268 27.8124 22.3358L20.8618 10.4893C20.6842 10.1866 20.3556 10.0001 20 10.0001C19.6444 10.0001 19.3158 10.1866 19.1382 10.4893L12.1876 22.3358Z" fill="white"/>
</g>
<defs>
<clipPath id="clip0_12954_39672">
<rect width="40" height="40" fill="white"/>
</clipPath>
</defs>
</svg>
`,
	__vite_glob_0_32 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g id="Style=Line">
<path id="Vector" d="M19 19L16 16M10.0002 20H7.19692C6.07901 20 5.5192 20 5.0918 19.7822C4.71547 19.5905 4.40973 19.2842 4.21799 18.9079C4 18.4801 4 17.9203 4 16.8002V7.2002C4 6.08009 4 5.51962 4.21799 5.0918C4.40973 4.71547 4.71547 4.40973 5.0918 4.21799C5.51962 4 6.08009 4 7.2002 4H16.8002C17.9203 4 18.4796 4 18.9074 4.21799C19.2837 4.40973 19.5905 4.71547 19.7822 5.0918C20 5.5192 20 6.07899 20 7.19691V10.0002M13.5 17C11.567 17 10 15.433 10 13.5C10 11.567 11.567 10 13.5 10C15.433 10 17 11.567 17 13.5C17 15.433 15.433 17 13.5 17Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
</svg>
`,
	__vite_glob_0_33 = `<svg width="390" height="718" viewBox="0 0 390 718" fill="none" xmlns="http://www.w3.org/2000/svg">
<mask id="mask0_30_1219" style="mask-type:alpha" maskUnits="userSpaceOnUse" x="0" y="0" width="390" height="718">
<g style="mix-blend-mode:hard-light">
<rect width="390" height="718" fill="url(#paint0_diamond_30_1219)"/>
</g>
</mask>
<g mask="url(#mask0_30_1219)">
<g style="mix-blend-mode:lighten">
<path d="M322.67 640.39L334.087 649.685L345.504 658.981L331.745 664.22L317.987 669.46L320.329 654.925L322.67 640.39Z" fill="white" fill-opacity="0.4"/>
<path d="M362.128 627.259L367.371 634.639L372.614 642.02L363.601 642.87L354.588 643.721L358.358 635.49L362.128 627.259Z" fill="white" fill-opacity="0.4"/>
<path d="M381.128 576.259L386.371 583.639L391.614 591.02L382.601 591.87L373.588 592.721L377.358 584.49L381.128 576.259Z" fill="white" fill-opacity="0.4"/>
<path d="M380.038 615.674L386.669 621.838L393.3 628.002L384.646 630.663L375.993 633.323L378.015 624.499L380.038 615.674Z" fill="white" fill-opacity="0.4"/>
<path d="M362.328 648.826L365.106 655.023L367.883 661.221L361.127 660.528L354.372 659.835L358.35 654.33L362.328 648.826Z" fill="white" fill-opacity="0.4"/>
<path d="M376.07 620.876L381.792 633.641L387.513 646.406L373.598 644.978L359.682 643.551L367.876 632.214L376.07 620.876Z" fill="white" fill-opacity="0.4"/>
<path d="M357.657 591.502L362.849 595.88L368.041 600.258L361.654 602.565L355.266 604.873L356.462 598.188L357.657 591.502Z" fill="white" fill-opacity="0.4"/>
<path d="M371.725 552.632L375.025 557.732L378.325 562.832L372.259 563.14L366.192 563.448L368.959 558.04L371.725 552.632Z" fill="white" fill-opacity="0.4"/>
<path d="M380.725 515.632L384.025 520.732L387.325 525.832L381.259 526.14L375.192 526.448L377.959 521.04L380.725 515.632Z" fill="white" fill-opacity="0.4"/>
<path d="M359.725 513.632L363.025 518.732L366.325 523.832L360.259 524.14L354.192 524.448L356.959 519.04L359.725 513.632Z" fill="white" fill-opacity="0.4"/>
<path d="M385.725 510.632L389.025 515.732L392.325 520.832L386.259 521.14L380.192 521.448L382.959 516.04L385.725 510.632Z" fill="white" fill-opacity="0.4"/>
<path d="M374.361 625.324L379.205 630.168L384.049 635.012L377.432 636.785L370.815 638.558L372.588 631.941L374.361 625.324Z" fill="white" fill-opacity="0.4"/>
<path d="M384.571 568.279L387.217 574.598L389.863 580.917L383.068 580.049L376.272 579.181L380.422 573.73L384.571 568.279Z" fill="white" fill-opacity="0.4"/>
<path d="M366.202 658.779L373.199 665.713L380.196 672.646L370.693 675.239L361.189 677.832L363.696 668.305L366.202 658.779Z" fill="white" fill-opacity="0.4"/>
<path d="M371.592 665.077L386.748 670.198L401.904 675.319L389.891 685.884L377.878 696.449L374.735 680.763L371.592 665.077Z" fill="white" fill-opacity="0.4"/>
<path d="M379.757 684.242L389.923 696.594L400.09 708.946L384.309 711.575L368.528 714.203L374.143 699.222L379.757 684.242Z" fill="white" fill-opacity="0.4"/>
<path d="M365.092 690.092L371.599 704.707L378.106 719.321L362.196 717.649L346.285 715.977L355.689 703.034L365.092 690.092Z" fill="white" fill-opacity="0.4"/>
<path d="M310.814 683.647L315.569 694.255L320.324 704.864L308.759 703.678L297.194 702.492L304.004 693.069L310.814 683.647Z" fill="white" fill-opacity="0.4"/>
<path d="M353.938 666.891L363.252 670.096L372.567 673.3L365.134 679.765L357.701 686.229L355.82 676.56L353.938 666.891Z" fill="white" fill-opacity="0.4"/>
<path d="M345.747 669.347L352.942 671.822L360.136 674.298L354.395 679.291L348.654 684.283L347.201 676.815L345.747 669.347Z" fill="white" fill-opacity="0.4"/>
<path d="M294.038 653.902L299.809 655.887L305.58 657.873L300.975 661.878L296.37 665.883L295.204 659.892L294.038 653.902Z" fill="white" fill-opacity="0.4"/>
<path d="M337.132 608.34L341.259 612.837L345.386 617.333L339.428 618.659L333.471 619.984L335.301 614.162L337.132 608.34Z" fill="white" fill-opacity="0.4"/>
<path d="M367.259 605.75L369.002 609.482L370.746 613.214L366.642 612.858L362.538 612.502L364.899 609.126L367.259 605.75Z" fill="white" fill-opacity="0.4"/>
<path d="M366.157 567.723L368.728 570.942L371.299 574.161L367.226 574.778L363.153 575.395L364.655 571.559L366.157 567.723Z" fill="white" fill-opacity="0.4"/>
<path d="M354.14 692.126L357.515 696.932L360.891 701.739L355.041 702.258L349.191 702.778L351.665 697.452L354.14 692.126Z" fill="white" fill-opacity="0.4"/>
<path d="M331.058 688.69L335.612 692.398L340.167 696.106L334.678 698.196L329.19 700.287L330.124 694.488L331.058 688.69Z" fill="white" fill-opacity="0.4"/>
<path d="M335.374 667.151L336.901 671.304L338.429 675.457L334.069 674.703L329.709 673.95L332.541 670.551L335.374 667.151Z" fill="white" fill-opacity="0.4"/>
<path d="M347.496 623.138L349.024 627.294L350.553 631.45L346.19 630.696L341.826 629.942L344.661 626.54L347.496 623.138Z" fill="white" fill-opacity="0.4"/>
<path d="M354.415 563.219L357.477 566.418L360.538 569.618L356.237 570.669L351.935 571.721L353.175 567.47L354.415 563.219Z" fill="white" fill-opacity="0.4"/>
<path d="M376.442 476.188L380.564 477.806L384.686 479.424L381.223 482.185L377.761 484.946L377.101 480.567L376.442 476.188Z" fill="white" fill-opacity="0.4"/>
<path d="M327.901 673.27L331.112 675.885L334.324 678.5L330.454 679.974L326.583 681.448L327.242 677.359L327.901 673.27Z" fill="white" fill-opacity="0.4"/>
<path d="M352.635 641.044L360.078 656.238L367.522 671.431L350.642 670.281L333.762 669.13L343.199 655.087L352.635 641.044Z" fill="white" fill-opacity="0.4"/>
<path d="M374.208 537.674L384.016 541.627L393.825 545.581L385.497 552.099L377.169 558.617L375.688 548.145L374.208 537.674Z" fill="white" fill-opacity="0.4"/>
<path d="M361.982 577.863L370.408 581.26L378.835 584.656L371.681 590.256L364.526 595.855L363.254 586.859L361.982 577.863Z" fill="white" fill-opacity="0.4"/>
<path d="M380.434 528.24L387.612 533.809L394.791 539.378L386.379 542.81L377.966 546.243L379.2 537.241L380.434 528.24Z" fill="white" fill-opacity="0.4"/>
<path d="M368.628 603.596L380.773 608.491L392.919 613.386L382.607 621.457L372.295 629.528L370.461 616.562L368.628 603.596Z" fill="white" fill-opacity="0.4"/>
<path d="M386.26 586.128L396 594.88L405.741 603.632L393.291 607.691L380.841 611.751L383.55 598.939L386.26 586.128Z" fill="white" fill-opacity="0.4"/>
<path d="M370.092 683.188L375.838 694.916L381.584 706.644L368.554 705.756L355.525 704.868L362.809 694.028L370.092 683.188Z" fill="white" fill-opacity="0.4"/>
<path d="M316.711 695.032L327.786 701.953L338.862 708.874L327.331 715.005L315.8 721.136L316.255 708.084L316.711 695.032Z" fill="white" fill-opacity="0.4"/>
<path d="M345.061 676.746L356.294 688.355L367.527 699.964L351.857 703.887L336.187 707.81L340.624 692.278L345.061 676.746Z" fill="white" fill-opacity="0.4"/>
<path d="M346.392 691.259L351.201 705.155L356.009 719.051L341.571 716.267L327.132 713.484L336.762 702.372L346.392 691.259Z" fill="white" fill-opacity="0.4"/>
<path d="M314.047 665.907L320.372 674.383L326.696 682.859L316.194 684.098L305.691 685.338L309.869 675.622L314.047 665.907Z" fill="white" fill-opacity="0.4"/>
<path d="M378.848 643.708L385.172 652.184L391.497 660.66L380.994 661.899L370.492 663.139L374.67 653.423L378.848 643.708Z" fill="white" fill-opacity="0.4"/>
<path d="M370.31 676.287L378.287 683.23L386.265 690.172L376.263 693.61L366.262 697.047L368.286 686.667L370.31 676.287Z" fill="white" fill-opacity="0.4"/>
<path d="M343.227 672.678L346.858 679.794L350.489 686.909L342.511 686.496L334.534 686.082L338.88 679.38L343.227 672.678Z" fill="white" fill-opacity="0.4"/>
<path d="M289.887 696.754L293.517 703.869L297.148 710.985L289.171 710.571L281.193 710.158L285.54 703.456L289.887 696.754Z" fill="white" fill-opacity="0.4"/>
<path d="M279.341 675.688L285.977 680.134L292.613 684.581L285.444 688.104L278.275 691.628L278.808 683.658L279.341 675.688Z" fill="white" fill-opacity="0.4"/>
<path d="M263.971 682.011L266.984 688.629L269.998 695.246L262.76 694.547L255.523 693.848L259.747 687.93L263.971 682.011Z" fill="white" fill-opacity="0.4"/>
<path d="M303.622 670.66L308.689 675.696L313.756 680.732L306.861 682.602L299.966 684.472L301.794 677.566L303.622 670.66Z" fill="white" fill-opacity="0.4"/>
<path d="M374.548 588.857L378.257 592.544L381.967 596.231L376.919 597.6L371.872 598.968L373.21 593.913L374.548 588.857Z" fill="white" fill-opacity="0.4"/>
</g>
<g style="mix-blend-mode:lighten">
<path d="M320.67 73.6105L332.087 64.3149L343.504 55.0193L329.745 49.7799L315.987 44.5405L318.329 59.0755L320.67 73.6105Z" fill="white" fill-opacity="0.4"/>
<path d="M360.128 86.7415L365.371 79.3611L370.614 71.9806L361.601 71.13L352.588 70.2794L356.358 78.5105L360.128 86.7415Z" fill="white" fill-opacity="0.4"/>
<path d="M379.128 137.741L384.371 130.361L389.614 122.981L380.601 122.13L371.588 121.279L375.358 129.51L379.128 137.741Z" fill="white" fill-opacity="0.4"/>
<path d="M378.038 98.326L384.669 92.1619L391.3 85.9977L382.646 83.3375L373.993 80.6772L376.015 89.5016L378.038 98.326Z" fill="white" fill-opacity="0.4"/>
<path d="M360.328 65.1741L363.106 58.9769L365.883 52.7797L359.127 53.4727L352.372 54.1657L356.35 59.6699L360.328 65.1741Z" fill="white" fill-opacity="0.4"/>
<path d="M374.07 93.1239L379.792 80.3592L385.513 67.5945L371.598 69.022L357.682 70.4494L365.876 81.7867L374.07 93.1239Z" fill="white" fill-opacity="0.4"/>
<path d="M355.657 122.498L360.849 118.12L366.041 113.742L359.654 111.435L353.266 109.127L354.462 115.813L355.657 122.498Z" fill="white" fill-opacity="0.4"/>
<path d="M369.725 161.368L373.025 156.268L376.325 151.169L370.259 150.861L364.192 150.553L366.959 155.96L369.725 161.368Z" fill="white" fill-opacity="0.4"/>
<path d="M378.725 198.368L382.025 193.268L385.325 188.169L379.259 187.861L373.192 187.553L375.959 192.96L378.725 198.368Z" fill="white" fill-opacity="0.4"/>
<path d="M357.725 200.368L361.025 195.268L364.325 190.169L358.259 189.861L352.192 189.553L354.959 194.96L357.725 200.368Z" fill="white" fill-opacity="0.4"/>
<path d="M383.725 203.368L387.025 198.268L390.325 193.169L384.259 192.861L378.192 192.553L380.959 197.96L383.725 203.368Z" fill="white" fill-opacity="0.4"/>
<path d="M372.361 88.676L377.205 83.8319L382.049 78.9879L375.432 77.2148L368.815 75.4418L370.588 82.0589L372.361 88.676Z" fill="white" fill-opacity="0.4"/>
<path d="M382.571 145.721L385.217 139.402L387.863 133.084L381.068 133.951L374.272 134.819L378.422 140.27L382.571 145.721Z" fill="white" fill-opacity="0.4"/>
<path d="M364.202 55.221L371.199 48.2874L378.196 41.3538L368.693 38.7611L359.189 36.1685L361.696 45.6948L364.202 55.221Z" fill="white" fill-opacity="0.4"/>
<path d="M369.592 48.9231L384.748 43.8023L399.904 38.6815L387.891 28.1163L375.878 17.551L372.735 33.2371L369.592 48.9231Z" fill="white" fill-opacity="0.4"/>
<path d="M377.757 29.7583L387.923 17.4061L398.09 5.05396L382.309 2.42564L366.528 -0.202668L372.143 14.7778L377.757 29.7583Z" fill="white" fill-opacity="0.4"/>
<path d="M363.092 23.9084L369.599 9.29362L376.106 -5.32119L360.196 -3.64895L344.285 -1.97672L353.689 10.9659L363.092 23.9084Z" fill="white" fill-opacity="0.4"/>
<path d="M308.814 30.3535L313.569 19.7448L318.324 9.13599L306.759 10.3223L295.194 11.5087L302.004 20.9311L308.814 30.3535Z" fill="white" fill-opacity="0.4"/>
<path d="M351.938 47.1095L361.252 43.9047L370.567 40.6999L363.134 34.2357L355.701 27.7714L353.82 37.4405L351.938 47.1095Z" fill="white" fill-opacity="0.4"/>
<path d="M343.747 44.6532L350.942 42.1779L358.136 39.7025L352.395 34.7096L346.654 29.7168L345.201 37.185L343.747 44.6532Z" fill="white" fill-opacity="0.4"/>
<path d="M292.038 60.0986L297.809 58.113L303.58 56.1273L298.975 52.1222L294.37 48.117L293.204 54.1078L292.038 60.0986Z" fill="white" fill-opacity="0.4"/>
<path d="M335.132 105.66L339.259 101.164L343.386 96.6669L337.428 95.3414L331.471 94.0159L333.301 99.8381L335.132 105.66Z" fill="white" fill-opacity="0.4"/>
<path d="M365.259 108.25L367.002 104.518L368.746 100.786L364.642 101.142L360.538 101.498L362.899 104.874L365.259 108.25Z" fill="white" fill-opacity="0.4"/>
<path d="M364.157 146.277L366.728 143.058L369.299 139.84L365.226 139.223L361.153 138.605L362.655 142.441L364.157 146.277Z" fill="white" fill-opacity="0.4"/>
<path d="M352.14 21.8743L355.515 17.068L358.891 12.2616L353.041 11.7419L347.191 11.2222L349.665 16.5482L352.14 21.8743Z" fill="white" fill-opacity="0.4"/>
<path d="M329.058 25.3101L333.612 21.602L338.167 17.8938L332.678 15.8038L327.19 13.7137L328.124 19.5119L329.058 25.3101Z" fill="white" fill-opacity="0.4"/>
<path d="M333.374 46.8488L334.901 42.6963L336.429 38.5437L332.069 39.2971L327.709 40.0505L330.541 43.4496L333.374 46.8488Z" fill="white" fill-opacity="0.4"/>
<path d="M345.496 90.8622L347.024 86.7062L348.553 82.5502L344.19 83.3042L339.826 84.0582L342.661 87.4602L345.496 90.8622Z" fill="white" fill-opacity="0.4"/>
<path d="M352.415 150.781L355.477 147.582L358.538 144.382L354.237 143.331L349.935 142.279L351.175 146.53L352.415 150.781Z" fill="white" fill-opacity="0.4"/>
<path d="M374.442 237.812L378.564 236.194L382.686 234.576L379.223 231.815L375.761 229.055L375.101 233.433L374.442 237.812Z" fill="white" fill-opacity="0.4"/>
<path d="M325.901 40.7302L329.112 38.1153L332.324 35.5004L328.454 34.0266L324.583 32.5527L325.242 36.6414L325.901 40.7302Z" fill="white" fill-opacity="0.4"/>
<path d="M350.635 72.9561L358.078 57.7626L365.522 42.5691L348.642 43.7195L331.762 44.8698L341.199 58.913L350.635 72.9561Z" fill="white" fill-opacity="0.4"/>
<path d="M372.208 176.326L382.016 172.373L391.825 168.42L383.497 161.902L375.169 155.384L373.688 165.855L372.208 176.326Z" fill="white" fill-opacity="0.4"/>
<path d="M359.982 136.137L368.408 132.74L376.835 129.344L369.681 123.745L362.526 118.145L361.254 127.141L359.982 136.137Z" fill="white" fill-opacity="0.4"/>
<path d="M378.434 185.76L385.612 180.191L392.791 174.622L384.379 171.19L375.966 167.758L377.2 176.759L378.434 185.76Z" fill="white" fill-opacity="0.4"/>
<path d="M366.628 110.404L378.773 105.509L390.919 100.614L380.607 92.5432L370.295 84.4723L368.461 97.4384L366.628 110.404Z" fill="white" fill-opacity="0.4"/>
<path d="M384.26 127.873L394 119.121L403.741 110.368L391.291 106.309L378.841 102.249L381.55 115.061L384.26 127.873Z" fill="white" fill-opacity="0.4"/>
<path d="M368.092 30.8121L373.838 19.0842L379.584 7.35628L366.554 8.24422L353.525 9.13216L360.809 19.9721L368.092 30.8121Z" fill="white" fill-opacity="0.4"/>
<path d="M314.711 18.9679L325.786 12.0472L336.862 5.12661L325.331 -1.00458L313.8 -7.13578L314.255 5.91605L314.711 18.9679Z" fill="white" fill-opacity="0.4"/>
<path d="M343.061 37.2542L354.294 25.6454L365.527 14.0366L349.857 10.1132L334.187 6.18978L338.624 21.722L343.061 37.2542Z" fill="white" fill-opacity="0.4"/>
<path d="M344.392 22.7408L349.201 8.845L354.009 -5.05077L339.571 -2.26711L325.132 0.516558L334.762 11.6287L344.392 22.7408Z" fill="white" fill-opacity="0.4"/>
<path d="M312.047 48.093L318.372 39.6171L324.696 31.1413L314.194 29.9019L303.691 28.6625L307.869 38.3777L312.047 48.093Z" fill="white" fill-opacity="0.4"/>
<path d="M376.848 70.2922L383.172 61.8163L389.497 53.3405L378.994 52.1011L368.492 50.8617L372.67 60.577L376.848 70.2922Z" fill="white" fill-opacity="0.4"/>
<path d="M368.31 37.7134L376.287 30.7706L384.265 23.8278L374.263 20.3906L364.262 16.9533L366.286 27.3333L368.31 37.7134Z" fill="white" fill-opacity="0.4"/>
<path d="M341.227 41.3219L344.858 34.2066L348.489 27.0913L340.511 27.5045L332.534 27.9178L336.88 34.6198L341.227 41.3219Z" fill="white" fill-opacity="0.4"/>
<path d="M287.887 17.2462L291.517 10.1309L295.148 3.01559L287.171 3.42886L279.193 3.84212L283.54 10.5442L287.887 17.2462Z" fill="white" fill-opacity="0.4"/>
<path d="M277.341 38.3126L283.977 33.8661L290.613 29.4196L283.444 25.8958L276.275 22.3719L276.808 30.3423L277.341 38.3126Z" fill="white" fill-opacity="0.4"/>
<path d="M261.971 31.9888L264.984 25.3717L267.998 18.7546L260.76 19.4533L253.523 20.152L257.747 26.0704L261.971 31.9888Z" fill="white" fill-opacity="0.4"/>
<path d="M301.622 43.3406L306.689 38.3046L311.756 33.2686L304.861 31.3986L297.966 29.5287L299.794 36.4347L301.622 43.3406Z" fill="white" fill-opacity="0.4"/>
<path d="M372.548 125.143L376.257 121.456L379.967 117.77L374.919 116.401L369.872 115.032L371.21 120.087L372.548 125.143Z" fill="white" fill-opacity="0.4"/>
</g>
<g style="mix-blend-mode:lighten">
<path d="M68.34 639.39L56.9232 648.685L45.5065 657.981L59.2651 663.22L73.0237 668.46L70.6818 653.925L68.34 639.39Z" fill="white" fill-opacity="0.4"/>
<path d="M28.8826 626.259L23.6393 633.639L18.3961 641.02L27.4093 641.87L36.4226 642.721L32.6526 634.49L28.8826 626.259Z" fill="white" fill-opacity="0.4"/>
<path d="M9.88261 575.259L4.63934 582.639L-0.603934 590.02L8.40932 590.87L17.4226 591.721L13.6526 583.49L9.88261 575.259Z" fill="white" fill-opacity="0.4"/>
<path d="M10.9719 614.674L4.34126 620.838L-2.28942 627.002L6.3642 629.663L15.0178 632.323L12.9949 623.499L10.9719 614.674Z" fill="white" fill-opacity="0.4"/>
<path d="M28.6826 647.826L25.9049 654.023L23.1271 660.221L29.883 659.528L36.6388 658.835L32.6607 653.33L28.6826 647.826Z" fill="white" fill-opacity="0.4"/>
<path d="M14.9403 619.876L9.21883 632.641L3.49738 645.406L17.4127 643.978L31.328 642.551L23.1341 631.214L14.9403 619.876Z" fill="white" fill-opacity="0.4"/>
<path d="M33.3533 590.502L28.1614 594.88L22.9695 599.258L29.3568 601.565L35.744 603.873L34.5487 597.188L33.3533 590.502Z" fill="white" fill-opacity="0.4"/>
<path d="M19.2853 551.632L15.9853 556.732L12.6853 561.832L18.7517 562.14L24.8181 562.448L22.0517 557.04L19.2853 551.632Z" fill="white" fill-opacity="0.4"/>
<path d="M10.2853 514.632L6.98532 519.732L3.68532 524.832L9.75173 525.14L15.8181 525.448L13.0517 520.04L10.2853 514.632Z" fill="white" fill-opacity="0.4"/>
<path d="M31.2853 512.632L27.9853 517.732L24.6853 522.832L30.7517 523.14L36.8181 523.448L34.0517 518.04L31.2853 512.632Z" fill="white" fill-opacity="0.4"/>
<path d="M5.28533 509.632L1.98532 514.732L-1.31468 519.832L4.75173 520.14L10.8181 520.448L8.05174 515.04L5.28533 509.632Z" fill="white" fill-opacity="0.4"/>
<path d="M16.6494 624.324L11.8054 629.168L6.96132 634.012L13.5784 635.785L20.1955 637.558L18.4225 630.941L16.6494 624.324Z" fill="white" fill-opacity="0.4"/>
<path d="M6.43948 567.279L3.79335 573.598L1.14723 579.917L7.94258 579.049L14.7379 578.181L10.5887 572.73L6.43948 567.279Z" fill="white" fill-opacity="0.4"/>
<path d="M24.8084 657.779L17.8115 664.713L10.8146 671.646L20.3178 674.239L29.8209 676.832L27.3147 667.305L24.8084 657.779Z" fill="white" fill-opacity="0.4"/>
<path d="M19.4188 664.077L4.26257 669.198L-10.8936 674.319L1.11919 684.884L13.132 695.449L16.2754 679.763L19.4188 664.077Z" fill="white" fill-opacity="0.4"/>
<path d="M11.2538 683.242L1.08731 695.594L-9.07913 707.946L6.70138 710.575L22.4819 713.203L16.8678 698.222L11.2538 683.242Z" fill="white" fill-opacity="0.4"/>
<path d="M25.9184 689.092L19.4115 703.707L12.9045 718.321L28.8148 716.649L44.725 714.977L35.3217 702.034L25.9184 689.092Z" fill="white" fill-opacity="0.4"/>
<path d="M80.1961 682.647L75.4411 693.255L70.686 703.864L82.251 702.678L93.816 701.492L87.0061 692.069L80.1961 682.647Z" fill="white" fill-opacity="0.4"/>
<path d="M37.0727 665.891L27.7581 669.096L18.4436 672.3L25.8763 678.765L33.309 685.229L35.1908 675.56L37.0727 665.891Z" fill="white" fill-opacity="0.4"/>
<path d="M45.263 668.347L38.0685 670.822L30.8741 673.298L36.615 678.291L42.356 683.283L43.8095 675.815L45.263 668.347Z" fill="white" fill-opacity="0.4"/>
<path d="M96.9724 652.902L91.2012 654.887L85.43 656.873L90.0352 660.878L94.6404 664.883L95.8064 658.892L96.9724 652.902Z" fill="white" fill-opacity="0.4"/>
<path d="M53.8781 607.34L49.7514 611.837L45.6247 616.333L51.5823 617.659L57.5398 618.984L55.7089 613.162L53.8781 607.34Z" fill="white" fill-opacity="0.4"/>
<path d="M23.7517 604.75L22.008 608.482L20.2643 612.214L24.3682 611.858L28.472 611.502L26.1119 608.126L23.7517 604.75Z" fill="white" fill-opacity="0.4"/>
<path d="M24.8533 566.723L22.2825 569.942L19.7117 573.161L23.7844 573.778L27.8572 574.395L26.3552 570.559L24.8533 566.723Z" fill="white" fill-opacity="0.4"/>
<path d="M36.87 691.126L33.4949 695.932L30.1199 700.739L35.9698 701.258L41.8197 701.778L39.3449 696.452L36.87 691.126Z" fill="white" fill-opacity="0.4"/>
<path d="M59.9524 687.69L55.3981 691.398L50.8438 695.106L56.3323 697.196L61.8208 699.287L60.8866 693.488L59.9524 687.69Z" fill="white" fill-opacity="0.4"/>
<path d="M55.6368 666.151L54.1093 670.304L52.5818 674.457L56.9417 673.703L61.3017 672.95L58.4693 669.551L55.6368 666.151Z" fill="white" fill-opacity="0.4"/>
<path d="M43.5147 622.138L41.9859 626.294L40.4571 630.45L44.8207 629.696L49.1843 628.942L46.3495 625.54L43.5147 622.138Z" fill="white" fill-opacity="0.4"/>
<path d="M36.5952 562.219L33.5337 565.418L30.4722 568.618L34.7738 569.669L39.0755 570.721L37.8353 566.47L36.5952 562.219Z" fill="white" fill-opacity="0.4"/>
<path d="M14.5691 475.188L10.447 476.806L6.32495 478.424L9.78733 481.185L13.2497 483.945L13.9094 479.567L14.5691 475.188Z" fill="white" fill-opacity="0.4"/>
<path d="M63.1095 672.27L59.8979 674.885L56.6864 677.5L60.5567 678.974L64.427 680.448L63.7682 676.359L63.1095 672.27Z" fill="white" fill-opacity="0.4"/>
<path d="M38.3757 640.044L30.932 655.238L23.4883 670.431L40.3681 669.281L57.2479 668.13L47.8118 654.087L38.3757 640.044Z" fill="white" fill-opacity="0.4"/>
<path d="M16.8027 536.674L6.9939 540.627L-2.81488 544.581L5.5132 551.099L13.8413 557.617L15.322 547.145L16.8027 536.674Z" fill="white" fill-opacity="0.4"/>
<path d="M29.0287 576.863L20.6019 580.26L12.1751 583.656L19.3298 589.256L26.4845 594.855L27.7566 585.859L29.0287 576.863Z" fill="white" fill-opacity="0.4"/>
<path d="M10.5766 527.24L3.39811 532.809L-3.78042 538.378L4.63179 541.81L13.044 545.243L11.8103 536.241L10.5766 527.24Z" fill="white" fill-opacity="0.4"/>
<path d="M22.3828 602.596L10.2372 607.491L-1.90847 612.386L8.40368 620.457L18.7158 628.528L20.5493 615.562L22.3828 602.596Z" fill="white" fill-opacity="0.4"/>
<path d="M4.75075 585.128L-4.98977 593.88L-14.7303 602.632L-2.28041 606.691L10.1695 610.751L7.46012 597.939L4.75075 585.128Z" fill="white" fill-opacity="0.4"/>
<path d="M20.9181 682.188L15.1723 693.916L9.42646 705.644L22.456 704.756L35.4856 703.868L28.2018 693.028L20.9181 682.188Z" fill="white" fill-opacity="0.4"/>
<path d="M74.2992 694.032L63.2239 700.953L52.1486 707.874L63.6797 714.005L75.2108 720.136L74.755 707.084L74.2992 694.032Z" fill="white" fill-opacity="0.4"/>
<path d="M45.9491 675.746L34.7164 687.355L23.4837 698.964L39.1536 702.887L54.8235 706.81L50.3863 691.278L45.9491 675.746Z" fill="white" fill-opacity="0.4"/>
<path d="M44.6183 690.259L39.8099 704.155L35.0014 718.051L49.4397 715.267L63.8781 712.484L54.2482 701.372L44.6183 690.259Z" fill="white" fill-opacity="0.4"/>
<path d="M76.9634 664.907L70.6388 673.383L64.3141 681.859L74.8167 683.098L85.3194 684.338L81.1414 674.622L76.9634 664.907Z" fill="white" fill-opacity="0.4"/>
<path d="M12.1626 642.708L5.83795 651.184L-0.486691 659.66L10.0159 660.899L20.5186 662.139L16.3406 652.423L12.1626 642.708Z" fill="white" fill-opacity="0.4"/>
<path d="M20.7004 675.287L12.723 682.23L4.74563 689.172L14.747 692.61L24.7483 696.047L22.7244 685.667L20.7004 675.287Z" fill="white" fill-opacity="0.4"/>
<path d="M47.7835 671.678L44.1527 678.794L40.5218 685.909L48.4993 685.496L56.4767 685.082L52.1301 678.38L47.7835 671.678Z" fill="white" fill-opacity="0.4"/>
<path d="M101.124 695.754L97.493 702.869L93.8622 709.985L101.84 709.571L109.817 709.158L105.47 702.456L101.124 695.754Z" fill="white" fill-opacity="0.4"/>
<path d="M111.67 674.688L105.034 679.134L98.3975 683.581L105.566 687.104L112.735 690.628L112.203 682.658L111.67 674.688Z" fill="white" fill-opacity="0.4"/>
<path d="M127.04 681.011L124.026 687.629L121.013 694.246L128.25 693.547L135.487 692.848L131.264 686.93L127.04 681.011Z" fill="white" fill-opacity="0.4"/>
<path d="M87.3881 669.66L82.3214 674.696L77.2546 679.732L84.1493 681.602L91.044 683.472L89.2161 676.566L87.3881 669.66Z" fill="white" fill-opacity="0.4"/>
<path d="M16.4621 587.857L12.7529 591.544L9.04373 595.231L14.0911 596.6L19.1384 597.968L17.8002 592.913L16.4621 587.857Z" fill="white" fill-opacity="0.4"/>
</g>
<g style="mix-blend-mode:lighten">
<path d="M67.34 73.6105L55.9232 64.3149L44.5065 55.0193L58.2651 49.7799L72.0237 44.5405L69.6818 59.0755L67.34 73.6105Z" fill="white" fill-opacity="0.4"/>
<path d="M27.8826 86.7415L22.6393 79.3611L17.3961 71.9806L26.4093 71.13L35.4226 70.2794L31.6526 78.5105L27.8826 86.7415Z" fill="white" fill-opacity="0.4"/>
<path d="M8.88261 137.741L3.63934 130.361L-1.60393 122.981L7.40932 122.13L16.4226 121.279L12.6526 129.51L8.88261 137.741Z" fill="white" fill-opacity="0.4"/>
<path d="M9.97195 98.326L3.34126 92.1619L-3.28942 85.9977L5.3642 83.3375L14.0178 80.6772L11.9949 89.5016L9.97195 98.326Z" fill="white" fill-opacity="0.4"/>
<path d="M27.6826 65.1741L24.9049 58.9769L22.1271 52.7797L28.883 53.4727L35.6388 54.1657L31.6607 59.6699L27.6826 65.1741Z" fill="white" fill-opacity="0.4"/>
<path d="M13.9403 93.1239L8.21883 80.3592L2.49738 67.5945L16.4127 69.022L30.328 70.4494L22.1341 81.7867L13.9403 93.1239Z" fill="white" fill-opacity="0.4"/>
<path d="M32.3533 122.498L27.1614 118.12L21.9695 113.742L28.3568 111.435L34.744 109.127L33.5487 115.813L32.3533 122.498Z" fill="white" fill-opacity="0.4"/>
<path d="M18.2853 161.368L14.9853 156.268L11.6853 151.169L17.7517 150.861L23.8181 150.553L21.0517 155.96L18.2853 161.368Z" fill="white" fill-opacity="0.4"/>
<path d="M9.28533 198.368L5.98532 193.268L2.68532 188.169L8.75173 187.861L14.8181 187.553L12.0517 192.96L9.28533 198.368Z" fill="white" fill-opacity="0.4"/>
<path d="M30.2853 200.368L26.9853 195.268L23.6853 190.169L29.7517 189.861L35.8181 189.553L33.0517 194.96L30.2853 200.368Z" fill="white" fill-opacity="0.4"/>
<path d="M4.28533 203.368L0.985321 198.268L-2.31468 193.169L3.75173 192.861L9.81815 192.553L7.05174 197.96L4.28533 203.368Z" fill="white" fill-opacity="0.4"/>
<path d="M15.6494 88.676L10.8054 83.8319L5.96132 78.9879L12.5784 77.2148L19.1955 75.4418L17.4225 82.0589L15.6494 88.676Z" fill="white" fill-opacity="0.4"/>
<path d="M5.43948 145.721L2.79335 139.402L0.147228 133.084L6.94258 133.951L13.7379 134.819L9.5887 140.27L5.43948 145.721Z" fill="white" fill-opacity="0.4"/>
<path d="M23.8084 55.221L16.8115 48.2874L9.81463 41.3538L19.3178 38.7611L28.8209 36.1685L26.3147 45.6948L23.8084 55.221Z" fill="white" fill-opacity="0.4"/>
<path d="M18.4188 48.9231L3.26257 43.8023L-11.8936 38.6815L0.119189 28.1163L12.132 17.551L15.2754 33.2371L18.4188 48.9231Z" fill="white" fill-opacity="0.4"/>
<path d="M10.2538 29.7583L0.0873106 17.4061L-10.0791 5.05396L5.70138 2.42564L21.4819 -0.202668L15.8678 14.7778L10.2538 29.7583Z" fill="white" fill-opacity="0.4"/>
<path d="M24.9184 23.9084L18.4115 9.29362L11.9045 -5.32119L27.8148 -3.64895L43.725 -1.97672L34.3217 10.9659L24.9184 23.9084Z" fill="white" fill-opacity="0.4"/>
<path d="M79.1961 30.3535L74.4411 19.7448L69.686 9.13599L81.251 10.3223L92.816 11.5087L86.0061 20.9311L79.1961 30.3535Z" fill="white" fill-opacity="0.4"/>
<path d="M36.0727 47.1095L26.7581 43.9047L17.4436 40.6999L24.8763 34.2357L32.309 27.7714L34.1908 37.4405L36.0727 47.1095Z" fill="white" fill-opacity="0.4"/>
<path d="M44.263 44.6532L37.0685 42.1779L29.8741 39.7025L35.615 34.7096L41.356 29.7168L42.8095 37.185L44.263 44.6532Z" fill="white" fill-opacity="0.4"/>
<path d="M95.9724 60.0986L90.2012 58.113L84.43 56.1273L89.0352 52.1222L93.6404 48.117L94.8064 54.1078L95.9724 60.0986Z" fill="white" fill-opacity="0.4"/>
<path d="M52.8781 105.66L48.7514 101.164L44.6247 96.6669L50.5823 95.3414L56.5398 94.0159L54.7089 99.8381L52.8781 105.66Z" fill="white" fill-opacity="0.4"/>
<path d="M22.7517 108.25L21.008 104.518L19.2643 100.786L23.3682 101.142L27.472 101.498L25.1119 104.874L22.7517 108.25Z" fill="white" fill-opacity="0.4"/>
<path d="M23.8533 146.277L21.2825 143.058L18.7117 139.84L22.7844 139.223L26.8572 138.605L25.3552 142.441L23.8533 146.277Z" fill="white" fill-opacity="0.4"/>
<path d="M35.87 21.8743L32.4949 17.068L29.1199 12.2616L34.9698 11.7419L40.8197 11.2222L38.3449 16.5482L35.87 21.8743Z" fill="white" fill-opacity="0.4"/>
<path d="M58.9524 25.3101L54.3981 21.602L49.8438 17.8938L55.3323 15.8038L60.8208 13.7137L59.8866 19.5119L58.9524 25.3101Z" fill="white" fill-opacity="0.4"/>
<path d="M54.6368 46.8488L53.1093 42.6963L51.5818 38.5437L55.9417 39.2971L60.3017 40.0505L57.4693 43.4496L54.6368 46.8488Z" fill="white" fill-opacity="0.4"/>
<path d="M42.5147 90.8622L40.9859 86.7062L39.4571 82.5502L43.8207 83.3042L48.1843 84.0582L45.3495 87.4602L42.5147 90.8622Z" fill="white" fill-opacity="0.4"/>
<path d="M35.5952 150.781L32.5337 147.582L29.4722 144.382L33.7738 143.331L38.0755 142.279L36.8353 146.53L35.5952 150.781Z" fill="white" fill-opacity="0.4"/>
<path d="M13.5691 237.812L9.44701 236.194L5.32495 234.576L8.78733 231.815L12.2497 229.055L12.9094 233.433L13.5691 237.812Z" fill="white" fill-opacity="0.4"/>
<path d="M62.1095 40.7302L58.8979 38.1153L55.6864 35.5004L59.5567 34.0266L63.427 32.5527L62.7682 36.6414L62.1095 40.7302Z" fill="white" fill-opacity="0.4"/>
<path d="M37.3757 72.9561L29.932 57.7626L22.4883 42.5691L39.3681 43.7195L56.2479 44.8698L46.8118 58.913L37.3757 72.9561Z" fill="white" fill-opacity="0.4"/>
<path d="M15.8027 176.326L5.9939 172.373L-3.81488 168.42L4.5132 161.902L12.8413 155.384L14.322 165.855L15.8027 176.326Z" fill="white" fill-opacity="0.4"/>
<path d="M28.0287 136.137L19.6019 132.74L11.1751 129.344L18.3298 123.745L25.4845 118.145L26.7566 127.141L28.0287 136.137Z" fill="white" fill-opacity="0.4"/>
<path d="M9.57664 185.76L2.39811 180.191L-4.78042 174.622L3.63179 171.19L12.044 167.758L10.8103 176.759L9.57664 185.76Z" fill="white" fill-opacity="0.4"/>
<path d="M21.3828 110.404L9.23715 105.509L-2.90847 100.614L7.40368 92.5432L17.7158 84.4723L19.5493 97.4384L21.3828 110.404Z" fill="white" fill-opacity="0.4"/>
<path d="M3.75075 127.873L-5.98977 119.121L-15.7303 110.368L-3.28041 106.309L9.16948 102.249L6.46012 115.061L3.75075 127.873Z" fill="white" fill-opacity="0.4"/>
<path d="M19.9181 30.8121L14.1723 19.0842L8.42646 7.35628L21.456 8.24422L34.4856 9.13216L27.2018 19.9721L19.9181 30.8121Z" fill="white" fill-opacity="0.4"/>
<path d="M73.2992 18.9679L62.2239 12.0472L51.1486 5.12661L62.6797 -1.00458L74.2108 -7.13578L73.755 5.91605L73.2992 18.9679Z" fill="white" fill-opacity="0.4"/>
<path d="M44.9491 37.2542L33.7164 25.6454L22.4837 14.0366L38.1536 10.1132L53.8235 6.18978L49.3863 21.722L44.9491 37.2542Z" fill="white" fill-opacity="0.4"/>
<path d="M43.6183 22.7408L38.8099 8.845L34.0014 -5.05077L48.4397 -2.26711L62.8781 0.516558L53.2482 11.6287L43.6183 22.7408Z" fill="white" fill-opacity="0.4"/>
<path d="M75.9634 48.093L69.6388 39.6171L63.3141 31.1413L73.8167 29.9019L84.3194 28.6625L80.1414 38.3777L75.9634 48.093Z" fill="white" fill-opacity="0.4"/>
<path d="M11.1626 70.2922L4.83795 61.8163L-1.48669 53.3405L9.01593 52.1011L19.5186 50.8617L15.3406 60.577L11.1626 70.2922Z" fill="white" fill-opacity="0.4"/>
<path d="M19.7004 37.7134L11.723 30.7706L3.74563 23.8278L13.747 20.3906L23.7483 16.9533L21.7244 27.3333L19.7004 37.7134Z" fill="white" fill-opacity="0.4"/>
<path d="M46.7835 41.3219L43.1527 34.2066L39.5218 27.0913L47.4993 27.5045L55.4767 27.9178L51.1301 34.6198L46.7835 41.3219Z" fill="white" fill-opacity="0.4"/>
<path d="M100.124 17.2462L96.493 10.1309L92.8622 3.01559L100.84 3.42886L108.817 3.84212L104.47 10.5442L100.124 17.2462Z" fill="white" fill-opacity="0.4"/>
<path d="M110.67 38.3126L104.034 33.8661L97.3975 29.4196L104.566 25.8958L111.735 22.3719L111.203 30.3423L110.67 38.3126Z" fill="white" fill-opacity="0.4"/>
<path d="M126.04 31.9888L123.026 25.3717L120.013 18.7546L127.25 19.4533L134.487 20.152L130.264 26.0704L126.04 31.9888Z" fill="white" fill-opacity="0.4"/>
<path d="M86.3881 43.3406L81.3214 38.3046L76.2546 33.2686L83.1493 31.3986L90.044 29.5287L88.2161 36.4347L86.3881 43.3406Z" fill="white" fill-opacity="0.4"/>
<path d="M15.4621 125.143L11.7529 121.456L8.04373 117.77L13.0911 116.401L18.1384 115.032L16.8002 120.087L15.4621 125.143Z" fill="white" fill-opacity="0.4"/>
</g>
</g>
<defs>
<radialGradient id="paint0_diamond_30_1219" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(195 359) rotate(89.9488) scale(581.81 316.025)">
<stop stop-color="#FF00C7" stop-opacity="0"/>
<stop offset="0.615" stop-color="#FF00C7" stop-opacity="0"/>
<stop offset="1" stop-color="#FF00C7" stop-opacity="0.5"/>
</radialGradient>
</defs>
</svg>
`,
	__vite_glob_0_34 = `<svg width="100" height="44" viewBox="0 0 100 44" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_204_1787)">
<rect width="100" height="44" fill="white" fill-opacity="0.4"/>
<mask id="mask0_204_1787" style="mask-type:alpha" maskUnits="userSpaceOnUse" x="0" y="0" width="100" height="44">
<rect width="100" height="44" rx="22" fill="#D9D9D9"/>
</mask>
<g mask="url(#mask0_204_1787)">
<rect width="9.59474" height="73.8563" transform="matrix(0.86261 0.50587 -0.494153 0.869375 44.7837 -17)" fill="white" fill-opacity="0.29"/>
<rect width="6.92511" height="73.8563" transform="matrix(0.86261 0.50587 -0.494153 0.869375 32.4961 -15.6133)" fill="white" fill-opacity="0.29"/>
</g>
<g filter="url(#filter0_f_204_1787)">
<g style="mix-blend-mode:overlay">
<path d="M77.6392 30.1918C75.5752 30.1918 74.0152 29.5038 72.9592 28.1278C71.9192 26.7358 71.3992 24.7358 71.3992 22.1278V21.0718C71.3992 18.4638 71.9192 16.4718 72.9592 15.0958C74.0152 13.7038 75.5752 13.0078 77.6392 13.0078H78.6232C80.7192 13.0078 82.2872 13.6958 83.3272 15.0718C84.3672 16.4478 84.8872 18.4478 84.8872 21.0718V22.1278C84.8872 24.7518 84.3672 26.7518 83.3272 28.1278C82.2872 29.5038 80.7192 30.1918 78.6232 30.1918H77.6392ZM78.4792 27.0718C79.3112 27.0718 79.9832 26.7438 80.4952 26.0878C81.0072 25.4318 81.2632 24.4718 81.2632 23.2078V19.9918C81.2632 18.7278 81.0072 17.7678 80.4952 17.1118C79.9832 16.4398 79.3112 16.1038 78.4792 16.1038H77.8312C76.9832 16.1038 76.3032 16.4398 75.7912 17.1118C75.2792 17.7678 75.0232 18.7278 75.0232 19.9918V23.2078C75.0232 24.4718 75.2792 25.4318 75.7912 26.0878C76.3192 26.7438 76.9992 27.0718 77.8312 27.0718H78.4792ZM82.9192 15.1678L75.9832 28.5358L73.3912 27.8638L80.2552 14.6398L82.9192 15.1678Z" fill="white" fill-opacity="0.5"/>
</g>
<g style="mix-blend-mode:overlay">
<path d="M63.4579 30.1918C62.2899 30.1918 61.2259 29.9758 60.2659 29.5438C59.3219 29.0958 58.5699 28.4558 58.0099 27.6238C57.4499 26.7918 57.1699 25.8158 57.1699 24.6958H60.6499C60.6499 25.2078 60.7699 25.6478 61.0099 26.0158C61.2659 26.3678 61.6099 26.6318 62.0419 26.8078C62.4739 26.9838 62.9539 27.0718 63.4819 27.0718C64.3299 27.0718 64.9939 26.8798 65.4739 26.4958C65.9699 26.0958 66.2179 25.5518 66.2179 24.8638C66.2179 24.2078 65.9699 23.7038 65.4739 23.3518C64.9939 22.9998 64.3299 22.8238 63.4819 22.8238H61.8979V19.8718H63.4099C64.0659 19.8718 64.5939 19.6958 64.9939 19.3438C65.3939 18.9758 65.5939 18.5198 65.5939 17.9758C65.5939 17.3998 65.3779 16.9438 64.9459 16.6078C64.5299 16.2718 63.9699 16.1038 63.2659 16.1038C62.5459 16.1038 61.9619 16.3038 61.5139 16.7038C61.0819 17.1038 60.8659 17.6478 60.8659 18.3358H57.4579C57.4579 17.2798 57.7059 16.3518 58.2019 15.5518C58.7139 14.7518 59.4099 14.1278 60.2899 13.6798C61.1859 13.2318 62.2099 13.0078 63.3619 13.0078C64.4499 13.0078 65.4259 13.2078 66.2899 13.6078C67.1699 13.9918 67.8579 14.5358 68.3539 15.2398C68.8499 15.9278 69.0979 16.6958 69.0979 17.5438C69.0979 18.2958 68.9059 19.0078 68.5219 19.6798C68.1539 20.3358 67.6819 20.8238 67.1059 21.1438C67.9219 21.4318 68.5699 21.8958 69.0499 22.5358C69.5459 23.1758 69.7939 23.9678 69.7939 24.9118C69.7939 25.9518 69.5219 26.8718 68.9779 27.6718C68.4339 28.4718 67.6819 29.0958 66.7219 29.5438C65.7619 29.9758 64.6739 30.1918 63.4579 30.1918Z" fill="white" fill-opacity="0.5"/>
</g>
<g style="mix-blend-mode:overlay">
<path d="M53.4 18.0718V21.5278H49.8V18.0718H53.4ZM53.4 26.5438V29.9998H49.8V26.5438H53.4Z" fill="white" fill-opacity="0.5"/>
</g>
<g style="mix-blend-mode:overlay">
<path d="M39.5399 30.1918C37.4759 30.1918 35.9159 29.5038 34.8599 28.1278C33.8199 26.7358 33.2999 24.7358 33.2999 22.1278V21.0718C33.2999 18.4638 33.8199 16.4718 34.8599 15.0958C35.9159 13.7038 37.4759 13.0078 39.5399 13.0078H40.5239C42.6199 13.0078 44.1879 13.6958 45.2279 15.0718C46.2679 16.4478 46.7879 18.4478 46.7879 21.0718V22.1278C46.7879 24.7518 46.2679 26.7518 45.2279 28.1278C44.1879 29.5038 42.6199 30.1918 40.5239 30.1918H39.5399ZM40.3799 27.0718C41.2119 27.0718 41.8839 26.7438 42.3959 26.0878C42.9079 25.4318 43.1639 24.4718 43.1639 23.2078V19.9918C43.1639 18.7278 42.9079 17.7678 42.3959 17.1118C41.8839 16.4398 41.2119 16.1038 40.3799 16.1038H39.7319C38.8839 16.1038 38.2039 16.4398 37.6919 17.1118C37.1799 17.7678 36.9239 18.7278 36.9239 19.9918V23.2078C36.9239 24.4718 37.1799 25.4318 37.6919 26.0878C38.2199 26.7438 38.8999 27.0718 39.7319 27.0718H40.3799ZM44.8199 15.1678L37.8839 28.5358L35.2919 27.8638L42.1559 14.6398L44.8199 15.1678Z" fill="white" fill-opacity="0.5"/>
</g>
<g style="mix-blend-mode:overlay">
<path d="M23.44 30.1918C21.376 30.1918 19.816 29.5038 18.76 28.1278C17.72 26.7358 17.2 24.7358 17.2 22.1278V21.0718C17.2 18.4638 17.72 16.4718 18.76 15.0958C19.816 13.7038 21.376 13.0078 23.44 13.0078H24.424C26.52 13.0078 28.088 13.6958 29.128 15.0718C30.168 16.4478 30.688 18.4478 30.688 21.0718V22.1278C30.688 24.7518 30.168 26.7518 29.128 28.1278C28.088 29.5038 26.52 30.1918 24.424 30.1918H23.44ZM24.28 27.0718C25.112 27.0718 25.784 26.7438 26.296 26.0878C26.808 25.4318 27.064 24.4718 27.064 23.2078V19.9918C27.064 18.7278 26.808 17.7678 26.296 17.1118C25.784 16.4398 25.112 16.1038 24.28 16.1038H23.632C22.784 16.1038 22.104 16.4398 21.592 17.1118C21.08 17.7678 20.824 18.7278 20.824 19.9918V23.2078C20.824 24.4718 21.08 25.4318 21.592 26.0878C22.12 26.7438 22.8 27.0718 23.632 27.0718H24.28ZM28.72 15.1678L21.784 28.5358L19.192 27.8638L26.056 14.6398L28.72 15.1678Z" fill="white" fill-opacity="0.5"/>
</g>
</g>
</g>
<defs>
<filter id="filter0_f_204_1787" x="5.19995" y="1.00781" width="91.6873" height="41.1841" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feGaussianBlur stdDeviation="6" result="effect1_foregroundBlur_204_1787"/>
</filter>
<clipPath id="clip0_204_1787">
<rect width="100" height="44" fill="white"/>
</clipPath>
</defs>
</svg>
`,
	__vite_glob_0_35 = `<svg width="390" height="844" viewBox="0 0 390 844" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M-18.7563 -620L34.4966 -377.127V-403.973H34.7466V-376.098H74.4966V-403.973H74.7466V-376.098H114.497V-403.973H114.747V-376.098H154.497V-403.973H154.747V-376.098H194.497V-403.973H194.747V-376.098H234.497V-403.973H234.747V-376.098H274.497V-403.973H274.747V-376.098H314.497V-403.973H314.747V-376.098H354.497V-403.973H354.747V-377.127L407.999 -620L408.244 -619.946L354.747 -375.96V-321.083L366.997 -374.775V-403.973H367.247V-375.871L401.5 -526.001L401.743 -525.945L367.247 -374.747V-316.75L416 -518.503L416.243 -518.444L367.247 -315.686V-254.254L407.001 -398.506L407.242 -398.44L367.247 -253.313V-193.998L410.502 -336.51L410.741 -336.437L367.247 -193.138V-134.498L404.503 -247.013L404.74 -246.934L367.247 -133.703V-75.2222L403.004 -174.016L403.239 -173.931L367.247 -74.4877V-13.3L406.507 -103.523L406.736 -103.423L367.247 -12.6734V46.2593L408.01 -36.0287L408.234 -35.9177L367.247 46.8225V106.406L405.014 42.4631L405.229 42.5903L367.247 106.898V167.136L396.522 128.451L396.721 128.602L367.247 167.551V226.605L395.531 196.941L395.712 197.113L367.247 226.967V287.507L399.053 266.422L399.191 266.631L367.247 287.807V347.394L395.079 337.409L395.164 337.644L367.247 347.66V407.902H392.122V408.152L367.247 408.152V468.394L395.164 478.409L395.079 478.645L367.247 468.659V528.246L399.191 549.423L399.053 549.631L367.247 528.546V589.086L395.712 618.94L395.531 619.113L367.247 589.449V648.503L396.721 687.451L396.522 687.602L367.247 648.917V709.156L405.229 773.463L405.014 773.59L367.247 709.647V769.231L408.234 851.971L408.01 852.082L367.247 769.794V828.727L406.736 919.477L406.507 919.577L367.247 829.354V890.541L403.239 989.984L403.004 990.069L367.247 891.276V949.757L404.74 1062.99L404.503 1063.07L367.247 950.552V1009.19L410.741 1152.49L410.502 1152.56L367.247 1010.05V1069.37L407.242 1214.49L407.001 1214.56L367.247 1070.31V1131.74L416.243 1334.5L416 1334.56L367.247 1132.8V1190.8L401.743 1342L401.5 1342.05L367.247 1191.92V1220.03H366.997V1190.83L354.747 1137.14V1192.01L408.244 1436L407.999 1436.05L354.747 1193.18V1220.03H354.497V1192.15H314.747V1220.03H314.497V1192.15H274.747V1220.03H274.497V1192.15H234.747V1220.03H234.497V1192.15H194.747V1220.03H194.497V1192.15H154.747V1220.03H154.497V1192.15H114.747V1220.03H114.497V1192.15H74.7466V1220.03H74.4966V1192.15H34.7466V1220.03H34.4966V1193.18L-18.7563 1436.05L-19.0005 1436L34.4966 1192.01V1137.14L22.2466 1190.83V1220.03H21.9966V1191.92L-12.2565 1342.05L-12.5002 1342L21.9966 1190.8V1132.8L-26.757 1334.56L-27 1334.5L21.9966 1131.74V1070.31L-17.758 1214.56L-17.999 1214.49L21.9966 1069.37V1010.05L-21.2588 1152.56L-21.498 1152.49L21.9966 1009.19V950.552L-15.2597 1063.07L-15.4971 1062.99L21.9966 949.757V891.276L-13.7608 990.069L-13.9958 989.984L21.9966 890.541V829.354L-17.2637 919.577L-17.4929 919.477L21.9966 828.727V769.794L-18.7665 852.082L-18.9905 851.971L21.9966 769.231V709.647L-15.7708 773.59L-15.9861 773.463L21.9966 709.156V648.917L-7.27868 687.602L-7.47803 687.451L21.9966 648.503V589.449L-6.28806 619.113L-6.46899 618.94L21.9966 589.086V528.546L-9.80938 549.631L-9.94751 549.423L21.9966 528.246V468.659L-5.83624 478.645L-5.92065 478.409L21.9966 468.394V408.152L-2.87842 408.152V407.902H21.9966V347.66L-5.92065 337.644L-5.83624 337.409L21.9966 347.394V287.807L-9.94751 266.631L-9.80938 266.422L21.9966 287.507V226.967L-6.46899 197.113L-6.28806 196.941L21.9966 226.605V167.551L-7.47803 128.602L-7.27868 128.451L21.9966 167.136V106.898L-15.9861 42.5903L-15.7708 42.4631L21.9966 106.406V46.8225L-18.9905 -35.9177L-18.7665 -36.0287L21.9966 46.2593V-12.6734L-17.4929 -103.423L-17.2637 -103.523L21.9966 -13.3V-74.4877L-13.9958 -173.931L-13.7608 -174.016L21.9966 -75.2222V-133.703L-15.4971 -246.934L-15.2597 -247.013L21.9966 -134.498V-193.138L-21.498 -336.437L-21.2588 -336.51L21.9966 -193.998V-253.313L-17.999 -398.44L-17.758 -398.506L21.9966 -254.254V-315.686L-27 -518.444L-26.757 -518.503L21.9966 -316.75V-374.747L-12.5002 -525.945L-12.2565 -526.001L21.9966 -375.871V-403.973H22.2466V-374.775L34.4966 -321.083V-375.96L-19.0005 -619.946L-18.7563 -620ZM194.497 1191.9V1136.15H154.747V1191.9H194.497ZM194.497 1135.9V1080.15H154.747V1135.9H194.497ZM194.497 1079.9V1024.15H154.747V1079.9H194.497ZM194.497 1023.9V968.152H154.747V1023.9H194.497ZM194.497 967.902V912.152H154.747V967.902H194.497ZM194.497 911.902V856.152H154.747V911.902H194.497ZM194.497 855.902V800.152H154.747V855.902H194.497ZM194.497 799.902V744.152H154.747V799.902H194.497ZM194.497 743.902V688.152H154.747V743.902H194.497ZM194.497 687.902V632.152H154.747V687.902H194.497ZM194.497 631.902V576.152H154.747V631.902H194.497ZM194.497 575.902V520.152H154.747V575.902H194.497ZM194.497 519.902V464.152H154.747V519.902H194.497ZM194.497 463.902V408.152H154.747V463.902H194.497ZM194.747 407.902H234.497V352.152H194.747V407.902ZM234.747 407.902H274.497V352.152H234.747V407.902ZM274.747 407.902H314.497V352.152H274.747V407.902ZM314.747 407.902H354.497V352.152H314.747V407.902ZM354.747 407.902H366.997V347.749L354.747 352.144V407.902ZM194.747 1191.9H234.497V1136.15H194.747V1191.9ZM194.747 1135.9H234.497V1080.15H194.747V1135.9ZM194.747 1079.9H234.497V1024.15H194.747V1079.9ZM194.747 1023.9H234.497V968.152H194.747V1023.9ZM194.747 967.902H234.497V912.152H194.747V967.902ZM194.747 911.902H234.497V856.152H194.747V911.902ZM194.747 855.902H234.497V800.152H194.747V855.902ZM194.747 799.902H234.497V744.152H194.747V799.902ZM194.747 743.902H234.497V688.152H194.747V743.902ZM194.747 687.902H234.497V632.152H194.747V687.902ZM194.747 631.902H234.497V576.152H194.747V631.902ZM194.747 575.902H234.497V520.152H194.747V575.902ZM194.747 519.902H234.497V464.152H194.747V519.902ZM194.747 463.902H234.497V408.152L194.747 408.152V463.902ZM234.747 408.152V463.902H274.497V408.152H234.747ZM274.747 408.152V463.902H314.497V408.152H274.747ZM314.747 408.152V463.902H354.497V408.152H314.747ZM354.747 408.152V463.909L366.997 468.304V408.152H354.747ZM154.747 -375.848H194.497V-320.098H154.747V-375.848ZM154.747 -319.848H194.497V-264.098H154.747V-319.848ZM154.747 -263.848H194.497V-208.098H154.747V-263.848ZM154.747 -207.848H194.497V-152.098H154.747V-207.848ZM154.747 -151.848H194.497V-96.0983H154.747V-151.848ZM154.747 -95.8483H194.497V-40.0983H154.747V-95.8483ZM154.747 -39.8483H194.497V15.9017H154.747V-39.8483ZM154.747 16.1517H194.497V71.9017H154.747V16.1517ZM154.747 72.1517H194.497V127.902H154.747V72.1517ZM154.747 128.152H194.497V183.902H154.747V128.152ZM154.747 184.152H194.497V239.902H154.747V184.152ZM154.747 240.152H194.497V295.902H154.747V240.152ZM154.747 296.152H194.497V351.902H154.747V296.152ZM154.747 352.152H194.497V407.902H154.747V352.152ZM194.747 -320.098V-375.848H234.497V-320.098H194.747ZM194.747 -264.098V-319.848H234.497V-264.098H194.747ZM194.747 -208.098V-263.848H234.497V-208.098H194.747ZM194.747 -152.098V-207.848H234.497V-152.098H194.747ZM194.747 -96.0983V-151.848H234.497V-96.0983H194.747ZM194.747 -40.0983V-95.8483H234.497V-40.0983H194.747ZM194.747 15.9017V-39.8483H234.497V15.9017H194.747ZM194.747 71.9017V16.1517H234.497V71.9017H194.747ZM194.747 127.902V72.1517H234.497V127.902H194.747ZM194.747 183.902V128.152H234.497V183.902H194.747ZM194.747 239.902V184.152H234.497V239.902H194.747ZM194.747 295.902V240.152H234.497V295.902H194.747ZM194.747 351.902V296.152H234.497V351.902H194.747ZM22.2466 407.902H34.4966V352.144L22.2466 347.749V407.902ZM34.7466 407.902H74.4966V352.152H34.7466V407.902ZM74.7466 407.902H114.497V352.152H74.7466V407.902ZM114.747 407.902H154.497V352.152H114.747V407.902ZM22.2466 408.152V468.304L34.4966 463.909V408.152H22.2466ZM34.7466 408.152V463.902H74.4966V408.152H34.7466ZM74.7466 408.152V463.902H114.497V408.152H74.7466ZM114.747 408.152V463.902H154.497V408.152H114.747ZM22.2466 -373.651V-315.715L34.4966 -265.022V-319.959L22.2466 -373.651ZM22.2466 -253.347V-314.651L34.4966 -263.958V-208.897L22.2466 -253.347ZM22.2466 -252.406V-193.175L34.4966 -152.815V-207.956L22.2466 -252.406ZM22.2466 -192.314L34.4966 -151.955V-96.7485L22.2466 -133.743V-192.314ZM22.2466 -132.948V-74.5315L34.4966 -40.6862V-95.9531L22.2466 -132.948ZM22.2466 -73.7969L34.4966 -39.9516V15.426L22.2466 -12.7255V-73.7969ZM22.2466 -12.0989V46.764L34.4966 71.493V16.0526L22.2466 -12.0989ZM22.2466 47.3272L34.4966 72.0562V127.569L22.2466 106.829V47.3272ZM22.2466 107.321V167.467L34.4966 183.654V128.061L22.2466 107.321ZM22.2466 167.881L34.4966 184.069V239.715L22.2466 226.867V167.881ZM22.2466 227.229V287.673L34.4966 295.794V240.077L22.2466 227.229ZM22.2466 287.973L34.4966 296.094V351.878L22.2466 347.484V287.973ZM114.747 -375.848H154.497V-320.098H114.747V-375.848ZM74.7466 -375.848H114.497V-320.098H74.7466V-375.848ZM34.7466 -375.848H74.4966V-320.098H34.7466V-375.848ZM34.7466 -319.848V-264.098H74.4966V-319.848H34.7466ZM74.7466 -319.848V-264.098H114.497V-319.848H74.7466ZM114.747 -319.848V-264.098H154.497V-319.848H114.747ZM114.747 -263.848H154.497V-208.098H114.747V-263.848ZM74.7466 -263.848H114.497V-208.098H74.7466V-263.848ZM34.7466 -263.848H74.4966V-208.098H34.7466V-263.848ZM34.7466 -207.848V-152.098H74.4966V-207.848H34.7466ZM74.7466 -207.848V-152.098H114.497V-207.848H74.7466ZM114.747 -207.848V-152.098H154.497V-207.848H114.747ZM114.747 -151.848H154.497V-96.0983H114.747V-151.848ZM74.7466 -151.848H114.497V-96.0983H74.7466V-151.848ZM34.7466 -151.848H74.4966V-96.0983H34.7466V-151.848ZM34.7466 -95.8483V-40.0983H74.4966V-95.8483H34.7466ZM74.7466 -95.8483V-40.0983H114.497V-95.8483H74.7466ZM114.747 -95.8483V-40.0983H154.497V-95.8483H114.747ZM114.747 -39.8483H154.497V15.9017H114.747V-39.8483ZM74.7466 -39.8483H114.497V15.9017H74.7466V-39.8483ZM34.7466 -39.8483H74.4966V15.9017H34.7466V-39.8483ZM34.7466 16.1517V71.9017H74.4966V16.1517H34.7466ZM74.7466 16.1517V71.9017H114.497V16.1517H74.7466ZM114.747 16.1517V71.9017H154.497V16.1517H114.747ZM114.747 72.1517H154.497V127.902H114.747V72.1517ZM74.7466 72.1517H114.497V127.902H74.7466V72.1517ZM34.7466 72.1517H74.4966V127.902H34.7466V72.1517ZM34.7466 128.152V183.902H74.4966V128.152H34.7466ZM74.7466 128.152V183.902H114.497V128.152H74.7466ZM114.747 128.152V183.902H154.497V128.152H114.747ZM114.747 184.152H154.497V239.902H114.747V184.152ZM74.7466 184.152H114.497V239.902H74.7466V184.152ZM34.7466 184.152H74.4966V239.902H34.7466V184.152ZM34.7466 240.152V295.902H74.4966V240.152H34.7466ZM74.7466 240.152V295.902H114.497V240.152H74.7466ZM114.747 240.152V295.902H154.497V240.152H114.747ZM114.747 296.152H154.497V351.902H114.747V296.152ZM74.7466 296.152H114.497V351.902H74.7466V296.152ZM34.7466 296.152H74.4966V351.902H34.7466V296.152ZM22.2466 1189.7V1131.77L34.4966 1081.08V1136.01L22.2466 1189.7ZM22.2466 1069.4V1130.7L34.4966 1080.01V1024.95L22.2466 1069.4ZM22.2466 1068.46V1009.23L34.4966 968.869V1024.01L22.2466 1068.46ZM22.2466 1008.37L34.4966 968.008V912.802L22.2466 949.797V1008.37ZM22.2466 949.002V890.585L34.4966 856.74V912.007L22.2466 949.002ZM22.2466 889.851L34.4966 856.005V800.628L22.2466 828.779V889.851ZM22.2466 828.152V769.29L34.4966 744.561V800.001L22.2466 828.152ZM22.2466 768.726L34.4966 743.997V688.484L22.2466 709.224V768.726ZM22.2466 708.733V648.587L34.4966 632.399V687.993L22.2466 708.733ZM22.2466 648.172L34.4966 631.985V576.339L22.2466 589.187V648.172ZM22.2466 588.824V528.381L34.4966 520.26V575.977L22.2466 588.824ZM22.2466 528.081L34.4966 519.96V464.175L22.2466 468.57V528.081ZM114.747 1191.9H154.497V1136.15H114.747V1191.9ZM74.7466 1191.9H114.497V1136.15H74.7466V1191.9ZM34.7466 1191.9H74.4966V1136.15H34.7466V1191.9ZM34.7466 1135.9V1080.15H74.4966V1135.9H34.7466ZM74.7466 1135.9V1080.15H114.497V1135.9H74.7466ZM114.747 1135.9V1080.15H154.497V1135.9H114.747ZM114.747 1079.9H154.497V1024.15H114.747V1079.9ZM74.7466 1079.9H114.497V1024.15H74.7466V1079.9ZM34.7466 1079.9H74.4966V1024.15H34.7466V1079.9ZM34.7466 1023.9V968.152H74.4966V1023.9H34.7466ZM74.7466 1023.9V968.152H114.497V1023.9H74.7466ZM114.747 1023.9V968.152H154.497V1023.9H114.747ZM114.747 967.902H154.497V912.152H114.747V967.902ZM74.7466 967.902H114.497V912.152H74.7466V967.902ZM34.7466 967.902H74.4966V912.152H34.7466V967.902ZM34.7466 911.902V856.152H74.4966V911.902H34.7466ZM74.7466 911.902V856.152H114.497V911.902H74.7466ZM114.747 911.902V856.152H154.497V911.902H114.747ZM114.747 855.902H154.497V800.152H114.747V855.902ZM74.7466 855.902H114.497V800.152H74.7466V855.902ZM34.7466 855.902H74.4966V800.152H34.7466V855.902ZM34.7466 799.902V744.152H74.4966V799.902H34.7466ZM74.7466 799.902V744.152H114.497V799.902H74.7466ZM114.747 799.902V744.152H154.497V799.902H114.747ZM114.747 743.902H154.497V688.152H114.747V743.902ZM74.7466 743.902H114.497V688.152H74.7466V743.902ZM34.7466 743.902H74.4966V688.152H34.7466V743.902ZM34.7466 687.902V632.152H74.4966V687.902H34.7466ZM74.7466 687.902V632.152H114.497V687.902H74.7466ZM114.747 687.902V632.152H154.497V687.902H114.747ZM114.747 631.902H154.497V576.152H114.747V631.902ZM74.7466 631.902H114.497V576.152H74.7466V631.902ZM34.7466 631.902H74.4966V576.152H34.7466V631.902ZM34.7466 575.902V520.152H74.4966V575.902H34.7466ZM74.7466 575.902V520.152H114.497V575.902H74.7466ZM114.747 575.902V520.152H154.497V575.902H114.747ZM114.747 519.902H154.497V464.152H114.747V519.902ZM74.7466 519.902H114.497V464.152H74.7466V519.902ZM34.7466 519.902H74.4966V464.152H34.7466V519.902ZM366.997 -315.715V-373.651L354.747 -319.959V-265.022L366.997 -315.715ZM366.997 -314.651V-253.347L354.747 -208.897V-263.958L366.997 -314.651ZM366.997 -193.175V-252.406L354.747 -207.956V-152.815L366.997 -193.175ZM354.747 -151.955L366.997 -192.314V-133.743L354.747 -96.7485V-151.955ZM366.997 -74.5315V-132.948L354.747 -95.9531V-40.6862L366.997 -74.5315ZM354.747 -39.9516L366.997 -73.7969V-12.7255L354.747 15.426V-39.9516ZM366.997 46.764V-12.0989L354.747 16.0526V71.493L366.997 46.764ZM354.747 72.0562L366.997 47.3272V106.829L354.747 127.569V72.0562ZM366.997 167.467V107.321L354.747 128.061V183.654L366.997 167.467ZM354.747 184.069L366.997 167.881V226.867L354.747 239.715V184.069ZM366.997 287.673V227.229L354.747 240.077V295.794L366.997 287.673ZM354.747 296.094L366.997 287.973V347.484L354.747 351.878V296.094ZM234.747 -375.848H274.497V-320.098H234.747V-375.848ZM274.747 -375.848H314.497V-320.098H274.747V-375.848ZM314.747 -375.848H354.497V-320.098H314.747V-375.848ZM354.497 -264.098V-319.848H314.747V-264.098H354.497ZM314.497 -264.098V-319.848H274.747V-264.098H314.497ZM274.497 -264.098V-319.848H234.747V-264.098H274.497ZM234.747 -263.848H274.497V-208.098H234.747V-263.848ZM274.747 -263.848H314.497V-208.098H274.747V-263.848ZM314.747 -263.848H354.497V-208.098H314.747V-263.848ZM354.497 -152.098V-207.848H314.747V-152.098H354.497ZM314.497 -152.098V-207.848H274.747V-152.098H314.497ZM274.497 -152.098V-207.848H234.747V-152.098H274.497ZM234.747 -151.848H274.497V-96.0983H234.747V-151.848ZM274.747 -151.848H314.497V-96.0983H274.747V-151.848ZM314.747 -151.848H354.497V-96.0983H314.747V-151.848ZM354.497 -40.0983V-95.8483H314.747V-40.0983H354.497ZM314.497 -40.0983V-95.8483H274.747V-40.0983H314.497ZM274.497 -40.0983V-95.8483H234.747V-40.0983H274.497ZM234.747 -39.8483H274.497V15.9017H234.747V-39.8483ZM274.747 -39.8483H314.497V15.9017H274.747V-39.8483ZM314.747 -39.8483H354.497V15.9017H314.747V-39.8483ZM354.497 71.9017V16.1517H314.747V71.9017H354.497ZM314.497 71.9017V16.1517H274.747V71.9017H314.497ZM274.497 71.9017V16.1517H234.747V71.9017H274.497ZM234.747 72.1517H274.497V127.902H234.747V72.1517ZM274.747 72.1517H314.497V127.902H274.747V72.1517ZM314.747 72.1517H354.497V127.902H314.747V72.1517ZM354.497 183.902V128.152H314.747V183.902H354.497ZM314.497 183.902V128.152H274.747V183.902H314.497ZM274.497 183.902V128.152H234.747V183.902H274.497ZM234.747 184.152H274.497V239.902H234.747V184.152ZM274.747 184.152H314.497V239.902H274.747V184.152ZM314.747 184.152H354.497V239.902H314.747V184.152ZM354.497 295.902V240.152H314.747V295.902H354.497ZM314.497 295.902V240.152H274.747V295.902H314.497ZM274.497 295.902V240.152H234.747V295.902H274.497ZM234.747 296.152H274.497V351.902H234.747V296.152ZM274.747 296.152H314.497V351.902H274.747V296.152ZM314.747 296.152H354.497V351.902H314.747V296.152ZM366.997 1189.7V1131.77L354.747 1081.08V1136.01L366.997 1189.7ZM366.997 1069.4V1130.7L354.747 1080.01V1024.95L366.997 1069.4ZM366.997 1068.46V1009.23L354.747 968.869V1024.01L366.997 1068.46ZM366.997 1008.37L354.747 968.008V912.802L366.997 949.797V1008.37ZM366.997 949.002V890.585L354.747 856.74V912.007L366.997 949.002ZM366.997 889.851L354.747 856.005V800.628L366.997 828.779V889.851ZM366.997 828.152V769.29L354.747 744.561V800.001L366.997 828.152ZM366.997 768.726L354.747 743.997V688.484L366.997 709.224V768.726ZM366.997 708.733V648.587L354.747 632.399V687.993L366.997 708.733ZM366.997 648.172L354.747 631.985V576.339L366.997 589.187V648.172ZM366.997 588.824V528.381L354.747 520.26V575.977L366.997 588.824ZM366.997 528.081L354.747 519.96V464.175L366.997 468.57V528.081ZM274.497 1191.9H234.747V1136.15H274.497V1191.9ZM314.497 1191.9H274.747V1136.15H314.497V1191.9ZM354.497 1191.9H314.747V1136.15H354.497V1191.9ZM354.497 1135.9V1080.15H314.747V1135.9H354.497ZM314.497 1135.9V1080.15H274.747V1135.9H314.497ZM274.497 1135.9V1080.15H234.747V1135.9H274.497ZM274.497 1079.9H234.747V1024.15H274.497V1079.9ZM314.497 1079.9H274.747V1024.15H314.497V1079.9ZM354.497 1079.9H314.747V1024.15H354.497V1079.9ZM354.497 1023.9V968.152H314.747V1023.9H354.497ZM314.497 1023.9V968.152H274.747V1023.9H314.497ZM274.497 1023.9V968.152H234.747V1023.9H274.497ZM274.497 967.902H234.747V912.152H274.497V967.902ZM314.497 967.902H274.747V912.152H314.497V967.902ZM354.497 967.902H314.747V912.152H354.497V967.902ZM354.497 911.902V856.152H314.747V911.902H354.497ZM314.497 911.902V856.152H274.747V911.902H314.497ZM274.497 911.902V856.152H234.747V911.902H274.497ZM274.497 855.902H234.747V800.152H274.497V855.902ZM314.497 855.902H274.747V800.152H314.497V855.902ZM354.497 855.902H314.747V800.152H354.497V855.902ZM354.497 799.902V744.152H314.747V799.902H354.497ZM314.497 799.902V744.152H274.747V799.902H314.497ZM274.497 799.902V744.152H234.747V799.902H274.497ZM274.497 743.902H234.747V688.152H274.497V743.902ZM314.497 743.902H274.747V688.152H314.497V743.902ZM354.497 743.902H314.747V688.152H354.497V743.902ZM354.497 687.902V632.152H314.747V687.902H354.497ZM314.497 687.902V632.152H274.747V687.902H314.497ZM274.497 687.902V632.152H234.747V687.902H274.497ZM274.497 631.902H234.747V576.152H274.497V631.902ZM314.497 631.902H274.747V576.152H314.497V631.902ZM354.497 631.902H314.747V576.152H354.497V631.902ZM354.497 575.902V520.152H314.747V575.902H354.497ZM314.497 575.902V520.152H274.747V575.902H314.497ZM274.497 575.902V520.152H234.747V575.902H274.497ZM274.497 519.902H234.747V464.152H274.497V519.902ZM314.497 519.902H274.747V464.152H314.497V519.902ZM354.497 519.902H314.747V464.152H354.497V519.902Z" fill="#707579"/>
</svg>
`,
	__vite_glob_0_36 = `<svg width="1" height="1" viewBox="0 0 1 1" fill="none" xmlns="http://www.w3.org/2000/svg">
    <rect width="1" height="1" fill="black"/>
</svg>
`,
	__vite_glob_0_37 = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="64" height="64" rx="32" fill="#57BC18"/>
<path d="M17 33L26.8995 42.8995L48.1145 21.6865" stroke="white" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_38 = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="64" height="64" rx="32" fill="#E53935"/>
<path d="M32 20V36M32.0996 44V44.2L31.9004 44.2004V44H32.0996Z" stroke="white" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_39 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0V20H20V0H0ZM8.5 15.1L2.90002 9.5L5 7.39999L8.40002 10.8L14.8 4.39999L16.9 6.5L8.5 15.1Z" fill="white"/>
</svg>
`,
	__vite_glob_0_40 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M5 10H10M10 10H15M10 10V15M10 10V5" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_41 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10.0002 12.5L12.5002 9.99998M12.5002 9.99998L10.0002 7.49998M12.5002 9.99998H3.3335M3.3335 6.04V6.00014C3.3335 5.06672 3.3335 4.59966 3.51515 4.24314C3.67494 3.92954 3.92972 3.67476 4.24333 3.51497C4.59985 3.33331 5.0669 3.33331 6.00033 3.33331H14.0003C14.9337 3.33331 15.3998 3.33331 15.7563 3.51497C16.0699 3.67476 16.3256 3.92954 16.4854 4.24314C16.6668 4.59931 16.6668 5.06581 16.6668 5.9974V14.003C16.6668 14.9346 16.6668 15.4004 16.4854 15.7565C16.3256 16.0702 16.0699 16.3254 15.7563 16.4852C15.4002 16.6666 14.9343 16.6666 14.0027 16.6666H5.99759C5.06599 16.6666 4.5995 16.6666 4.24333 16.4852C3.92972 16.3254 3.67494 16.0699 3.51515 15.7563C3.3335 15.3998 3.3335 14.9334 3.3335 14V13.9583" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_42 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12.5 15.8333C12.5 13.9924 10.2614 12.5 7.5 12.5C4.73858 12.5 2.5 13.9924 2.5 15.8333M15.8333 13.3333V10.8333M15.8333 10.8333V8.33331M15.8333 10.8333H13.3333M15.8333 10.8333H18.3333M7.5 9.99998C5.65905 9.99998 4.16667 8.5076 4.16667 6.66665C4.16667 4.8257 5.65905 3.33331 7.5 3.33331C9.34095 3.33331 10.8333 4.8257 10.8333 6.66665C10.8333 8.5076 9.34095 9.99998 7.5 9.99998Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_43 = `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8.00033 5.33333L2.66699 10.6667V13.3333L5.33366 13.3333L10.667 7.99999M8.00033 5.33333L9.91274 3.42089L9.91389 3.41976C10.1772 3.1565 10.309 3.02464 10.461 2.97526C10.5949 2.93175 10.7392 2.93175 10.873 2.97526C11.0249 3.02461 11.1567 3.15632 11.4195 3.4192L12.5794 4.57907C12.8434 4.84308 12.9755 4.97514 13.0249 5.12736C13.0684 5.26126 13.0684 5.40549 13.0249 5.53938C12.9755 5.69149 12.8436 5.82336 12.58 6.08699L12.5794 6.08756L10.667 7.99999M8.00033 5.33333L10.667 7.99999" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_44 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.32">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21Z" fill="#06C167"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15 10L11 14L9 12" fill="#06C167"/>
</g>
<path d="M15 10L11 14L9 12M12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21Z" stroke="#06C167" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_45 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_7706_35090)">
<path d="M10.0002 0.833496C4.91683 0.833496 0.833496 4.91683 0.833496 10.0002C0.833496 15.0835 4.91683 19.1668 10.0002 19.1668C15.0835 19.1668 19.1668 15.0835 19.1668 10.0002C19.1668 4.91683 15.0835 0.833496 10.0002 0.833496ZM15.0002 13.3335L13.3335 15.0002L10.0002 11.6668L6.66683 15.0002L5.00016 13.3335L8.3335 10.0002L5.00016 6.66683L6.66683 5.00016L10.0002 8.3335L13.3335 5.00016L15.0002 6.66683L11.6668 10.0002L15.0002 13.3335Z" fill="white"/>
</g>
<defs>
<clipPath id="clip0_7706_35090">
<rect width="20" height="20" fill="white"/>
</clipPath>
</defs>
</svg>
`,
	__vite_glob_0_46 = `<svg width="12" height="28" viewBox="0 0 12 28" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9.5656 3.31579C10.7713 1.83397 10.9478 0 10.9478 0C10.9478 0 8.90265 0.35761 7.6969 1.83945C6.49124 3.32127 6.58159 5.36615 6.58159 5.36615C6.58159 5.36615 8.35985 4.79759 9.5656 3.31579Z" fill="#DDDDDD"/>
<path d="M3.94771 1.62939C3.94771 1.62939 5.06598 3.10567 5.18159 5.00157C5.2971 6.89745 4.36622 8.495 4.36622 8.495C4.36622 8.495 2.90632 7.03897 2.7908 5.14305C2.6752 3.24719 3.94771 1.62939 3.94771 1.62939Z" fill="#DDDDDD"/>
<path d="M10.847 5.24345C10.847 5.24345 8.9801 5.14649 7.31567 6.1043C5.65126 7.06214 4.81962 8.71205 4.81962 8.71205C4.81962 8.71205 6.85911 9.10014 8.52353 8.14234C10.1879 7.18449 10.847 5.24345 10.847 5.24345Z" fill="#DDDDDD"/>
<path d="M3.17664 10.3194C2.59905 8.5074 1.15155 7.34155 1.15155 7.34155C1.15155 7.34155 0.314033 9.21463 0.891615 11.0267C1.4692 12.8387 3.24314 13.9035 3.24314 13.9035C3.24314 13.9035 3.75422 12.1314 3.17664 10.3194Z" fill="#DDDDDD"/>
<path d="M5.51809 10.8807C6.89792 9.55454 8.73323 9.20356 8.73323 9.20356C8.73323 9.20356 8.57022 11.2441 7.19041 12.5702C5.81059 13.8964 3.73641 14.006 3.73641 14.006C3.73641 14.006 4.13828 12.2068 5.51809 10.8807Z" fill="#DDDDDD"/>
<path d="M0.0155011 13.7232C0.0155011 13.7232 1.75779 14.3912 2.8754 15.9387C3.99294 17.4862 4.06265 19.327 4.06265 19.327C4.06265 19.327 2.04158 18.8546 0.923969 17.3071C-0.193575 15.7596 0.0155011 13.7232 0.0155011 13.7232Z" fill="#DDDDDD"/>
<path d="M7.81004 13.1855C7.81004 13.1855 6.17466 14.0781 5.27822 15.7595C4.38187 17.4409 4.56382 19.2744 4.56382 19.2744C4.56382 19.2744 6.50214 18.5385 7.39858 16.8571C8.29501 15.1758 7.81004 13.1855 7.81004 13.1855Z" fill="#DDDDDD"/>
<path d="M4.40463 21.3285C2.85642 20.1971 0.98998 20.0923 0.98998 20.0923C0.98998 20.0923 1.42971 22.0927 2.97782 23.2241C4.52601 24.3556 6.59632 24.1895 6.59632 24.1895C6.59632 24.1895 5.95274 22.46 4.40463 21.3285Z" fill="#DDDDDD"/>
<path d="M6.63367 20.4264C6.95896 18.5543 8.23432 17.2074 8.23432 17.2074C8.23432 17.2074 9.31971 18.9526 8.99442 20.8247C8.66913 22.6967 7.05646 23.9868 7.05646 23.9868C7.05646 23.9868 6.30838 22.2985 6.63367 20.4264Z" fill="#DDDDDD"/>
<path d="M4.11365 25.3986C4.11365 25.3986 5.92167 24.9299 7.74887 25.5345C9.57607 26.1391 10.7305 27.5882 10.7305 27.5882C10.7305 27.5882 8.81367 28.3765 6.98645 27.7718C5.15925 27.1672 4.11365 25.3986 4.11365 25.3986Z" fill="#DDDDDD"/>
<path d="M10.0988 20.4489C10.0988 20.4489 9.30818 22.1183 9.58593 23.9978C9.86368 25.8773 11.1046 27.2552 11.1046 27.2552C11.1046 27.2552 12.2338 25.5373 11.956 23.6578C11.6783 21.7782 10.0988 20.4489 10.0988 20.4489Z" fill="#DDDDDD"/>
</svg>
`,
	__vite_glob_0_47 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8.33348 11.6667L13.3335 6.66675M13.3335 6.66675H8.3335M13.3335 6.66675V11.6667" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_48 = `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8 2C4.66375 2 2 4.66375 2 8C2 11.3363 4.66375 14 8 14C11.3363 14 14 11.3363 14 8C14 4.66375 11.3363 2 8 2ZM0 8C0 3.58172 3.58172 0 8 0C12.4183 0 16 3.58172 16 8C16 12.4183 12.4183 16 8 16C3.58172 16 0 12.4183 0 8Z" fill="white"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14 8C14 4.68629 11.3137 2 8 2V0C12.4183 0 16 3.58172 16 8H14Z" fill="#276EF1"/>
</svg>
`,
	__vite_glob_0_49 = `<svg viewBox="0 0 78 36" xmlns="http://www.w3.org/2000/svg" fill="none">
  <path 
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M39 2H60.5833C69.0977 2 76 9.16344 76 18C76 26.8366 69.0977 34 60.5833 34H17.4167C8.90228 34 2 26.8366 2 18C2 9.16344 8.90228 2 17.4167 2H39.0195"
    stroke-width="4"
    opacity="0.32"
  />

  <path 
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M39 2H60.5833C69.0977 2 76 9.16344 76 18C76 26.8366 69.0977 34 60.5833 34H17.4167C8.90228 34 2 26.8366 2 18C2 9.16344 8.90228 2 17.4167 2H39.0195"
    stroke-width="4"
  />
</svg>`,
	__vite_glob_0_50 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path opacity="0.32" fill-rule="evenodd" clip-rule="evenodd" d="M12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21Z" fill="#DE1135"/>
<path d="M9 9L11.9999 11.9999M11.9999 11.9999L14.9999 14.9999M11.9999 11.9999L9 14.9999M11.9999 11.9999L14.9999 9M12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21Z" stroke="#DE1135" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_51 = `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6.66667 10.6667H3.33334V14M9.33334 5.33333H12.6667V2M3.05534 6.00227C3.42913 5.07711 4.05496 4.27536 4.86171 3.68815C5.66845 3.10094 6.62458 2.75168 7.61984 2.68034C8.61511 2.609 9.60983 2.81827 10.4921 3.28441C11.3743 3.75055 12.1075 4.45503 12.6094 5.31742M12.945 9.99805C12.5712 10.9232 11.9454 11.725 11.1387 12.3122C10.3319 12.8994 9.37678 13.2482 8.38152 13.3195C7.38625 13.3909 6.39071 13.1816 5.50847 12.7155C4.62622 12.2494 3.89255 11.545 3.39063 10.6826" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_52 = `<svg width="12" height="28" viewBox="0 0 12 28" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M2.4344 3.31579C1.22874 1.83397 1.05217 0 1.05217 0C1.05217 0 3.09735 0.35761 4.3031 1.83945C5.50876 3.32127 5.41841 5.36615 5.41841 5.36615C5.41841 5.36615 3.64016 4.79759 2.4344 3.31579Z" fill="#DDDDDD"/>
<path d="M8.05229 1.62939C8.05229 1.62939 6.93402 3.10567 6.81841 5.00157C6.7029 6.89745 7.63378 8.495 7.63378 8.495C7.63378 8.495 9.09368 7.03897 9.2092 5.14305C9.32479 3.24719 8.05229 1.62939 8.05229 1.62939Z" fill="#DDDDDD"/>
<path d="M1.15297 5.24345C1.15297 5.24345 3.0199 5.14649 4.68433 6.1043C6.34874 7.06214 7.18038 8.71205 7.18038 8.71205C7.18038 8.71205 5.14089 9.10014 3.47647 8.14234C1.81205 7.18449 1.15297 5.24345 1.15297 5.24345Z" fill="#DDDDDD"/>
<path d="M8.82337 10.3194C9.40095 8.5074 10.8485 7.34155 10.8485 7.34155C10.8485 7.34155 11.686 9.21463 11.1084 11.0267C10.5308 12.8387 8.75686 13.9035 8.75686 13.9035C8.75686 13.9035 8.24578 12.1314 8.82337 10.3194Z" fill="#DDDDDD"/>
<path d="M6.48191 10.8807C5.10208 9.55454 3.26677 9.20356 3.26677 9.20356C3.26677 9.20356 3.42978 11.2441 4.80959 12.5702C6.18941 13.8964 8.26359 14.006 8.26359 14.006C8.26359 14.006 7.86172 12.2068 6.48191 10.8807Z" fill="#DDDDDD"/>
<path d="M11.9845 13.7232C11.9845 13.7232 10.2422 14.3912 9.1246 15.9387C8.00706 17.4862 7.93735 19.327 7.93735 19.327C7.93735 19.327 9.95842 18.8546 11.076 17.3071C12.1936 15.7596 11.9845 13.7232 11.9845 13.7232Z" fill="#DDDDDD"/>
<path d="M4.18996 13.1855C4.18996 13.1855 5.82534 14.0781 6.72178 15.7595C7.61813 17.4409 7.43618 19.2744 7.43618 19.2744C7.43618 19.2744 5.49786 18.5385 4.60142 16.8571C3.70499 15.1758 4.18996 13.1855 4.18996 13.1855Z" fill="#DDDDDD"/>
<path d="M7.59537 21.3285C9.14358 20.1971 11.01 20.0923 11.01 20.0923C11.01 20.0923 10.5703 22.0927 9.02218 23.2241C7.47399 24.3556 5.40368 24.1895 5.40368 24.1895C5.40368 24.1895 6.04726 22.46 7.59537 21.3285Z" fill="#DDDDDD"/>
<path d="M5.36633 20.4264C5.04104 18.5543 3.76568 17.2074 3.76568 17.2074C3.76568 17.2074 2.68029 18.9526 3.00558 20.8247C3.33087 22.6967 4.94354 23.9868 4.94354 23.9868C4.94354 23.9868 5.69162 22.2985 5.36633 20.4264Z" fill="#DDDDDD"/>
<path d="M7.88635 25.3986C7.88635 25.3986 6.07833 24.9299 4.25113 25.5345C2.42393 26.1391 1.26946 27.5882 1.26946 27.5882C1.26946 27.5882 3.18633 28.3765 5.01355 27.7718C6.84075 27.1672 7.88635 25.3986 7.88635 25.3986Z" fill="#DDDDDD"/>
<path d="M1.90117 20.4489C1.90117 20.4489 2.69182 22.1183 2.41407 23.9978C2.13632 25.8773 0.895405 27.2552 0.895405 27.2552C0.895405 27.2552 -0.233787 25.5373 0.0439615 23.6578C0.32171 21.7782 1.90117 20.4489 1.90117 20.4489Z" fill="#DDDDDD"/>
</svg>
`,
	__vite_glob_0_53 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M18.8336 17L15.167 13.3333C16.0837 12 16.6668 10.4167 16.6668 8.66669C16.6668 4.33336 13.0835 0.75 8.75016 0.75C4.41683 0.75 0.833496 4.33336 0.833496 8.66669C0.833496 13 4.41683 16.5834 8.75016 16.5834C10.5002 16.5834 12.0836 16 13.4169 15.0833L17.0835 18.75L18.8336 17ZM3.3335 8.75001C3.3335 5.75001 5.75016 3.33334 8.75016 3.33334C11.7502 3.33334 14.1668 5.75001 14.1668 8.75001C14.1668 11.75 11.7502 14.1667 8.75016 14.1667C5.75016 14.1667 3.3335 11.75 3.3335 8.75001Z" fill="white"/>
</svg>
`,
	__vite_glob_0_54 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 4C2.46243 4 0 6.46243 0 9.5C0 12.5376 2.46243 15 5.5 15H7.02242C7.27504 17.8033 9.63098 20 12.5 20H18.5C21.5376 20 24 17.5376 24 14.5C24 11.4624 21.5376 9 18.5 9H16.9776C16.725 6.19675 14.369 4 11.5 4H5.5Z" />
<path d="M17.6 8.06966V7.5C17.6 4.935 13.817 3 8.8 3C3.783 3 0 4.935 0 7.5V11.5909C0 13.7274 2.625 15.4251 6.4 15.9334V16.5C6.4 19.065 10.183 21 15.2 21C20.217 21 24 19.065 24 16.5V12.4091C24 10.292 21.458 8.59227 17.6 8.06966ZM22.4 12.4091C22.4 13.7611 19.321 15.2727 15.2 15.2727C14.827 15.2727 14.457 15.2594 14.092 15.2349C16.249 14.431 17.6 13.125 17.6 11.5909V9.72341C20.587 10.1785 22.4 11.414 22.4 12.4091ZM6.4 14.2756V11.8425C7.19578 11.9485 7.9975 12.0012 8.8 12C9.6025 12.0012 10.4042 11.9485 11.2 11.8425V14.2756C10.4054 14.3956 9.60322 14.4554 8.8 14.4545C7.99678 14.4554 7.1946 14.3956 6.4 14.2756ZM16 10.1519V11.5909C16 12.449 14.759 13.3705 12.8 13.9299V11.5398C14.091 11.2197 15.184 10.7431 16 10.1519ZM8.8 4.63636C12.921 4.63636 16 6.14795 16 7.5C16 8.85205 12.921 10.3636 8.8 10.3636C4.679 10.3636 1.6 8.85205 1.6 7.5C1.6 6.14795 4.679 4.63636 8.8 4.63636ZM1.6 11.5909V10.1519C2.416 10.7431 3.509 11.2197 4.8 11.5398V13.9299C2.841 13.3705 1.6 12.449 1.6 11.5909ZM8 16.5V16.0735C8.263 16.0837 8.529 16.0909 8.8 16.0909C9.188 16.0909 9.567 16.0776 9.939 16.0551C10.3523 16.2064 10.7732 16.3348 11.2 16.4397V18.839C9.241 18.2795 8 17.3581 8 16.5ZM12.8 19.1847V16.7455C13.5955 16.8548 14.3973 16.9095 15.2 16.9091C16.0025 16.9102 16.8042 16.8576 17.6 16.7516V19.1847C16.0085 19.4233 14.3915 19.4233 12.8 19.1847ZM19.2 18.839V16.4489C20.491 16.1287 21.584 15.6522 22.4 15.061V16.5C22.4 17.3581 21.159 18.2795 19.2 18.839Z" fill="#A6A6A6"/>
</svg>
`,
	__vite_glob_0_55 = `<svg width="25" height="24" viewBox="0 0 25 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M17.5 20C17.5 18.3431 15.2614 17 12.5 17C9.73858 17 7.5 18.3431 7.5 20M21.5 17.0004C21.5 15.7702 20.2659 14.7129 18.5 14.25M3.5 17.0004C3.5 15.7702 4.7341 14.7129 6.5 14.25M18.5 10.2361C19.1137 9.68679 19.5 8.8885 19.5 8C19.5 6.34315 18.1569 5 16.5 5C15.7316 5 15.0308 5.28885 14.5 5.76389M6.5 10.2361C5.88625 9.68679 5.5 8.8885 5.5 8C5.5 6.34315 6.84315 5 8.5 5C9.26835 5 9.96924 5.28885 10.5 5.76389M12.5 14C10.8431 14 9.5 12.6569 9.5 11C9.5 9.34315 10.8431 8 12.5 8C14.1569 8 15.5 9.34315 15.5 11C15.5 12.6569 14.1569 14 12.5 14Z" stroke="#A6A6A6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_56 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g id="Style=Line">
<path id="Vector" d="M20 17.0002V11.4522C20 10.9179 19.9995 10.6506 19.9346 10.4019C19.877 10.1816 19.7825 9.97307 19.6546 9.78464C19.5102 9.57201 19.3096 9.39569 18.9074 9.04383L14.1074 4.84383C13.3608 4.19054 12.9875 3.86406 12.5674 3.73982C12.1972 3.63035 11.8026 3.63035 11.4324 3.73982C11.0126 3.86397 10.6398 4.19014 9.89436 4.84244L5.09277 9.04383C4.69064 9.39569 4.49004 9.57201 4.3457 9.78464C4.21779 9.97307 4.12255 10.1816 4.06497 10.4019C4 10.6506 4 10.9179 4 11.4522V17.0002C4 17.932 4 18.3978 4.15224 18.7654C4.35523 19.2554 4.74432 19.6452 5.23438 19.8482C5.60192 20.0005 6.06786 20.0005 6.99974 20.0005C7.93163 20.0005 8.39808 20.0005 8.76562 19.8482C9.25568 19.6452 9.64467 19.2555 9.84766 18.7654C9.9999 18.3979 10 17.932 10 17.0001V16.0001C10 14.8955 10.8954 14.0001 12 14.0001C13.1046 14.0001 14 14.8955 14 16.0001V17.0001C14 17.932 14 18.3979 14.1522 18.7654C14.3552 19.2555 14.7443 19.6452 15.2344 19.8482C15.6019 20.0005 16.0679 20.0005 16.9997 20.0005C17.9316 20.0005 18.3981 20.0005 18.7656 19.8482C19.2557 19.6452 19.6447 19.2554 19.8477 18.7654C19.9999 18.3978 20 17.932 20 17.0002Z" stroke="#A6A6A6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
</svg>
`,
	__vite_glob_0_57 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g id="Style=Line">
<path id="Vector" d="M8 4H7.2002C6.08009 4 5.51962 4 5.0918 4.21799C4.71547 4.40973 4.40973 4.71547 4.21799 5.0918C4 5.51962 4 6.08009 4 7.2002V16.8002C4 17.9203 4 18.4801 4.21799 18.9079C4.40973 19.2842 4.71547 19.5905 5.0918 19.7822C5.5192 20 6.07899 20 7.19691 20H8M8 4H16.8002C17.9203 4 18.4796 4 18.9074 4.21799C19.2837 4.40973 19.5905 4.71547 19.7822 5.0918C20 5.5192 20 6.07899 20 7.19691V16.8036C20 17.9215 20 18.4805 19.7822 18.9079C19.5905 19.2842 19.2837 19.5905 18.9074 19.7822C18.48 20 17.921 20 16.8031 20H8M8 4V20M12 11H16M12 8H16" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
</svg>
`,
	__vite_glob_0_58 = `<svg width="25" height="24" viewBox="0 0 25 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect opacity="0.32" x="1.25" y="3" width="22" height="18" rx="4" fill=""/>
<rect x="2.25" y="4" width="20" height="16" rx="4" stroke="#A6A6A6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M12.75 12C12.75 10.3431 14.0931 9 15.75 9H21.75V15H15.75C14.0931 15 12.75 13.6569 12.75 12V12Z" stroke="#A6A6A6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M15.75 12C15.75 12.2761 15.9739 12.5 16.25 12.5C16.5261 12.5 16.75 12.2761 16.75 12C16.75 11.7239 16.5261 11.5 16.25 11.5C15.9739 11.5 15.75 11.7239 15.75 12Z" stroke="#A6A6A6" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_59 = `<svg width="15" height="14" viewBox="0 0 15 14" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_10150_57085)">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.4613 13.2878C11.6491 13.4208 11.8912 13.454 12.1071 13.3724C12.3229 13.2901 12.4816 13.1058 12.5294 12.8824C13.0363 10.5 14.266 4.47011 14.7274 2.30303C14.7624 2.13969 14.7041 1.96994 14.5757 1.86086C14.4474 1.75178 14.2695 1.72028 14.1108 1.77919C11.6649 2.68453 4.13231 5.51078 1.05347 6.65003C0.858058 6.72236 0.730891 6.91019 0.737308 7.11611C0.744308 7.32261 0.883141 7.50169 1.08322 7.56178C2.46397 7.97478 4.27639 8.54936 4.27639 8.54936C4.27639 8.54936 5.12339 11.1073 5.56497 12.4081C5.62039 12.5714 5.74814 12.6998 5.91672 12.7441C6.08472 12.7879 6.26439 12.7418 6.38981 12.6234C7.09914 11.9537 8.19581 10.9183 8.19581 10.9183C8.19581 10.9183 10.2795 12.446 11.4613 13.2878ZM5.03881 8.22619L6.01822 11.4567L6.23581 9.41094C6.23581 9.41094 10.0199 5.99786 12.1771 4.05244C12.2401 3.99528 12.2488 3.89961 12.1963 3.83253C12.1444 3.76544 12.0487 3.74969 11.977 3.79519C9.47681 5.39178 5.03881 8.22619 5.03881 8.22619Z" fill="white"/>
</g>
<defs>
<clipPath id="clip0_10150_57085">
<rect width="14" height="14" fill="white" transform="translate(0.737305)"/>
</clipPath>
</defs>
</svg>
`,
	__vite_glob_0_60 = `<svg width="17" height="16" viewBox="0 0 17 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_12285_76772)">
<path d="M16.25 8C16.25 12.2802 12.7802 15.75 8.5 15.75C4.21979 15.75 0.75 12.2802 0.75 8C0.75 3.71979 4.21979 0.25 8.5 0.25C12.7802 0.25 16.25 3.71979 16.25 8Z" fill="#0088CC" stroke="#282828" stroke-width="0.5"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.76529 4.44434H11.2438C11.4532 4.44434 11.6276 4.48121 11.837 4.59184C12.0813 4.70246 12.2208 4.88684 12.2906 5.03434C12.2906 5.03434 12.2906 5.07122 12.3255 5.07122C12.4302 5.25559 12.5 5.47684 12.5 5.73497C12.5 5.95622 12.4651 6.17747 12.3255 6.39873L8.87093 12.6675C8.80115 12.815 8.66157 12.8888 8.48709 12.8888C8.34751 12.8888 8.20793 12.815 8.10325 12.6675L4.71845 6.39873C4.64866 6.25123 4.50908 6.06685 4.50908 5.77185C4.47418 5.51372 4.54397 5.29247 4.64866 5.07122C4.75334 4.84996 4.92782 4.66559 5.17208 4.59184C5.38145 4.44434 5.62571 4.44434 5.76529 4.44434ZM8.06835 5.32934H5.76529C5.62571 5.32934 5.55592 5.32934 5.52103 5.36622C5.45124 5.40309 5.41634 5.43997 5.38145 5.51372C5.34655 5.55059 5.34655 5.62435 5.34655 5.6981C5.34655 5.73497 5.38145 5.77185 5.45124 5.91935L8.06835 10.7131V5.32934ZM8.90583 5.32934V10.75L11.5578 5.91935C11.5927 5.8456 11.5927 5.77185 11.5927 5.6981C11.5927 5.62435 11.5927 5.55059 11.5578 5.51372C11.5229 5.47684 11.5229 5.43997 11.488 5.43997L11.4532 5.40309C11.3834 5.36622 11.3136 5.36622 11.2089 5.36622H8.90583V5.32934Z" fill="white"/>
</g>
<defs>
<clipPath id="clip0_12285_76772">
<rect width="16" height="16" fill="white" transform="translate(0.5)"/>
</clipPath>
</defs>
</svg>
`,
	__vite_glob_0_61 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<g id="Style=Line">
<path id="Vector" d="M21 19.9999C21 18.2583 19.3304 16.7767 17 16.2275M15 20C15 17.7909 12.3137 16 9 16C5.68629 16 3 17.7909 3 20M15 13C17.2091 13 19 11.2091 19 9C19 6.79086 17.2091 5 15 5M9 13C6.79086 13 5 11.2091 5 9C5 6.79086 6.79086 5 9 5C11.2091 5 13 6.79086 13 9C13 11.2091 11.2091 13 9 13Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
</svg>
`,
	__vite_glob_0_62 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M17.5 10C17.5 8.96447 16.6605 8.125 15.625 8.125H12.5C12.5 9.50571 11.3807 10.625 10 10.625C8.61929 10.625 7.5 9.50571 7.5 8.125H4.375C3.33947 8.125 2.5 8.96447 2.5 10M17.5 10V15C17.5 16.0355 16.6605 16.875 15.625 16.875H4.375C3.33947 16.875 2.5 16.0355 2.5 15V10M17.5 10V7.5M2.5 10V7.5M17.5 7.5C17.5 6.46447 16.6605 5.625 15.625 5.625H4.375C3.33947 5.625 2.5 6.46447 2.5 7.5M17.5 7.5V5C17.5 3.96447 16.6605 3.125 15.625 3.125H4.375C3.33947 3.125 2.5 3.96447 2.5 5V7.5" stroke="#121212" stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	__vite_glob_0_63 = `<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M40 26.6667L29.3333 37.3333L24 32M32 56C18.7452 56 8 45.2548 8 32C8 18.7452 18.7452 8 32 8C45.2548 8 56 18.7452 56 32C56 45.2548 45.2548 56 32 56Z" stroke="#A6A6A6" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`,
	_hoisted_1$7 = ["innerHTML"],
	_sfc_main$7 = defineComponent({
		__name: "Icon",
		props: {
			name: {
				type: String,
				required: !0
			}
		},
		setup(ue) {
			const Yi = ue,
				ea = ref$1(""),
				ta = () => {
					const na = Object.assign({
						"/assets/icons/arrow-down-bold.svg": __vite_glob_0_0,
						"/assets/icons/arrow-down.svg": __vite_glob_0_1,
						"/assets/icons/arrow-right.svg": __vite_glob_0_2,
						"/assets/icons/arrow-up.svg": __vite_glob_0_3,
						"/assets/icons/b-qr.svg": __vite_glob_0_4,
						"/assets/icons/bp-logo.svg": __vite_glob_0_5,
						"/assets/icons/chevron-left.svg": __vite_glob_0_6,
						"/assets/icons/chevron-right.svg": __vite_glob_0_7,
						"/assets/icons/circle-check-fill.svg": __vite_glob_0_8,
						"/assets/icons/circle-check-white.svg": __vite_glob_0_9,
						"/assets/icons/circle-check.svg": __vite_glob_0_10,
						"/assets/icons/circle-help.svg": __vite_glob_0_11,
						"/assets/icons/circle-lightning.svg": __vite_glob_0_12,
						"/assets/icons/circle-small.svg": __vite_glob_0_13,
						"/assets/icons/circle-warning-fill.svg": __vite_glob_0_14,
						"/assets/icons/clock.svg": __vite_glob_0_15,
						"/assets/icons/close-circle.svg": __vite_glob_0_16,
						"/assets/icons/close.svg": __vite_glob_0_17,
						"/assets/icons/copy.svg": __vite_glob_0_18,
						"/assets/icons/dogs-logo.svg": __vite_glob_0_19,
						"/assets/icons/dogs-token.svg": __vite_glob_0_20,
						"/assets/icons/edit-copy.svg": __vite_glob_0_21,
						"/assets/icons/external-link.svg": __vite_glob_0_22,
						"/assets/icons/game/background.svg": __vite_glob_0_23,
						"/assets/icons/game/freeze-items.svg": __vite_glob_0_24,
						"/assets/icons/game/freeze-timer.svg": __vite_glob_0_25,
						"/assets/icons/game/index-drop-bg.svg": __vite_glob_0_26,
						"/assets/icons/leaf.svg": __vite_glob_0_27,
						"/assets/icons/logo-mini.svg": __vite_glob_0_28,
						"/assets/icons/logo-token.svg": __vite_glob_0_29,
						"/assets/icons/logo.svg": __vite_glob_0_30,
						"/assets/icons/notcoin-logo.svg": __vite_glob_0_31,
						"/assets/icons/note-search.svg": __vite_glob_0_32,
						"/assets/icons/pokras/freeze-items.svg": __vite_glob_0_33,
						"/assets/icons/pokras/freeze-timer.svg": __vite_glob_0_34,
						"/assets/icons/pokras/game-grid-bg.svg": __vite_glob_0_35,
						"/assets/icons/pokras/loader-thumb.svg": __vite_glob_0_36,
						"/assets/icons/special/big-green-check.svg": __vite_glob_0_37,
						"/assets/icons/special/big-red-cross.svg": __vite_glob_0_38,
						"/assets/icons/special/checkbox-legal-checked.svg": __vite_glob_0_39,
						"/assets/icons/special/control-add-plus.svg": __vite_glob_0_40,
						"/assets/icons/special/control-exit.svg": __vite_glob_0_41,
						"/assets/icons/special/control-user-add.svg": __vite_glob_0_42,
						"/assets/icons/special/edit-bold.svg": __vite_glob_0_43,
						"/assets/icons/special/green-check.svg": __vite_glob_0_44,
						"/assets/icons/special/input-close.svg": __vite_glob_0_45,
						"/assets/icons/special/left-wing.svg": __vite_glob_0_46,
						"/assets/icons/special/link-external-small.svg": __vite_glob_0_47,
						"/assets/icons/special/loading.svg": __vite_glob_0_48,
						"/assets/icons/special/progress-pill.svg": __vite_glob_0_49,
						"/assets/icons/special/red-cancel.svg": __vite_glob_0_50,
						"/assets/icons/special/reload.svg": __vite_glob_0_51,
						"/assets/icons/special/right-wing.svg": __vite_glob_0_52,
						"/assets/icons/special/search-bold.svg": __vite_glob_0_53,
						"/assets/icons/special/tab-coins.svg": __vite_glob_0_54,
						"/assets/icons/special/tab-frens.svg": __vite_glob_0_55,
						"/assets/icons/special/tab-home.svg": __vite_glob_0_56,
						"/assets/icons/special/tab-tasks.svg": __vite_glob_0_57,
						"/assets/icons/special/tab-wallet.svg": __vite_glob_0_58,
						"/assets/icons/tg.svg": __vite_glob_0_59,
						"/assets/icons/ton-logo.svg": __vite_glob_0_60,
						"/assets/icons/users.svg": __vite_glob_0_61,
						"/assets/icons/wallet.svg": __vite_glob_0_62,
						"/assets/icons/warning-circle-check.svg": __vite_glob_0_63
					});
					if (!(`/assets/icons/${Yi.name}.svg` in na)) throw err(`Icon ${Yi.name} not existed`);
					ea.value = na[`/assets/icons/${Yi.name}.svg`]
				};
			return ta(), watchEffect(ta), (na, ra) => (openBlock(), createElementBlock("div", {
				class: "kit-icon",
				innerHTML: unref(ea)
			}, null, 8, _hoisted_1$7))
		}
	}),
	_hoisted_1$6 = {
		class: "layout-tabs"
	},
	_hoisted_2$3 = {
		class: "label"
	},
	_sfc_main$6 = defineComponent({
		__name: "Tabs",
		setup(ue) {
			const Yi = computed(() => [{
				label: t$2("tabs.home"),
				pathName: "index",
				icon: "special/tab-home",
				type: "home"
			}, {
				label: t$2("tabs.earn"),
				pathName: "tasks",
				icon: "special/tab-coins",
				type: "tasks"
			}, {
				label: t$2("tabs.frens"),
				pathName: "frens",
				icon: "special/tab-frens",
				noActiveFill: !0,
				type: "frens"
			}, {
				label: t$2("tabs.wallet"),
				pathName: "wallet",
				icon: "special/tab-wallet",
				type: "wallet"
			}]);
			return (ea, ta) => {
				const na = _sfc_main$7,
					ra = __nuxt_component_0$1;
				return openBlock(), createElementBlock("div", _hoisted_1$6, [(openBlock(!0), createElementBlock(Fragment, null, renderList(unref(Yi), (ia, aa) => (openBlock(), createBlock(ra, {
					key: aa,
					class: "tab",
					to: {
						name: ia.pathName
					}
				}, {
					default: withCtx(() => [createVNode(na, {
						name: ia.icon,
						class: normalizeClass(["icon", [{
							"no-active-fill": ia.noActiveFill
						}, `type-${ia.type}`]])
					}, null, 8, ["name", "class"]), createBaseVNode("span", _hoisted_2$3, toDisplayString$1(ia.label), 1)]),
					_: 2
				}, 1032, ["to"]))), 128))])
			}
		}
	}),
	_export_sfc = (ue, Yi) => {
		const ea = ue.__vccOpts || ue;
		for (const [ta, na] of Yi) ea[ta] = na;
		return ea
	},
	__nuxt_component_1 = _export_sfc(_sfc_main$6, [
		["__scopeId", "data-v-659fed9c"]
	]),
	__vite_glob_0_113 = "data:image/svg+xml,%3csvg%20width='1'%20height='1'%20viewBox='0%200%201%201'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20width='1'%20height='1'%20fill='black'/%3e%3c/svg%3e",
	__vite_glob_1_5 = "" + new URL("loader.CHvAPMmo.webm", import.meta.url).href,
	__vite_glob_1_4 = "" + new URL("loader.CuI5ghga.mp4", import.meta.url).href,
	_hoisted_1$5 = {
		key: 0,
		class: "pokras-loader"
	},
	LOADER_WATCHED_KEY = "__telegram__loader-watched",
	POKRAS_ANIMATION_DURATION = 3e3,
	_sfc_main$5 = defineComponent({
		__name: "Loader",
		setup(ue) {
			const Yi = useApp().internal.isPokrasTheme,
				ea = ref$1(!0),
				ta = [];
			return (() => {
				if (!!sessionStorage.getItem(LOADER_WATCHED_KEY)) {
					ea.value = !1;
					return
				}
				ta.push(setTimeout(() => {
					ea.value = !1, sessionStorage.setItem(LOADER_WATCHED_KEY, "true")
				}, POKRAS_ANIMATION_DURATION))
			})(), onUnmounted(() => {
				ta.forEach(ra => clearTimeout(ra))
			}), (ra, ia) => unref(ea) && unref(Yi) ? (openBlock(), createElementBlock("div", _hoisted_1$5, ia[0] || (ia[0] = [createBaseVNode("video", {
				class: "video",
				autoplay: "",
				muted: "",
				playsinline: "",
				poster: __vite_glob_0_113
			}, [createBaseVNode("source", {
				src: __vite_glob_1_5,
				type: "video/webm"
			}), createBaseVNode("source", {
				src: __vite_glob_1_4,
				type: "video/mp4"
			})], -1)]))) : renderSlot(ra.$slots, "default", {
				key: 1
			}, void 0, !0)
		}
	}),
	__nuxt_component_2 = _export_sfc(_sfc_main$5, [
		["__scopeId", "data-v-994560aa"]
	]),
	_hoisted_1$4 = {
		key: 0,
		class: "alerts-containers"
	},
	_hoisted_2$2 = ["onMouseenter", "onMouseleave"],
	_hoisted_3$1 = {
		key: 0,
		class: "kit-bottom-alert"
	},
	_hoisted_4$1 = {
		key: 0
	},
	_sfc_main$4 = defineComponent({
		__name: "Alert",
		setup(ue) {
			const Yi = useAlert().internal,
				ea = ta => {
					switch (ta) {
						case BOTTOM_ALERT_TYPE.ERROR:
							return "close-circle";
						case BOTTOM_ALERT_TYPE.SUCCESS:
							return "circle-check-white";
						default:
							throw err(`Unknown bottom alert type: ${ta}`)
					}
				};
			return (ta, na) => {
				const ra = _sfc_main$7;
				return openBlock(), createElementBlock(Fragment, null, [unref(Yi).topNotifications.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$4, [(openBlock(!0), createElementBlock(Fragment, null, renderList(unref(Yi).topNotifications.value, ia => (openBlock(), createElementBlock("div", {
					key: ia.id,
					onMouseenter: aa => ia.timer.pause(),
					onMouseleave: aa => ia.timer.run()
				}, toDisplayString$1(ia.message), 41, _hoisted_2$2))), 128))])) : createCommentVNode("", !0), createVNode(Transition, {
					name: "bottom-notification-animation"
				}, {
					default: withCtx(() => [unref(Yi).bottomNotification.value ? (openBlock(), createElementBlock("div", _hoisted_3$1, [createVNode(ra, {
						name: ea(unref(Yi).bottomNotification.value.type),
						class: "icon"
					}, null, 8, ["name"]), typeof unref(Yi).bottomNotification.value.message == "string" ? (openBlock(), createElementBlock("span", _hoisted_4$1, toDisplayString$1(unref(Yi).bottomNotification.value.message), 1)) : (openBlock(), createBlock(resolveDynamicComponent(unref(Yi).bottomNotification.value.message), {
						key: 1
					}))])) : createCommentVNode("", !0)]),
					_: 1
				})], 64)
			}
		}
	}),
	__nuxt_component_3 = _export_sfc(_sfc_main$4, [
		["__scopeId", "data-v-a861840b"]
	]),
	_hoisted_1$3 = {
		class: "heading"
	},
	_hoisted_2$1 = {
		class: "title"
	},
	_hoisted_3 = {
		class: "message"
	},
	_hoisted_4 = {
		class: "buttons"
	},
	_hoisted_5 = ["onClick"],
	_sfc_main$3 = defineComponent({
		__name: "FallbackPopup",
		props: {
			popup: {
				type: Object,
				default: void 0
			}
		},
		emits: ["close"],
		setup(ue, {
			emit: Yi
		}) {
			const ea = ue,
				ta = Yi,
				na = ia => {
					switch (ia.type) {
						case void 0:
						case "destructive":
						case "default":
							return ia.label;
						case "ok":
							return capitalize$1(t$2("base.ok"));
						case "cancel":
							return t$2("base.cancel");
						case "close":
							return t$2("base.close");
						default:
							throw ia.type, err("Unknown button type")
					}
				},
				ra = ia => {
					ia.code === "Escape" && ta("close")
				};
			return watch(() => ea.popup, ia => {
				ia ? (useApp().blockOverflow(), useLogger().warn("FallbackPopup showed")) : useApp().unblockOverflow()
			}), window.addEventListener("keyup", ra), onUnmounted(() => {
				window.removeEventListener("keyup", ra)
			}), (ia, aa) => (openBlock(), createBlock(Transition, {
				name: "popup-transition"
			}, {
				default: withCtx(() => [ue.popup ? (openBlock(), createElementBlock("div", {
					key: 0,
					class: "kit-fallback-popup",
					onClick: aa[1] || (aa[1] = oa => ia.$emit("close"))
				}, [createBaseVNode("dialog", {
					ref: "dialogRef",
					open: "",
					onClick: aa[0] || (aa[0] = withModifiers(() => {}, ["stop"]))
				}, [createBaseVNode("div", _hoisted_1$3, [createBaseVNode("div", _hoisted_2$1, toDisplayString$1(ue.popup.title), 1), createBaseVNode("div", _hoisted_3, toDisplayString$1(ue.popup.message), 1)]), createBaseVNode("div", _hoisted_4, [(openBlock(!0), createElementBlock(Fragment, null, renderList(ue.popup.buttons, (oa, la) => (openBlock(), createElementBlock("button", {
					key: la,
					class: normalizeClass(["reset", [`is-type-${oa.type}`]]),
					onClick: sa => (ia.$emit("close"), oa.onClick && oa.onClick())
				}, toDisplayString$1(na(oa)), 11, _hoisted_5))), 128))])], 512)])) : createCommentVNode("", !0)]),
				_: 1
			}))
		}
	}),
	__nuxt_component_4 = _export_sfc(_sfc_main$3, [
		["__scopeId", "data-v-3ee0107c"]
	]),
	BoldUrl = "" + new URL("Bold.vYYfUnV7.woff2", import.meta.url).href,
	MediumUrl = "" + new URL("Medium.9CUCDBk_.woff2", import.meta.url).href,
	RegularUrl = "" + new URL("Regular.CLmC6DVf.woff2", import.meta.url).href,
	SemiBoldUrl = "" + new URL("SemiBold.BiIuU0GS.woff2", import.meta.url).href,
	preload = [{
		rel: "preload",
		as: "font",
		crossorigin: "anonymous",
		type: "font/woff2",
		href: RegularUrl
	}, {
		rel: "preload",
		as: "font",
		crossorigin: "anonymous",
		type: "font/woff2",
		href: MediumUrl
	}, {
		rel: "preload",
		as: "font",
		crossorigin: "anonymous",
		type: "font/woff2",
		href: SemiBoldUrl
	}, {
		rel: "preload",
		as: "font",
		crossorigin: "anonymous",
		type: "font/woff2",
		href: BoldUrl
	}],
	tganalytics = "" + new URL("tganalytics.Hsn8KsCe.js", import.meta.url).href,
	_hoisted_1$2 = {
		id: "app"
	},
	_sfc_main$2 = defineComponent({
		__name: "app",
		setup(ue) {
			const Yi = () => {
				const ea = document.documentElement.clientHeight;
				document.documentElement.style.setProperty("--svh", ea + "px");
				const ta = window.innerHeight;
				document.documentElement.style.setProperty("--dvh", ta + "px");
				const na = document.createElement("div");
				na.style.width = "1px", na.style.height = "100vh", na.style.position = "fixed", na.style.left = "0", na.style.top = "0", na.style.bottom = "0", na.style.visibility = "hidden", document.body.appendChild(na);
				const ra = na.clientHeight;
				na.remove();
				const ia = ra;
				document.documentElement.style.setProperty("--lvh", ia + "px")
			};
			return onMounted(() => {
				Yi(), window.addEventListener("resize", Yi)
			}), onUnmounted(() => {
				window.removeEventListener("resize", Yi)
			}), useHead({
				meta: [{
					name: "viewport",
					content: "width=device-width, user-scalable=no"
				}],
				link: [...preload],
				script: [{
					async: !0,
					src: tganalytics,
					type: "text/javascript",
					onload: useApp().internal.initTganalytics
				}],
				htmlAttrs: {
					class: {
						"is-blocked": useApp().internal.isOverflowBlocked,
						"has-layout-tabs": useApp().hasLayoutTabs
					}
				}
			}), (ea, ta) => {
				const na = __nuxt_component_0,
					ra = __nuxt_component_1,
					ia = __nuxt_component_2,
					aa = __nuxt_component_3,
					oa = __nuxt_component_4;
				return openBlock(), createElementBlock("div", _hoisted_1$2, [createVNode(ia, null, {
					default: withCtx(() => [createVNode(na), createVNode(Transition, {
						name: "translate-bottom-transition"
					}, {
						default: withCtx(() => [("useApp" in ea ? ea.useApp : unref(useApp))().hasLayoutTabs.value ? (openBlock(), createBlock(ra, {
							key: 0,
							class: "tabs"
						})) : createCommentVNode("", !0)]),
						_: 1
					})]),
					_: 1
				}), createVNode(aa), createVNode(oa, {
					popup: ("useApp" in ea ? ea.useApp : unref(useApp))().internal.fallbackPopup.value,
					onClose: ta[0] || (ta[0] = la => ("useApp" in ea ? ea.useApp : unref(useApp))().internal.closeFallbackPopup())
				}, null, 8, ["popup"]), ta[1] || (ta[1] = createBaseVNode("div", {
					class: "tg-bottom-fix"
				}, "tg bottom fix", -1))])
			}
		}
	}),
	AppComponent = _export_sfc(_sfc_main$2, [
		["__scopeId", "data-v-88679695"]
	]),
	__vite_glob_0_133 = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M6.66667%2010.6667H3.33334V14M9.33334%205.33333H12.6667V2M3.05534%206.00227C3.42913%205.07711%204.05496%204.27536%204.86171%203.68815C5.66845%203.10094%206.62458%202.75168%207.61984%202.68034C8.61511%202.609%209.60983%202.81827%2010.4921%203.28441C11.3743%203.75055%2012.1075%204.45503%2012.6094%205.31742M12.945%209.99805C12.5712%2010.9232%2011.9454%2011.725%2011.1387%2012.3122C10.3319%2012.8994%209.37678%2013.2482%208.38152%2013.3195C7.38625%2013.3909%206.39071%2013.1816%205.50847%2012.7155C4.62622%2012.2494%203.89255%2011.545%203.39063%2010.6826'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e",
	_hoisted_1$1 = {
		class: "error page wrapper"
	},
	_hoisted_2 = {
		key: 0,
		class: "error-message"
	},
	_sfc_main$1 = defineComponent({
		__name: "error",
		props: {
			error: {
				type: Object,
				required: !0
			}
		},
		setup(ue) {
			useLogger().info("Error layout enabled");
			const Yi = ref$1(!1),
				ea = calledNTimes(() => Yi.value = !0, 5);
			return (ta, na) => (openBlock(), createElementBlock("div", _hoisted_1$1, [createBaseVNode("div", {
				class: "title",
				onClick: na[0] || (na[0] = ra => unref(ea)())
			}, na[2] || (na[2] = [createTextVNode(" Sorry, something"), createBaseVNode("br", null, null, -1), createTextVNode(" went wrong ")])), na[4] || (na[4] = createBaseVNode("div", {
				class: "subtitle"
			}, "We are already on the issue", -1)), createBaseVNode("button", {
				class: "reset",
				onClick: na[1] || (na[1] = ra => ("reloadNuxtApp" in ta ? ta.reloadNuxtApp : unref(reloadNuxtApp))({
					force: !0
				}))
			}, na[3] || (na[3] = [createBaseVNode("img", {
				src: __vite_glob_0_133,
				alt: "Reload icon"
			}, null, -1)])), unref(Yi) ? (openBlock(), createElementBlock("div", _hoisted_2, toDisplayString$1(ue.error.message ? ue.error.message : "Unknown error"), 1)) : createCommentVNode("", !0)]))
		}
	}),
	ErrorComponent = _export_sfc(_sfc_main$1, [
		["__scopeId", "data-v-c374fe65"]
	]),
	_hoisted_1 = {
		key: 0
	},
	_sfc_main = {
		__name: "nuxt-root",
		setup(ue) {
			const Yi = () => null,
				ea = useNuxtApp(),
				ta = ea.deferHydration();
			if (ea.isHydrating) {
				const oa = ea.hooks.hookOnce("app:error", ta);
				useRouter().beforeEach(oa)
			}
			const na = !1;
			provide(PageRouteSymbol, useRoute()), ea.hooks.callHookWith(oa => oa.map(la => la()), "vue:setup");
			const ra = useError(),
				ia = !1;
			onErrorCaptured((oa, la, sa) => {
				if (ea.hooks.callHook("vue:error", oa, la, sa).catch(ca => console.error("[nuxt] Error in `vue:error` hook", ca)), isNuxtError(oa) && (oa.fatal || oa.unhandled)) return ea.runWithContext(() => showError(oa)), !1
			});
			const aa = !1;
			return (oa, la) => (openBlock(), createBlock(Suspense, {
				onResolve: unref(ta)
			}, {
				default: withCtx(() => [unref(ia) ? (openBlock(), createElementBlock("div", _hoisted_1)) : unref(ra) ? (openBlock(), createBlock(unref(ErrorComponent), {
					key: 1,
					error: unref(ra)
				}, null, 8, ["error"])) : unref(aa) ? (openBlock(), createBlock(unref(Yi), {
					key: 2,
					context: unref(aa)
				}, null, 8, ["context"])) : unref(na) ? (openBlock(), createBlock(resolveDynamicComponent(unref(na)), {
					key: 3
				})) : (openBlock(), createBlock(unref(AppComponent), {
					key: 4
				}))]),
				_: 1
			}, 8, ["onResolve"]))
		}
	};
let entry;
{
	let ue;
	entry = async function() {
		var ia, aa;
		if (ue) return ue;
		const ta = !!(((ia = window.__NUXT__) == null ? void 0 : ia.serverRendered) ?? ((aa = document.getElementById("__NUXT_DATA__")) == null ? void 0 : aa.dataset.ssr) === "true") ? createSSRApp(_sfc_main) : createApp(_sfc_main),
			na = createNuxtApp({
				vueApp: ta
			});
		async function ra(oa) {
			await na.callHook("app:error", oa), na.payload.error = na.payload.error || createError(oa)
		}
		ta.config.errorHandler = ra;
		try {
			await applyPlugins(na, plugins)
		} catch (oa) {
			ra(oa)
		}
		try {
			await na.hooks.callHook("app:created", ta), await na.hooks.callHook("app:beforeMount", ta), ta.mount(vueAppRootContainer), await na.hooks.callHook("app:mounted", ta), await nextTick()
		} catch (oa) {
			ra(oa)
		}
		return ta.config.errorHandler === ra && (ta.config.errorHandler = void 0), ta
	}, ue = entry().catch(Yi => {
		throw console.error("Error while mounting app:", Yi), Yi
	})
}
export {
	Transition as $, _sfc_main$7 as A, BUTTON_SIZE as B, useLogger as C, useLocale as D, reloadNuxtApp as E, useAuth as F, useRuntimeConfig as G, vModelSelect as H, isRef as I, Fragment as J, renderList as K, BUTTON_TYPE as L, dataClient as M, useBackendTime as N, getHHMmFromMs as O, createBlock as P, SPINNER_TYPE as Q, resolveDirective as R, SERVICE as S, useAnalytics as T, asyncInterval as U, GAME_ASSETS_TYPE as V, getRandomInt as W, reactive as X, onMounted as Y, Decimal as Z, _export_sfc as _, openBlock as a, watchEffect as a$, getMmSsFromMs as a0, debounce$1 as a1, getWalletAmount as a2, useWallet as a3, resolveDynamicComponent as a4, global$1 as a5, uuid as a6, watch as a7, useRoute as a8, useHead as a9, getFileUrl as aA, process$1 as aB, Buffer as aC, getAugmentedNamespace as aD, commonjsGlobal as aE, dist$1 as aF, requireDist as aG, isTaskFinished as aH, TASK_TYPE as aI, mustGet as aJ, formatFloatLine as aK, normalizeProps as aL, guardReactiveProps as aM, isTaskStarted as aN, useCssVars as aO, TransitionGroup as aP, TASK_ITEM_MODE as aQ, inject as aR, TABS_INJECTION_KEY as aS, vModelRadio as aT, TABS_TYPE as aU, provide as aV, isTaskHasAction as aW, getTasksSectionMode as aX, isTaskHidden as aY, sortTasks as aZ, useTribe as a_, toRaw as aa, mergeModels as ab, useModel as ac, renderSlot as ad, COMPONENT_WRAPPER_TAG as ae, __nuxt_component_0$1 as af, FARMING_STATUS as ag, normalizeStyle as ah, useMyTribe as ai, calledNTimes as aj, setInterval$1 as ak, INPUT_TYPE as al, INPUT_STATUS as am, FILE_TYPE as an, markRaw as ao, createSlots as ap, mergeProps as aq, vModelCheckbox as ar, vModelDynamic as as, TASK_PILL_MODE as at, TASK_STATUS as au, TASK_KIND as av, isTaskHasSubtasks as aw, TASKS_CLAIM_OVERRIDE as ax, minExecutionTime as ay, TASK_VERIFY_STATUS as az, createBaseVNode as b, __nuxt_component_0 as b0, getTribeRankLabel as b1, isTribeUserPerkBalanceHighlited as b2, TRIBE_USER_PERK as b3, TRIBE_MEMBER_ROLE as b4, getDDHHFromMs as b5, TribeExtended as b6, useStore as b7, getDefaultExportFromCjs$1 as b8, t$2 as b9, vModelText as ba, withKeys as bb, useTribeSearch as bc, INPUT_SIZE as bd, ANALYTICS_TRIBE_CREATE_SOURCE as be, shallowRef as bf, HistoryPoints as bg, HistoryTokens as bh, HistoryShared as bi, getDateShort as bj, nacl$1 as bk, useState as bl, __vite_glob_1_4 as bm, __vite_glob_1_5 as bn, __vite_glob_0_113 as bo, __vite_glob_0_133 as bp, getMimeType as bq, FILE_UPLOAD_STATUS as br, AUTH_ERROR as bs, getFirstPrintableSymbol as bt, withModifiers as bu, createElementBlock as c, defineComponent as d, unref as e, createCommentVNode as f, createTextVNode as g, createVNode as h, formatBp as i, withCtx as j, useDailyReward as k, useBalance as l, computed as m, normalizeClass as n, onUnmounted as o, useAlert as p, h$2 as q, ref$1 as r, useNuxtApp as s, toDisplayString$1 as t, useApp as u, vShow as v, withDirectives as w, useRouter as x, client as y, err as z
};